import { check } from '@augment-vir/assert';
import { getOrSet } from '@augment-vir/common/dist/augments/object/get-or-set.js';
import { getObjectTypedValues } from '@augment-vir/common/dist/augments/object/object-values.js';
/**
 * Similar to `TypedEventTarget` except that it uses a `listen` method to add listeners and that
 * method returns a callback to remove the attached listener rather than having a
 * `removeEventListener` method.
 *
 * @category Main
 */
export class TypedListenTarget {
    /** All listeners that are listening to specific events. */
    listeners = {};
    /** All listeners that are listening to _all_ events. */
    universalListeners = new Map();
    /**
     * Get a count of all currently attached listeners. If a listener is removed, it will no longer
     * be counted.
     */
    getListenerCount() {
        const counts = getObjectTypedValues(this.listeners).map((listenersEntry) => listenersEntry.size || 0);
        return counts.reduce((accum, current) => accum + current, 0) + this.universalListeners.size;
    }
    /**
     * Attach a listener that will be fired on any and all events.
     *
     * @returns A callback to remove the listener.
     */
    listenToAll(listenerCallback, options = {}) {
        const removeListener = () => {
            return this.universalListeners.delete(listenerCallback) || false;
        };
        function wrappedCallback(event, removeSelf) {
            if (options.once) {
                removeListener();
            }
            listenerCallback(event, removeSelf);
        }
        this.universalListeners.set(listenerCallback, {
            listener: wrappedCallback,
            removeListener,
        });
        return removeListener;
    }
    /**
     * Remove a previous attached universal listener (added via `.listenToAll`).
     *
     * @returns Whether the listener existed and was removed or not.
     */
    removeUniversalListener(listenerCallback) {
        return !!this.universalListeners.get(listenerCallback)?.removeListener();
    }
    /**
     * Listen to events. Listening can be attached by a type string or by the event definition
     * itself.
     *
     * @returns A callback to remove the listener.
     */
    listen(eventTypeOrConstructor, listenerCallback, options = {}) {
        const eventType = check.isString(eventTypeOrConstructor)
            ? eventTypeOrConstructor
            : eventTypeOrConstructor.type;
        const removeListener = () => {
            return this.listeners[eventType]?.delete(listenerCallback) || false;
        };
        // eslint-disable-next-line sonarjs/no-identical-functions
        function wrappedCallback(event, removeSelf) {
            if (options.once) {
                removeListener();
            }
            listenerCallback(event, removeSelf);
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        getOrSet(this.listeners, eventType, () => new Map()).set(listenerCallback, {
            listener: wrappedCallback,
            removeListener,
        });
        return removeListener;
    }
    /** Removes a listener. */
    removeListener(eventTypeOrConstructor, listenerCallback) {
        const eventType = check.isString(eventTypeOrConstructor)
            ? eventTypeOrConstructor
            : eventTypeOrConstructor.type;
        const eventTypeListeners = this.listeners[eventType];
        if (!eventTypeListeners) {
            return false;
        }
        const attachedListenerWrapper = eventTypeListeners.get(listenerCallback);
        if (!attachedListenerWrapper) {
            return false;
        }
        return attachedListenerWrapper.removeListener();
    }
    /**
     * Dispatch a typed event. Causes all attached listeners listening to this event to be fired.
     *
     * @returns The number of listeners that were fired.
     */
    dispatch(event) {
        const listenerSet = this.listeners[event.type];
        if (event.target == undefined) {
            Object.defineProperty(event, 'target', { writable: false, value: this });
        }
        /**
         * This must be calculated before calling the listeners as the listeners might remove
         * themselves.
         */
        const size = listenerSet?.size || 0;
        listenerSet?.forEach((listenerWrapper) => {
            listenerWrapper.listener(event, listenerWrapper.removeListener);
        });
        this.universalListeners.forEach((listenerWrapper) => {
            listenerWrapper.listener(event, listenerWrapper.removeListener);
        });
        return size + this.universalListeners.size;
    }
    /**
     * Remove all currently attached event and universal listeners.
     *
     * @returns The number of listeners that were removed.
     */
    removeAllListeners() {
        const listenerSets = getObjectTypedValues(this.listeners);
        const totalRemoved = listenerSets.reduce((accum, listenerSet) => {
            const size = listenerSet.size || 0;
            listenerSet.clear();
            return accum + size;
        }, 0) + this.universalListeners.size;
        this.listeners = {};
        this.universalListeners.clear();
        return totalRemoved;
    }
    /** Remove all internal state to free up resources. */
    destroy() {
        this.removeAllListeners();
    }
}
/**
 * An alias for `TypedListenTarget`.
 *
 * @category Main
 */
export class ListenTarget extends TypedListenTarget {
}
