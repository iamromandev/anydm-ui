/**
 * @license
 * @qwik.dev/core/testing 2.0.0-beta.13-dev+cb19ff7
 * Copyright QwikDev. All Rights Reserved.
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/QwikDev/qwik/blob/main/LICENSE
 */
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/Event.js
var require_Event = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/Event.js"(exports, module) {
    "use strict";
    module.exports = Event2;
    Event2.CAPTURING_PHASE = 1;
    Event2.AT_TARGET = 2;
    Event2.BUBBLING_PHASE = 3;
    function Event2(type, dictionary) {
      this.type = "";
      this.target = null;
      this.currentTarget = null;
      this.eventPhase = Event2.AT_TARGET;
      this.bubbles = false;
      this.cancelable = false;
      this.isTrusted = false;
      this.defaultPrevented = false;
      this.timeStamp = Date.now();
      this._propagationStopped = false;
      this._immediatePropagationStopped = false;
      this._initialized = true;
      this._dispatching = false;
      if (type) this.type = type;
      if (dictionary) {
        for (var p in dictionary) {
          this[p] = dictionary[p];
        }
      }
    }
    Event2.prototype = Object.create(Object.prototype, {
      constructor: { value: Event2 },
      stopPropagation: { value: function stopPropagation() {
        this._propagationStopped = true;
      } },
      stopImmediatePropagation: { value: function stopImmediatePropagation() {
        this._propagationStopped = true;
        this._immediatePropagationStopped = true;
      } },
      preventDefault: { value: function preventDefault() {
        if (this.cancelable) this.defaultPrevented = true;
      } },
      initEvent: { value: function initEvent(type, bubbles, cancelable) {
        this._initialized = true;
        if (this._dispatching) return;
        this._propagationStopped = false;
        this._immediatePropagationStopped = false;
        this.defaultPrevented = false;
        this.isTrusted = false;
        this.target = null;
        this.type = type;
        this.bubbles = bubbles;
        this.cancelable = cancelable;
      } }
    });
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/UIEvent.js
var require_UIEvent = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/UIEvent.js"(exports, module) {
    "use strict";
    var Event2 = require_Event();
    module.exports = UIEvent;
    function UIEvent() {
      Event2.call(this);
      this.view = null;
      this.detail = 0;
    }
    UIEvent.prototype = Object.create(Event2.prototype, {
      constructor: { value: UIEvent },
      initUIEvent: { value: function(type, bubbles, cancelable, view, detail) {
        this.initEvent(type, bubbles, cancelable);
        this.view = view;
        this.detail = detail;
      } }
    });
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/MouseEvent.js
var require_MouseEvent = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/MouseEvent.js"(exports, module) {
    "use strict";
    var UIEvent = require_UIEvent();
    module.exports = MouseEvent;
    function MouseEvent() {
      UIEvent.call(this);
      this.screenX = this.screenY = this.clientX = this.clientY = 0;
      this.ctrlKey = this.altKey = this.shiftKey = this.metaKey = false;
      this.button = 0;
      this.buttons = 1;
      this.relatedTarget = null;
    }
    MouseEvent.prototype = Object.create(UIEvent.prototype, {
      constructor: { value: MouseEvent },
      initMouseEvent: { value: function(type, bubbles, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget) {
        this.initEvent(type, bubbles, cancelable, view, detail);
        this.screenX = screenX;
        this.screenY = screenY;
        this.clientX = clientX;
        this.clientY = clientY;
        this.ctrlKey = ctrlKey;
        this.altKey = altKey;
        this.shiftKey = shiftKey;
        this.metaKey = metaKey;
        this.button = button;
        switch (button) {
          case 0:
            this.buttons = 1;
            break;
          case 1:
            this.buttons = 4;
            break;
          case 2:
            this.buttons = 2;
            break;
          default:
            this.buttons = 0;
            break;
        }
        this.relatedTarget = relatedTarget;
      } },
      getModifierState: { value: function(key) {
        switch (key) {
          case "Alt":
            return this.altKey;
          case "Control":
            return this.ctrlKey;
          case "Shift":
            return this.shiftKey;
          case "Meta":
            return this.metaKey;
          default:
            return false;
        }
      } }
    });
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/DOMException.js
var require_DOMException = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/DOMException.js"(exports, module) {
    "use strict";
    module.exports = DOMException;
    var INDEX_SIZE_ERR = 1;
    var HIERARCHY_REQUEST_ERR = 3;
    var WRONG_DOCUMENT_ERR = 4;
    var INVALID_CHARACTER_ERR = 5;
    var NO_MODIFICATION_ALLOWED_ERR = 7;
    var NOT_FOUND_ERR = 8;
    var NOT_SUPPORTED_ERR = 9;
    var INVALID_STATE_ERR = 11;
    var SYNTAX_ERR = 12;
    var INVALID_MODIFICATION_ERR = 13;
    var NAMESPACE_ERR = 14;
    var INVALID_ACCESS_ERR = 15;
    var TYPE_MISMATCH_ERR = 17;
    var SECURITY_ERR = 18;
    var NETWORK_ERR = 19;
    var ABORT_ERR = 20;
    var URL_MISMATCH_ERR = 21;
    var QUOTA_EXCEEDED_ERR = 22;
    var TIMEOUT_ERR = 23;
    var INVALID_NODE_TYPE_ERR = 24;
    var DATA_CLONE_ERR = 25;
    var names = [
      null,
      // No error with code 0
      "INDEX_SIZE_ERR",
      null,
      // historical
      "HIERARCHY_REQUEST_ERR",
      "WRONG_DOCUMENT_ERR",
      "INVALID_CHARACTER_ERR",
      null,
      // historical
      "NO_MODIFICATION_ALLOWED_ERR",
      "NOT_FOUND_ERR",
      "NOT_SUPPORTED_ERR",
      "INUSE_ATTRIBUTE_ERR",
      // historical
      "INVALID_STATE_ERR",
      "SYNTAX_ERR",
      "INVALID_MODIFICATION_ERR",
      "NAMESPACE_ERR",
      "INVALID_ACCESS_ERR",
      null,
      // historical
      "TYPE_MISMATCH_ERR",
      "SECURITY_ERR",
      "NETWORK_ERR",
      "ABORT_ERR",
      "URL_MISMATCH_ERR",
      "QUOTA_EXCEEDED_ERR",
      "TIMEOUT_ERR",
      "INVALID_NODE_TYPE_ERR",
      "DATA_CLONE_ERR"
    ];
    var messages = [
      null,
      // No error with code 0
      "INDEX_SIZE_ERR (1): the index is not in the allowed range",
      null,
      "HIERARCHY_REQUEST_ERR (3): the operation would yield an incorrect nodes model",
      "WRONG_DOCUMENT_ERR (4): the object is in the wrong Document, a call to importNode is required",
      "INVALID_CHARACTER_ERR (5): the string contains invalid characters",
      null,
      "NO_MODIFICATION_ALLOWED_ERR (7): the object can not be modified",
      "NOT_FOUND_ERR (8): the object can not be found here",
      "NOT_SUPPORTED_ERR (9): this operation is not supported",
      "INUSE_ATTRIBUTE_ERR (10): setAttributeNode called on owned Attribute",
      "INVALID_STATE_ERR (11): the object is in an invalid state",
      "SYNTAX_ERR (12): the string did not match the expected pattern",
      "INVALID_MODIFICATION_ERR (13): the object can not be modified in this way",
      "NAMESPACE_ERR (14): the operation is not allowed by Namespaces in XML",
      "INVALID_ACCESS_ERR (15): the object does not support the operation or argument",
      null,
      "TYPE_MISMATCH_ERR (17): the type of the object does not match the expected type",
      "SECURITY_ERR (18): the operation is insecure",
      "NETWORK_ERR (19): a network error occurred",
      "ABORT_ERR (20): the user aborted an operation",
      "URL_MISMATCH_ERR (21): the given URL does not match another URL",
      "QUOTA_EXCEEDED_ERR (22): the quota has been exceeded",
      "TIMEOUT_ERR (23): a timeout occurred",
      "INVALID_NODE_TYPE_ERR (24): the supplied node is invalid or has an invalid ancestor for this operation",
      "DATA_CLONE_ERR (25): the object can not be cloned."
    ];
    var constants = {
      INDEX_SIZE_ERR,
      DOMSTRING_SIZE_ERR: 2,
      // historical
      HIERARCHY_REQUEST_ERR,
      WRONG_DOCUMENT_ERR,
      INVALID_CHARACTER_ERR,
      NO_DATA_ALLOWED_ERR: 6,
      // historical
      NO_MODIFICATION_ALLOWED_ERR,
      NOT_FOUND_ERR,
      NOT_SUPPORTED_ERR,
      INUSE_ATTRIBUTE_ERR: 10,
      // historical
      INVALID_STATE_ERR,
      SYNTAX_ERR,
      INVALID_MODIFICATION_ERR,
      NAMESPACE_ERR,
      INVALID_ACCESS_ERR,
      VALIDATION_ERR: 16,
      // historical
      TYPE_MISMATCH_ERR,
      SECURITY_ERR,
      NETWORK_ERR,
      ABORT_ERR,
      URL_MISMATCH_ERR,
      QUOTA_EXCEEDED_ERR,
      TIMEOUT_ERR,
      INVALID_NODE_TYPE_ERR,
      DATA_CLONE_ERR
    };
    function DOMException(code2) {
      Error.call(this);
      Error.captureStackTrace(this, this.constructor);
      this.code = code2;
      this.message = messages[code2];
      this.name = names[code2];
    }
    DOMException.prototype.__proto__ = Error.prototype;
    for (c in constants) {
      v = { value: constants[c] };
      Object.defineProperty(DOMException, c, v);
      Object.defineProperty(DOMException.prototype, c, v);
    }
    var v;
    var c;
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/config.js
var require_config = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/config.js"(exports) {
    exports.isApiWritable = !global.__domino_frozen__;
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/utils.js"(exports) {
    "use strict";
    var DOMException = require_DOMException();
    var ERR = DOMException;
    var isApiWritable = require_config().isApiWritable;
    exports.NAMESPACE = {
      HTML: "http://www.w3.org/1999/xhtml",
      XML: "http://www.w3.org/XML/1998/namespace",
      XMLNS: "http://www.w3.org/2000/xmlns/",
      MATHML: "http://www.w3.org/1998/Math/MathML",
      SVG: "http://www.w3.org/2000/svg",
      XLINK: "http://www.w3.org/1999/xlink"
    };
    exports.IndexSizeError = function() {
      throw new DOMException(ERR.INDEX_SIZE_ERR);
    };
    exports.HierarchyRequestError = function() {
      throw new DOMException(ERR.HIERARCHY_REQUEST_ERR);
    };
    exports.WrongDocumentError = function() {
      throw new DOMException(ERR.WRONG_DOCUMENT_ERR);
    };
    exports.InvalidCharacterError = function() {
      throw new DOMException(ERR.INVALID_CHARACTER_ERR);
    };
    exports.NoModificationAllowedError = function() {
      throw new DOMException(ERR.NO_MODIFICATION_ALLOWED_ERR);
    };
    exports.NotFoundError = function() {
      throw new DOMException(ERR.NOT_FOUND_ERR);
    };
    exports.NotSupportedError = function() {
      throw new DOMException(ERR.NOT_SUPPORTED_ERR);
    };
    exports.InvalidStateError = function() {
      throw new DOMException(ERR.INVALID_STATE_ERR);
    };
    exports.SyntaxError = function() {
      throw new DOMException(ERR.SYNTAX_ERR);
    };
    exports.InvalidModificationError = function() {
      throw new DOMException(ERR.INVALID_MODIFICATION_ERR);
    };
    exports.NamespaceError = function() {
      throw new DOMException(ERR.NAMESPACE_ERR);
    };
    exports.InvalidAccessError = function() {
      throw new DOMException(ERR.INVALID_ACCESS_ERR);
    };
    exports.TypeMismatchError = function() {
      throw new DOMException(ERR.TYPE_MISMATCH_ERR);
    };
    exports.SecurityError = function() {
      throw new DOMException(ERR.SECURITY_ERR);
    };
    exports.NetworkError = function() {
      throw new DOMException(ERR.NETWORK_ERR);
    };
    exports.AbortError = function() {
      throw new DOMException(ERR.ABORT_ERR);
    };
    exports.UrlMismatchError = function() {
      throw new DOMException(ERR.URL_MISMATCH_ERR);
    };
    exports.QuotaExceededError = function() {
      throw new DOMException(ERR.QUOTA_EXCEEDED_ERR);
    };
    exports.TimeoutError = function() {
      throw new DOMException(ERR.TIMEOUT_ERR);
    };
    exports.InvalidNodeTypeError = function() {
      throw new DOMException(ERR.INVALID_NODE_TYPE_ERR);
    };
    exports.DataCloneError = function() {
      throw new DOMException(ERR.DATA_CLONE_ERR);
    };
    exports.nyi = function() {
      throw new Error("NotYetImplemented");
    };
    exports.shouldOverride = function() {
      throw new Error("Abstract function; should be overriding in subclass.");
    };
    exports.assert = function(expr, msg) {
      if (!expr) {
        throw new Error("Assertion failed: " + (msg || "") + "\n" + new Error().stack);
      }
    };
    exports.expose = function(src, c) {
      for (var n in src) {
        Object.defineProperty(c.prototype, n, { value: src[n], writable: isApiWritable });
      }
    };
    exports.merge = function(a, b) {
      for (var n in b) {
        a[n] = b[n];
      }
    };
    exports.documentOrder = function(n, m) {
      return 3 - (n.compareDocumentPosition(m) & 6);
    };
    exports.toASCIILowerCase = function(s) {
      return s.replace(/[A-Z]+/g, function(c) {
        return c.toLowerCase();
      });
    };
    exports.toASCIIUpperCase = function(s) {
      return s.replace(/[a-z]+/g, function(c) {
        return c.toUpperCase();
      });
    };
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/EventTarget.js
var require_EventTarget = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/EventTarget.js"(exports, module) {
    "use strict";
    var Event2 = require_Event();
    var MouseEvent = require_MouseEvent();
    var utils = require_utils();
    module.exports = EventTarget;
    function EventTarget() {
    }
    EventTarget.prototype = {
      // XXX
      // See WebIDL ยง4.8 for details on object event handlers
      // and how they should behave.  We actually have to accept
      // any object to addEventListener... Can't type check it.
      // on registration.
      // XXX:
      // Capturing event listeners are sort of rare.  I think I can optimize
      // them so that dispatchEvent can skip the capturing phase (or much of
      // it).  Each time a capturing listener is added, increment a flag on
      // the target node and each of its ancestors.  Decrement when removed.
      // And update the counter when nodes are added and removed from the
      // tree as well.  Then, in dispatch event, the capturing phase can
      // abort if it sees any node with a zero count.
      addEventListener: function addEventListener(type, listener, capture) {
        if (!listener) return;
        if (capture === void 0) capture = false;
        if (!this._listeners) this._listeners = /* @__PURE__ */ Object.create(null);
        if (!this._listeners[type]) this._listeners[type] = [];
        var list = this._listeners[type];
        for (var i = 0, n = list.length; i < n; i++) {
          var l = list[i];
          if (l.listener === listener && l.capture === capture)
            return;
        }
        var obj = { listener, capture };
        if (typeof listener === "function") obj.f = listener;
        list.push(obj);
      },
      removeEventListener: function removeEventListener(type, listener, capture) {
        if (capture === void 0) capture = false;
        if (this._listeners) {
          var list = this._listeners[type];
          if (list) {
            for (var i = 0, n = list.length; i < n; i++) {
              var l = list[i];
              if (l.listener === listener && l.capture === capture) {
                if (list.length === 1) {
                  this._listeners[type] = void 0;
                } else {
                  list.splice(i, 1);
                }
                return;
              }
            }
          }
        }
      },
      // This is the public API for dispatching untrusted public events.
      // See _dispatchEvent for the implementation
      dispatchEvent: function dispatchEvent(event) {
        return this._dispatchEvent(event, false);
      },
      //
      // See DOMCore ยง4.4
      // XXX: I'll probably need another version of this method for
      // internal use, one that does not set isTrusted to false.
      // XXX: see Document._dispatchEvent: perhaps that and this could
      // call a common internal function with different settings of
      // a trusted boolean argument
      //
      // XXX:
      // The spec has changed in how to deal with handlers registered
      // on idl or content attributes rather than with addEventListener.
      // Used to say that they always ran first.  That's how webkit does it
      // Spec now says that they run in a position determined by
      // when they were first set.  FF does it that way.  See:
      // http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#event-handlers
      //
      _dispatchEvent: function _dispatchEvent(event, trusted) {
        if (typeof trusted !== "boolean") trusted = false;
        function invoke2(target, event2) {
          var type = event2.type, phase = event2.eventPhase;
          event2.currentTarget = target;
          if (phase !== Event2.CAPTURING_PHASE && target._handlers && target._handlers[type]) {
            var handler = target._handlers[type];
            var rv;
            if (typeof handler === "function") {
              rv = handler.call(event2.currentTarget, event2);
            } else {
              var f = handler.handleEvent;
              if (typeof f !== "function")
                throw new TypeError("handleEvent property of event handler object isnot a function.");
              rv = f.call(handler, event2);
            }
            switch (event2.type) {
              case "mouseover":
                if (rv === true)
                  event2.preventDefault();
                break;
              case "beforeunload":
              // XXX: eventually we need a special case here
              /* falls through */
              default:
                if (rv === false)
                  event2.preventDefault();
                break;
            }
          }
          var list = target._listeners && target._listeners[type];
          if (!list) return;
          list = list.slice();
          for (var i2 = 0, n2 = list.length; i2 < n2; i2++) {
            if (event2._immediatePropagationStopped) return;
            var l = list[i2];
            if (phase === Event2.CAPTURING_PHASE && !l.capture || phase === Event2.BUBBLING_PHASE && l.capture)
              continue;
            if (l.f) {
              l.f.call(event2.currentTarget, event2);
            } else {
              var fn = l.listener.handleEvent;
              if (typeof fn !== "function")
                throw new TypeError("handleEvent property of event listener object is not a function.");
              fn.call(l.listener, event2);
            }
          }
        }
        if (!event._initialized || event._dispatching) utils.InvalidStateError();
        event.isTrusted = trusted;
        event._dispatching = true;
        event.target = this;
        var ancestors = [];
        for (var n = this.parentNode; n; n = n.parentNode)
          ancestors.push(n);
        event.eventPhase = Event2.CAPTURING_PHASE;
        for (var i = ancestors.length - 1; i >= 0; i--) {
          invoke2(ancestors[i], event);
          if (event._propagationStopped) break;
        }
        if (!event._propagationStopped) {
          event.eventPhase = Event2.AT_TARGET;
          invoke2(this, event);
        }
        if (event.bubbles && !event._propagationStopped) {
          event.eventPhase = Event2.BUBBLING_PHASE;
          for (var ii = 0, nn = ancestors.length; ii < nn; ii++) {
            invoke2(ancestors[ii], event);
            if (event._propagationStopped) break;
          }
        }
        event._dispatching = false;
        event.eventPhase = Event2.AT_TARGET;
        event.currentTarget = null;
        if (trusted && !event.defaultPrevented && event instanceof MouseEvent) {
          switch (event.type) {
            case "mousedown":
              this._armed = {
                x: event.clientX,
                y: event.clientY,
                t: event.timeStamp
              };
              break;
            case "mouseout":
            case "mouseover":
              this._armed = null;
              break;
            case "mouseup":
              if (this._isClick(event)) this._doClick(event);
              this._armed = null;
              break;
          }
        }
        return !event.defaultPrevented;
      },
      // Determine whether a click occurred
      // XXX We don't support double clicks for now
      _isClick: function(event) {
        return this._armed !== null && event.type === "mouseup" && event.isTrusted && event.button === 0 && event.timeStamp - this._armed.t < 1e3 && Math.abs(event.clientX - this._armed.x) < 10 && Math.abs(event.clientY - this._armed.Y) < 10;
      },
      // Clicks are handled like this:
      // http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#interactive-content-0
      //
      // Note that this method is similar to the HTMLElement.click() method
      // The event argument must be the trusted mouseup event
      _doClick: function(event) {
        if (this._click_in_progress) return;
        this._click_in_progress = true;
        var activated = this;
        while (activated && !activated._post_click_activation_steps)
          activated = activated.parentNode;
        if (activated && activated._pre_click_activation_steps) {
          activated._pre_click_activation_steps();
        }
        var click = this.ownerDocument.createEvent("MouseEvent");
        click.initMouseEvent(
          "click",
          true,
          true,
          this.ownerDocument.defaultView,
          1,
          event.screenX,
          event.screenY,
          event.clientX,
          event.clientY,
          event.ctrlKey,
          event.altKey,
          event.shiftKey,
          event.metaKey,
          event.button,
          null
        );
        var result2 = this._dispatchEvent(click, true);
        if (activated) {
          if (result2) {
            if (activated._post_click_activation_steps)
              activated._post_click_activation_steps(click);
          } else {
            if (activated._cancelled_activation_steps)
              activated._cancelled_activation_steps();
          }
        }
      },
      //
      // An event handler is like an event listener, but it registered
      // by setting an IDL or content attribute like onload or onclick.
      // There can only be one of these at a time for any event type.
      // This is an internal method for the attribute accessors and
      // content attribute handlers that need to register events handlers.
      // The type argument is the same as in addEventListener().
      // The handler argument is the same as listeners in addEventListener:
      // it can be a function or an object. Pass null to remove any existing
      // handler.  Handlers are always invoked before any listeners of
      // the same type.  They are not invoked during the capturing phase
      // of event dispatch.
      //
      _setEventHandler: function _setEventHandler(type, handler) {
        if (!this._handlers) this._handlers = /* @__PURE__ */ Object.create(null);
        this._handlers[type] = handler;
      },
      _getEventHandler: function _getEventHandler(type) {
        return this._handlers && this._handlers[type] || null;
      }
    };
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/LinkedList.js
var require_LinkedList = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/LinkedList.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var LinkedList = module.exports = {
      // basic validity tests on a circular linked list a
      valid: function(a) {
        utils.assert(a, "list falsy");
        utils.assert(a._previousSibling, "previous falsy");
        utils.assert(a._nextSibling, "next falsy");
        return true;
      },
      // insert a before b
      insertBefore: function(a, b) {
        utils.assert(LinkedList.valid(a) && LinkedList.valid(b));
        var a_first = a, a_last = a._previousSibling;
        var b_first = b, b_last = b._previousSibling;
        a_first._previousSibling = b_last;
        a_last._nextSibling = b_first;
        b_last._nextSibling = a_first;
        b_first._previousSibling = a_last;
        utils.assert(LinkedList.valid(a) && LinkedList.valid(b));
      },
      // replace a single node a with a list b (which could be null)
      replace: function(a, b) {
        utils.assert(LinkedList.valid(a) && (b === null || LinkedList.valid(b)));
        if (b !== null) {
          LinkedList.insertBefore(b, a);
        }
        LinkedList.remove(a);
        utils.assert(LinkedList.valid(a) && (b === null || LinkedList.valid(b)));
      },
      // remove single node a from its list
      remove: function(a) {
        utils.assert(LinkedList.valid(a));
        var prev = a._previousSibling;
        if (prev === a) {
          return;
        }
        var next = a._nextSibling;
        prev._nextSibling = next;
        next._previousSibling = prev;
        a._previousSibling = a._nextSibling = a;
        utils.assert(LinkedList.valid(a));
      }
    };
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/NodeUtils.js
var require_NodeUtils = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/NodeUtils.js"(exports, module) {
    "use strict";
    module.exports = {
      // NOTE: The `serializeOne()` function used to live on the `Node.prototype`
      // as a private method `Node#_serializeOne(child)`, however that requires
      // a megamorphic property access `this._serializeOne` just to get to the
      // method, and this is being done on lots of different `Node` subclasses,
      // which puts a lot of pressure on V8's megamorphic stub cache. So by
      // moving the helper off of the `Node.prototype` and into a separate
      // function in this helper module, we get a monomorphic property access
      // `NodeUtils.serializeOne` to get to the function and reduce pressure
      // on the megamorphic stub cache.
      // See https://github.com/fgnass/domino/pull/142 for more information.
      serializeOne
    };
    var utils = require_utils();
    var NAMESPACE = utils.NAMESPACE;
    var hasRawContent = {
      STYLE: true,
      SCRIPT: true,
      XMP: true,
      IFRAME: true,
      NOEMBED: true,
      NOFRAMES: true,
      PLAINTEXT: true
    };
    var emptyElements = {
      area: true,
      base: true,
      basefont: true,
      bgsound: true,
      br: true,
      col: true,
      embed: true,
      frame: true,
      hr: true,
      img: true,
      input: true,
      keygen: true,
      link: true,
      meta: true,
      param: true,
      source: true,
      track: true,
      wbr: true
    };
    var extraNewLine = {
      /* Removed in https://github.com/whatwg/html/issues/944
      pre: true,
      textarea: true,
      listing: true
      */
    };
    function escape(s) {
      return s.replace(/[&<>\u00A0]/g, function(c) {
        switch (c) {
          case "&":
            return "&amp;";
          case "<":
            return "&lt;";
          case ">":
            return "&gt;";
          case "\xA0":
            return "&nbsp;";
        }
      });
    }
    function escapeAttr(s) {
      var toEscape = /[&"\u00A0]/g;
      if (!toEscape.test(s)) {
        return s;
      } else {
        return s.replace(toEscape, function(c) {
          switch (c) {
            case "&":
              return "&amp;";
            case '"':
              return "&quot;";
            case "\xA0":
              return "&nbsp;";
          }
        });
      }
    }
    function attrname(a) {
      var ns = a.namespaceURI;
      if (!ns)
        return a.localName;
      if (ns === NAMESPACE.XML)
        return "xml:" + a.localName;
      if (ns === NAMESPACE.XLINK)
        return "xlink:" + a.localName;
      if (ns === NAMESPACE.XMLNS) {
        if (a.localName === "xmlns") return "xmlns";
        else return "xmlns:" + a.localName;
      }
      return a.name;
    }
    function serializeOne(kid, parent) {
      var s = "";
      switch (kid.nodeType) {
        case 1:
          var ns = kid.namespaceURI;
          var html = ns === NAMESPACE.HTML;
          var tagname = html || ns === NAMESPACE.SVG || ns === NAMESPACE.MATHML ? kid.localName : kid.tagName;
          s += "<" + tagname;
          for (var j = 0, k = kid._numattrs; j < k; j++) {
            var a = kid._attr(j);
            s += " " + attrname(a);
            if (a.value !== void 0) s += '="' + escapeAttr(a.value) + '"';
          }
          s += ">";
          if (!(html && emptyElements[tagname])) {
            var ss = kid.serialize();
            if (html && extraNewLine[tagname] && ss.charAt(0) === "\n") s += "\n";
            s += ss;
            s += "</" + tagname + ">";
          }
          break;
        case 3:
        //TEXT_NODE
        case 4:
          var parenttag;
          if (parent.nodeType === 1 && parent.namespaceURI === NAMESPACE.HTML)
            parenttag = parent.tagName;
          else
            parenttag = "";
          if (hasRawContent[parenttag] || parenttag === "NOSCRIPT" && parent.ownerDocument._scripting_enabled) {
            s += kid.data;
          } else {
            s += escape(kid.data);
          }
          break;
        case 8:
          s += "<!--" + kid.data + "-->";
          break;
        case 7:
          s += "<?" + kid.target + " " + kid.data + "?>";
          break;
        case 10:
          s += "<!DOCTYPE " + kid.name;
          if (false) {
            if (kid.publicID) {
              s += ' PUBLIC "' + kid.publicId + '"';
            }
            if (kid.systemId) {
              s += ' "' + kid.systemId + '"';
            }
          }
          s += ">";
          break;
        default:
          utils.InvalidStateError();
      }
      return s;
    }
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/Node.js
var require_Node = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/Node.js"(exports, module) {
    "use strict";
    module.exports = Node;
    var EventTarget = require_EventTarget();
    var LinkedList = require_LinkedList();
    var NodeUtils = require_NodeUtils();
    var utils = require_utils();
    function Node() {
      EventTarget.call(this);
      this.parentNode = null;
      this._nextSibling = this._previousSibling = this;
      this._index = void 0;
    }
    var ELEMENT_NODE = Node.ELEMENT_NODE = 1;
    var ATTRIBUTE_NODE = Node.ATTRIBUTE_NODE = 2;
    var TEXT_NODE = Node.TEXT_NODE = 3;
    var CDATA_SECTION_NODE = Node.CDATA_SECTION_NODE = 4;
    var ENTITY_REFERENCE_NODE = Node.ENTITY_REFERENCE_NODE = 5;
    var ENTITY_NODE = Node.ENTITY_NODE = 6;
    var PROCESSING_INSTRUCTION_NODE = Node.PROCESSING_INSTRUCTION_NODE = 7;
    var COMMENT_NODE = Node.COMMENT_NODE = 8;
    var DOCUMENT_NODE = Node.DOCUMENT_NODE = 9;
    var DOCUMENT_TYPE_NODE = Node.DOCUMENT_TYPE_NODE = 10;
    var DOCUMENT_FRAGMENT_NODE = Node.DOCUMENT_FRAGMENT_NODE = 11;
    var NOTATION_NODE = Node.NOTATION_NODE = 12;
    var DOCUMENT_POSITION_DISCONNECTED = Node.DOCUMENT_POSITION_DISCONNECTED = 1;
    var DOCUMENT_POSITION_PRECEDING = Node.DOCUMENT_POSITION_PRECEDING = 2;
    var DOCUMENT_POSITION_FOLLOWING = Node.DOCUMENT_POSITION_FOLLOWING = 4;
    var DOCUMENT_POSITION_CONTAINS = Node.DOCUMENT_POSITION_CONTAINS = 8;
    var DOCUMENT_POSITION_CONTAINED_BY = Node.DOCUMENT_POSITION_CONTAINED_BY = 16;
    var DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
    Node.prototype = Object.create(EventTarget.prototype, {
      // Node that are not inserted into the tree inherit a null parent
      // XXX: the baseURI attribute is defined by dom core, but
      // a correct implementation of it requires HTML features, so
      // we'll come back to this later.
      baseURI: { get: utils.nyi },
      parentElement: { get: function() {
        return this.parentNode && this.parentNode.nodeType === ELEMENT_NODE ? this.parentNode : null;
      } },
      hasChildNodes: { value: utils.shouldOverride },
      firstChild: { get: utils.shouldOverride },
      lastChild: { get: utils.shouldOverride },
      isConnected: {
        get: function() {
          let node = this;
          while (node != null) {
            if (node.nodeType === Node.DOCUMENT_NODE) {
              return true;
            }
            node = node.parentNode;
            if (node != null && node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
              node = node.host;
            }
          }
          return false;
        }
      },
      previousSibling: { get: function() {
        var parent = this.parentNode;
        if (!parent) return null;
        if (this === parent.firstChild) return null;
        return this._previousSibling;
      } },
      nextSibling: { get: function() {
        var parent = this.parentNode, next = this._nextSibling;
        if (!parent) return null;
        if (next === parent.firstChild) return null;
        return next;
      } },
      textContent: {
        // Should override for DocumentFragment/Element/Attr/Text/PI/Comment
        get: function() {
          return null;
        },
        set: function(v) {
        }
      },
      _countChildrenOfType: { value: function(type) {
        var sum = 0;
        for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {
          if (kid.nodeType === type) sum++;
        }
        return sum;
      } },
      _ensureInsertValid: { value: function _ensureInsertValid(node, child, isPreinsert) {
        var parent = this, i, kid;
        if (!node.nodeType) throw new TypeError("not a node");
        switch (parent.nodeType) {
          case DOCUMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE:
          case ELEMENT_NODE:
            break;
          default:
            utils.HierarchyRequestError();
        }
        if (node.isAncestor(parent)) utils.HierarchyRequestError();
        if (child !== null || !isPreinsert) {
          if (child.parentNode !== parent) utils.NotFoundError();
        }
        switch (node.nodeType) {
          case DOCUMENT_FRAGMENT_NODE:
          case DOCUMENT_TYPE_NODE:
          case ELEMENT_NODE:
          case TEXT_NODE:
          case PROCESSING_INSTRUCTION_NODE:
          case COMMENT_NODE:
            break;
          default:
            utils.HierarchyRequestError();
        }
        if (parent.nodeType === DOCUMENT_NODE) {
          switch (node.nodeType) {
            case TEXT_NODE:
              utils.HierarchyRequestError();
              break;
            case DOCUMENT_FRAGMENT_NODE:
              if (node._countChildrenOfType(TEXT_NODE) > 0)
                utils.HierarchyRequestError();
              switch (node._countChildrenOfType(ELEMENT_NODE)) {
                case 0:
                  break;
                case 1:
                  if (child !== null) {
                    if (isPreinsert && child.nodeType === DOCUMENT_TYPE_NODE)
                      utils.HierarchyRequestError();
                    for (kid = child.nextSibling; kid !== null; kid = kid.nextSibling) {
                      if (kid.nodeType === DOCUMENT_TYPE_NODE)
                        utils.HierarchyRequestError();
                    }
                  }
                  i = parent._countChildrenOfType(ELEMENT_NODE);
                  if (isPreinsert) {
                    if (i > 0)
                      utils.HierarchyRequestError();
                  } else {
                    if (i > 1 || i === 1 && child.nodeType !== ELEMENT_NODE)
                      utils.HierarchyRequestError();
                  }
                  break;
                default:
                  utils.HierarchyRequestError();
              }
              break;
            case ELEMENT_NODE:
              if (child !== null) {
                if (isPreinsert && child.nodeType === DOCUMENT_TYPE_NODE)
                  utils.HierarchyRequestError();
                for (kid = child.nextSibling; kid !== null; kid = kid.nextSibling) {
                  if (kid.nodeType === DOCUMENT_TYPE_NODE)
                    utils.HierarchyRequestError();
                }
              }
              i = parent._countChildrenOfType(ELEMENT_NODE);
              if (isPreinsert) {
                if (i > 0)
                  utils.HierarchyRequestError();
              } else {
                if (i > 1 || i === 1 && child.nodeType !== ELEMENT_NODE)
                  utils.HierarchyRequestError();
              }
              break;
            case DOCUMENT_TYPE_NODE:
              if (child === null) {
                if (parent._countChildrenOfType(ELEMENT_NODE))
                  utils.HierarchyRequestError();
              } else {
                for (kid = parent.firstChild; kid !== null; kid = kid.nextSibling) {
                  if (kid === child) break;
                  if (kid.nodeType === ELEMENT_NODE)
                    utils.HierarchyRequestError();
                }
              }
              i = parent._countChildrenOfType(DOCUMENT_TYPE_NODE);
              if (isPreinsert) {
                if (i > 0)
                  utils.HierarchyRequestError();
              } else {
                if (i > 1 || i === 1 && child.nodeType !== DOCUMENT_TYPE_NODE)
                  utils.HierarchyRequestError();
              }
              break;
          }
        } else {
          if (node.nodeType === DOCUMENT_TYPE_NODE) utils.HierarchyRequestError();
        }
      } },
      insertBefore: { value: function insertBefore(node, child) {
        var parent = this;
        parent._ensureInsertValid(node, child, true);
        var refChild = child;
        if (refChild === node) {
          refChild = node.nextSibling;
        }
        parent.doc.adoptNode(node);
        node._insertOrReplace(parent, refChild, false);
        return node;
      } },
      appendChild: { value: function(child) {
        return this.insertBefore(child, null);
      } },
      _appendChild: { value: function(child) {
        child._insertOrReplace(this, null, false);
      } },
      removeChild: { value: function removeChild(child) {
        var parent = this;
        if (!child.nodeType) throw new TypeError("not a node");
        if (child.parentNode !== parent) utils.NotFoundError();
        child.remove();
        return child;
      } },
      // To replace a `child` with `node` within a `parent` (this)
      replaceChild: { value: function replaceChild(node, child) {
        var parent = this;
        parent._ensureInsertValid(node, child, false);
        if (node.doc !== parent.doc) {
          parent.doc.adoptNode(node);
        }
        node._insertOrReplace(parent, child, true);
        return child;
      } },
      // See: http://ejohn.org/blog/comparing-document-position/
      contains: { value: function contains(node) {
        if (node === null) {
          return false;
        }
        if (this === node) {
          return true;
        }
        return (this.compareDocumentPosition(node) & DOCUMENT_POSITION_CONTAINED_BY) !== 0;
      } },
      compareDocumentPosition: { value: function compareDocumentPosition(that) {
        if (this === that) return 0;
        if (this.doc !== that.doc || this.rooted !== that.rooted)
          return DOCUMENT_POSITION_DISCONNECTED + DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
        var these = [], those = [];
        for (var n = this; n !== null; n = n.parentNode) these.push(n);
        for (n = that; n !== null; n = n.parentNode) those.push(n);
        these.reverse();
        those.reverse();
        if (these[0] !== those[0])
          return DOCUMENT_POSITION_DISCONNECTED + DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
        n = Math.min(these.length, those.length);
        for (var i = 1; i < n; i++) {
          if (these[i] !== those[i]) {
            if (these[i].index < those[i].index)
              return DOCUMENT_POSITION_FOLLOWING;
            else
              return DOCUMENT_POSITION_PRECEDING;
          }
        }
        if (these.length < those.length)
          return DOCUMENT_POSITION_FOLLOWING + DOCUMENT_POSITION_CONTAINED_BY;
        else
          return DOCUMENT_POSITION_PRECEDING + DOCUMENT_POSITION_CONTAINS;
      } },
      isSameNode: { value: function isSameNode(node) {
        return this === node;
      } },
      // This method implements the generic parts of node equality testing
      // and defers to the (non-recursive) type-specific isEqual() method
      // defined by subclasses
      isEqualNode: { value: function isEqualNode(node) {
        if (!node) return false;
        if (node.nodeType !== this.nodeType) return false;
        if (!this.isEqual(node)) return false;
        for (var c1 = this.firstChild, c2 = node.firstChild; c1 && c2; c1 = c1.nextSibling, c2 = c2.nextSibling) {
          if (!c1.isEqualNode(c2)) return false;
        }
        return c1 === null && c2 === null;
      } },
      // This method delegates shallow cloning to a clone() method
      // that each concrete subclass must implement
      cloneNode: { value: function(deep) {
        var clone = this.clone();
        if (deep) {
          for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {
            clone._appendChild(kid.cloneNode(true));
          }
        }
        return clone;
      } },
      lookupPrefix: { value: function lookupPrefix(ns) {
        var e;
        if (ns === "" || ns === null || ns === void 0) return null;
        switch (this.nodeType) {
          case ELEMENT_NODE:
            return this._lookupNamespacePrefix(ns, this);
          case DOCUMENT_NODE:
            e = this.documentElement;
            return e ? e.lookupPrefix(ns) : null;
          case ENTITY_NODE:
          case NOTATION_NODE:
          case DOCUMENT_FRAGMENT_NODE:
          case DOCUMENT_TYPE_NODE:
            return null;
          case ATTRIBUTE_NODE:
            e = this.ownerElement;
            return e ? e.lookupPrefix(ns) : null;
          default:
            e = this.parentElement;
            return e ? e.lookupPrefix(ns) : null;
        }
      } },
      lookupNamespaceURI: { value: function lookupNamespaceURI(prefix) {
        if (prefix === "" || prefix === void 0) {
          prefix = null;
        }
        var e;
        switch (this.nodeType) {
          case ELEMENT_NODE:
            return utils.shouldOverride();
          case DOCUMENT_NODE:
            e = this.documentElement;
            return e ? e.lookupNamespaceURI(prefix) : null;
          case ENTITY_NODE:
          case NOTATION_NODE:
          case DOCUMENT_TYPE_NODE:
          case DOCUMENT_FRAGMENT_NODE:
            return null;
          case ATTRIBUTE_NODE:
            e = this.ownerElement;
            return e ? e.lookupNamespaceURI(prefix) : null;
          default:
            e = this.parentElement;
            return e ? e.lookupNamespaceURI(prefix) : null;
        }
      } },
      isDefaultNamespace: { value: function isDefaultNamespace(ns) {
        if (ns === "" || ns === void 0) {
          ns = null;
        }
        var defaultNamespace = this.lookupNamespaceURI(null);
        return defaultNamespace === ns;
      } },
      // Utility methods for nodes.  Not part of the DOM
      // Return the index of this node in its parent.
      // Throw if no parent, or if this node is not a child of its parent
      index: { get: function() {
        var parent = this.parentNode;
        if (this === parent.firstChild) return 0;
        var kids = parent.childNodes;
        if (this._index === void 0 || kids[this._index] !== this) {
          for (var i = 0; i < kids.length; i++) {
            kids[i]._index = i;
          }
          utils.assert(kids[this._index] === this);
        }
        return this._index;
      } },
      // Return true if this node is equal to or is an ancestor of that node
      // Note that nodes are considered to be ancestors of themselves
      isAncestor: { value: function(that) {
        if (this.doc !== that.doc) return false;
        if (this.rooted !== that.rooted) return false;
        for (var e = that; e; e = e.parentNode) {
          if (e === this) return true;
        }
        return false;
      } },
      // DOMINO Changed the behavior to conform with the specs. See:
      // https://groups.google.com/d/topic/mozilla.dev.platform/77sIYcpdDmc/discussion
      ensureSameDoc: { value: function(that) {
        if (that.ownerDocument === null) {
          that.ownerDocument = this.doc;
        } else if (that.ownerDocument !== this.doc) {
          utils.WrongDocumentError();
        }
      } },
      removeChildren: { value: utils.shouldOverride },
      // Insert this node as a child of parent before the specified child,
      // or insert as the last child of parent if specified child is null,
      // or replace the specified child with this node, firing mutation events as
      // necessary
      _insertOrReplace: { value: function _insertOrReplace(parent, before, isReplace) {
        var child = this, before_index, i;
        if (child.nodeType === DOCUMENT_FRAGMENT_NODE && child.rooted) {
          utils.HierarchyRequestError();
        }
        if (parent._childNodes) {
          before_index = before === null ? parent._childNodes.length : before.index;
          if (child.parentNode === parent) {
            var child_index = child.index;
            if (child_index < before_index) {
              before_index--;
            }
          }
        }
        if (isReplace) {
          if (before.rooted) before.doc.mutateRemove(before);
          before.parentNode = null;
        }
        var n = before;
        if (n === null) {
          n = parent.firstChild;
        }
        var bothRooted = child.rooted && parent.rooted;
        if (child.nodeType === DOCUMENT_FRAGMENT_NODE) {
          var spliceArgs = [0, isReplace ? 1 : 0], next;
          for (var kid = child.firstChild; kid !== null; kid = next) {
            next = kid.nextSibling;
            spliceArgs.push(kid);
            kid.parentNode = parent;
          }
          var len = spliceArgs.length;
          if (isReplace) {
            LinkedList.replace(n, len > 2 ? spliceArgs[2] : null);
          } else if (len > 2 && n !== null) {
            LinkedList.insertBefore(spliceArgs[2], n);
          }
          if (parent._childNodes) {
            spliceArgs[0] = before === null ? parent._childNodes.length : before._index;
            parent._childNodes.splice.apply(parent._childNodes, spliceArgs);
            for (i = 2; i < len; i++) {
              spliceArgs[i]._index = spliceArgs[0] + (i - 2);
            }
          } else if (parent._firstChild === before) {
            if (len > 2) {
              parent._firstChild = spliceArgs[2];
            } else if (isReplace) {
              parent._firstChild = null;
            }
          }
          if (child._childNodes) {
            child._childNodes.length = 0;
          } else {
            child._firstChild = null;
          }
          if (parent.rooted) {
            parent.modify();
            for (i = 2; i < len; i++) {
              parent.doc.mutateInsert(spliceArgs[i]);
            }
          }
        } else {
          if (before === child) {
            return;
          }
          if (bothRooted) {
            child._remove();
          } else if (child.parentNode) {
            child.remove();
          }
          child.parentNode = parent;
          if (isReplace) {
            LinkedList.replace(n, child);
            if (parent._childNodes) {
              child._index = before_index;
              parent._childNodes[before_index] = child;
            } else if (parent._firstChild === before) {
              parent._firstChild = child;
            }
          } else {
            if (n !== null) {
              LinkedList.insertBefore(child, n);
            }
            if (parent._childNodes) {
              child._index = before_index;
              parent._childNodes.splice(before_index, 0, child);
            } else if (parent._firstChild === before) {
              parent._firstChild = child;
            }
          }
          if (bothRooted) {
            parent.modify();
            parent.doc.mutateMove(child);
          } else if (parent.rooted) {
            parent.modify();
            parent.doc.mutateInsert(child);
          }
        }
      } },
      // Return the lastModTime value for this node. (For use as a
      // cache invalidation mechanism. If the node does not already
      // have one, initialize it from the owner document's modclock
      // property. (Note that modclock does not return the actual
      // time; it is simply a counter incremented on each document
      // modification)
      lastModTime: { get: function() {
        if (!this._lastModTime) {
          this._lastModTime = this.doc.modclock;
        }
        return this._lastModTime;
      } },
      // Increment the owner document's modclock and use the new
      // value to update the lastModTime value for this node and
      // all of its ancestors. Nodes that have never had their
      // lastModTime value queried do not need to have a
      // lastModTime property set on them since there is no
      // previously queried value to ever compare the new value
      // against, so only update nodes that already have a
      // _lastModTime property.
      modify: { value: function() {
        if (this.doc.modclock) {
          var time = ++this.doc.modclock;
          for (var n = this; n; n = n.parentElement) {
            if (n._lastModTime) {
              n._lastModTime = time;
            }
          }
        }
      } },
      // This attribute is not part of the DOM but is quite helpful.
      // It returns the document with which a node is associated.  Usually
      // this is the ownerDocument. But ownerDocument is null for the
      // document object itself, so this is a handy way to get the document
      // regardless of the node type
      doc: { get: function() {
        return this.ownerDocument || this;
      } },
      // If the node has a nid (node id), then it is rooted in a document
      rooted: { get: function() {
        return !!this._nid;
      } },
      normalize: { value: function() {
        var next;
        for (var child = this.firstChild; child !== null; child = next) {
          next = child.nextSibling;
          if (child.normalize) {
            child.normalize();
          }
          if (child.nodeType !== Node.TEXT_NODE) {
            continue;
          }
          if (child.nodeValue === "") {
            this.removeChild(child);
            continue;
          }
          var prevChild = child.previousSibling;
          if (prevChild === null) {
            continue;
          } else if (prevChild.nodeType === Node.TEXT_NODE) {
            prevChild.appendData(child.nodeValue);
            this.removeChild(child);
          }
        }
      } },
      // Convert the children of a node to an HTML string.
      // This is used by the innerHTML getter
      // The serialization spec is at:
      // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#serializing-html-fragments
      //
      // The serialization logic is intentionally implemented in a separate
      // `NodeUtils` helper instead of the more obvious choice of a private
      // `_serializeOne()` method on the `Node.prototype` in order to avoid
      // the megamorphic `this._serializeOne` property access, which reduces
      // performance unnecessarily. If you need specialized behavior for a
      // certain subclass, you'll need to implement that in `NodeUtils`.
      // See https://github.com/fgnass/domino/pull/142 for more information.
      serialize: { value: function() {
        var s = "";
        for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {
          s += NodeUtils.serializeOne(kid, this);
        }
        return s;
      } },
      // Non-standard, but often useful for debugging.
      outerHTML: {
        get: function() {
          return NodeUtils.serializeOne(this, { nodeType: 0 });
        },
        set: utils.nyi
      },
      // mirror node type properties in the prototype, so they are present
      // in instances of Node (and subclasses)
      ELEMENT_NODE: { value: ELEMENT_NODE },
      ATTRIBUTE_NODE: { value: ATTRIBUTE_NODE },
      TEXT_NODE: { value: TEXT_NODE },
      CDATA_SECTION_NODE: { value: CDATA_SECTION_NODE },
      ENTITY_REFERENCE_NODE: { value: ENTITY_REFERENCE_NODE },
      ENTITY_NODE: { value: ENTITY_NODE },
      PROCESSING_INSTRUCTION_NODE: { value: PROCESSING_INSTRUCTION_NODE },
      COMMENT_NODE: { value: COMMENT_NODE },
      DOCUMENT_NODE: { value: DOCUMENT_NODE },
      DOCUMENT_TYPE_NODE: { value: DOCUMENT_TYPE_NODE },
      DOCUMENT_FRAGMENT_NODE: { value: DOCUMENT_FRAGMENT_NODE },
      NOTATION_NODE: { value: NOTATION_NODE },
      DOCUMENT_POSITION_DISCONNECTED: { value: DOCUMENT_POSITION_DISCONNECTED },
      DOCUMENT_POSITION_PRECEDING: { value: DOCUMENT_POSITION_PRECEDING },
      DOCUMENT_POSITION_FOLLOWING: { value: DOCUMENT_POSITION_FOLLOWING },
      DOCUMENT_POSITION_CONTAINS: { value: DOCUMENT_POSITION_CONTAINS },
      DOCUMENT_POSITION_CONTAINED_BY: { value: DOCUMENT_POSITION_CONTAINED_BY },
      DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: { value: DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC }
    });
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/NodeList.es6.js
var require_NodeList_es6 = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/NodeList.es6.js"(exports, module) {
    "use strict";
    module.exports = class NodeList extends Array {
      constructor(a) {
        super(a && a.length || 0);
        if (a) {
          for (var idx in a) {
            this[idx] = a[idx];
          }
        }
      }
      item(i) {
        return this[i] || null;
      }
    };
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/NodeList.es5.js
var require_NodeList_es5 = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/NodeList.es5.js"(exports, module) {
    "use strict";
    function item(i) {
      return this[i] || null;
    }
    function NodeList(a) {
      if (!a) a = [];
      a.item = item;
      return a;
    }
    module.exports = NodeList;
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/NodeList.js
var require_NodeList = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/NodeList.js"(exports, module) {
    "use strict";
    var NodeList;
    try {
      NodeList = require_NodeList_es6();
    } catch (e) {
      NodeList = require_NodeList_es5();
    }
    module.exports = NodeList;
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/ContainerNode.js
var require_ContainerNode = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/ContainerNode.js"(exports, module) {
    "use strict";
    module.exports = ContainerNode;
    var Node = require_Node();
    var NodeList = require_NodeList();
    function ContainerNode() {
      Node.call(this);
      this._firstChild = this._childNodes = null;
    }
    ContainerNode.prototype = Object.create(Node.prototype, {
      hasChildNodes: { value: function() {
        if (this._childNodes) {
          return this._childNodes.length > 0;
        }
        return this._firstChild !== null;
      } },
      childNodes: { get: function() {
        this._ensureChildNodes();
        return this._childNodes;
      } },
      firstChild: { get: function() {
        if (this._childNodes) {
          return this._childNodes.length === 0 ? null : this._childNodes[0];
        }
        return this._firstChild;
      } },
      lastChild: { get: function() {
        var kids = this._childNodes, first;
        if (kids) {
          return kids.length === 0 ? null : kids[kids.length - 1];
        }
        first = this._firstChild;
        if (first === null) {
          return null;
        }
        return first._previousSibling;
      } },
      _ensureChildNodes: { value: function() {
        if (this._childNodes) {
          return;
        }
        var first = this._firstChild, kid = first, childNodes = this._childNodes = new NodeList();
        if (first) do {
          childNodes.push(kid);
          kid = kid._nextSibling;
        } while (kid !== first);
        this._firstChild = null;
      } },
      replaceChildren: {
        value: function replaceChildren() {
          this.removeChildren();
        }
      },
      // Remove all of this node's children.  This is a minor
      // optimization that only calls modify() once.
      removeChildren: { value: function removeChildren() {
        var root = this.rooted ? this.ownerDocument : null, next = this.firstChild, kid;
        while (next !== null) {
          kid = next;
          next = kid.nextSibling;
          if (root) root.mutateRemove(kid);
          kid.parentNode = null;
        }
        if (this._childNodes) {
          this._childNodes.length = 0;
        } else {
          this._firstChild = null;
        }
        this.modify();
      } }
    });
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/xmlnames.js
var require_xmlnames = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/xmlnames.js"(exports) {
    "use strict";
    exports.isValidName = isValidName;
    exports.isValidQName = isValidQName;
    var simplename = /^[_:A-Za-z][-.:\w]+$/;
    var simpleqname = /^([_A-Za-z][-.\w]+|[_A-Za-z][-.\w]+:[_A-Za-z][-.\w]+)$/;
    var ncnamestartchars = "_A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";
    var ncnamechars = "-._A-Za-z0-9\xB7\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0300-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";
    var ncname = "[" + ncnamestartchars + "][" + ncnamechars + "]*";
    var namestartchars = ncnamestartchars + ":";
    var namechars = ncnamechars + ":";
    var name = new RegExp("^[" + namestartchars + "][" + namechars + "]*$");
    var qname = new RegExp("^(" + ncname + "|" + ncname + ":" + ncname + ")$");
    var hassurrogates = /[\uD800-\uDB7F\uDC00-\uDFFF]/;
    var surrogatechars = /[\uD800-\uDB7F\uDC00-\uDFFF]/g;
    var surrogatepairs = /[\uD800-\uDB7F][\uDC00-\uDFFF]/g;
    ncnamestartchars += "\uD800-\u{EFC00}-\uDFFF";
    ncnamechars += "\uD800-\u{EFC00}-\uDFFF";
    ncname = "[" + ncnamestartchars + "][" + ncnamechars + "]*";
    namestartchars = ncnamestartchars + ":";
    namechars = ncnamechars + ":";
    var surrogatename = new RegExp("^[" + namestartchars + "][" + namechars + "]*$");
    var surrogateqname = new RegExp("^(" + ncname + "|" + ncname + ":" + ncname + ")$");
    function isValidName(s) {
      if (simplename.test(s)) return true;
      if (name.test(s)) return true;
      if (!hassurrogates.test(s)) return false;
      if (!surrogatename.test(s)) return false;
      var chars = s.match(surrogatechars), pairs = s.match(surrogatepairs);
      return pairs !== null && 2 * pairs.length === chars.length;
    }
    function isValidQName(s) {
      if (simpleqname.test(s)) return true;
      if (qname.test(s)) return true;
      if (!hassurrogates.test(s)) return false;
      if (!surrogateqname.test(s)) return false;
      var chars = s.match(surrogatechars), pairs = s.match(surrogatepairs);
      return pairs !== null && 2 * pairs.length === chars.length;
    }
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/attributes.js
var require_attributes = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/attributes.js"(exports) {
    "use strict";
    var utils = require_utils();
    exports.property = function(attr) {
      if (Array.isArray(attr.type)) {
        var valid = /* @__PURE__ */ Object.create(null);
        attr.type.forEach(function(val) {
          valid[val.value || val] = val.alias || val;
        });
        var missingValueDefault = attr.missing;
        if (missingValueDefault === void 0) {
          missingValueDefault = null;
        }
        var invalidValueDefault = attr.invalid;
        if (invalidValueDefault === void 0) {
          invalidValueDefault = missingValueDefault;
        }
        return {
          get: function() {
            var v = this._getattr(attr.name);
            if (v === null) return missingValueDefault;
            v = valid[v.toLowerCase()];
            if (v !== void 0) return v;
            if (invalidValueDefault !== null) return invalidValueDefault;
            return v;
          },
          set: function(v) {
            this._setattr(attr.name, v);
          }
        };
      } else if (attr.type === Boolean) {
        return {
          get: function() {
            return this.hasAttribute(attr.name);
          },
          set: function(v) {
            if (v) {
              this._setattr(attr.name, "");
            } else {
              this.removeAttribute(attr.name);
            }
          }
        };
      } else if (attr.type === Number || attr.type === "long" || attr.type === "unsigned long" || attr.type === "limited unsigned long with fallback") {
        return numberPropDesc(attr);
      } else if (!attr.type || attr.type === String) {
        return {
          get: function() {
            return this._getattr(attr.name) || "";
          },
          set: function(v) {
            if (attr.treatNullAsEmptyString && v === null) {
              v = "";
            }
            this._setattr(attr.name, v);
          }
        };
      } else if (typeof attr.type === "function") {
        return attr.type(attr.name, attr);
      }
      throw new Error("Invalid attribute definition");
    };
    function numberPropDesc(a) {
      var def;
      if (typeof a.default === "function") {
        def = a.default;
      } else if (typeof a.default === "number") {
        def = function() {
          return a.default;
        };
      } else {
        def = function() {
          utils.assert(false, typeof a.default);
        };
      }
      var unsigned_long = a.type === "unsigned long";
      var signed_long = a.type === "long";
      var unsigned_fallback = a.type === "limited unsigned long with fallback";
      var min = a.min, max = a.max, setmin = a.setmin;
      if (min === void 0) {
        if (unsigned_long) min = 0;
        if (signed_long) min = -2147483648;
        if (unsigned_fallback) min = 1;
      }
      if (max === void 0) {
        if (unsigned_long || signed_long || unsigned_fallback) max = 2147483647;
      }
      return {
        get: function() {
          var v = this._getattr(a.name);
          var n = a.float ? parseFloat(v) : parseInt(v, 10);
          if (v === null || !isFinite(n) || min !== void 0 && n < min || max !== void 0 && n > max) {
            return def.call(this);
          }
          if (unsigned_long || signed_long || unsigned_fallback) {
            if (!/^[ \t\n\f\r]*[-+]?[0-9]/.test(v)) {
              return def.call(this);
            }
            n = n | 0;
          }
          return n;
        },
        set: function(v) {
          if (!a.float) {
            v = Math.floor(v);
          }
          if (setmin !== void 0 && v < setmin) {
            utils.IndexSizeError(a.name + " set to " + v);
          }
          if (unsigned_long) {
            v = v < 0 || v > 2147483647 ? def.call(this) : v | 0;
          } else if (unsigned_fallback) {
            v = v < 1 || v > 2147483647 ? def.call(this) : v | 0;
          } else if (signed_long) {
            v = v < -2147483648 || v > 2147483647 ? def.call(this) : v | 0;
          }
          this._setattr(a.name, String(v));
        }
      };
    }
    exports.registerChangeHandler = function(c, name, handler) {
      var p = c.prototype;
      if (!Object.prototype.hasOwnProperty.call(p, "_attributeChangeHandlers")) {
        p._attributeChangeHandlers = Object.create(p._attributeChangeHandlers || null);
      }
      p._attributeChangeHandlers[name] = handler;
    };
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/FilteredElementList.js
var require_FilteredElementList = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/FilteredElementList.js"(exports, module) {
    "use strict";
    module.exports = FilteredElementList;
    var Node = require_Node();
    function FilteredElementList(root, filter) {
      this.root = root;
      this.filter = filter;
      this.lastModTime = root.lastModTime;
      this.done = false;
      this.cache = [];
      this.traverse();
    }
    FilteredElementList.prototype = Object.create(Object.prototype, {
      length: { get: function() {
        this.checkcache();
        if (!this.done) this.traverse();
        return this.cache.length;
      } },
      item: { value: function(n) {
        this.checkcache();
        if (!this.done && n >= this.cache.length) {
          this.traverse(
            /*n*/
          );
        }
        return this.cache[n];
      } },
      checkcache: { value: function() {
        if (this.lastModTime !== this.root.lastModTime) {
          for (var i = this.cache.length - 1; i >= 0; i--) {
            this[i] = void 0;
          }
          this.cache.length = 0;
          this.done = false;
          this.lastModTime = this.root.lastModTime;
        }
      } },
      // If n is specified, then traverse the tree until we've found the nth
      // item (or until we've found all items).  If n is not specified,
      // traverse until we've found all items.
      traverse: { value: function(n) {
        if (n !== void 0) n++;
        var elt;
        while ((elt = this.next()) !== null) {
          this[this.cache.length] = elt;
          this.cache.push(elt);
          if (n && this.cache.length === n) return;
        }
        this.done = true;
      } },
      // Return the next element under root that matches filter
      next: { value: function() {
        var start = this.cache.length === 0 ? this.root : this.cache[this.cache.length - 1];
        var elt;
        if (start.nodeType === Node.DOCUMENT_NODE)
          elt = start.documentElement;
        else
          elt = start.nextElement(this.root);
        while (elt) {
          if (this.filter(elt)) {
            return elt;
          }
          elt = elt.nextElement(this.root);
        }
        return null;
      } }
    });
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/DOMTokenList.js
var require_DOMTokenList = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/DOMTokenList.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = DOMTokenList;
    function DOMTokenList(getter, setter) {
      this._getString = getter;
      this._setString = setter;
      this._length = 0;
      this._lastStringValue = "";
      this._update();
    }
    Object.defineProperties(DOMTokenList.prototype, {
      length: { get: function() {
        return this._length;
      } },
      item: { value: function(index) {
        var list = getList(this);
        if (index < 0 || index >= list.length) {
          return null;
        }
        return list[index];
      } },
      contains: { value: function(token) {
        token = String(token);
        var list = getList(this);
        return list.indexOf(token) > -1;
      } },
      add: { value: function() {
        var list = getList(this);
        for (var i = 0, len = arguments.length; i < len; i++) {
          var token = handleErrors(arguments[i]);
          if (list.indexOf(token) < 0) {
            list.push(token);
          }
        }
        this._update(list);
      } },
      remove: { value: function() {
        var list = getList(this);
        for (var i = 0, len = arguments.length; i < len; i++) {
          var token = handleErrors(arguments[i]);
          var index = list.indexOf(token);
          if (index > -1) {
            list.splice(index, 1);
          }
        }
        this._update(list);
      } },
      toggle: { value: function toggle(token, force) {
        token = handleErrors(token);
        if (this.contains(token)) {
          if (force === void 0 || force === false) {
            this.remove(token);
            return false;
          }
          return true;
        } else {
          if (force === void 0 || force === true) {
            this.add(token);
            return true;
          }
          return false;
        }
      } },
      replace: { value: function replace(token, newToken) {
        if (String(newToken) === "") {
          utils.SyntaxError();
        }
        token = handleErrors(token);
        newToken = handleErrors(newToken);
        var list = getList(this);
        var idx = list.indexOf(token);
        if (idx < 0) {
          return false;
        }
        var idx2 = list.indexOf(newToken);
        if (idx2 < 0) {
          list[idx] = newToken;
        } else {
          if (idx < idx2) {
            list[idx] = newToken;
            list.splice(idx2, 1);
          } else {
            list.splice(idx, 1);
          }
        }
        this._update(list);
        return true;
      } },
      toString: { value: function() {
        return this._getString();
      } },
      value: {
        get: function() {
          return this._getString();
        },
        set: function(v) {
          this._setString(v);
          this._update();
        }
      },
      // Called when the setter is called from outside this interface.
      _update: { value: function(list) {
        if (list) {
          fixIndex(this, list);
          this._setString(list.join(" ").trim());
        } else {
          fixIndex(this, getList(this));
        }
        this._lastStringValue = this._getString();
      } }
    });
    function fixIndex(clist, list) {
      var oldLength = clist._length;
      var i;
      clist._length = list.length;
      for (i = 0; i < list.length; i++) {
        clist[i] = list[i];
      }
      for (; i < oldLength; i++) {
        clist[i] = void 0;
      }
    }
    function handleErrors(token) {
      token = String(token);
      if (token === "") {
        utils.SyntaxError();
      }
      if (/[ \t\r\n\f]/.test(token)) {
        utils.InvalidCharacterError();
      }
      return token;
    }
    function toArray(clist) {
      var length = clist._length;
      var arr = Array(length);
      for (var i = 0; i < length; i++) {
        arr[i] = clist[i];
      }
      return arr;
    }
    function getList(clist) {
      var strProp = clist._getString();
      if (strProp === clist._lastStringValue) {
        return toArray(clist);
      }
      var str = strProp.replace(/(^[ \t\r\n\f]+)|([ \t\r\n\f]+$)/g, "");
      if (str === "") {
        return [];
      } else {
        var seen = /* @__PURE__ */ Object.create(null);
        return str.split(/[ \t\r\n\f]+/g).filter(function(n) {
          var key = "$" + n;
          if (seen[key]) {
            return false;
          }
          seen[key] = true;
          return true;
        });
      }
    }
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/select.js
var require_select = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/select.js"(exports, module) {
    "use strict";
    var window2 = Object.create(null, {
      location: { get: function() {
        throw new Error("window.location is not supported.");
      } }
    });
    var compareDocumentPosition = function(a, b) {
      return a.compareDocumentPosition(b);
    };
    var order = function(a, b) {
      return compareDocumentPosition(a, b) & 2 ? 1 : -1;
    };
    var next = function(el) {
      while ((el = el.nextSibling) && el.nodeType !== 1) ;
      return el;
    };
    var prev = function(el) {
      while ((el = el.previousSibling) && el.nodeType !== 1) ;
      return el;
    };
    var child = function(el) {
      if (el = el.firstChild) {
        while (el.nodeType !== 1 && (el = el.nextSibling)) ;
      }
      return el;
    };
    var lastChild = function(el) {
      if (el = el.lastChild) {
        while (el.nodeType !== 1 && (el = el.previousSibling)) ;
      }
      return el;
    };
    var parentIsElement = function(n) {
      if (!n.parentNode) {
        return false;
      }
      var nodeType = n.parentNode.nodeType;
      return nodeType === 1 || nodeType === 9;
    };
    var unquote = function(str) {
      if (!str) return str;
      var ch = str[0];
      if (ch === '"' || ch === "'") {
        if (str[str.length - 1] === ch) {
          str = str.slice(1, -1);
        } else {
          str = str.slice(1);
        }
        return str.replace(rules.str_escape, function(s) {
          var m = /^\\(?:([0-9A-Fa-f]+)|([\r\n\f]+))/.exec(s);
          if (!m) {
            return s.slice(1);
          }
          if (m[2]) {
            return "";
          }
          var cp = parseInt(m[1], 16);
          return String.fromCodePoint ? String.fromCodePoint(cp) : (
            // Not all JavaScript implementations have String.fromCodePoint yet.
            String.fromCharCode(cp)
          );
        });
      } else if (rules.ident.test(str)) {
        return decodeid(str);
      } else {
        return str;
      }
    };
    var decodeid = function(str) {
      return str.replace(rules.escape, function(s) {
        var m = /^\\([0-9A-Fa-f]+)/.exec(s);
        if (!m) {
          return s[1];
        }
        var cp = parseInt(m[1], 16);
        return String.fromCodePoint ? String.fromCodePoint(cp) : (
          // Not all JavaScript implementations have String.fromCodePoint yet.
          String.fromCharCode(cp)
        );
      });
    };
    var indexOf = (function() {
      if (Array.prototype.indexOf) {
        return Array.prototype.indexOf;
      }
      return function(obj, item) {
        var i = this.length;
        while (i--) {
          if (this[i] === item) return i;
        }
        return -1;
      };
    })();
    var makeInside = function(start, end) {
      var regex = rules.inside.source.replace(/</g, start).replace(/>/g, end);
      return new RegExp(regex);
    };
    var replace = function(regex, name, val) {
      regex = regex.source;
      regex = regex.replace(name, val.source || val);
      return new RegExp(regex);
    };
    var truncateUrl = function(url, num) {
      return url.replace(/^(?:\w+:\/\/|\/+)/, "").replace(/(?:\/+|\/*#.*?)$/, "").split("/", num).join("/");
    };
    var parseNth = function(param_, test) {
      var param = param_.replace(/\s+/g, ""), cap;
      if (param === "even") {
        param = "2n+0";
      } else if (param === "odd") {
        param = "2n+1";
      } else if (param.indexOf("n") === -1) {
        param = "0n" + param;
      }
      cap = /^([+-])?(\d+)?n([+-])?(\d+)?$/.exec(param);
      return {
        group: cap[1] === "-" ? -(cap[2] || 1) : +(cap[2] || 1),
        offset: cap[4] ? cap[3] === "-" ? -cap[4] : +cap[4] : 0
      };
    };
    var nth = function(param_, test, last) {
      var param = parseNth(param_), group = param.group, offset = param.offset, find2 = !last ? child : lastChild, advance = !last ? next : prev;
      return function(el) {
        if (!parentIsElement(el)) return;
        var rel2 = find2(el.parentNode), pos = 0;
        while (rel2) {
          if (test(rel2, el)) pos++;
          if (rel2 === el) {
            pos -= offset;
            return group && pos ? pos % group === 0 && pos < 0 === group < 0 : !pos;
          }
          rel2 = advance(rel2);
        }
      };
    };
    var selectors = {
      "*": (function() {
        if (false) {
          return function(el) {
            if (el.nodeType === 1) return true;
          };
        }
        return function() {
          return true;
        };
      })(),
      "type": function(type) {
        type = type.toLowerCase();
        return function(el) {
          return el.nodeName.toLowerCase() === type;
        };
      },
      "attr": function(key, op, val, i) {
        op = operators[op];
        return function(el) {
          var attr;
          switch (key) {
            case "for":
              attr = el.htmlFor;
              break;
            case "class":
              attr = el.className;
              if (attr === "" && el.getAttribute("class") == null) {
                attr = null;
              }
              break;
            case "href":
            case "src":
              attr = el.getAttribute(key, 2);
              break;
            case "title":
              attr = el.getAttribute("title") || null;
              break;
            // careful with attributes with special getter functions
            case "id":
            case "lang":
            case "dir":
            case "accessKey":
            case "hidden":
            case "tabIndex":
            case "style":
              if (el.getAttribute) {
                attr = el.getAttribute(key);
                break;
              }
            /* falls through */
            default:
              if (el.hasAttribute && !el.hasAttribute(key)) {
                break;
              }
              attr = el[key] != null ? el[key] : el.getAttribute && el.getAttribute(key);
              break;
          }
          if (attr == null) return;
          attr = attr + "";
          if (i) {
            attr = attr.toLowerCase();
            val = val.toLowerCase();
          }
          return op(attr, val);
        };
      },
      ":first-child": function(el) {
        return !prev(el) && parentIsElement(el);
      },
      ":last-child": function(el) {
        return !next(el) && parentIsElement(el);
      },
      ":only-child": function(el) {
        return !prev(el) && !next(el) && parentIsElement(el);
      },
      ":nth-child": function(param, last) {
        return nth(param, function() {
          return true;
        }, last);
      },
      ":nth-last-child": function(param) {
        return selectors[":nth-child"](param, true);
      },
      ":root": function(el) {
        return el.ownerDocument.documentElement === el;
      },
      ":empty": function(el) {
        return !el.firstChild;
      },
      ":not": function(sel) {
        var test = compileGroup(sel);
        return function(el) {
          return !test(el);
        };
      },
      ":first-of-type": function(el) {
        if (!parentIsElement(el)) return;
        var type = el.nodeName;
        while (el = prev(el)) {
          if (el.nodeName === type) return;
        }
        return true;
      },
      ":last-of-type": function(el) {
        if (!parentIsElement(el)) return;
        var type = el.nodeName;
        while (el = next(el)) {
          if (el.nodeName === type) return;
        }
        return true;
      },
      ":only-of-type": function(el) {
        return selectors[":first-of-type"](el) && selectors[":last-of-type"](el);
      },
      ":nth-of-type": function(param, last) {
        return nth(param, function(rel2, el) {
          return rel2.nodeName === el.nodeName;
        }, last);
      },
      ":nth-last-of-type": function(param) {
        return selectors[":nth-of-type"](param, true);
      },
      ":checked": function(el) {
        return !!(el.checked || el.selected);
      },
      ":indeterminate": function(el) {
        return !selectors[":checked"](el);
      },
      ":enabled": function(el) {
        return !el.disabled && el.type !== "hidden";
      },
      ":disabled": function(el) {
        return !!el.disabled;
      },
      ":target": function(el) {
        return el.id === window2.location.hash.substring(1);
      },
      ":focus": function(el) {
        return el === el.ownerDocument.activeElement;
      },
      ":is": function(sel) {
        return compileGroup(sel);
      },
      // :matches is an older name for :is; see
      // https://github.com/w3c/csswg-drafts/issues/3258
      ":matches": function(sel) {
        return selectors[":is"](sel);
      },
      ":nth-match": function(param, last) {
        var args = param.split(/\s*,\s*/), arg = args.shift(), test = compileGroup(args.join(","));
        return nth(arg, test, last);
      },
      ":nth-last-match": function(param) {
        return selectors[":nth-match"](param, true);
      },
      ":links-here": function(el) {
        return el + "" === window2.location + "";
      },
      ":lang": function(param) {
        return function(el) {
          while (el) {
            if (el.lang) return el.lang.indexOf(param) === 0;
            el = el.parentNode;
          }
        };
      },
      ":dir": function(param) {
        return function(el) {
          while (el) {
            if (el.dir) return el.dir === param;
            el = el.parentNode;
          }
        };
      },
      ":scope": function(el, con) {
        var context = con || el.ownerDocument;
        if (context.nodeType === 9) {
          return el === context.documentElement;
        }
        return el === context;
      },
      ":any-link": function(el) {
        return typeof el.href === "string";
      },
      ":local-link": function(el) {
        if (el.nodeName) {
          return el.href && el.host === window2.location.host;
        }
        var param = +el + 1;
        return function(el2) {
          if (!el2.href) return;
          var url = window2.location + "", href = el2 + "";
          return truncateUrl(url, param) === truncateUrl(href, param);
        };
      },
      ":default": function(el) {
        return !!el.defaultSelected;
      },
      ":valid": function(el) {
        return el.willValidate || el.validity && el.validity.valid;
      },
      ":invalid": function(el) {
        return !selectors[":valid"](el);
      },
      ":in-range": function(el) {
        return el.value > el.min && el.value <= el.max;
      },
      ":out-of-range": function(el) {
        return !selectors[":in-range"](el);
      },
      ":required": function(el) {
        return !!el.required;
      },
      ":optional": function(el) {
        return !el.required;
      },
      ":read-only": function(el) {
        if (el.readOnly) return true;
        var attr = el.getAttribute("contenteditable"), prop = el.contentEditable, name = el.nodeName.toLowerCase();
        name = name !== "input" && name !== "textarea";
        return (name || el.disabled) && attr == null && prop !== "true";
      },
      ":read-write": function(el) {
        return !selectors[":read-only"](el);
      },
      ":hover": function() {
        throw new Error(":hover is not supported.");
      },
      ":active": function() {
        throw new Error(":active is not supported.");
      },
      ":link": function() {
        throw new Error(":link is not supported.");
      },
      ":visited": function() {
        throw new Error(":visited is not supported.");
      },
      ":column": function() {
        throw new Error(":column is not supported.");
      },
      ":nth-column": function() {
        throw new Error(":nth-column is not supported.");
      },
      ":nth-last-column": function() {
        throw new Error(":nth-last-column is not supported.");
      },
      ":current": function() {
        throw new Error(":current is not supported.");
      },
      ":past": function() {
        throw new Error(":past is not supported.");
      },
      ":future": function() {
        throw new Error(":future is not supported.");
      },
      // Non-standard, for compatibility purposes.
      ":contains": function(param) {
        return function(el) {
          var text = el.innerText || el.textContent || el.value || "";
          return text.indexOf(param) !== -1;
        };
      },
      ":has": function(param) {
        return function(el) {
          return find(param, el).length > 0;
        };
      }
      // Potentially add more pseudo selectors for
      // compatibility with sizzle and most other
      // selector engines (?).
    };
    var operators = {
      "-": function() {
        return true;
      },
      "=": function(attr, val) {
        return attr === val;
      },
      "*=": function(attr, val) {
        return attr.indexOf(val) !== -1;
      },
      "~=": function(attr, val) {
        var i, s, f, l;
        for (s = 0; true; s = i + 1) {
          i = attr.indexOf(val, s);
          if (i === -1) return false;
          f = attr[i - 1];
          l = attr[i + val.length];
          if ((!f || f === " ") && (!l || l === " ")) return true;
        }
      },
      "|=": function(attr, val) {
        var i = attr.indexOf(val), l;
        if (i !== 0) return;
        l = attr[i + val.length];
        return l === "-" || !l;
      },
      "^=": function(attr, val) {
        return attr.indexOf(val) === 0;
      },
      "$=": function(attr, val) {
        var i = attr.lastIndexOf(val);
        return i !== -1 && i + val.length === attr.length;
      },
      // non-standard
      "!=": function(attr, val) {
        return attr !== val;
      }
    };
    var combinators = {
      " ": function(test) {
        return function(el) {
          while (el = el.parentNode) {
            if (test(el)) return el;
          }
        };
      },
      ">": function(test) {
        return function(el) {
          if (el = el.parentNode) {
            return test(el) && el;
          }
        };
      },
      "+": function(test) {
        return function(el) {
          if (el = prev(el)) {
            return test(el) && el;
          }
        };
      },
      "~": function(test) {
        return function(el) {
          while (el = prev(el)) {
            if (test(el)) return el;
          }
        };
      },
      "noop": function(test) {
        return function(el) {
          return test(el) && el;
        };
      },
      "ref": function(test, name) {
        var node;
        function ref(el) {
          var doc2 = el.ownerDocument, nodes = doc2.getElementsByTagName("*"), i = nodes.length;
          while (i--) {
            node = nodes[i];
            if (ref.test(el)) {
              node = null;
              return true;
            }
          }
          node = null;
        }
        ref.combinator = function(el) {
          if (!node || !node.getAttribute) return;
          var attr = node.getAttribute(name) || "";
          if (attr[0] === "#") attr = attr.substring(1);
          if (attr === el.id && test(node)) {
            return node;
          }
        };
        return ref;
      }
    };
    var rules = {
      escape: /\\(?:[^0-9A-Fa-f\r\n]|[0-9A-Fa-f]{1,6}[\r\n\t ]?)/g,
      str_escape: /(escape)|\\(\n|\r\n?|\f)/g,
      nonascii: /[\u00A0-\uFFFF]/,
      cssid: /(?:(?!-?[0-9])(?:escape|nonascii|[-_a-zA-Z0-9])+)/,
      qname: /^ *(cssid|\*)/,
      simple: /^(?:([.#]cssid)|pseudo|attr)/,
      ref: /^ *\/(cssid)\/ */,
      combinator: /^(?: +([^ \w*.#\\]) +|( )+|([^ \w*.#\\]))(?! *$)/,
      attr: /^\[(cssid)(?:([^\w]?=)(inside))?\]/,
      pseudo: /^(:cssid)(?:\((inside)\))?/,
      inside: /(?:"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|<[^"'>]*>|\\["'>]|[^"'>])*/,
      ident: /^(cssid)$/
    };
    rules.cssid = replace(rules.cssid, "nonascii", rules.nonascii);
    rules.cssid = replace(rules.cssid, "escape", rules.escape);
    rules.qname = replace(rules.qname, "cssid", rules.cssid);
    rules.simple = replace(rules.simple, "cssid", rules.cssid);
    rules.ref = replace(rules.ref, "cssid", rules.cssid);
    rules.attr = replace(rules.attr, "cssid", rules.cssid);
    rules.pseudo = replace(rules.pseudo, "cssid", rules.cssid);
    rules.inside = replace(rules.inside, `[^"'>]*`, rules.inside);
    rules.attr = replace(rules.attr, "inside", makeInside("\\[", "\\]"));
    rules.pseudo = replace(rules.pseudo, "inside", makeInside("\\(", "\\)"));
    rules.simple = replace(rules.simple, "pseudo", rules.pseudo);
    rules.simple = replace(rules.simple, "attr", rules.attr);
    rules.ident = replace(rules.ident, "cssid", rules.cssid);
    rules.str_escape = replace(rules.str_escape, "escape", rules.escape);
    var compile = function(sel_) {
      var sel = sel_.replace(/^\s+|\s+$/g, ""), test, filter = [], buff = [], subject, qname, cap, op, ref;
      while (sel) {
        if (cap = rules.qname.exec(sel)) {
          sel = sel.substring(cap[0].length);
          qname = decodeid(cap[1]);
          buff.push(tok(qname, true));
        } else if (cap = rules.simple.exec(sel)) {
          sel = sel.substring(cap[0].length);
          qname = "*";
          buff.push(tok(qname, true));
          buff.push(tok(cap));
        } else {
          throw new SyntaxError("Invalid selector.");
        }
        while (cap = rules.simple.exec(sel)) {
          sel = sel.substring(cap[0].length);
          buff.push(tok(cap));
        }
        if (sel[0] === "!") {
          sel = sel.substring(1);
          subject = makeSubject();
          subject.qname = qname;
          buff.push(subject.simple);
        }
        if (cap = rules.ref.exec(sel)) {
          sel = sel.substring(cap[0].length);
          ref = combinators.ref(makeSimple(buff), decodeid(cap[1]));
          filter.push(ref.combinator);
          buff = [];
          continue;
        }
        if (cap = rules.combinator.exec(sel)) {
          sel = sel.substring(cap[0].length);
          op = cap[1] || cap[2] || cap[3];
          if (op === ",") {
            filter.push(combinators.noop(makeSimple(buff)));
            break;
          }
        } else {
          op = "noop";
        }
        if (!combinators[op]) {
          throw new SyntaxError("Bad combinator.");
        }
        filter.push(combinators[op](makeSimple(buff)));
        buff = [];
      }
      test = makeTest(filter);
      test.qname = qname;
      test.sel = sel;
      if (subject) {
        subject.lname = test.qname;
        subject.test = test;
        subject.qname = subject.qname;
        subject.sel = test.sel;
        test = subject;
      }
      if (ref) {
        ref.test = test;
        ref.qname = test.qname;
        ref.sel = test.sel;
        test = ref;
      }
      return test;
    };
    var tok = function(cap, qname) {
      if (qname) {
        return cap === "*" ? selectors["*"] : selectors.type(cap);
      }
      if (cap[1]) {
        return cap[1][0] === "." ? selectors.attr("class", "~=", decodeid(cap[1].substring(1)), false) : selectors.attr("id", "=", decodeid(cap[1].substring(1)), false);
      }
      if (cap[2]) {
        return cap[3] ? selectors[decodeid(cap[2])](unquote(cap[3])) : selectors[decodeid(cap[2])];
      }
      if (cap[4]) {
        var value = cap[6];
        var i = /["'\s]\s*I$/i.test(value);
        if (i) {
          value = value.replace(/\s*I$/i, "");
        }
        return selectors.attr(decodeid(cap[4]), cap[5] || "-", unquote(value), i);
      }
      throw new SyntaxError("Unknown Selector.");
    };
    var makeSimple = function(func) {
      var l = func.length, i;
      if (l < 2) return func[0];
      return function(el) {
        if (!el) return;
        for (i = 0; i < l; i++) {
          if (!func[i](el)) return;
        }
        return true;
      };
    };
    var makeTest = function(func) {
      if (func.length < 2) {
        return function(el) {
          return !!func[0](el);
        };
      }
      return function(el) {
        var i = func.length;
        while (i--) {
          if (!(el = func[i](el))) return;
        }
        return true;
      };
    };
    var makeSubject = function() {
      var target;
      function subject(el) {
        var node = el.ownerDocument, scope = node.getElementsByTagName(subject.lname), i = scope.length;
        while (i--) {
          if (subject.test(scope[i]) && target === el) {
            target = null;
            return true;
          }
        }
        target = null;
      }
      subject.simple = function(el) {
        target = el;
        return true;
      };
      return subject;
    };
    var compileGroup = function(sel) {
      var test = compile(sel), tests = [test];
      while (test.sel) {
        test = compile(test.sel);
        tests.push(test);
      }
      if (tests.length < 2) return test;
      return function(el) {
        var l = tests.length, i = 0;
        for (; i < l; i++) {
          if (tests[i](el)) return true;
        }
      };
    };
    var find = function(sel, node) {
      var results = [], test = compile(sel), scope = node.getElementsByTagName(test.qname), i = 0, el;
      while (el = scope[i++]) {
        if (test(el)) results.push(el);
      }
      if (test.sel) {
        while (test.sel) {
          test = compile(test.sel);
          scope = node.getElementsByTagName(test.qname);
          i = 0;
          while (el = scope[i++]) {
            if (test(el) && indexOf.call(results, el) === -1) {
              results.push(el);
            }
          }
        }
        results.sort(order);
      }
      return results;
    };
    module.exports = exports = function(sel, context) {
      var id, r;
      if (context.nodeType !== 11 && sel.indexOf(" ") === -1) {
        if (sel[0] === "#" && context.rooted && /^#[A-Z_][-A-Z0-9_]*$/i.test(sel)) {
          if (context.doc._hasMultipleElementsWithId) {
            id = sel.substring(1);
            if (!context.doc._hasMultipleElementsWithId(id)) {
              r = context.doc.getElementById(id);
              return r ? [r] : [];
            }
          }
        }
        if (sel[0] === "." && /^\.\w+$/.test(sel)) {
          return context.getElementsByClassName(sel.substring(1));
        }
        if (/^\w+$/.test(sel)) {
          return context.getElementsByTagName(sel);
        }
      }
      return find(sel, context);
    };
    exports.selectors = selectors;
    exports.operators = operators;
    exports.combinators = combinators;
    exports.matches = function(el, sel) {
      var test = { sel };
      do {
        test = compile(test.sel);
        if (test(el)) {
          return true;
        }
      } while (test.sel);
      return false;
    };
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/ChildNode.js
var require_ChildNode = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/ChildNode.js"(exports, module) {
    "use strict";
    var Node = require_Node();
    var LinkedList = require_LinkedList();
    var createDocumentFragmentFromArguments = function(document2, args) {
      var docFrag = document2.createDocumentFragment();
      for (var i = 0; i < args.length; i++) {
        var argItem = args[i];
        var isNode3 = argItem instanceof Node;
        docFrag.appendChild(isNode3 ? argItem : document2.createTextNode(String(argItem)));
      }
      return docFrag;
    };
    var ChildNode = {
      // Inserts a set of Node or String objects in the children list of this
      // ChildNode's parent, just after this ChildNode.  String objects are
      // inserted as the equivalent Text nodes.
      after: { value: function after() {
        var argArr = Array.prototype.slice.call(arguments);
        var parentNode = this.parentNode, nextSibling = this.nextSibling;
        if (parentNode === null) {
          return;
        }
        while (nextSibling && argArr.some(function(v) {
          return v === nextSibling;
        }))
          nextSibling = nextSibling.nextSibling;
        var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);
        parentNode.insertBefore(docFrag, nextSibling);
      } },
      // Inserts a set of Node or String objects in the children list of this
      // ChildNode's parent, just before this ChildNode.  String objects are
      // inserted as the equivalent Text nodes.
      before: { value: function before() {
        var argArr = Array.prototype.slice.call(arguments);
        var parentNode = this.parentNode, prevSibling = this.previousSibling;
        if (parentNode === null) {
          return;
        }
        while (prevSibling && argArr.some(function(v) {
          return v === prevSibling;
        }))
          prevSibling = prevSibling.previousSibling;
        var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);
        var nextSibling = prevSibling ? prevSibling.nextSibling : parentNode.firstChild;
        parentNode.insertBefore(docFrag, nextSibling);
      } },
      // Remove this node from its parent
      remove: { value: function remove() {
        if (this.parentNode === null) return;
        if (this.doc) {
          this.doc._preremoveNodeIterators(this);
          if (this.rooted) {
            this.doc.mutateRemove(this);
          }
        }
        this._remove();
        this.parentNode = null;
      } },
      // Remove this node w/o uprooting or sending mutation events
      // (But do update the structure id for all ancestors)
      _remove: { value: function _remove() {
        var parent = this.parentNode;
        if (parent === null) return;
        if (parent._childNodes) {
          parent._childNodes.splice(this.index, 1);
        } else if (parent._firstChild === this) {
          if (this._nextSibling === this) {
            parent._firstChild = null;
          } else {
            parent._firstChild = this._nextSibling;
          }
        }
        LinkedList.remove(this);
        parent.modify();
      } },
      // Replace this node with the nodes or strings provided as arguments.
      replaceWith: { value: function replaceWith() {
        var argArr = Array.prototype.slice.call(arguments);
        var parentNode = this.parentNode, nextSibling = this.nextSibling;
        if (parentNode === null) {
          return;
        }
        while (nextSibling && argArr.some(function(v) {
          return v === nextSibling;
        }))
          nextSibling = nextSibling.nextSibling;
        var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);
        if (this.parentNode === parentNode) {
          parentNode.replaceChild(docFrag, this);
        } else {
          parentNode.insertBefore(docFrag, nextSibling);
        }
      } }
    };
    module.exports = ChildNode;
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/NonDocumentTypeChildNode.js
var require_NonDocumentTypeChildNode = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/NonDocumentTypeChildNode.js"(exports, module) {
    "use strict";
    var Node = require_Node();
    var NonDocumentTypeChildNode = {
      nextElementSibling: { get: function() {
        if (this.parentNode) {
          for (var kid = this.nextSibling; kid !== null; kid = kid.nextSibling) {
            if (kid.nodeType === Node.ELEMENT_NODE) return kid;
          }
        }
        return null;
      } },
      previousElementSibling: { get: function() {
        if (this.parentNode) {
          for (var kid = this.previousSibling; kid !== null; kid = kid.previousSibling) {
            if (kid.nodeType === Node.ELEMENT_NODE) return kid;
          }
        }
        return null;
      } }
    };
    module.exports = NonDocumentTypeChildNode;
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/NamedNodeMap.js
var require_NamedNodeMap = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/NamedNodeMap.js"(exports, module) {
    "use strict";
    module.exports = NamedNodeMap;
    var utils = require_utils();
    function NamedNodeMap(element) {
      this.element = element;
    }
    Object.defineProperties(NamedNodeMap.prototype, {
      length: { get: utils.shouldOverride },
      item: { value: utils.shouldOverride },
      getNamedItem: { value: function getNamedItem(qualifiedName) {
        return this.element.getAttributeNode(qualifiedName);
      } },
      getNamedItemNS: { value: function getNamedItemNS(namespace, localName) {
        return this.element.getAttributeNodeNS(namespace, localName);
      } },
      setNamedItem: { value: utils.nyi },
      setNamedItemNS: { value: utils.nyi },
      removeNamedItem: { value: function removeNamedItem(qualifiedName) {
        var attr = this.element.getAttributeNode(qualifiedName);
        if (attr) {
          this.element.removeAttribute(qualifiedName);
          return attr;
        }
        utils.NotFoundError();
      } },
      removeNamedItemNS: { value: function removeNamedItemNS(ns, lname) {
        var attr = this.element.getAttributeNodeNS(ns, lname);
        if (attr) {
          this.element.removeAttributeNS(ns, lname);
          return attr;
        }
        utils.NotFoundError();
      } }
    });
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/Element.js
var require_Element = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/Element.js"(exports, module) {
    "use strict";
    module.exports = Element;
    var xml = require_xmlnames();
    var utils = require_utils();
    var NAMESPACE = utils.NAMESPACE;
    var attributes = require_attributes();
    var Node = require_Node();
    var NodeList = require_NodeList();
    var NodeUtils = require_NodeUtils();
    var FilteredElementList = require_FilteredElementList();
    var DOMException = require_DOMException();
    var DOMTokenList = require_DOMTokenList();
    var select = require_select();
    var ContainerNode = require_ContainerNode();
    var ChildNode = require_ChildNode();
    var NonDocumentTypeChildNode = require_NonDocumentTypeChildNode();
    var NamedNodeMap = require_NamedNodeMap();
    var uppercaseCache = /* @__PURE__ */ Object.create(null);
    function Element(doc2, localName, namespaceURI, prefix) {
      ContainerNode.call(this);
      this.nodeType = Node.ELEMENT_NODE;
      this.ownerDocument = doc2;
      this.localName = localName;
      this.namespaceURI = namespaceURI;
      this.prefix = prefix;
      this._tagName = void 0;
      this._attrsByQName = /* @__PURE__ */ Object.create(null);
      this._attrsByLName = /* @__PURE__ */ Object.create(null);
      this._attrKeys = [];
    }
    function recursiveGetText(node, a) {
      if (node.nodeType === Node.TEXT_NODE) {
        a.push(node._data);
      } else {
        for (var i = 0, n = node.childNodes.length; i < n; i++)
          recursiveGetText(node.childNodes[i], a);
      }
    }
    Element.prototype = Object.create(ContainerNode.prototype, {
      isHTML: { get: function isHTML() {
        return this.namespaceURI === NAMESPACE.HTML && this.ownerDocument.isHTML;
      } },
      tagName: { get: function tagName() {
        if (this._tagName === void 0) {
          var tn;
          if (this.prefix === null) {
            tn = this.localName;
          } else {
            tn = this.prefix + ":" + this.localName;
          }
          if (this.isHTML) {
            var up = uppercaseCache[tn];
            if (!up) {
              uppercaseCache[tn] = up = utils.toASCIIUpperCase(tn);
            }
            tn = up;
          }
          this._tagName = tn;
        }
        return this._tagName;
      } },
      nodeName: { get: function() {
        return this.tagName;
      } },
      nodeValue: {
        get: function() {
          return null;
        },
        set: function() {
        }
      },
      textContent: {
        get: function() {
          var strings = [];
          recursiveGetText(this, strings);
          return strings.join("");
        },
        set: function(newtext) {
          this.removeChildren();
          if (newtext !== null && newtext !== void 0 && newtext !== "") {
            this._appendChild(this.ownerDocument.createTextNode(newtext));
          }
        }
      },
      innerHTML: {
        get: function() {
          return this.serialize();
        },
        set: function(v) {
          var parser = this.ownerDocument.implementation.mozHTMLParser(
            this.ownerDocument._address,
            this
          );
          parser.parse(v === null ? "" : String(v), true);
          var target = this;
          while (target.hasChildNodes())
            target.removeChild(target.firstChild);
          target.appendChild(parser._asDocumentFragment());
        }
      },
      outerHTML: {
        get: function() {
          return NodeUtils.serializeOne(this, { nodeType: 0 });
        },
        set: function(v) {
          var document2 = this.ownerDocument;
          var parent = this.parentNode;
          if (parent === null) {
            return;
          }
          if (parent.nodeType === Node.DOCUMENT_NODE) {
            utils.NoModificationAllowedError();
          }
          if (parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
            parent = parent.ownerDocument.createElement("body");
          }
          var parser = document2.implementation.mozHTMLParser(
            document2._address,
            parent
          );
          parser.parse(v === null ? "" : String(v), true);
          this.replaceWith(parser._asDocumentFragment());
        }
      },
      _insertAdjacent: { value: function _insertAdjacent(position, node) {
        var first = false;
        switch (position) {
          case "beforebegin":
            first = true;
          /* falls through */
          case "afterend":
            var parent = this.parentNode;
            if (parent === null) {
              return null;
            }
            return parent.insertBefore(node, first ? this : this.nextSibling);
          case "afterbegin":
            first = true;
          /* falls through */
          case "beforeend":
            return this.insertBefore(node, first ? this.firstChild : null);
          default:
            return utils.SyntaxError();
        }
      } },
      insertAdjacentElement: { value: function insertAdjacentElement(position, element) {
        if (element.nodeType !== Node.ELEMENT_NODE) {
          throw new TypeError("not an element");
        }
        position = utils.toASCIILowerCase(String(position));
        return this._insertAdjacent(position, element);
      } },
      insertAdjacentText: { value: function insertAdjacentText(position, data) {
        var textNode = this.ownerDocument.createTextNode(data);
        position = utils.toASCIILowerCase(String(position));
        this._insertAdjacent(position, textNode);
      } },
      insertAdjacentHTML: { value: function insertAdjacentHTML(position, text) {
        position = utils.toASCIILowerCase(String(position));
        text = String(text);
        var context;
        switch (position) {
          case "beforebegin":
          case "afterend":
            context = this.parentNode;
            if (context === null || context.nodeType === Node.DOCUMENT_NODE) {
              utils.NoModificationAllowedError();
            }
            break;
          case "afterbegin":
          case "beforeend":
            context = this;
            break;
          default:
            utils.SyntaxError();
        }
        if (!(context instanceof Element) || context.ownerDocument.isHTML && context.localName === "html" && context.namespaceURI === NAMESPACE.HTML) {
          context = context.ownerDocument.createElementNS(NAMESPACE.HTML, "body");
        }
        var parser = this.ownerDocument.implementation.mozHTMLParser(
          this.ownerDocument._address,
          context
        );
        parser.parse(text, true);
        this._insertAdjacent(position, parser._asDocumentFragment());
      } },
      children: { get: function() {
        if (!this._children) {
          this._children = new ChildrenCollection(this);
        }
        return this._children;
      } },
      attributes: { get: function() {
        if (!this._attributes) {
          this._attributes = new AttributesArray(this);
        }
        return this._attributes;
      } },
      firstElementChild: { get: function() {
        for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {
          if (kid.nodeType === Node.ELEMENT_NODE) return kid;
        }
        return null;
      } },
      lastElementChild: { get: function() {
        for (var kid = this.lastChild; kid !== null; kid = kid.previousSibling) {
          if (kid.nodeType === Node.ELEMENT_NODE) return kid;
        }
        return null;
      } },
      childElementCount: { get: function() {
        return this.children.length;
      } },
      // Return the next element, in source order, after this one or
      // null if there are no more.  If root element is specified,
      // then don't traverse beyond its subtree.
      //
      // This is not a DOM method, but is convenient for
      // lazy traversals of the tree.
      nextElement: { value: function(root) {
        if (!root) root = this.ownerDocument.documentElement;
        var next = this.firstElementChild;
        if (!next) {
          if (this === root) return null;
          next = this.nextElementSibling;
        }
        if (next) return next;
        for (var parent = this.parentElement; parent && parent !== root; parent = parent.parentElement) {
          next = parent.nextElementSibling;
          if (next) return next;
        }
        return null;
      } },
      // XXX:
      // Tests are currently failing for this function.
      // Awaiting resolution of:
      // http://lists.w3.org/Archives/Public/www-dom/2011JulSep/0016.html
      getElementsByTagName: { value: function getElementsByTagName(lname) {
        var filter;
        if (!lname) return new NodeList();
        if (lname === "*")
          filter = function() {
            return true;
          };
        else if (this.isHTML)
          filter = htmlLocalNameElementFilter(lname);
        else
          filter = localNameElementFilter(lname);
        return new FilteredElementList(this, filter);
      } },
      getElementsByTagNameNS: { value: function getElementsByTagNameNS(ns, lname) {
        var filter;
        if (ns === "*" && lname === "*")
          filter = function() {
            return true;
          };
        else if (ns === "*")
          filter = localNameElementFilter(lname);
        else if (lname === "*")
          filter = namespaceElementFilter(ns);
        else
          filter = namespaceLocalNameElementFilter(ns, lname);
        return new FilteredElementList(this, filter);
      } },
      getElementsByClassName: { value: function getElementsByClassName(names) {
        names = String(names).trim();
        if (names === "") {
          var result2 = new NodeList();
          return result2;
        }
        names = names.split(/[ \t\r\n\f]+/);
        return new FilteredElementList(this, classNamesElementFilter(names));
      } },
      getElementsByName: { value: function getElementsByName(name) {
        return new FilteredElementList(this, elementNameFilter(String(name)));
      } },
      // Utility methods used by the public API methods above
      clone: { value: function clone() {
        var e;
        if (this.namespaceURI !== NAMESPACE.HTML || this.prefix || !this.ownerDocument.isHTML) {
          e = this.ownerDocument.createElementNS(
            this.namespaceURI,
            this.prefix !== null ? this.prefix + ":" + this.localName : this.localName
          );
        } else {
          e = this.ownerDocument.createElement(this.localName);
        }
        for (var i = 0, n = this._attrKeys.length; i < n; i++) {
          var lname = this._attrKeys[i];
          var a = this._attrsByLName[lname];
          var b = a.cloneNode();
          b._setOwnerElement(e);
          e._attrsByLName[lname] = b;
          e._addQName(b);
        }
        e._attrKeys = this._attrKeys.concat();
        return e;
      } },
      isEqual: { value: function isEqual(that) {
        if (this.localName !== that.localName || this.namespaceURI !== that.namespaceURI || this.prefix !== that.prefix || this._numattrs !== that._numattrs)
          return false;
        for (var i = 0, n = this._numattrs; i < n; i++) {
          var a = this._attr(i);
          if (!that.hasAttributeNS(a.namespaceURI, a.localName))
            return false;
          if (that.getAttributeNS(a.namespaceURI, a.localName) !== a.value)
            return false;
        }
        return true;
      } },
      // This is the 'locate a namespace prefix' algorithm from the
      // DOM specification.  It is used by Node.lookupPrefix()
      // (Be sure to compare DOM3 and DOM4 versions of spec.)
      _lookupNamespacePrefix: { value: function _lookupNamespacePrefix(ns, originalElement) {
        if (this.namespaceURI && this.namespaceURI === ns && this.prefix !== null && originalElement.lookupNamespaceURI(this.prefix) === ns) {
          return this.prefix;
        }
        for (var i = 0, n = this._numattrs; i < n; i++) {
          var a = this._attr(i);
          if (a.prefix === "xmlns" && a.value === ns && originalElement.lookupNamespaceURI(a.localName) === ns) {
            return a.localName;
          }
        }
        var parent = this.parentElement;
        return parent ? parent._lookupNamespacePrefix(ns, originalElement) : null;
      } },
      // This is the 'locate a namespace' algorithm for Element nodes
      // from the DOM Core spec.  It is used by Node#lookupNamespaceURI()
      lookupNamespaceURI: { value: function lookupNamespaceURI(prefix) {
        if (prefix === "" || prefix === void 0) {
          prefix = null;
        }
        if (this.namespaceURI !== null && this.prefix === prefix)
          return this.namespaceURI;
        for (var i = 0, n = this._numattrs; i < n; i++) {
          var a = this._attr(i);
          if (a.namespaceURI === NAMESPACE.XMLNS) {
            if (a.prefix === "xmlns" && a.localName === prefix || prefix === null && a.prefix === null && a.localName === "xmlns") {
              return a.value || null;
            }
          }
        }
        var parent = this.parentElement;
        return parent ? parent.lookupNamespaceURI(prefix) : null;
      } },
      //
      // Attribute handling methods and utilities
      //
      /*
       * Attributes in the DOM are tricky:
       *
       * - there are the 8 basic get/set/has/removeAttribute{NS} methods
       *
       * - but many HTML attributes are also 'reflected' through IDL
       *   attributes which means that they can be queried and set through
       *   regular properties of the element.  There is just one attribute
       *   value, but two ways to get and set it.
       *
       * - Different HTML element types have different sets of reflected
         attributes.
       *
       * - attributes can also be queried and set through the .attributes
       *   property of an element.  This property behaves like an array of
       *   Attr objects.  The value property of each Attr is writeable, so
       *   this is a third way to read and write attributes.
       *
       * - for efficiency, we really want to store attributes in some kind
       *   of name->attr map.  But the attributes[] array is an array, not a
       *   map, which is kind of unnatural.
       *
       * - When using namespaces and prefixes, and mixing the NS methods
       *   with the non-NS methods, it is apparently actually possible for
       *   an attributes[] array to have more than one attribute with the
       *   same qualified name.  And certain methods must operate on only
       *   the first attribute with such a name.  So for these methods, an
       *   inefficient array-like data structure would be easier to
       *   implement.
       *
       * - The attributes[] array is live, not a snapshot, so changes to the
       *   attributes must be immediately visible through existing arrays.
       *
       * - When attributes are queried and set through IDL properties
       *   (instead of the get/setAttributes() method or the attributes[]
       *   array) they may be subject to type conversions, URL
       *   normalization, etc., so some extra processing is required in that
       *   case.
       *
       * - But access through IDL properties is probably the most common
       *   case, so we'd like that to be as fast as possible.
       *
       * - We can't just store attribute values in their parsed idl form,
       *   because setAttribute() has to return whatever string is passed to
       *   getAttribute even if it is not a legal, parseable value. So
       *   attribute values must be stored in unparsed string form.
       *
       * - We need to be able to send change notifications or mutation
       *   events of some sort to the renderer whenever an attribute value
       *   changes, regardless of the way in which it changes.
       *
       * - Some attributes, such as id and class affect other parts of the
       *   DOM API, like getElementById and getElementsByClassName and so
       *   for efficiency, we need to specially track changes to these
       *   special attributes.
       *
       * - Some attributes like class have different names (className) when
       *   reflected.
       *
       * - Attributes whose names begin with the string 'data-' are treated
         specially.
       *
       * - Reflected attributes that have a boolean type in IDL have special
       *   behavior: setting them to false (in IDL) is the same as removing
       *   them with removeAttribute()
       *
       * - numeric attributes (like HTMLElement.tabIndex) can have default
       *   values that must be returned by the idl getter even if the
       *   content attribute does not exist. (The default tabIndex value
       *   actually varies based on the type of the element, so that is a
       *   tricky one).
       *
       * See
       * http://www.whatwg.org/specs/web-apps/current-work/multipage/urls.html#reflect
       * for rules on how attributes are reflected.
       *
       */
      getAttribute: { value: function getAttribute(qname) {
        var attr = this.getAttributeNode(qname);
        return attr ? attr.value : null;
      } },
      getAttributeNS: { value: function getAttributeNS(ns, lname) {
        var attr = this.getAttributeNodeNS(ns, lname);
        return attr ? attr.value : null;
      } },
      getAttributeNode: { value: function getAttributeNode(qname) {
        qname = String(qname);
        if (/[A-Z]/.test(qname) && this.isHTML)
          qname = utils.toASCIILowerCase(qname);
        var attr = this._attrsByQName[qname];
        if (!attr) return null;
        if (Array.isArray(attr))
          attr = attr[0];
        return attr;
      } },
      getAttributeNodeNS: { value: function getAttributeNodeNS(ns, lname) {
        ns = ns === void 0 || ns === null ? "" : String(ns);
        lname = String(lname);
        var attr = this._attrsByLName[ns + "|" + lname];
        return attr ? attr : null;
      } },
      hasAttribute: { value: function hasAttribute(qname) {
        qname = String(qname);
        if (/[A-Z]/.test(qname) && this.isHTML)
          qname = utils.toASCIILowerCase(qname);
        return this._attrsByQName[qname] !== void 0;
      } },
      hasAttributeNS: { value: function hasAttributeNS(ns, lname) {
        ns = ns === void 0 || ns === null ? "" : String(ns);
        lname = String(lname);
        var key = ns + "|" + lname;
        return this._attrsByLName[key] !== void 0;
      } },
      hasAttributes: { value: function hasAttributes() {
        return this._numattrs > 0;
      } },
      toggleAttribute: { value: function toggleAttribute(qname, force) {
        qname = String(qname);
        if (!xml.isValidName(qname)) utils.InvalidCharacterError();
        if (/[A-Z]/.test(qname) && this.isHTML)
          qname = utils.toASCIILowerCase(qname);
        var a = this._attrsByQName[qname];
        if (a === void 0) {
          if (force === void 0 || force === true) {
            this._setAttribute(qname, "");
            return true;
          }
          return false;
        } else {
          if (force === void 0 || force === false) {
            this.removeAttribute(qname);
            return false;
          }
          return true;
        }
      } },
      // Set the attribute without error checking. The parser uses this.
      _setAttribute: { value: function _setAttribute(qname, value) {
        var attr = this._attrsByQName[qname];
        var isnew;
        if (!attr) {
          attr = this._newattr(qname);
          isnew = true;
        } else {
          if (Array.isArray(attr)) attr = attr[0];
        }
        attr.value = value;
        if (this._attributes) this._attributes[qname] = attr;
        if (isnew && this._newattrhook) this._newattrhook(qname, value);
      } },
      // Check for errors, and then set the attribute
      setAttribute: { value: function setAttribute(qname, value) {
        qname = String(qname);
        if (!xml.isValidName(qname)) utils.InvalidCharacterError();
        if (/[A-Z]/.test(qname) && this.isHTML)
          qname = utils.toASCIILowerCase(qname);
        this._setAttribute(qname, String(value));
      } },
      // The version with no error checking used by the parser
      _setAttributeNS: { value: function _setAttributeNS(ns, qname, value) {
        var pos = qname.indexOf(":"), prefix, lname;
        if (pos < 0) {
          prefix = null;
          lname = qname;
        } else {
          prefix = qname.substring(0, pos);
          lname = qname.substring(pos + 1);
        }
        if (ns === "" || ns === void 0) ns = null;
        var key = (ns === null ? "" : ns) + "|" + lname;
        var attr = this._attrsByLName[key];
        var isnew;
        if (!attr) {
          attr = new Attr(this, lname, prefix, ns);
          isnew = true;
          this._attrsByLName[key] = attr;
          if (this._attributes) {
            this._attributes[this._attrKeys.length] = attr;
          }
          this._attrKeys.push(key);
          this._addQName(attr);
        } else if (false) {
          if (attr.prefix !== prefix) {
            this._removeQName(attr);
            attr.prefix = prefix;
            this._addQName(attr);
          }
        }
        attr.value = value;
        if (isnew && this._newattrhook) this._newattrhook(qname, value);
      } },
      // Do error checking then call _setAttributeNS
      setAttributeNS: { value: function setAttributeNS(ns, qname, value) {
        ns = ns === null || ns === void 0 || ns === "" ? null : String(ns);
        qname = String(qname);
        if (!xml.isValidQName(qname)) utils.InvalidCharacterError();
        var pos = qname.indexOf(":");
        var prefix = pos < 0 ? null : qname.substring(0, pos);
        if (prefix !== null && ns === null || prefix === "xml" && ns !== NAMESPACE.XML || (qname === "xmlns" || prefix === "xmlns") && ns !== NAMESPACE.XMLNS || ns === NAMESPACE.XMLNS && !(qname === "xmlns" || prefix === "xmlns"))
          utils.NamespaceError();
        this._setAttributeNS(ns, qname, String(value));
      } },
      setAttributeNode: { value: function setAttributeNode(attr) {
        if (attr.ownerElement !== null && attr.ownerElement !== this) {
          throw new DOMException(DOMException.INUSE_ATTRIBUTE_ERR);
        }
        var result2 = null;
        var oldAttrs = this._attrsByQName[attr.name];
        if (oldAttrs) {
          if (!Array.isArray(oldAttrs)) {
            oldAttrs = [oldAttrs];
          }
          if (oldAttrs.some(function(a) {
            return a === attr;
          })) {
            return attr;
          } else if (attr.ownerElement !== null) {
            throw new DOMException(DOMException.INUSE_ATTRIBUTE_ERR);
          }
          oldAttrs.forEach(function(a) {
            this.removeAttributeNode(a);
          }, this);
          result2 = oldAttrs[0];
        }
        this.setAttributeNodeNS(attr);
        return result2;
      } },
      setAttributeNodeNS: { value: function setAttributeNodeNS(attr) {
        if (attr.ownerElement !== null) {
          throw new DOMException(DOMException.INUSE_ATTRIBUTE_ERR);
        }
        var ns = attr.namespaceURI;
        var key = (ns === null ? "" : ns) + "|" + attr.localName;
        var oldAttr = this._attrsByLName[key];
        if (oldAttr) {
          this.removeAttributeNode(oldAttr);
        }
        attr._setOwnerElement(this);
        this._attrsByLName[key] = attr;
        if (this._attributes) {
          this._attributes[this._attrKeys.length] = attr;
        }
        this._attrKeys.push(key);
        this._addQName(attr);
        if (this._newattrhook) this._newattrhook(attr.name, attr.value);
        return oldAttr || null;
      } },
      removeAttribute: { value: function removeAttribute(qname) {
        qname = String(qname);
        if (/[A-Z]/.test(qname) && this.isHTML)
          qname = utils.toASCIILowerCase(qname);
        var attr = this._attrsByQName[qname];
        if (!attr) return;
        if (Array.isArray(attr)) {
          if (attr.length > 2) {
            attr = attr.shift();
          } else {
            this._attrsByQName[qname] = attr[1];
            attr = attr[0];
          }
        } else {
          this._attrsByQName[qname] = void 0;
        }
        var ns = attr.namespaceURI;
        var key = (ns === null ? "" : ns) + "|" + attr.localName;
        this._attrsByLName[key] = void 0;
        var i = this._attrKeys.indexOf(key);
        if (this._attributes) {
          Array.prototype.splice.call(this._attributes, i, 1);
          this._attributes[qname] = void 0;
        }
        this._attrKeys.splice(i, 1);
        var onchange = attr.onchange;
        attr._setOwnerElement(null);
        if (onchange) {
          onchange.call(attr, this, attr.localName, attr.value, null);
        }
        if (this.rooted) this.ownerDocument.mutateRemoveAttr(attr);
      } },
      removeAttributeNS: { value: function removeAttributeNS(ns, lname) {
        ns = ns === void 0 || ns === null ? "" : String(ns);
        lname = String(lname);
        var key = ns + "|" + lname;
        var attr = this._attrsByLName[key];
        if (!attr) return;
        this._attrsByLName[key] = void 0;
        var i = this._attrKeys.indexOf(key);
        if (this._attributes) {
          Array.prototype.splice.call(this._attributes, i, 1);
        }
        this._attrKeys.splice(i, 1);
        this._removeQName(attr);
        var onchange = attr.onchange;
        attr._setOwnerElement(null);
        if (onchange) {
          onchange.call(attr, this, attr.localName, attr.value, null);
        }
        if (this.rooted) this.ownerDocument.mutateRemoveAttr(attr);
      } },
      removeAttributeNode: { value: function removeAttributeNode(attr) {
        var ns = attr.namespaceURI;
        var key = (ns === null ? "" : ns) + "|" + attr.localName;
        if (this._attrsByLName[key] !== attr) {
          utils.NotFoundError();
        }
        this.removeAttributeNS(ns, attr.localName);
        return attr;
      } },
      getAttributeNames: { value: function getAttributeNames() {
        var elt = this;
        return this._attrKeys.map(function(key) {
          return elt._attrsByLName[key].name;
        });
      } },
      // This 'raw' version of getAttribute is used by the getter functions
      // of reflected attributes. It skips some error checking and
      // namespace steps
      _getattr: { value: function _getattr(qname) {
        var attr = this._attrsByQName[qname];
        return attr ? attr.value : null;
      } },
      // The raw version of setAttribute for reflected idl attributes.
      _setattr: { value: function _setattr(qname, value) {
        var attr = this._attrsByQName[qname];
        var isnew;
        if (!attr) {
          attr = this._newattr(qname);
          isnew = true;
        }
        attr.value = String(value);
        if (this._attributes) this._attributes[qname] = attr;
        if (isnew && this._newattrhook) this._newattrhook(qname, value);
      } },
      // Create a new Attr object, insert it, and return it.
      // Used by setAttribute() and by set()
      _newattr: { value: function _newattr(qname) {
        var attr = new Attr(this, qname, null, null);
        var key = "|" + qname;
        this._attrsByQName[qname] = attr;
        this._attrsByLName[key] = attr;
        if (this._attributes) {
          this._attributes[this._attrKeys.length] = attr;
        }
        this._attrKeys.push(key);
        return attr;
      } },
      // Add a qname->Attr mapping to the _attrsByQName object, taking into
      // account that there may be more than one attr object with the
      // same qname
      _addQName: { value: function(attr) {
        var qname = attr.name;
        var existing = this._attrsByQName[qname];
        if (!existing) {
          this._attrsByQName[qname] = attr;
        } else if (Array.isArray(existing)) {
          existing.push(attr);
        } else {
          this._attrsByQName[qname] = [existing, attr];
        }
        if (this._attributes) this._attributes[qname] = attr;
      } },
      // Remove a qname->Attr mapping to the _attrsByQName object, taking into
      // account that there may be more than one attr object with the
      // same qname
      _removeQName: { value: function(attr) {
        var qname = attr.name;
        var target = this._attrsByQName[qname];
        if (Array.isArray(target)) {
          var idx = target.indexOf(attr);
          utils.assert(idx !== -1);
          if (target.length === 2) {
            this._attrsByQName[qname] = target[1 - idx];
            if (this._attributes) {
              this._attributes[qname] = this._attrsByQName[qname];
            }
          } else {
            target.splice(idx, 1);
            if (this._attributes && this._attributes[qname] === attr) {
              this._attributes[qname] = target[0];
            }
          }
        } else {
          utils.assert(target === attr);
          this._attrsByQName[qname] = void 0;
          if (this._attributes) {
            this._attributes[qname] = void 0;
          }
        }
      } },
      // Return the number of attributes
      _numattrs: { get: function() {
        return this._attrKeys.length;
      } },
      // Return the nth Attr object
      _attr: { value: function(n) {
        return this._attrsByLName[this._attrKeys[n]];
      } },
      // Define getters and setters for an 'id' property that reflects
      // the content attribute 'id'.
      id: attributes.property({ name: "id" }),
      // Define getters and setters for a 'className' property that reflects
      // the content attribute 'class'.
      className: attributes.property({ name: "class" }),
      classList: { get: function() {
        var self2 = this;
        if (this._classList) {
          return this._classList;
        }
        var dtlist = new DOMTokenList(
          function() {
            return self2.className || "";
          },
          function(v) {
            self2.className = v;
          }
        );
        this._classList = dtlist;
        return dtlist;
      }, set: function(v) {
        this.className = v;
      } },
      matches: { value: function(selector) {
        return select.matches(this, selector);
      } },
      closest: { value: function(selector) {
        var el = this;
        do {
          if (el.matches && el.matches(selector)) {
            return el;
          }
          el = el.parentElement || el.parentNode;
        } while (el !== null && el.nodeType === Node.ELEMENT_NODE);
        return null;
      } },
      querySelector: { value: function(selector) {
        return select(selector, this)[0];
      } },
      querySelectorAll: { value: function(selector) {
        var nodes = select(selector, this);
        return nodes.item ? nodes : new NodeList(nodes);
      } }
    });
    Object.defineProperties(Element.prototype, ChildNode);
    Object.defineProperties(Element.prototype, NonDocumentTypeChildNode);
    attributes.registerChangeHandler(
      Element,
      "id",
      function(element, lname, oldval, newval) {
        if (element.rooted) {
          if (oldval) {
            element.ownerDocument.delId(oldval, element);
          }
          if (newval) {
            element.ownerDocument.addId(newval, element);
          }
        }
      }
    );
    attributes.registerChangeHandler(
      Element,
      "class",
      function(element, lname, oldval, newval) {
        if (element._classList) {
          element._classList._update();
        }
      }
    );
    function Attr(elt, lname, prefix, namespace, value) {
      this.localName = lname;
      this.prefix = prefix === null || prefix === "" ? null : "" + prefix;
      this.namespaceURI = namespace === null || namespace === "" ? null : "" + namespace;
      this.data = value;
      this._setOwnerElement(elt);
    }
    Attr.prototype = Object.create(Object.prototype, {
      ownerElement: {
        get: function() {
          return this._ownerElement;
        }
      },
      _setOwnerElement: { value: function _setOwnerElement(elt) {
        this._ownerElement = elt;
        if (this.prefix === null && this.namespaceURI === null && elt) {
          this.onchange = elt._attributeChangeHandlers[this.localName];
        } else {
          this.onchange = null;
        }
      } },
      name: { get: function() {
        return this.prefix ? this.prefix + ":" + this.localName : this.localName;
      } },
      specified: { get: function() {
        return true;
      } },
      value: {
        get: function() {
          return this.data;
        },
        set: function(value) {
          var oldval = this.data;
          value = value === void 0 ? "" : value + "";
          if (value === oldval) return;
          this.data = value;
          if (this.ownerElement) {
            if (this.onchange)
              this.onchange(this.ownerElement, this.localName, oldval, value);
            if (this.ownerElement.rooted)
              this.ownerElement.ownerDocument.mutateAttr(this, oldval);
          }
        }
      },
      cloneNode: { value: function cloneNode(deep) {
        return new Attr(
          null,
          this.localName,
          this.prefix,
          this.namespaceURI,
          this.data
        );
      } },
      // Legacy aliases (see gh#70 and https://dom.spec.whatwg.org/#interface-attr)
      nodeType: { get: function() {
        return Node.ATTRIBUTE_NODE;
      } },
      nodeName: { get: function() {
        return this.name;
      } },
      nodeValue: {
        get: function() {
          return this.value;
        },
        set: function(v) {
          this.value = v;
        }
      },
      textContent: {
        get: function() {
          return this.value;
        },
        set: function(v) {
          if (v === null || v === void 0) {
            v = "";
          }
          this.value = v;
        }
      }
    });
    Element._Attr = Attr;
    function AttributesArray(elt) {
      NamedNodeMap.call(this, elt);
      for (var name in elt._attrsByQName) {
        this[name] = elt._attrsByQName[name];
      }
      for (var i = 0; i < elt._attrKeys.length; i++) {
        this[i] = elt._attrsByLName[elt._attrKeys[i]];
      }
    }
    AttributesArray.prototype = Object.create(NamedNodeMap.prototype, {
      length: { get: function() {
        return this.element._attrKeys.length;
      }, set: function() {
      } },
      item: { value: function(n) {
        n = n >>> 0;
        if (n >= this.length) {
          return null;
        }
        return this.element._attrsByLName[this.element._attrKeys[n]];
      } }
    });
    if (global.Symbol && global.Symbol.iterator) {
      AttributesArray.prototype[global.Symbol.iterator] = function() {
        var i = 0, n = this.length, self2 = this;
        return {
          next: function() {
            if (i < n) return { value: self2.item(i++) };
            return { done: true };
          }
        };
      };
    }
    function ChildrenCollection(e) {
      this.element = e;
      this.updateCache();
    }
    ChildrenCollection.prototype = Object.create(Object.prototype, {
      length: { get: function() {
        this.updateCache();
        return this.childrenByNumber.length;
      } },
      item: { value: function item(n) {
        this.updateCache();
        return this.childrenByNumber[n] || null;
      } },
      namedItem: { value: function namedItem(name) {
        this.updateCache();
        return this.childrenByName[name] || null;
      } },
      // This attribute returns the entire name->element map.
      // It is not part of the HTMLCollection API, but we need it in
      // src/HTMLCollectionProxy
      namedItems: { get: function() {
        this.updateCache();
        return this.childrenByName;
      } },
      updateCache: { value: function updateCache() {
        var namedElts = /^(a|applet|area|embed|form|frame|frameset|iframe|img|object)$/;
        if (this.lastModTime !== this.element.lastModTime) {
          this.lastModTime = this.element.lastModTime;
          var n = this.childrenByNumber && this.childrenByNumber.length || 0;
          for (var i = 0; i < n; i++) {
            this[i] = void 0;
          }
          this.childrenByNumber = [];
          this.childrenByName = /* @__PURE__ */ Object.create(null);
          for (var c = this.element.firstChild; c !== null; c = c.nextSibling) {
            if (c.nodeType === Node.ELEMENT_NODE) {
              this[this.childrenByNumber.length] = c;
              this.childrenByNumber.push(c);
              var id = c.getAttribute("id");
              if (id && !this.childrenByName[id])
                this.childrenByName[id] = c;
              var name = c.getAttribute("name");
              if (name && this.element.namespaceURI === NAMESPACE.HTML && namedElts.test(this.element.localName) && !this.childrenByName[name])
                this.childrenByName[id] = c;
            }
          }
        }
      } }
    });
    function localNameElementFilter(lname) {
      return function(e) {
        return e.localName === lname;
      };
    }
    function htmlLocalNameElementFilter(lname) {
      var lclname = utils.toASCIILowerCase(lname);
      if (lclname === lname)
        return localNameElementFilter(lname);
      return function(e) {
        return e.isHTML ? e.localName === lclname : e.localName === lname;
      };
    }
    function namespaceElementFilter(ns) {
      return function(e) {
        return e.namespaceURI === ns;
      };
    }
    function namespaceLocalNameElementFilter(ns, lname) {
      return function(e) {
        return e.namespaceURI === ns && e.localName === lname;
      };
    }
    function classNamesElementFilter(names) {
      return function(e) {
        return names.every(function(n) {
          return e.classList.contains(n);
        });
      };
    }
    function elementNameFilter(name) {
      return function(e) {
        if (e.namespaceURI !== NAMESPACE.HTML) {
          return false;
        }
        return e.getAttribute("name") === name;
      };
    }
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/Leaf.js
var require_Leaf = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/Leaf.js"(exports, module) {
    "use strict";
    module.exports = Leaf;
    var Node = require_Node();
    var NodeList = require_NodeList();
    var utils = require_utils();
    var HierarchyRequestError = utils.HierarchyRequestError;
    var NotFoundError = utils.NotFoundError;
    function Leaf() {
      Node.call(this);
    }
    Leaf.prototype = Object.create(Node.prototype, {
      hasChildNodes: { value: function() {
        return false;
      } },
      firstChild: { value: null },
      lastChild: { value: null },
      insertBefore: { value: function(node, child) {
        if (!node.nodeType) throw new TypeError("not a node");
        HierarchyRequestError();
      } },
      replaceChild: { value: function(node, child) {
        if (!node.nodeType) throw new TypeError("not a node");
        HierarchyRequestError();
      } },
      removeChild: { value: function(node) {
        if (!node.nodeType) throw new TypeError("not a node");
        NotFoundError();
      } },
      removeChildren: { value: function() {
      } },
      childNodes: { get: function() {
        if (!this._childNodes) this._childNodes = new NodeList();
        return this._childNodes;
      } }
    });
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/CharacterData.js
var require_CharacterData = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/CharacterData.js"(exports, module) {
    "use strict";
    module.exports = CharacterData;
    var Leaf = require_Leaf();
    var utils = require_utils();
    var ChildNode = require_ChildNode();
    var NonDocumentTypeChildNode = require_NonDocumentTypeChildNode();
    function CharacterData() {
      Leaf.call(this);
    }
    CharacterData.prototype = Object.create(Leaf.prototype, {
      // DOMString substringData(unsigned long offset,
      //               unsigned long count);
      // The substringData(offset, count) method must run these steps:
      //
      //     If offset is greater than the context object's
      //     length, throw an INDEX_SIZE_ERR exception and
      //     terminate these steps.
      //
      //     If offset+count is greater than the context
      //     object's length, return a DOMString whose value is
      //     the UTF-16 code units from the offsetth UTF-16 code
      //     unit to the end of data.
      //
      //     Return a DOMString whose value is the UTF-16 code
      //     units from the offsetth UTF-16 code unit to the
      //     offset+countth UTF-16 code unit in data.
      substringData: { value: function substringData(offset, count2) {
        if (arguments.length < 2) {
          throw new TypeError("Not enough arguments");
        }
        offset = offset >>> 0;
        count2 = count2 >>> 0;
        if (offset > this.data.length || offset < 0 || count2 < 0) {
          utils.IndexSizeError();
        }
        return this.data.substring(offset, offset + count2);
      } },
      // void appendData(DOMString data);
      // The appendData(data) method must append data to the context
      // object's data.
      appendData: { value: function appendData(data) {
        if (arguments.length < 1) {
          throw new TypeError("Not enough arguments");
        }
        this.data += String(data);
      } },
      // void insertData(unsigned long offset, DOMString data);
      // The insertData(offset, data) method must run these steps:
      //
      //     If offset is greater than the context object's
      //     length, throw an INDEX_SIZE_ERR exception and
      //     terminate these steps.
      //
      //     Insert data into the context object's data after
      //     offset UTF-16 code units.
      //
      insertData: { value: function insertData(offset, data) {
        return this.replaceData(offset, 0, data);
      } },
      // void deleteData(unsigned long offset, unsigned long count);
      // The deleteData(offset, count) method must run these steps:
      //
      //     If offset is greater than the context object's
      //     length, throw an INDEX_SIZE_ERR exception and
      //     terminate these steps.
      //
      //     If offset+count is greater than the context
      //     object's length var count be length-offset.
      //
      //     Starting from offset UTF-16 code units remove count
      //     UTF-16 code units from the context object's data.
      deleteData: { value: function deleteData(offset, count2) {
        return this.replaceData(offset, count2, "");
      } },
      // void replaceData(unsigned long offset, unsigned long count,
      //          DOMString data);
      //
      // The replaceData(offset, count, data) method must act as
      // if the deleteData() method is invoked with offset and
      // count as arguments followed by the insertData() method
      // with offset and data as arguments and re-throw any
      // exceptions these methods might have thrown.
      replaceData: { value: function replaceData(offset, count2, data) {
        var curtext = this.data, len = curtext.length;
        offset = offset >>> 0;
        count2 = count2 >>> 0;
        data = String(data);
        if (offset > len || offset < 0) utils.IndexSizeError();
        if (offset + count2 > len)
          count2 = len - offset;
        var prefix = curtext.substring(0, offset), suffix = curtext.substring(offset + count2);
        this.data = prefix + data + suffix;
      } },
      // Utility method that Node.isEqualNode() calls to test Text and
      // Comment nodes for equality.  It is okay to put it here, since
      // Node will have already verified that nodeType is equal
      isEqual: { value: function isEqual(n) {
        return this._data === n._data;
      } },
      length: { get: function() {
        return this.data.length;
      } }
    });
    Object.defineProperties(CharacterData.prototype, ChildNode);
    Object.defineProperties(CharacterData.prototype, NonDocumentTypeChildNode);
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/Text.js
var require_Text = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/Text.js"(exports, module) {
    "use strict";
    module.exports = Text;
    var utils = require_utils();
    var Node = require_Node();
    var CharacterData = require_CharacterData();
    function Text(doc2, data) {
      CharacterData.call(this);
      this.nodeType = Node.TEXT_NODE;
      this.ownerDocument = doc2;
      this._data = data;
      this._index = void 0;
    }
    var nodeValue = {
      get: function() {
        return this._data;
      },
      set: function(v) {
        if (v === null || v === void 0) {
          v = "";
        } else {
          v = String(v);
        }
        if (v === this._data) return;
        this._data = v;
        if (this.rooted)
          this.ownerDocument.mutateValue(this);
        if (this.parentNode && this.parentNode._textchangehook)
          this.parentNode._textchangehook(this);
      }
    };
    Text.prototype = Object.create(CharacterData.prototype, {
      nodeName: { value: "#text" },
      // These three attributes are all the same.
      // The data attribute has a [TreatNullAs=EmptyString] but we'll
      // implement that at the interface level
      nodeValue,
      textContent: nodeValue,
      data: {
        get: nodeValue.get,
        set: function(v) {
          nodeValue.set.call(this, v === null ? "" : String(v));
        }
      },
      splitText: { value: function splitText(offset) {
        if (offset > this._data.length || offset < 0) utils.IndexSizeError();
        var newdata = this._data.substring(offset), newnode = this.ownerDocument.createTextNode(newdata);
        this.data = this.data.substring(0, offset);
        var parent = this.parentNode;
        if (parent !== null)
          parent.insertBefore(newnode, this.nextSibling);
        return newnode;
      } },
      wholeText: { get: function wholeText() {
        var result2 = this.textContent;
        for (var next = this.nextSibling; next; next = next.nextSibling) {
          if (next.nodeType !== Node.TEXT_NODE) {
            break;
          }
          result2 += next.textContent;
        }
        return result2;
      } },
      // Obsolete, removed from spec.
      replaceWholeText: { value: utils.nyi },
      // Utility methods
      clone: { value: function clone() {
        return new Text(this.ownerDocument, this._data);
      } }
    });
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/Comment.js
var require_Comment = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/Comment.js"(exports, module) {
    "use strict";
    module.exports = Comment;
    var Node = require_Node();
    var CharacterData = require_CharacterData();
    function Comment(doc2, data) {
      CharacterData.call(this);
      this.nodeType = Node.COMMENT_NODE;
      this.ownerDocument = doc2;
      this._data = data;
    }
    var nodeValue = {
      get: function() {
        return this._data;
      },
      set: function(v) {
        if (v === null || v === void 0) {
          v = "";
        } else {
          v = String(v);
        }
        this._data = v;
        if (this.rooted)
          this.ownerDocument.mutateValue(this);
      }
    };
    Comment.prototype = Object.create(CharacterData.prototype, {
      nodeName: { value: "#comment" },
      nodeValue,
      textContent: nodeValue,
      data: {
        get: nodeValue.get,
        set: function(v) {
          nodeValue.set.call(this, v === null ? "" : String(v));
        }
      },
      // Utility methods
      clone: { value: function clone() {
        return new Comment(this.ownerDocument, this._data);
      } }
    });
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/DocumentFragment.js
var require_DocumentFragment = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/DocumentFragment.js"(exports, module) {
    "use strict";
    module.exports = DocumentFragment;
    var Node = require_Node();
    var NodeList = require_NodeList();
    var ContainerNode = require_ContainerNode();
    var Element = require_Element();
    var select = require_select();
    var utils = require_utils();
    function DocumentFragment(doc2) {
      ContainerNode.call(this);
      this.nodeType = Node.DOCUMENT_FRAGMENT_NODE;
      this.ownerDocument = doc2;
    }
    DocumentFragment.prototype = Object.create(ContainerNode.prototype, {
      nodeName: { value: "#document-fragment" },
      nodeValue: {
        get: function() {
          return null;
        },
        set: function() {
        }
      },
      // Copy the text content getter/setter from Element
      textContent: Object.getOwnPropertyDescriptor(Element.prototype, "textContent"),
      querySelector: { value: function(selector) {
        var nodes = this.querySelectorAll(selector);
        return nodes.length ? nodes[0] : null;
      } },
      querySelectorAll: { value: function(selector) {
        var context = Object.create(this);
        context.isHTML = true;
        context.getElementsByTagName = Element.prototype.getElementsByTagName;
        context.nextElement = Object.getOwnPropertyDescriptor(Element.prototype, "firstElementChild").get;
        var nodes = select(selector, context);
        return nodes.item ? nodes : new NodeList(nodes);
      } },
      // Utility methods
      clone: { value: function clone() {
        return new DocumentFragment(this.ownerDocument);
      } },
      isEqual: { value: function isEqual(n) {
        return true;
      } },
      // Non-standard, but useful (github issue #73)
      innerHTML: {
        get: function() {
          return this.serialize();
        },
        set: utils.nyi
      },
      outerHTML: {
        get: function() {
          return this.serialize();
        },
        set: utils.nyi
      }
    });
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/ProcessingInstruction.js
var require_ProcessingInstruction = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/ProcessingInstruction.js"(exports, module) {
    "use strict";
    module.exports = ProcessingInstruction;
    var Node = require_Node();
    var CharacterData = require_CharacterData();
    function ProcessingInstruction(doc2, target, data) {
      CharacterData.call(this);
      this.nodeType = Node.PROCESSING_INSTRUCTION_NODE;
      this.ownerDocument = doc2;
      this.target = target;
      this._data = data;
    }
    var nodeValue = {
      get: function() {
        return this._data;
      },
      set: function(v) {
        if (v === null || v === void 0) {
          v = "";
        } else {
          v = String(v);
        }
        this._data = v;
        if (this.rooted) this.ownerDocument.mutateValue(this);
      }
    };
    ProcessingInstruction.prototype = Object.create(CharacterData.prototype, {
      nodeName: { get: function() {
        return this.target;
      } },
      nodeValue,
      textContent: nodeValue,
      data: {
        get: nodeValue.get,
        set: function(v) {
          nodeValue.set.call(this, v === null ? "" : String(v));
        }
      },
      // Utility methods
      clone: { value: function clone() {
        return new ProcessingInstruction(this.ownerDocument, this.target, this._data);
      } },
      isEqual: { value: function isEqual(n) {
        return this.target === n.target && this._data === n._data;
      } }
    });
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/NodeFilter.js
var require_NodeFilter = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/NodeFilter.js"(exports, module) {
    "use strict";
    var NodeFilter2 = {
      // Constants for acceptNode()
      FILTER_ACCEPT: 1,
      FILTER_REJECT: 2,
      FILTER_SKIP: 3,
      // Constants for whatToShow
      SHOW_ALL: 4294967295,
      SHOW_ELEMENT: 1,
      SHOW_ATTRIBUTE: 2,
      // historical
      SHOW_TEXT: 4,
      SHOW_CDATA_SECTION: 8,
      // historical
      SHOW_ENTITY_REFERENCE: 16,
      // historical
      SHOW_ENTITY: 32,
      // historical
      SHOW_PROCESSING_INSTRUCTION: 64,
      SHOW_COMMENT: 128,
      SHOW_DOCUMENT: 256,
      SHOW_DOCUMENT_TYPE: 512,
      SHOW_DOCUMENT_FRAGMENT: 1024,
      SHOW_NOTATION: 2048
      // historical
    };
    module.exports = NodeFilter2.constructor = NodeFilter2.prototype = NodeFilter2;
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/NodeTraversal.js
var require_NodeTraversal = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/NodeTraversal.js"(exports, module) {
    "use strict";
    var NodeTraversal = module.exports = {
      nextSkippingChildren,
      nextAncestorSibling,
      next,
      previous,
      deepLastChild
    };
    function nextSkippingChildren(node, stayWithin) {
      if (node === stayWithin) {
        return null;
      }
      if (node.nextSibling !== null) {
        return node.nextSibling;
      }
      return nextAncestorSibling(node, stayWithin);
    }
    function nextAncestorSibling(node, stayWithin) {
      for (node = node.parentNode; node !== null; node = node.parentNode) {
        if (node === stayWithin) {
          return null;
        }
        if (node.nextSibling !== null) {
          return node.nextSibling;
        }
      }
      return null;
    }
    function next(node, stayWithin) {
      var n;
      n = node.firstChild;
      if (n !== null) {
        return n;
      }
      if (node === stayWithin) {
        return null;
      }
      n = node.nextSibling;
      if (n !== null) {
        return n;
      }
      return nextAncestorSibling(node, stayWithin);
    }
    function deepLastChild(node) {
      while (node.lastChild) {
        node = node.lastChild;
      }
      return node;
    }
    function previous(node, stayWithin) {
      var p;
      p = node.previousSibling;
      if (p !== null) {
        return deepLastChild(p);
      }
      p = node.parentNode;
      if (p === stayWithin) {
        return null;
      }
      return p;
    }
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/TreeWalker.js
var require_TreeWalker = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/TreeWalker.js"(exports, module) {
    "use strict";
    module.exports = TreeWalker;
    var Node = require_Node();
    var NodeFilter2 = require_NodeFilter();
    var NodeTraversal = require_NodeTraversal();
    var utils = require_utils();
    var mapChild = {
      first: "firstChild",
      last: "lastChild",
      next: "firstChild",
      previous: "lastChild"
    };
    var mapSibling = {
      first: "nextSibling",
      last: "previousSibling",
      next: "nextSibling",
      previous: "previousSibling"
    };
    function traverseChildren(tw, type) {
      var child, node, parent, result2, sibling;
      node = tw._currentNode[mapChild[type]];
      while (node !== null) {
        result2 = tw._internalFilter(node);
        if (result2 === NodeFilter2.FILTER_ACCEPT) {
          tw._currentNode = node;
          return node;
        }
        if (result2 === NodeFilter2.FILTER_SKIP) {
          child = node[mapChild[type]];
          if (child !== null) {
            node = child;
            continue;
          }
        }
        while (node !== null) {
          sibling = node[mapSibling[type]];
          if (sibling !== null) {
            node = sibling;
            break;
          }
          parent = node.parentNode;
          if (parent === null || parent === tw.root || parent === tw._currentNode) {
            return null;
          } else {
            node = parent;
          }
        }
      }
      return null;
    }
    function traverseSiblings(tw, type) {
      var node, result2, sibling;
      node = tw._currentNode;
      if (node === tw.root) {
        return null;
      }
      while (true) {
        sibling = node[mapSibling[type]];
        while (sibling !== null) {
          node = sibling;
          result2 = tw._internalFilter(node);
          if (result2 === NodeFilter2.FILTER_ACCEPT) {
            tw._currentNode = node;
            return node;
          }
          sibling = node[mapChild[type]];
          if (result2 === NodeFilter2.FILTER_REJECT || sibling === null) {
            sibling = node[mapSibling[type]];
          }
        }
        node = node.parentNode;
        if (node === null || node === tw.root) {
          return null;
        }
        if (tw._internalFilter(node) === NodeFilter2.FILTER_ACCEPT) {
          return null;
        }
      }
    }
    function TreeWalker(root, whatToShow, filter) {
      if (!root || !root.nodeType) {
        utils.NotSupportedError();
      }
      this._root = root;
      this._whatToShow = Number(whatToShow) || 0;
      this._filter = filter || null;
      this._active = false;
      this._currentNode = root;
    }
    Object.defineProperties(TreeWalker.prototype, {
      root: { get: function() {
        return this._root;
      } },
      whatToShow: { get: function() {
        return this._whatToShow;
      } },
      filter: { get: function() {
        return this._filter;
      } },
      currentNode: {
        get: function currentNode() {
          return this._currentNode;
        },
        set: function setCurrentNode(v) {
          if (!(v instanceof Node)) {
            throw new TypeError("Not a Node");
          }
          this._currentNode = v;
        }
      },
      /**
       * @method
       * @param {Node} node
       * @return {Number} Constant NodeFilter.FILTER_ACCEPT,
       *  NodeFilter.FILTER_REJECT or NodeFilter.FILTER_SKIP.
       */
      _internalFilter: { value: function _internalFilter(node) {
        var result2, filter;
        if (this._active) {
          utils.InvalidStateError();
        }
        if (!(1 << node.nodeType - 1 & this._whatToShow)) {
          return NodeFilter2.FILTER_SKIP;
        }
        filter = this._filter;
        if (filter === null) {
          result2 = NodeFilter2.FILTER_ACCEPT;
        } else {
          this._active = true;
          try {
            if (typeof filter === "function") {
              result2 = filter(node);
            } else {
              result2 = filter.acceptNode(node);
            }
          } finally {
            this._active = false;
          }
        }
        return +result2;
      } },
      /**
       * @spec https://dom.spec.whatwg.org/#dom-treewalker-parentnode
       * @based on WebKit's TreeWalker::parentNode
       * https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/dom/TreeWalker.cpp?rev=220453#L50
       * @method
       * @return {Node|null}
       */
      parentNode: { value: function parentNode() {
        var node = this._currentNode;
        while (node !== this.root) {
          node = node.parentNode;
          if (node === null) {
            return null;
          }
          if (this._internalFilter(node) === NodeFilter2.FILTER_ACCEPT) {
            this._currentNode = node;
            return node;
          }
        }
        return null;
      } },
      /**
       * @spec https://dom.spec.whatwg.org/#dom-treewalker-firstchild
       * @method
       * @return {Node|null}
       */
      firstChild: { value: function firstChild() {
        return traverseChildren(this, "first");
      } },
      /**
       * @spec https://dom.spec.whatwg.org/#dom-treewalker-lastchild
       * @method
       * @return {Node|null}
       */
      lastChild: { value: function lastChild() {
        return traverseChildren(this, "last");
      } },
      /**
       * @spec http://www.w3.org/TR/dom/#dom-treewalker-previoussibling
       * @method
       * @return {Node|null}
       */
      previousSibling: { value: function previousSibling() {
        return traverseSiblings(this, "previous");
      } },
      /**
       * @spec http://www.w3.org/TR/dom/#dom-treewalker-nextsibling
       * @method
       * @return {Node|null}
       */
      nextSibling: { value: function nextSibling() {
        return traverseSiblings(this, "next");
      } },
      /**
       * @spec https://dom.spec.whatwg.org/#dom-treewalker-previousnode
       * @based on WebKit's TreeWalker::previousNode
       * https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/dom/TreeWalker.cpp?rev=220453#L181
       * @method
       * @return {Node|null}
       */
      previousNode: { value: function previousNode() {
        var node, result2, previousSibling, lastChild;
        node = this._currentNode;
        while (node !== this._root) {
          for (previousSibling = node.previousSibling; previousSibling; previousSibling = node.previousSibling) {
            node = previousSibling;
            result2 = this._internalFilter(node);
            if (result2 === NodeFilter2.FILTER_REJECT) {
              continue;
            }
            for (lastChild = node.lastChild; lastChild; lastChild = node.lastChild) {
              node = lastChild;
              result2 = this._internalFilter(node);
              if (result2 === NodeFilter2.FILTER_REJECT) {
                break;
              }
            }
            if (result2 === NodeFilter2.FILTER_ACCEPT) {
              this._currentNode = node;
              return node;
            }
          }
          if (node === this.root || node.parentNode === null) {
            return null;
          }
          node = node.parentNode;
          if (this._internalFilter(node) === NodeFilter2.FILTER_ACCEPT) {
            this._currentNode = node;
            return node;
          }
        }
        return null;
      } },
      /**
       * @spec https://dom.spec.whatwg.org/#dom-treewalker-nextnode
       * @based on WebKit's TreeWalker::nextNode
       * https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/dom/TreeWalker.cpp?rev=220453#L228
       * @method
       * @return {Node|null}
       */
      nextNode: { value: function nextNode() {
        var node, result2, firstChild, nextSibling;
        node = this._currentNode;
        result2 = NodeFilter2.FILTER_ACCEPT;
        CHILDREN:
          while (true) {
            for (firstChild = node.firstChild; firstChild; firstChild = node.firstChild) {
              node = firstChild;
              result2 = this._internalFilter(node);
              if (result2 === NodeFilter2.FILTER_ACCEPT) {
                this._currentNode = node;
                return node;
              } else if (result2 === NodeFilter2.FILTER_REJECT) {
                break;
              }
            }
            for (nextSibling = NodeTraversal.nextSkippingChildren(node, this.root); nextSibling; nextSibling = NodeTraversal.nextSkippingChildren(node, this.root)) {
              node = nextSibling;
              result2 = this._internalFilter(node);
              if (result2 === NodeFilter2.FILTER_ACCEPT) {
                this._currentNode = node;
                return node;
              } else if (result2 === NodeFilter2.FILTER_SKIP) {
                continue CHILDREN;
              }
            }
            return null;
          }
      } },
      /** For compatibility with web-platform-tests. */
      toString: { value: function toString() {
        return "[object TreeWalker]";
      } }
    });
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/NodeIterator.js
var require_NodeIterator = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/NodeIterator.js"(exports, module) {
    "use strict";
    module.exports = NodeIterator;
    var NodeFilter2 = require_NodeFilter();
    var NodeTraversal = require_NodeTraversal();
    var utils = require_utils();
    function move(node, stayWithin, directionIsNext) {
      if (directionIsNext) {
        return NodeTraversal.next(node, stayWithin);
      } else {
        if (node === stayWithin) {
          return null;
        }
        return NodeTraversal.previous(node, null);
      }
    }
    function isInclusiveAncestor(node, possibleChild) {
      for (; possibleChild; possibleChild = possibleChild.parentNode) {
        if (node === possibleChild) {
          return true;
        }
      }
      return false;
    }
    function traverse(ni, directionIsNext) {
      var node, beforeNode;
      node = ni._referenceNode;
      beforeNode = ni._pointerBeforeReferenceNode;
      while (true) {
        if (beforeNode === directionIsNext) {
          beforeNode = !beforeNode;
        } else {
          node = move(node, ni._root, directionIsNext);
          if (node === null) {
            return null;
          }
        }
        var result2 = ni._internalFilter(node);
        if (result2 === NodeFilter2.FILTER_ACCEPT) {
          break;
        }
      }
      ni._referenceNode = node;
      ni._pointerBeforeReferenceNode = beforeNode;
      return node;
    }
    function NodeIterator(root, whatToShow, filter) {
      if (!root || !root.nodeType) {
        utils.NotSupportedError();
      }
      this._root = root;
      this._referenceNode = root;
      this._pointerBeforeReferenceNode = true;
      this._whatToShow = Number(whatToShow) || 0;
      this._filter = filter || null;
      this._active = false;
      root.doc._attachNodeIterator(this);
    }
    Object.defineProperties(NodeIterator.prototype, {
      root: { get: function root() {
        return this._root;
      } },
      referenceNode: { get: function referenceNode() {
        return this._referenceNode;
      } },
      pointerBeforeReferenceNode: { get: function pointerBeforeReferenceNode() {
        return this._pointerBeforeReferenceNode;
      } },
      whatToShow: { get: function whatToShow() {
        return this._whatToShow;
      } },
      filter: { get: function filter() {
        return this._filter;
      } },
      /**
       * @method
       * @param {Node} node
       * @return {Number} Constant NodeFilter.FILTER_ACCEPT,
       *  NodeFilter.FILTER_REJECT or NodeFilter.FILTER_SKIP.
       */
      _internalFilter: { value: function _internalFilter(node) {
        var result2, filter;
        if (this._active) {
          utils.InvalidStateError();
        }
        if (!(1 << node.nodeType - 1 & this._whatToShow)) {
          return NodeFilter2.FILTER_SKIP;
        }
        filter = this._filter;
        if (filter === null) {
          result2 = NodeFilter2.FILTER_ACCEPT;
        } else {
          this._active = true;
          try {
            if (typeof filter === "function") {
              result2 = filter(node);
            } else {
              result2 = filter.acceptNode(node);
            }
          } finally {
            this._active = false;
          }
        }
        return +result2;
      } },
      /**
       * @spec https://dom.spec.whatwg.org/#nodeiterator-pre-removing-steps
       * @method
       * @return void
       */
      _preremove: { value: function _preremove(toBeRemovedNode) {
        if (isInclusiveAncestor(toBeRemovedNode, this._root)) {
          return;
        }
        if (!isInclusiveAncestor(toBeRemovedNode, this._referenceNode)) {
          return;
        }
        if (this._pointerBeforeReferenceNode) {
          var next = toBeRemovedNode;
          while (next.lastChild) {
            next = next.lastChild;
          }
          next = NodeTraversal.next(next, this.root);
          if (next) {
            this._referenceNode = next;
            return;
          }
          this._pointerBeforeReferenceNode = false;
        }
        if (toBeRemovedNode.previousSibling === null) {
          this._referenceNode = toBeRemovedNode.parentNode;
        } else {
          this._referenceNode = toBeRemovedNode.previousSibling;
          var lastChild;
          for (lastChild = this._referenceNode.lastChild; lastChild; lastChild = this._referenceNode.lastChild) {
            this._referenceNode = lastChild;
          }
        }
      } },
      /**
       * @spec http://www.w3.org/TR/dom/#dom-nodeiterator-nextnode
       * @method
       * @return {Node|null}
       */
      nextNode: { value: function nextNode() {
        return traverse(this, true);
      } },
      /**
       * @spec http://www.w3.org/TR/dom/#dom-nodeiterator-previousnode
       * @method
       * @return {Node|null}
       */
      previousNode: { value: function previousNode() {
        return traverse(this, false);
      } },
      /**
       * @spec http://www.w3.org/TR/dom/#dom-nodeiterator-detach
       * @method
       * @return void
       */
      detach: { value: function detach() {
      } },
      /** For compatibility with web-platform-tests. */
      toString: { value: function toString() {
        return "[object NodeIterator]";
      } }
    });
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/URL.js
var require_URL = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/URL.js"(exports, module) {
    "use strict";
    module.exports = URL2;
    function URL2(url) {
      if (!url) return Object.create(URL2.prototype);
      this.url = url.replace(/^[ \t\n\r\f]+|[ \t\n\r\f]+$/g, "");
      var match = URL2.pattern.exec(this.url);
      if (match) {
        if (match[2]) this.scheme = match[2];
        if (match[4]) {
          var userinfo = match[4].match(URL2.userinfoPattern);
          if (userinfo) {
            this.username = userinfo[1];
            this.password = userinfo[3];
            match[4] = match[4].substring(userinfo[0].length);
          }
          if (match[4].match(URL2.portPattern)) {
            var pos = match[4].lastIndexOf(":");
            this.host = match[4].substring(0, pos);
            this.port = match[4].substring(pos + 1);
          } else {
            this.host = match[4];
          }
        }
        if (match[5]) this.path = match[5];
        if (match[6]) this.query = match[7];
        if (match[8]) this.fragment = match[9];
      }
    }
    URL2.pattern = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/;
    URL2.userinfoPattern = /^([^@:]*)(:([^@]*))?@/;
    URL2.portPattern = /:\d+$/;
    URL2.authorityPattern = /^[^:\/?#]+:\/\//;
    URL2.hierarchyPattern = /^[^:\/?#]+:\//;
    URL2.percentEncode = function percentEncode(s) {
      var c = s.charCodeAt(0);
      if (c < 256) return "%" + c.toString(16);
      else throw Error("can't percent-encode codepoints > 255 yet");
    };
    URL2.prototype = {
      constructor: URL2,
      // XXX: not sure if this is the precise definition of absolute
      isAbsolute: function() {
        return !!this.scheme;
      },
      isAuthorityBased: function() {
        return URL2.authorityPattern.test(this.url);
      },
      isHierarchical: function() {
        return URL2.hierarchyPattern.test(this.url);
      },
      toString: function() {
        var s = "";
        if (this.scheme !== void 0) s += this.scheme + ":";
        if (this.isAbsolute()) {
          s += "//";
          if (this.username || this.password) {
            s += this.username || "";
            if (this.password) {
              s += ":" + this.password;
            }
            s += "@";
          }
          if (this.host) {
            s += this.host;
          }
        }
        if (this.port !== void 0) s += ":" + this.port;
        if (this.path !== void 0) s += this.path;
        if (this.query !== void 0) s += "?" + this.query;
        if (this.fragment !== void 0) s += "#" + this.fragment;
        return s;
      },
      // See: http://tools.ietf.org/html/rfc3986#section-5.2
      // and https://url.spec.whatwg.org/#constructors
      resolve: function(relative) {
        var base2 = this;
        var r = new URL2(relative);
        var t = new URL2();
        if (r.scheme !== void 0) {
          t.scheme = r.scheme;
          t.username = r.username;
          t.password = r.password;
          t.host = r.host;
          t.port = r.port;
          t.path = remove_dot_segments(r.path);
          t.query = r.query;
        } else {
          t.scheme = base2.scheme;
          if (r.host !== void 0) {
            t.username = r.username;
            t.password = r.password;
            t.host = r.host;
            t.port = r.port;
            t.path = remove_dot_segments(r.path);
            t.query = r.query;
          } else {
            t.username = base2.username;
            t.password = base2.password;
            t.host = base2.host;
            t.port = base2.port;
            if (!r.path) {
              t.path = base2.path;
              if (r.query !== void 0)
                t.query = r.query;
              else
                t.query = base2.query;
            } else {
              if (r.path.charAt(0) === "/") {
                t.path = remove_dot_segments(r.path);
              } else {
                t.path = merge(base2.path, r.path);
                t.path = remove_dot_segments(t.path);
              }
              t.query = r.query;
            }
          }
        }
        t.fragment = r.fragment;
        return t.toString();
        function merge(basepath, refpath) {
          if (base2.host !== void 0 && !base2.path)
            return "/" + refpath;
          var lastslash = basepath.lastIndexOf("/");
          if (lastslash === -1)
            return refpath;
          else
            return basepath.substring(0, lastslash + 1) + refpath;
        }
        function remove_dot_segments(path) {
          if (!path) return path;
          var output = "";
          while (path.length > 0) {
            if (path === "." || path === "..") {
              path = "";
              break;
            }
            var twochars = path.substring(0, 2);
            var threechars = path.substring(0, 3);
            var fourchars = path.substring(0, 4);
            if (threechars === "../") {
              path = path.substring(3);
            } else if (twochars === "./") {
              path = path.substring(2);
            } else if (threechars === "/./") {
              path = "/" + path.substring(3);
            } else if (twochars === "/." && path.length === 2) {
              path = "/";
            } else if (fourchars === "/../" || threechars === "/.." && path.length === 3) {
              path = "/" + path.substring(4);
              output = output.replace(/\/?[^\/]*$/, "");
            } else {
              var segment = path.match(/(\/?([^\/]*))/)[0];
              output += segment;
              path = path.substring(segment.length);
            }
          }
          return output;
        }
      }
    };
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/CustomEvent.js
var require_CustomEvent = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/CustomEvent.js"(exports, module) {
    "use strict";
    module.exports = CustomEvent2;
    var Event2 = require_Event();
    function CustomEvent2(type, dictionary) {
      Event2.call(this, type, dictionary);
    }
    CustomEvent2.prototype = Object.create(Event2.prototype, {
      constructor: { value: CustomEvent2 }
    });
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/events.js
var require_events = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/events.js"(exports, module) {
    "use strict";
    module.exports = {
      Event: require_Event(),
      UIEvent: require_UIEvent(),
      MouseEvent: require_MouseEvent(),
      CustomEvent: require_CustomEvent()
    };
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/cssparser.js
var require_cssparser = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/cssparser.js"(exports) {
    "use strict";
    var parserlib = /* @__PURE__ */ Object.create(null);
    (function() {
      function EventTarget() {
        this._listeners = /* @__PURE__ */ Object.create(null);
      }
      EventTarget.prototype = {
        //restore constructor
        constructor: EventTarget,
        /**
         * Adds a listener for a given event type.
         * @param {String} type The type of event to add a listener for.
         * @param {Function} listener The function to call when the event occurs.
         * @return {void}
         * @method addListener
         */
        addListener: function(type, listener) {
          if (!this._listeners[type]) {
            this._listeners[type] = [];
          }
          this._listeners[type].push(listener);
        },
        /**
         * Fires an event based on the passed-in object.
         * @param {Object|String} event An object with at least a 'type' attribute
         *      or a string indicating the event name.
         * @return {void}
         * @method fire
         */
        fire: function(event) {
          if (typeof event === "string") {
            event = { type: event };
          }
          if (typeof event.target !== "undefined") {
            event.target = this;
          }
          if (typeof event.type === "undefined") {
            throw new Error("Event object missing 'type' property.");
          }
          if (this._listeners[event.type]) {
            var listeners = this._listeners[event.type].concat();
            for (var i = 0, len = listeners.length; i < len; i++) {
              listeners[i].call(this, event);
            }
          }
        },
        /**
         * Removes a listener for a given event type.
         * @param {String} type The type of event to remove a listener from.
         * @param {Function} listener The function to remove from the event.
         * @return {void}
         * @method removeListener
         */
        removeListener: function(type, listener) {
          if (this._listeners[type]) {
            var listeners = this._listeners[type];
            for (var i = 0, len = listeners.length; i < len; i++) {
              if (listeners[i] === listener) {
                listeners.splice(i, 1);
                break;
              }
            }
          }
        }
      };
      function StringReader(text) {
        this._input = text.replace(/(\r|\n){1,2}/g, "\n");
        this._line = 1;
        this._col = 1;
        this._cursor = 0;
      }
      StringReader.prototype = {
        //restore constructor
        constructor: StringReader,
        //-------------------------------------------------------------------------
        // Position info
        //-------------------------------------------------------------------------
        /**
         * Returns the column of the character to be read next.
         * @return {int} The column of the character to be read next.
         * @method getCol
         */
        getCol: function() {
          return this._col;
        },
        /**
         * Returns the row of the character to be read next.
         * @return {int} The row of the character to be read next.
         * @method getLine
         */
        getLine: function() {
          return this._line;
        },
        /**
         * Determines if you're at the end of the input.
         * @return {Boolean} True if there's no more input, false otherwise.
         * @method eof
         */
        eof: function() {
          return this._cursor === this._input.length;
        },
        //-------------------------------------------------------------------------
        // Basic reading
        //-------------------------------------------------------------------------
        /**
         * Reads the next character without advancing the cursor.
         * @param {int} count How many characters to look ahead (default is 1).
         * @return {String} The next character or null if there is no next character.
         * @method peek
         */
        peek: function(count2) {
          var c = null;
          count2 = typeof count2 === "undefined" ? 1 : count2;
          if (this._cursor < this._input.length) {
            c = this._input.charAt(this._cursor + count2 - 1);
          }
          return c;
        },
        /**
         * Reads the next character from the input and adjusts the row and column
         * accordingly.
         * @return {String} The next character or null if there is no next character.
         * @method read
         */
        read: function() {
          var c = null;
          if (this._cursor < this._input.length) {
            if (this._input.charAt(this._cursor) === "\n") {
              this._line++;
              this._col = 1;
            } else {
              this._col++;
            }
            c = this._input.charAt(this._cursor++);
          }
          return c;
        },
        //-------------------------------------------------------------------------
        // Misc
        //-------------------------------------------------------------------------
        /**
         * Saves the current location so it can be returned to later.
         * @method mark
         * @return {void}
         */
        mark: function() {
          this._bookmark = {
            cursor: this._cursor,
            line: this._line,
            col: this._col
          };
        },
        reset: function() {
          if (this._bookmark) {
            this._cursor = this._bookmark.cursor;
            this._line = this._bookmark.line;
            this._col = this._bookmark.col;
            delete this._bookmark;
          }
        },
        //-------------------------------------------------------------------------
        // Advanced reading
        //-------------------------------------------------------------------------
        /**
         * Reads up to and including the given string. Throws an error if that
         * string is not found.
         * @param {String} pattern The string to read.
         * @return {String} The string when it is found.
         * @throws Error when the string pattern is not found.
         * @method readTo
         */
        readTo: function(pattern) {
          var buffer = "", c;
          while (buffer.length < pattern.length || buffer.lastIndexOf(pattern) !== buffer.length - pattern.length) {
            c = this.read();
            if (c) {
              buffer += c;
            } else {
              throw new Error('Expected "' + pattern + '" at line ' + this._line + ", col " + this._col + ".");
            }
          }
          return buffer;
        },
        /**
         * Reads characters while each character causes the given
         * filter function to return true. The function is passed
         * in each character and either returns true to continue
         * reading or false to stop.
         * @param {Function} filter The function to read on each character.
         * @return {String} The string made up of all characters that passed the
         *      filter check.
         * @method readWhile
         */
        readWhile: function(filter) {
          var buffer = "", c = this.read();
          while (c !== null && filter(c)) {
            buffer += c;
            c = this.read();
          }
          return buffer;
        },
        /**
         * Reads characters that match either text or a regular expression and
         * returns those characters. If a match is found, the row and column
         * are adjusted; if no match is found, the reader's state is unchanged.
         * reading or false to stop.
         * @param {String|RegExp} matchter If a string, then the literal string
         *      value is searched for. If a regular expression, then any string
         *      matching the pattern is search for.
         * @return {String} The string made up of all characters that matched or
         *      null if there was no match.
         * @method readMatch
         */
        readMatch: function(matcher) {
          var source = this._input.substring(this._cursor), value = null;
          if (typeof matcher === "string") {
            if (source.indexOf(matcher) === 0) {
              value = this.readCount(matcher.length);
            }
          } else if (matcher instanceof RegExp) {
            if (matcher.test(source)) {
              value = this.readCount(RegExp.lastMatch.length);
            }
          }
          return value;
        },
        /**
         * Reads a given number of characters. If the end of the input is reached,
         * it reads only the remaining characters and does not throw an error.
         * @param {int} count The number of characters to read.
         * @return {String} The string made up the read characters.
         * @method readCount
         */
        readCount: function(count2) {
          var buffer = "";
          while (count2--) {
            buffer += this.read();
          }
          return buffer;
        }
      };
      function SyntaxError2(message, line, col) {
        Error.call(this);
        this.name = this.constructor.name;
        this.col = col;
        this.line = line;
        this.message = message;
      }
      SyntaxError2.prototype = Object.create(Error.prototype);
      SyntaxError2.prototype.constructor = SyntaxError2;
      function SyntaxUnit(text, line, col, type) {
        this.col = col;
        this.line = line;
        this.text = text;
        this.type = type;
      }
      SyntaxUnit.fromToken = function(token) {
        return new SyntaxUnit(token.value, token.startLine, token.startCol);
      };
      SyntaxUnit.prototype = {
        //restore constructor
        constructor: SyntaxUnit,
        /**
         * Returns the text representation of the unit.
         * @return {String} The text representation of the unit.
         * @method valueOf
         */
        valueOf: function() {
          return this.toString();
        },
        /**
         * Returns the text representation of the unit.
         * @return {String} The text representation of the unit.
         * @method toString
         */
        toString: function() {
          return this.text;
        }
      };
      function TokenStreamBase(input, tokenData) {
        this._reader = input ? new StringReader(input.toString()) : null;
        this._token = null;
        this._tokenData = tokenData;
        this._lt = [];
        this._ltIndex = 0;
        this._ltIndexCache = [];
      }
      TokenStreamBase.createTokenData = function(tokens) {
        var nameMap = [], typeMap = /* @__PURE__ */ Object.create(null), tokenData = tokens.concat([]), i = 0, len = tokenData.length + 1;
        tokenData.UNKNOWN = -1;
        tokenData.unshift({ name: "EOF" });
        for (; i < len; i++) {
          nameMap.push(tokenData[i].name);
          tokenData[tokenData[i].name] = i;
          if (tokenData[i].text) {
            typeMap[tokenData[i].text] = i;
          }
        }
        tokenData.name = function(tt) {
          return nameMap[tt];
        };
        tokenData.type = function(c) {
          return typeMap[c];
        };
        return tokenData;
      };
      TokenStreamBase.prototype = {
        //restore constructor
        constructor: TokenStreamBase,
        //-------------------------------------------------------------------------
        // Matching methods
        //-------------------------------------------------------------------------
        /**
         * Determines if the next token matches the given token type.
         * If so, that token is consumed; if not, the token is placed
         * back onto the token stream. You can pass in any number of
         * token types and this will return true if any of the token
         * types is found.
         * @param {int|int[]} tokenTypes Either a single token type or an array of
         *      token types that the next token might be. If an array is passed,
         *      it's assumed that the token can be any of these.
         * @param {variant} channel (Optional) The channel to read from. If not
         *      provided, reads from the default (unnamed) channel.
         * @return {Boolean} True if the token type matches, false if not.
         * @method match
         */
        match: function(tokenTypes, channel) {
          if (!(tokenTypes instanceof Array)) {
            tokenTypes = [tokenTypes];
          }
          var tt = this.get(channel), i = 0, len = tokenTypes.length;
          while (i < len) {
            if (tt === tokenTypes[i++]) {
              return true;
            }
          }
          this.unget();
          return false;
        },
        /**
         * Determines if the next token matches the given token type.
         * If so, that token is consumed; if not, an error is thrown.
         * @param {int|int[]} tokenTypes Either a single token type or an array of
         *      token types that the next token should be. If an array is passed,
         *      it's assumed that the token must be one of these.
         * @param {variant} channel (Optional) The channel to read from. If not
         *      provided, reads from the default (unnamed) channel.
         * @return {void}
         * @method mustMatch
         */
        mustMatch: function(tokenTypes, channel) {
          var token;
          if (!(tokenTypes instanceof Array)) {
            tokenTypes = [tokenTypes];
          }
          if (!this.match.apply(this, arguments)) {
            token = this.LT(1);
            throw new SyntaxError2("Expected " + this._tokenData[tokenTypes[0]].name + " at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
          }
        },
        //-------------------------------------------------------------------------
        // Consuming methods
        //-------------------------------------------------------------------------
        /**
         * Keeps reading from the token stream until either one of the specified
         * token types is found or until the end of the input is reached.
         * @param {int|int[]} tokenTypes Either a single token type or an array of
         *      token types that the next token should be. If an array is passed,
         *      it's assumed that the token must be one of these.
         * @param {variant} channel (Optional) The channel to read from. If not
         *      provided, reads from the default (unnamed) channel.
         * @return {void}
         * @method advance
         */
        advance: function(tokenTypes, channel) {
          while (this.LA(0) !== 0 && !this.match(tokenTypes, channel)) {
            this.get();
          }
          return this.LA(0);
        },
        /**
         * Consumes the next token from the token stream.
         * @return {int} The token type of the token that was just consumed.
         * @method get
         */
        get: function(channel) {
          var tokenInfo = this._tokenData, i = 0, token, info;
          if (this._lt.length && this._ltIndex >= 0 && this._ltIndex < this._lt.length) {
            i++;
            this._token = this._lt[this._ltIndex++];
            info = tokenInfo[this._token.type];
            while (info.channel !== void 0 && channel !== info.channel && this._ltIndex < this._lt.length) {
              this._token = this._lt[this._ltIndex++];
              info = tokenInfo[this._token.type];
              i++;
            }
            if ((info.channel === void 0 || channel === info.channel) && this._ltIndex <= this._lt.length) {
              this._ltIndexCache.push(i);
              return this._token.type;
            }
          }
          token = this._getToken();
          if (token.type > -1 && !tokenInfo[token.type].hide) {
            token.channel = tokenInfo[token.type].channel;
            this._token = token;
            this._lt.push(token);
            this._ltIndexCache.push(this._lt.length - this._ltIndex + i);
            if (this._lt.length > 5) {
              this._lt.shift();
            }
            if (this._ltIndexCache.length > 5) {
              this._ltIndexCache.shift();
            }
            this._ltIndex = this._lt.length;
          }
          info = tokenInfo[token.type];
          if (info && (info.hide || info.channel !== void 0 && channel !== info.channel)) {
            return this.get(channel);
          } else {
            return token.type;
          }
        },
        /**
         * Looks ahead a certain number of tokens and returns the token type at
         * that position. This will throw an error if you lookahead past the
         * end of input, past the size of the lookahead buffer, or back past
         * the first token in the lookahead buffer.
         * @param {int} The index of the token type to retrieve. 0 for the
         *      current token, 1 for the next, -1 for the previous, etc.
         * @return {int} The token type of the token in the given position.
         * @method LA
         */
        LA: function(index) {
          var total = index, tt;
          if (index > 0) {
            if (index > 5) {
              throw new Error("Too much lookahead.");
            }
            while (total) {
              tt = this.get();
              total--;
            }
            while (total < index) {
              this.unget();
              total++;
            }
          } else if (index < 0) {
            if (this._lt[this._ltIndex + index]) {
              tt = this._lt[this._ltIndex + index].type;
            } else {
              throw new Error("Too much lookbehind.");
            }
          } else {
            tt = this._token.type;
          }
          return tt;
        },
        /**
         * Looks ahead a certain number of tokens and returns the token at
         * that position. This will throw an error if you lookahead past the
         * end of input, past the size of the lookahead buffer, or back past
         * the first token in the lookahead buffer.
         * @param {int} The index of the token type to retrieve. 0 for the
         *      current token, 1 for the next, -1 for the previous, etc.
         * @return {Object} The token of the token in the given position.
         * @method LA
         */
        LT: function(index) {
          this.LA(index);
          return this._lt[this._ltIndex + index - 1];
        },
        /**
         * Returns the token type for the next token in the stream without
         * consuming it.
         * @return {int} The token type of the next token in the stream.
         * @method peek
         */
        peek: function() {
          return this.LA(1);
        },
        /**
         * Returns the actual token object for the last consumed token.
         * @return {Token} The token object for the last consumed token.
         * @method token
         */
        token: function() {
          return this._token;
        },
        /**
         * Returns the name of the token for the given token type.
         * @param {int} tokenType The type of token to get the name of.
         * @return {String} The name of the token or "UNKNOWN_TOKEN" for any
         *      invalid token type.
         * @method tokenName
         */
        tokenName: function(tokenType) {
          if (tokenType < 0 || tokenType > this._tokenData.length) {
            return "UNKNOWN_TOKEN";
          } else {
            return this._tokenData[tokenType].name;
          }
        },
        /**
         * Returns the token type value for the given token name.
         * @param {String} tokenName The name of the token whose value should be returned.
         * @return {int} The token type value for the given token name or -1
         *      for an unknown token.
         * @method tokenName
         */
        tokenType: function(tokenName) {
          return this._tokenData[tokenName] || -1;
        },
        /**
         * Returns the last consumed token to the token stream.
         * @method unget
         */
        unget: function() {
          if (this._ltIndexCache.length) {
            this._ltIndex -= this._ltIndexCache.pop();
            this._token = this._lt[this._ltIndex - 1];
          } else {
            throw new Error("Too much lookahead.");
          }
        }
      };
      parserlib.util = {
        __proto__: null,
        StringReader,
        SyntaxError: SyntaxError2,
        SyntaxUnit,
        EventTarget,
        TokenStreamBase
      };
    })();
    (function() {
      var EventTarget = parserlib.util.EventTarget, TokenStreamBase = parserlib.util.TokenStreamBase, StringReader = parserlib.util.StringReader, SyntaxError2 = parserlib.util.SyntaxError, SyntaxUnit = parserlib.util.SyntaxUnit;
      var Colors = {
        __proto__: null,
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        black: "#000000",
        blanchedalmond: "#ffebcd",
        blue: "#0000ff",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgrey: "#a9a9a9",
        darkgreen: "#006400",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#ff00ff",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        gold: "#ffd700",
        goldenrod: "#daa520",
        gray: "#808080",
        grey: "#808080",
        green: "#008000",
        greenyellow: "#adff2f",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        lavender: "#e6e6fa",
        lavenderblush: "#fff0f5",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrodyellow: "#fafad2",
        lightgray: "#d3d3d3",
        lightgrey: "#d3d3d3",
        lightgreen: "#90ee90",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#00ff00",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        magenta: "#ff00ff",
        maroon: "#800000",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370d8",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        navy: "#000080",
        oldlace: "#fdf5e6",
        olive: "#808000",
        olivedrab: "#6b8e23",
        orange: "#ffa500",
        orangered: "#ff4500",
        orchid: "#da70d6",
        palegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#d87093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        purple: "#800080",
        red: "#ff0000",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        silver: "#c0c0c0",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        steelblue: "#4682b4",
        tan: "#d2b48c",
        teal: "#008080",
        thistle: "#d8bfd8",
        tomato: "#ff6347",
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        white: "#ffffff",
        whitesmoke: "#f5f5f5",
        yellow: "#ffff00",
        yellowgreen: "#9acd32",
        //'currentColor' color keyword http://www.w3.org/TR/css3-color/#currentcolor
        currentColor: "The value of the 'color' property.",
        //CSS2 system colors http://www.w3.org/TR/css3-color/#css2-system
        activeBorder: "Active window border.",
        activecaption: "Active window caption.",
        appworkspace: "Background color of multiple document interface.",
        background: "Desktop background.",
        buttonface: "The face background color for 3-D elements that appear 3-D due to one layer of surrounding border.",
        buttonhighlight: "The color of the border facing the light source for 3-D elements that appear 3-D due to one layer of surrounding border.",
        buttonshadow: "The color of the border away from the light source for 3-D elements that appear 3-D due to one layer of surrounding border.",
        buttontext: "Text on push buttons.",
        captiontext: "Text in caption, size box, and scrollbar arrow box.",
        graytext: "Grayed (disabled) text. This color is set to #000 if the current display driver does not support a solid gray color.",
        greytext: "Greyed (disabled) text. This color is set to #000 if the current display driver does not support a solid grey color.",
        highlight: "Item(s) selected in a control.",
        highlighttext: "Text of item(s) selected in a control.",
        inactiveborder: "Inactive window border.",
        inactivecaption: "Inactive window caption.",
        inactivecaptiontext: "Color of text in an inactive caption.",
        infobackground: "Background color for tooltip controls.",
        infotext: "Text color for tooltip controls.",
        menu: "Menu background.",
        menutext: "Text in menus.",
        scrollbar: "Scroll bar gray area.",
        threeddarkshadow: "The color of the darker (generally outer) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
        threedface: "The face background color for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
        threedhighlight: "The color of the lighter (generally outer) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
        threedlightshadow: "The color of the darker (generally inner) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
        threedshadow: "The color of the lighter (generally inner) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.",
        window: "Window background.",
        windowframe: "Window frame.",
        windowtext: "Text in windows."
      };
      function Combinator(text, line, col) {
        SyntaxUnit.call(this, text, line, col, Parser.COMBINATOR_TYPE);
        this.type = "unknown";
        if (/^\s+$/.test(text)) {
          this.type = "descendant";
        } else if (text === ">") {
          this.type = "child";
        } else if (text === "+") {
          this.type = "adjacent-sibling";
        } else if (text === "~") {
          this.type = "sibling";
        }
      }
      Combinator.prototype = new SyntaxUnit();
      Combinator.prototype.constructor = Combinator;
      function MediaFeature(name, value) {
        SyntaxUnit.call(this, "(" + name + (value !== null ? ":" + value : "") + ")", name.startLine, name.startCol, Parser.MEDIA_FEATURE_TYPE);
        this.name = name;
        this.value = value;
      }
      MediaFeature.prototype = new SyntaxUnit();
      MediaFeature.prototype.constructor = MediaFeature;
      function MediaQuery(modifier, mediaType, features, line, col) {
        SyntaxUnit.call(this, (modifier ? modifier + " " : "") + (mediaType ? mediaType : "") + (mediaType && features.length > 0 ? " and " : "") + features.join(" and "), line, col, Parser.MEDIA_QUERY_TYPE);
        this.modifier = modifier;
        this.mediaType = mediaType;
        this.features = features;
      }
      MediaQuery.prototype = new SyntaxUnit();
      MediaQuery.prototype.constructor = MediaQuery;
      function Parser(options) {
        EventTarget.call(this);
        this.options = options || {};
        this._tokenStream = null;
      }
      Parser.DEFAULT_TYPE = 0;
      Parser.COMBINATOR_TYPE = 1;
      Parser.MEDIA_FEATURE_TYPE = 2;
      Parser.MEDIA_QUERY_TYPE = 3;
      Parser.PROPERTY_NAME_TYPE = 4;
      Parser.PROPERTY_VALUE_TYPE = 5;
      Parser.PROPERTY_VALUE_PART_TYPE = 6;
      Parser.SELECTOR_TYPE = 7;
      Parser.SELECTOR_PART_TYPE = 8;
      Parser.SELECTOR_SUB_PART_TYPE = 9;
      Parser.prototype = (function() {
        var proto = new EventTarget(), prop, additions = {
          __proto__: null,
          //restore constructor
          constructor: Parser,
          //instance constants - yuck
          DEFAULT_TYPE: 0,
          COMBINATOR_TYPE: 1,
          MEDIA_FEATURE_TYPE: 2,
          MEDIA_QUERY_TYPE: 3,
          PROPERTY_NAME_TYPE: 4,
          PROPERTY_VALUE_TYPE: 5,
          PROPERTY_VALUE_PART_TYPE: 6,
          SELECTOR_TYPE: 7,
          SELECTOR_PART_TYPE: 8,
          SELECTOR_SUB_PART_TYPE: 9,
          //-----------------------------------------------------------------
          // Grammar
          //-----------------------------------------------------------------
          _stylesheet: function() {
            var tokenStream = this._tokenStream, count2, token, tt;
            this.fire("startstylesheet");
            this._charset();
            this._skipCruft();
            while (tokenStream.peek() === Tokens.IMPORT_SYM) {
              this._import();
              this._skipCruft();
            }
            while (tokenStream.peek() === Tokens.NAMESPACE_SYM) {
              this._namespace();
              this._skipCruft();
            }
            tt = tokenStream.peek();
            while (tt > Tokens.EOF) {
              try {
                switch (tt) {
                  case Tokens.MEDIA_SYM:
                    this._media();
                    this._skipCruft();
                    break;
                  case Tokens.PAGE_SYM:
                    this._page();
                    this._skipCruft();
                    break;
                  case Tokens.FONT_FACE_SYM:
                    this._font_face();
                    this._skipCruft();
                    break;
                  case Tokens.KEYFRAMES_SYM:
                    this._keyframes();
                    this._skipCruft();
                    break;
                  case Tokens.VIEWPORT_SYM:
                    this._viewport();
                    this._skipCruft();
                    break;
                  case Tokens.DOCUMENT_SYM:
                    this._document();
                    this._skipCruft();
                    break;
                  case Tokens.UNKNOWN_SYM:
                    tokenStream.get();
                    if (!this.options.strict) {
                      this.fire({
                        type: "error",
                        error: null,
                        message: "Unknown @ rule: " + tokenStream.LT(0).value + ".",
                        line: tokenStream.LT(0).startLine,
                        col: tokenStream.LT(0).startCol
                      });
                      count2 = 0;
                      while (tokenStream.advance([Tokens.LBRACE, Tokens.RBRACE]) === Tokens.LBRACE) {
                        count2++;
                      }
                      while (count2) {
                        tokenStream.advance([Tokens.RBRACE]);
                        count2--;
                      }
                    } else {
                      throw new SyntaxError2("Unknown @ rule.", tokenStream.LT(0).startLine, tokenStream.LT(0).startCol);
                    }
                    break;
                  case Tokens.S:
                    this._readWhitespace();
                    break;
                  default:
                    if (!this._ruleset()) {
                      switch (tt) {
                        case Tokens.CHARSET_SYM:
                          token = tokenStream.LT(1);
                          this._charset(false);
                          throw new SyntaxError2("@charset not allowed here.", token.startLine, token.startCol);
                        case Tokens.IMPORT_SYM:
                          token = tokenStream.LT(1);
                          this._import(false);
                          throw new SyntaxError2("@import not allowed here.", token.startLine, token.startCol);
                        case Tokens.NAMESPACE_SYM:
                          token = tokenStream.LT(1);
                          this._namespace(false);
                          throw new SyntaxError2("@namespace not allowed here.", token.startLine, token.startCol);
                        default:
                          tokenStream.get();
                          this._unexpectedToken(tokenStream.token());
                      }
                    }
                }
              } catch (ex) {
                if (ex instanceof SyntaxError2 && !this.options.strict) {
                  this.fire({
                    type: "error",
                    error: ex,
                    message: ex.message,
                    line: ex.line,
                    col: ex.col
                  });
                } else {
                  throw ex;
                }
              }
              tt = tokenStream.peek();
            }
            if (tt !== Tokens.EOF) {
              this._unexpectedToken(tokenStream.token());
            }
            this.fire("endstylesheet");
          },
          _charset: function(emit) {
            var tokenStream = this._tokenStream, charset, token, line, col;
            if (tokenStream.match(Tokens.CHARSET_SYM)) {
              line = tokenStream.token().startLine;
              col = tokenStream.token().startCol;
              this._readWhitespace();
              tokenStream.mustMatch(Tokens.STRING);
              token = tokenStream.token();
              charset = token.value;
              this._readWhitespace();
              tokenStream.mustMatch(Tokens.SEMICOLON);
              if (emit !== false) {
                this.fire({
                  type: "charset",
                  charset,
                  line,
                  col
                });
              }
            }
          },
          _import: function(emit) {
            var tokenStream = this._tokenStream, uri, importToken, mediaList = [];
            tokenStream.mustMatch(Tokens.IMPORT_SYM);
            importToken = tokenStream.token();
            this._readWhitespace();
            tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);
            uri = tokenStream.token().value.replace(/^(?:url\()?["']?([^"']+?)["']?\)?$/, "$1");
            this._readWhitespace();
            mediaList = this._media_query_list();
            tokenStream.mustMatch(Tokens.SEMICOLON);
            this._readWhitespace();
            if (emit !== false) {
              this.fire({
                type: "import",
                uri,
                media: mediaList,
                line: importToken.startLine,
                col: importToken.startCol
              });
            }
          },
          _namespace: function(emit) {
            var tokenStream = this._tokenStream, line, col, prefix, uri;
            tokenStream.mustMatch(Tokens.NAMESPACE_SYM);
            line = tokenStream.token().startLine;
            col = tokenStream.token().startCol;
            this._readWhitespace();
            if (tokenStream.match(Tokens.IDENT)) {
              prefix = tokenStream.token().value;
              this._readWhitespace();
            }
            tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);
            uri = tokenStream.token().value.replace(/(?:url\()?["']([^"']+)["']\)?/, "$1");
            this._readWhitespace();
            tokenStream.mustMatch(Tokens.SEMICOLON);
            this._readWhitespace();
            if (emit !== false) {
              this.fire({
                type: "namespace",
                prefix,
                uri,
                line,
                col
              });
            }
          },
          _media: function() {
            var tokenStream = this._tokenStream, line, col, mediaList;
            tokenStream.mustMatch(Tokens.MEDIA_SYM);
            line = tokenStream.token().startLine;
            col = tokenStream.token().startCol;
            this._readWhitespace();
            mediaList = this._media_query_list();
            tokenStream.mustMatch(Tokens.LBRACE);
            this._readWhitespace();
            this.fire({
              type: "startmedia",
              media: mediaList,
              line,
              col
            });
            while (true) {
              if (tokenStream.peek() === Tokens.PAGE_SYM) {
                this._page();
              } else if (tokenStream.peek() === Tokens.FONT_FACE_SYM) {
                this._font_face();
              } else if (tokenStream.peek() === Tokens.VIEWPORT_SYM) {
                this._viewport();
              } else if (tokenStream.peek() === Tokens.DOCUMENT_SYM) {
                this._document();
              } else if (!this._ruleset()) {
                break;
              }
            }
            tokenStream.mustMatch(Tokens.RBRACE);
            this._readWhitespace();
            this.fire({
              type: "endmedia",
              media: mediaList,
              line,
              col
            });
          },
          //CSS3 Media Queries
          _media_query_list: function() {
            var tokenStream = this._tokenStream, mediaList = [];
            this._readWhitespace();
            if (tokenStream.peek() === Tokens.IDENT || tokenStream.peek() === Tokens.LPAREN) {
              mediaList.push(this._media_query());
            }
            while (tokenStream.match(Tokens.COMMA)) {
              this._readWhitespace();
              mediaList.push(this._media_query());
            }
            return mediaList;
          },
          /*
                       * Note: "expression" in the grammar maps to the _media_expression
                       * method.
          
                       */
          _media_query: function() {
            var tokenStream = this._tokenStream, type = null, ident = null, token = null, expressions = [];
            if (tokenStream.match(Tokens.IDENT)) {
              ident = tokenStream.token().value.toLowerCase();
              if (ident !== "only" && ident !== "not") {
                tokenStream.unget();
                ident = null;
              } else {
                token = tokenStream.token();
              }
            }
            this._readWhitespace();
            if (tokenStream.peek() === Tokens.IDENT) {
              type = this._media_type();
              if (token === null) {
                token = tokenStream.token();
              }
            } else if (tokenStream.peek() === Tokens.LPAREN) {
              if (token === null) {
                token = tokenStream.LT(1);
              }
              expressions.push(this._media_expression());
            }
            if (type === null && expressions.length === 0) {
              return null;
            } else {
              this._readWhitespace();
              while (tokenStream.match(Tokens.IDENT)) {
                if (tokenStream.token().value.toLowerCase() !== "and") {
                  this._unexpectedToken(tokenStream.token());
                }
                this._readWhitespace();
                expressions.push(this._media_expression());
              }
            }
            return new MediaQuery(ident, type, expressions, token.startLine, token.startCol);
          },
          //CSS3 Media Queries
          _media_type: function() {
            return this._media_feature();
          },
          /**
           * Note: in CSS3 Media Queries, this is called "expression".
           * Renamed here to avoid conflict with CSS3 Selectors
           * definition of "expression". Also note that "expr" in the
           * grammar now maps to "expression" from CSS3 selectors.
           * @method _media_expression
           * @private
           */
          _media_expression: function() {
            var tokenStream = this._tokenStream, feature = null, token, expression = null;
            tokenStream.mustMatch(Tokens.LPAREN);
            feature = this._media_feature();
            this._readWhitespace();
            if (tokenStream.match(Tokens.COLON)) {
              this._readWhitespace();
              token = tokenStream.LT(1);
              expression = this._expression();
            }
            tokenStream.mustMatch(Tokens.RPAREN);
            this._readWhitespace();
            return new MediaFeature(feature, expression ? new SyntaxUnit(expression, token.startLine, token.startCol) : null);
          },
          //CSS3 Media Queries
          _media_feature: function() {
            var tokenStream = this._tokenStream;
            this._readWhitespace();
            tokenStream.mustMatch(Tokens.IDENT);
            return SyntaxUnit.fromToken(tokenStream.token());
          },
          //CSS3 Paged Media
          _page: function() {
            var tokenStream = this._tokenStream, line, col, identifier = null, pseudoPage = null;
            tokenStream.mustMatch(Tokens.PAGE_SYM);
            line = tokenStream.token().startLine;
            col = tokenStream.token().startCol;
            this._readWhitespace();
            if (tokenStream.match(Tokens.IDENT)) {
              identifier = tokenStream.token().value;
              if (identifier.toLowerCase() === "auto") {
                this._unexpectedToken(tokenStream.token());
              }
            }
            if (tokenStream.peek() === Tokens.COLON) {
              pseudoPage = this._pseudo_page();
            }
            this._readWhitespace();
            this.fire({
              type: "startpage",
              id: identifier,
              pseudo: pseudoPage,
              line,
              col
            });
            this._readDeclarations(true, true);
            this.fire({
              type: "endpage",
              id: identifier,
              pseudo: pseudoPage,
              line,
              col
            });
          },
          //CSS3 Paged Media
          _margin: function() {
            var tokenStream = this._tokenStream, line, col, marginSym = this._margin_sym();
            if (marginSym) {
              line = tokenStream.token().startLine;
              col = tokenStream.token().startCol;
              this.fire({
                type: "startpagemargin",
                margin: marginSym,
                line,
                col
              });
              this._readDeclarations(true);
              this.fire({
                type: "endpagemargin",
                margin: marginSym,
                line,
                col
              });
              return true;
            } else {
              return false;
            }
          },
          //CSS3 Paged Media
          _margin_sym: function() {
            var tokenStream = this._tokenStream;
            if (tokenStream.match([
              Tokens.TOPLEFTCORNER_SYM,
              Tokens.TOPLEFT_SYM,
              Tokens.TOPCENTER_SYM,
              Tokens.TOPRIGHT_SYM,
              Tokens.TOPRIGHTCORNER_SYM,
              Tokens.BOTTOMLEFTCORNER_SYM,
              Tokens.BOTTOMLEFT_SYM,
              Tokens.BOTTOMCENTER_SYM,
              Tokens.BOTTOMRIGHT_SYM,
              Tokens.BOTTOMRIGHTCORNER_SYM,
              Tokens.LEFTTOP_SYM,
              Tokens.LEFTMIDDLE_SYM,
              Tokens.LEFTBOTTOM_SYM,
              Tokens.RIGHTTOP_SYM,
              Tokens.RIGHTMIDDLE_SYM,
              Tokens.RIGHTBOTTOM_SYM
            ])) {
              return SyntaxUnit.fromToken(tokenStream.token());
            } else {
              return null;
            }
          },
          _pseudo_page: function() {
            var tokenStream = this._tokenStream;
            tokenStream.mustMatch(Tokens.COLON);
            tokenStream.mustMatch(Tokens.IDENT);
            return tokenStream.token().value;
          },
          _font_face: function() {
            var tokenStream = this._tokenStream, line, col;
            tokenStream.mustMatch(Tokens.FONT_FACE_SYM);
            line = tokenStream.token().startLine;
            col = tokenStream.token().startCol;
            this._readWhitespace();
            this.fire({
              type: "startfontface",
              line,
              col
            });
            this._readDeclarations(true);
            this.fire({
              type: "endfontface",
              line,
              col
            });
          },
          _viewport: function() {
            var tokenStream = this._tokenStream, line, col;
            tokenStream.mustMatch(Tokens.VIEWPORT_SYM);
            line = tokenStream.token().startLine;
            col = tokenStream.token().startCol;
            this._readWhitespace();
            this.fire({
              type: "startviewport",
              line,
              col
            });
            this._readDeclarations(true);
            this.fire({
              type: "endviewport",
              line,
              col
            });
          },
          _document: function() {
            var tokenStream = this._tokenStream, token, functions = [], prefix = "";
            tokenStream.mustMatch(Tokens.DOCUMENT_SYM);
            token = tokenStream.token();
            if (/^@\-([^\-]+)\-/.test(token.value)) {
              prefix = RegExp.$1;
            }
            this._readWhitespace();
            functions.push(this._document_function());
            while (tokenStream.match(Tokens.COMMA)) {
              this._readWhitespace();
              functions.push(this._document_function());
            }
            tokenStream.mustMatch(Tokens.LBRACE);
            this._readWhitespace();
            this.fire({
              type: "startdocument",
              functions,
              prefix,
              line: token.startLine,
              col: token.startCol
            });
            while (true) {
              if (tokenStream.peek() === Tokens.PAGE_SYM) {
                this._page();
              } else if (tokenStream.peek() === Tokens.FONT_FACE_SYM) {
                this._font_face();
              } else if (tokenStream.peek() === Tokens.VIEWPORT_SYM) {
                this._viewport();
              } else if (tokenStream.peek() === Tokens.MEDIA_SYM) {
                this._media();
              } else if (!this._ruleset()) {
                break;
              }
            }
            tokenStream.mustMatch(Tokens.RBRACE);
            this._readWhitespace();
            this.fire({
              type: "enddocument",
              functions,
              prefix,
              line: token.startLine,
              col: token.startCol
            });
          },
          _document_function: function() {
            var tokenStream = this._tokenStream, value;
            if (tokenStream.match(Tokens.URI)) {
              value = tokenStream.token().value;
              this._readWhitespace();
            } else {
              value = this._function();
            }
            return value;
          },
          _operator: function(inFunction) {
            var tokenStream = this._tokenStream, token = null;
            if (tokenStream.match([Tokens.SLASH, Tokens.COMMA]) || inFunction && tokenStream.match([Tokens.PLUS, Tokens.STAR, Tokens.MINUS])) {
              token = tokenStream.token();
              this._readWhitespace();
            }
            return token ? PropertyValuePart.fromToken(token) : null;
          },
          _combinator: function() {
            var tokenStream = this._tokenStream, value = null, token;
            if (tokenStream.match([Tokens.PLUS, Tokens.GREATER, Tokens.TILDE])) {
              token = tokenStream.token();
              value = new Combinator(token.value, token.startLine, token.startCol);
              this._readWhitespace();
            }
            return value;
          },
          _unary_operator: function() {
            var tokenStream = this._tokenStream;
            if (tokenStream.match([Tokens.MINUS, Tokens.PLUS])) {
              return tokenStream.token().value;
            } else {
              return null;
            }
          },
          _property: function() {
            var tokenStream = this._tokenStream, value = null, hack = null, tokenValue, token, line, col;
            if (tokenStream.peek() === Tokens.STAR && this.options.starHack) {
              tokenStream.get();
              token = tokenStream.token();
              hack = token.value;
              line = token.startLine;
              col = token.startCol;
            }
            if (tokenStream.match(Tokens.IDENT)) {
              token = tokenStream.token();
              tokenValue = token.value;
              if (tokenValue.charAt(0) === "_" && this.options.underscoreHack) {
                hack = "_";
                tokenValue = tokenValue.substring(1);
              }
              value = new PropertyName(tokenValue, hack, line || token.startLine, col || token.startCol);
              this._readWhitespace();
            }
            return value;
          },
          //Augmented with CSS3 Selectors
          _ruleset: function() {
            var tokenStream = this._tokenStream, tt, selectors;
            try {
              selectors = this._selectors_group();
            } catch (ex) {
              if (ex instanceof SyntaxError2 && !this.options.strict) {
                this.fire({
                  type: "error",
                  error: ex,
                  message: ex.message,
                  line: ex.line,
                  col: ex.col
                });
                tt = tokenStream.advance([Tokens.RBRACE]);
                if (tt === Tokens.RBRACE) {
                } else {
                  throw ex;
                }
              } else {
                throw ex;
              }
              return true;
            }
            if (selectors) {
              this.fire({
                type: "startrule",
                selectors,
                line: selectors[0].line,
                col: selectors[0].col
              });
              this._readDeclarations(true);
              this.fire({
                type: "endrule",
                selectors,
                line: selectors[0].line,
                col: selectors[0].col
              });
            }
            return selectors;
          },
          //CSS3 Selectors
          _selectors_group: function() {
            var tokenStream = this._tokenStream, selectors = [], selector;
            selector = this._selector();
            if (selector !== null) {
              selectors.push(selector);
              while (tokenStream.match(Tokens.COMMA)) {
                this._readWhitespace();
                selector = this._selector();
                if (selector !== null) {
                  selectors.push(selector);
                } else {
                  this._unexpectedToken(tokenStream.LT(1));
                }
              }
            }
            return selectors.length ? selectors : null;
          },
          //CSS3 Selectors
          _selector: function() {
            var tokenStream = this._tokenStream, selector = [], nextSelector = null, combinator = null, ws = null;
            nextSelector = this._simple_selector_sequence();
            if (nextSelector === null) {
              return null;
            }
            selector.push(nextSelector);
            do {
              combinator = this._combinator();
              if (combinator !== null) {
                selector.push(combinator);
                nextSelector = this._simple_selector_sequence();
                if (nextSelector === null) {
                  this._unexpectedToken(tokenStream.LT(1));
                } else {
                  selector.push(nextSelector);
                }
              } else {
                if (this._readWhitespace()) {
                  ws = new Combinator(tokenStream.token().value, tokenStream.token().startLine, tokenStream.token().startCol);
                  combinator = this._combinator();
                  nextSelector = this._simple_selector_sequence();
                  if (nextSelector === null) {
                    if (combinator !== null) {
                      this._unexpectedToken(tokenStream.LT(1));
                    }
                  } else {
                    if (combinator !== null) {
                      selector.push(combinator);
                    } else {
                      selector.push(ws);
                    }
                    selector.push(nextSelector);
                  }
                } else {
                  break;
                }
              }
            } while (true);
            return new Selector(selector, selector[0].line, selector[0].col);
          },
          //CSS3 Selectors
          _simple_selector_sequence: function() {
            var tokenStream = this._tokenStream, elementName = null, modifiers = [], selectorText = "", components = [
              //HASH
              function() {
                return tokenStream.match(Tokens.HASH) ? new SelectorSubPart(tokenStream.token().value, "id", tokenStream.token().startLine, tokenStream.token().startCol) : null;
              },
              this._class,
              this._attrib,
              this._pseudo,
              this._negation
            ], i = 0, len = components.length, component = null, line, col;
            line = tokenStream.LT(1).startLine;
            col = tokenStream.LT(1).startCol;
            elementName = this._type_selector();
            if (!elementName) {
              elementName = this._universal();
            }
            if (elementName !== null) {
              selectorText += elementName;
            }
            while (true) {
              if (tokenStream.peek() === Tokens.S) {
                break;
              }
              while (i < len && component === null) {
                component = components[i++].call(this);
              }
              if (component === null) {
                if (selectorText === "") {
                  return null;
                } else {
                  break;
                }
              } else {
                i = 0;
                modifiers.push(component);
                selectorText += component.toString();
                component = null;
              }
            }
            return selectorText !== "" ? new SelectorPart(elementName, modifiers, selectorText, line, col) : null;
          },
          //CSS3 Selectors
          _type_selector: function() {
            var tokenStream = this._tokenStream, ns = this._namespace_prefix(), elementName = this._element_name();
            if (!elementName) {
              if (ns) {
                tokenStream.unget();
                if (ns.length > 1) {
                  tokenStream.unget();
                }
              }
              return null;
            } else {
              if (ns) {
                elementName.text = ns + elementName.text;
                elementName.col -= ns.length;
              }
              return elementName;
            }
          },
          //CSS3 Selectors
          _class: function() {
            var tokenStream = this._tokenStream, token;
            if (tokenStream.match(Tokens.DOT)) {
              tokenStream.mustMatch(Tokens.IDENT);
              token = tokenStream.token();
              return new SelectorSubPart("." + token.value, "class", token.startLine, token.startCol - 1);
            } else {
              return null;
            }
          },
          //CSS3 Selectors
          _element_name: function() {
            var tokenStream = this._tokenStream, token;
            if (tokenStream.match(Tokens.IDENT)) {
              token = tokenStream.token();
              return new SelectorSubPart(token.value, "elementName", token.startLine, token.startCol);
            } else {
              return null;
            }
          },
          //CSS3 Selectors
          _namespace_prefix: function() {
            var tokenStream = this._tokenStream, value = "";
            if (tokenStream.LA(1) === Tokens.PIPE || tokenStream.LA(2) === Tokens.PIPE) {
              if (tokenStream.match([Tokens.IDENT, Tokens.STAR])) {
                value += tokenStream.token().value;
              }
              tokenStream.mustMatch(Tokens.PIPE);
              value += "|";
            }
            return value.length ? value : null;
          },
          //CSS3 Selectors
          _universal: function() {
            var tokenStream = this._tokenStream, value = "", ns;
            ns = this._namespace_prefix();
            if (ns) {
              value += ns;
            }
            if (tokenStream.match(Tokens.STAR)) {
              value += "*";
            }
            return value.length ? value : null;
          },
          //CSS3 Selectors
          _attrib: function() {
            var tokenStream = this._tokenStream, value = null, ns, token;
            if (tokenStream.match(Tokens.LBRACKET)) {
              token = tokenStream.token();
              value = token.value;
              value += this._readWhitespace();
              ns = this._namespace_prefix();
              if (ns) {
                value += ns;
              }
              tokenStream.mustMatch(Tokens.IDENT);
              value += tokenStream.token().value;
              value += this._readWhitespace();
              if (tokenStream.match([
                Tokens.PREFIXMATCH,
                Tokens.SUFFIXMATCH,
                Tokens.SUBSTRINGMATCH,
                Tokens.EQUALS,
                Tokens.INCLUDES,
                Tokens.DASHMATCH
              ])) {
                value += tokenStream.token().value;
                value += this._readWhitespace();
                tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);
                value += tokenStream.token().value;
                value += this._readWhitespace();
              }
              tokenStream.mustMatch(Tokens.RBRACKET);
              return new SelectorSubPart(value + "]", "attribute", token.startLine, token.startCol);
            } else {
              return null;
            }
          },
          //CSS3 Selectors
          _pseudo: function() {
            var tokenStream = this._tokenStream, pseudo = null, colons = ":", line, col;
            if (tokenStream.match(Tokens.COLON)) {
              if (tokenStream.match(Tokens.COLON)) {
                colons += ":";
              }
              if (tokenStream.match(Tokens.IDENT)) {
                pseudo = tokenStream.token().value;
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol - colons.length;
              } else if (tokenStream.peek() === Tokens.FUNCTION) {
                line = tokenStream.LT(1).startLine;
                col = tokenStream.LT(1).startCol - colons.length;
                pseudo = this._functional_pseudo();
              }
              if (pseudo) {
                pseudo = new SelectorSubPart(colons + pseudo, "pseudo", line, col);
              }
            }
            return pseudo;
          },
          //CSS3 Selectors
          _functional_pseudo: function() {
            var tokenStream = this._tokenStream, value = null;
            if (tokenStream.match(Tokens.FUNCTION)) {
              value = tokenStream.token().value;
              value += this._readWhitespace();
              value += this._expression();
              tokenStream.mustMatch(Tokens.RPAREN);
              value += ")";
            }
            return value;
          },
          //CSS3 Selectors
          _expression: function() {
            var tokenStream = this._tokenStream, value = "";
            while (tokenStream.match([
              Tokens.PLUS,
              Tokens.MINUS,
              Tokens.DIMENSION,
              Tokens.NUMBER,
              Tokens.STRING,
              Tokens.IDENT,
              Tokens.LENGTH,
              Tokens.FREQ,
              Tokens.ANGLE,
              Tokens.TIME,
              Tokens.RESOLUTION,
              Tokens.SLASH
            ])) {
              value += tokenStream.token().value;
              value += this._readWhitespace();
            }
            return value.length ? value : null;
          },
          //CSS3 Selectors
          _negation: function() {
            var tokenStream = this._tokenStream, line, col, value = "", arg, subpart = null;
            if (tokenStream.match(Tokens.NOT)) {
              value = tokenStream.token().value;
              line = tokenStream.token().startLine;
              col = tokenStream.token().startCol;
              value += this._readWhitespace();
              arg = this._negation_arg();
              value += arg;
              value += this._readWhitespace();
              tokenStream.match(Tokens.RPAREN);
              value += tokenStream.token().value;
              subpart = new SelectorSubPart(value, "not", line, col);
              subpart.args.push(arg);
            }
            return subpart;
          },
          //CSS3 Selectors
          _negation_arg: function() {
            var tokenStream = this._tokenStream, args = [
              this._type_selector,
              this._universal,
              function() {
                return tokenStream.match(Tokens.HASH) ? new SelectorSubPart(tokenStream.token().value, "id", tokenStream.token().startLine, tokenStream.token().startCol) : null;
              },
              this._class,
              this._attrib,
              this._pseudo
            ], arg = null, i = 0, len = args.length, line, col, part;
            line = tokenStream.LT(1).startLine;
            col = tokenStream.LT(1).startCol;
            while (i < len && arg === null) {
              arg = args[i].call(this);
              i++;
            }
            if (arg === null) {
              this._unexpectedToken(tokenStream.LT(1));
            }
            if (arg.type === "elementName") {
              part = new SelectorPart(arg, [], arg.toString(), line, col);
            } else {
              part = new SelectorPart(null, [arg], arg.toString(), line, col);
            }
            return part;
          },
          _declaration: function() {
            var tokenStream = this._tokenStream, property = null, expr = null, prio = null, invalid = null, propertyName = "";
            property = this._property();
            if (property !== null) {
              tokenStream.mustMatch(Tokens.COLON);
              this._readWhitespace();
              expr = this._expr();
              if (!expr || expr.length === 0) {
                this._unexpectedToken(tokenStream.LT(1));
              }
              prio = this._prio();
              propertyName = property.toString();
              if (this.options.starHack && property.hack === "*" || this.options.underscoreHack && property.hack === "_") {
                propertyName = property.text;
              }
              try {
                this._validateProperty(propertyName, expr);
              } catch (ex) {
                invalid = ex;
              }
              this.fire({
                type: "property",
                property,
                value: expr,
                important: prio,
                line: property.line,
                col: property.col,
                invalid
              });
              return true;
            } else {
              return false;
            }
          },
          _prio: function() {
            var tokenStream = this._tokenStream, result2 = tokenStream.match(Tokens.IMPORTANT_SYM);
            this._readWhitespace();
            return result2;
          },
          _expr: function(inFunction) {
            var values = [], value = null, operator = null;
            value = this._term(inFunction);
            if (value !== null) {
              values.push(value);
              do {
                operator = this._operator(inFunction);
                if (operator) {
                  values.push(operator);
                }
                value = this._term(inFunction);
                if (value === null) {
                  break;
                } else {
                  values.push(value);
                }
              } while (true);
            }
            return values.length > 0 ? new PropertyValue(values, values[0].line, values[0].col) : null;
          },
          _term: function(inFunction) {
            var tokenStream = this._tokenStream, unary = null, value = null, endChar = null, token, line, col;
            unary = this._unary_operator();
            if (unary !== null) {
              line = tokenStream.token().startLine;
              col = tokenStream.token().startCol;
            }
            if (tokenStream.peek() === Tokens.IE_FUNCTION && this.options.ieFilters) {
              value = this._ie_function();
              if (unary === null) {
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;
              }
            } else if (inFunction && tokenStream.match([Tokens.LPAREN, Tokens.LBRACE, Tokens.LBRACKET])) {
              token = tokenStream.token();
              endChar = token.endChar;
              value = token.value + this._expr(inFunction).text;
              if (unary === null) {
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;
              }
              tokenStream.mustMatch(Tokens.type(endChar));
              value += endChar;
              this._readWhitespace();
            } else if (tokenStream.match([
              Tokens.NUMBER,
              Tokens.PERCENTAGE,
              Tokens.LENGTH,
              Tokens.ANGLE,
              Tokens.TIME,
              Tokens.FREQ,
              Tokens.STRING,
              Tokens.IDENT,
              Tokens.URI,
              Tokens.UNICODE_RANGE
            ])) {
              value = tokenStream.token().value;
              if (unary === null) {
                line = tokenStream.token().startLine;
                col = tokenStream.token().startCol;
              }
              this._readWhitespace();
            } else {
              token = this._hexcolor();
              if (token === null) {
                if (unary === null) {
                  line = tokenStream.LT(1).startLine;
                  col = tokenStream.LT(1).startCol;
                }
                if (value === null) {
                  if (tokenStream.LA(3) === Tokens.EQUALS && this.options.ieFilters) {
                    value = this._ie_function();
                  } else {
                    value = this._function();
                  }
                }
              } else {
                value = token.value;
                if (unary === null) {
                  line = token.startLine;
                  col = token.startCol;
                }
              }
            }
            return value !== null ? new PropertyValuePart(unary !== null ? unary + value : value, line, col) : null;
          },
          _function: function() {
            var tokenStream = this._tokenStream, functionText = null, expr = null, lt;
            if (tokenStream.match(Tokens.FUNCTION)) {
              functionText = tokenStream.token().value;
              this._readWhitespace();
              expr = this._expr(true);
              functionText += expr;
              if (this.options.ieFilters && tokenStream.peek() === Tokens.EQUALS) {
                do {
                  if (this._readWhitespace()) {
                    functionText += tokenStream.token().value;
                  }
                  if (tokenStream.LA(0) === Tokens.COMMA) {
                    functionText += tokenStream.token().value;
                  }
                  tokenStream.match(Tokens.IDENT);
                  functionText += tokenStream.token().value;
                  tokenStream.match(Tokens.EQUALS);
                  functionText += tokenStream.token().value;
                  lt = tokenStream.peek();
                  while (lt !== Tokens.COMMA && lt !== Tokens.S && lt !== Tokens.RPAREN) {
                    tokenStream.get();
                    functionText += tokenStream.token().value;
                    lt = tokenStream.peek();
                  }
                } while (tokenStream.match([Tokens.COMMA, Tokens.S]));
              }
              tokenStream.match(Tokens.RPAREN);
              functionText += ")";
              this._readWhitespace();
            }
            return functionText;
          },
          _ie_function: function() {
            var tokenStream = this._tokenStream, functionText = null, lt;
            if (tokenStream.match([Tokens.IE_FUNCTION, Tokens.FUNCTION])) {
              functionText = tokenStream.token().value;
              do {
                if (this._readWhitespace()) {
                  functionText += tokenStream.token().value;
                }
                if (tokenStream.LA(0) === Tokens.COMMA) {
                  functionText += tokenStream.token().value;
                }
                tokenStream.match(Tokens.IDENT);
                functionText += tokenStream.token().value;
                tokenStream.match(Tokens.EQUALS);
                functionText += tokenStream.token().value;
                lt = tokenStream.peek();
                while (lt !== Tokens.COMMA && lt !== Tokens.S && lt !== Tokens.RPAREN) {
                  tokenStream.get();
                  functionText += tokenStream.token().value;
                  lt = tokenStream.peek();
                }
              } while (tokenStream.match([Tokens.COMMA, Tokens.S]));
              tokenStream.match(Tokens.RPAREN);
              functionText += ")";
              this._readWhitespace();
            }
            return functionText;
          },
          _hexcolor: function() {
            var tokenStream = this._tokenStream, token = null, color;
            if (tokenStream.match(Tokens.HASH)) {
              token = tokenStream.token();
              color = token.value;
              if (!/#[a-f0-9]{3,6}/i.test(color)) {
                throw new SyntaxError2("Expected a hex color but found '" + color + "' at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
              }
              this._readWhitespace();
            }
            return token;
          },
          //-----------------------------------------------------------------
          // Animations methods
          //-----------------------------------------------------------------
          _keyframes: function() {
            var tokenStream = this._tokenStream, token, tt, name, prefix = "";
            tokenStream.mustMatch(Tokens.KEYFRAMES_SYM);
            token = tokenStream.token();
            if (/^@\-([^\-]+)\-/.test(token.value)) {
              prefix = RegExp.$1;
            }
            this._readWhitespace();
            name = this._keyframe_name();
            this._readWhitespace();
            tokenStream.mustMatch(Tokens.LBRACE);
            this.fire({
              type: "startkeyframes",
              name,
              prefix,
              line: token.startLine,
              col: token.startCol
            });
            this._readWhitespace();
            tt = tokenStream.peek();
            while (tt === Tokens.IDENT || tt === Tokens.PERCENTAGE) {
              this._keyframe_rule();
              this._readWhitespace();
              tt = tokenStream.peek();
            }
            this.fire({
              type: "endkeyframes",
              name,
              prefix,
              line: token.startLine,
              col: token.startCol
            });
            this._readWhitespace();
            tokenStream.mustMatch(Tokens.RBRACE);
          },
          _keyframe_name: function() {
            var tokenStream = this._tokenStream;
            tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);
            return SyntaxUnit.fromToken(tokenStream.token());
          },
          _keyframe_rule: function() {
            var keyList = this._key_list();
            this.fire({
              type: "startkeyframerule",
              keys: keyList,
              line: keyList[0].line,
              col: keyList[0].col
            });
            this._readDeclarations(true);
            this.fire({
              type: "endkeyframerule",
              keys: keyList,
              line: keyList[0].line,
              col: keyList[0].col
            });
          },
          _key_list: function() {
            var tokenStream = this._tokenStream, keyList = [];
            keyList.push(this._key());
            this._readWhitespace();
            while (tokenStream.match(Tokens.COMMA)) {
              this._readWhitespace();
              keyList.push(this._key());
              this._readWhitespace();
            }
            return keyList;
          },
          _key: function() {
            var tokenStream = this._tokenStream, token;
            if (tokenStream.match(Tokens.PERCENTAGE)) {
              return SyntaxUnit.fromToken(tokenStream.token());
            } else if (tokenStream.match(Tokens.IDENT)) {
              token = tokenStream.token();
              if (/from|to/i.test(token.value)) {
                return SyntaxUnit.fromToken(token);
              }
              tokenStream.unget();
            }
            this._unexpectedToken(tokenStream.LT(1));
          },
          //-----------------------------------------------------------------
          // Helper methods
          //-----------------------------------------------------------------
          /**
           * Not part of CSS grammar, but useful for skipping over
           * combination of white space and HTML-style comments.
           * @return {void}
           * @method _skipCruft
           * @private
           */
          _skipCruft: function() {
            while (this._tokenStream.match([Tokens.S, Tokens.CDO, Tokens.CDC])) {
            }
          },
          /**
           * Not part of CSS grammar, but this pattern occurs frequently
           * in the official CSS grammar. Split out here to eliminate
           * duplicate code.
           * @param {Boolean} checkStart Indicates if the rule should check
           *      for the left brace at the beginning.
           * @param {Boolean} readMargins Indicates if the rule should check
           *      for margin patterns.
           * @return {void}
           * @method _readDeclarations
           * @private
           */
          _readDeclarations: function(checkStart, readMargins) {
            var tokenStream = this._tokenStream, tt;
            this._readWhitespace();
            if (checkStart) {
              tokenStream.mustMatch(Tokens.LBRACE);
            }
            this._readWhitespace();
            try {
              while (true) {
                if (tokenStream.match(Tokens.SEMICOLON) || readMargins && this._margin()) {
                } else if (this._declaration()) {
                  if (!tokenStream.match(Tokens.SEMICOLON)) {
                    break;
                  }
                } else {
                  break;
                }
                this._readWhitespace();
              }
              tokenStream.mustMatch(Tokens.RBRACE);
              this._readWhitespace();
            } catch (ex) {
              if (ex instanceof SyntaxError2 && !this.options.strict) {
                this.fire({
                  type: "error",
                  error: ex,
                  message: ex.message,
                  line: ex.line,
                  col: ex.col
                });
                tt = tokenStream.advance([Tokens.SEMICOLON, Tokens.RBRACE]);
                if (tt === Tokens.SEMICOLON) {
                  this._readDeclarations(false, readMargins);
                } else if (tt !== Tokens.RBRACE) {
                  throw ex;
                }
              } else {
                throw ex;
              }
            }
          },
          /**
           * In some cases, you can end up with two white space tokens in a
           * row. Instead of making a change in every function that looks for
           * white space, this function is used to match as much white space
           * as necessary.
           * @method _readWhitespace
           * @return {String} The white space if found, empty string if not.
           * @private
           */
          _readWhitespace: function() {
            var tokenStream = this._tokenStream, ws = "";
            while (tokenStream.match(Tokens.S)) {
              ws += tokenStream.token().value;
            }
            return ws;
          },
          /**
           * Throws an error when an unexpected token is found.
           * @param {Object} token The token that was found.
           * @method _unexpectedToken
           * @return {void}
           * @private
           */
          _unexpectedToken: function(token) {
            throw new SyntaxError2("Unexpected token '" + token.value + "' at line " + token.startLine + ", col " + token.startCol + ".", token.startLine, token.startCol);
          },
          /**
           * Helper method used for parsing subparts of a style sheet.
           * @return {void}
           * @method _verifyEnd
           * @private
           */
          _verifyEnd: function() {
            if (this._tokenStream.LA(1) !== Tokens.EOF) {
              this._unexpectedToken(this._tokenStream.LT(1));
            }
          },
          //-----------------------------------------------------------------
          // Validation methods
          //-----------------------------------------------------------------
          _validateProperty: function(property, value) {
            Validation.validate(property, value);
          },
          //-----------------------------------------------------------------
          // Parsing methods
          //-----------------------------------------------------------------
          parse: function(input) {
            this._tokenStream = new TokenStream(input, Tokens);
            this._stylesheet();
          },
          parseStyleSheet: function(input) {
            return this.parse(input);
          },
          parseMediaQuery: function(input) {
            this._tokenStream = new TokenStream(input, Tokens);
            var result2 = this._media_query();
            this._verifyEnd();
            return result2;
          },
          /**
           * Parses a property value (everything after the semicolon).
           * @return {parserlib.css.PropertyValue} The property value.
           * @throws parserlib.util.SyntaxError If an unexpected token is found.
           * @method parserPropertyValue
           */
          parsePropertyValue: function(input) {
            this._tokenStream = new TokenStream(input, Tokens);
            this._readWhitespace();
            var result2 = this._expr();
            this._readWhitespace();
            this._verifyEnd();
            return result2;
          },
          /**
           * Parses a complete CSS rule, including selectors and
           * properties.
           * @param {String} input The text to parser.
           * @return {Boolean} True if the parse completed successfully, false if not.
           * @method parseRule
           */
          parseRule: function(input) {
            this._tokenStream = new TokenStream(input, Tokens);
            this._readWhitespace();
            var result2 = this._ruleset();
            this._readWhitespace();
            this._verifyEnd();
            return result2;
          },
          /**
           * Parses a single CSS selector (no comma)
           * @param {String} input The text to parse as a CSS selector.
           * @return {Selector} An object representing the selector.
           * @throws parserlib.util.SyntaxError If an unexpected token is found.
           * @method parseSelector
           */
          parseSelector: function(input) {
            this._tokenStream = new TokenStream(input, Tokens);
            this._readWhitespace();
            var result2 = this._selector();
            this._readWhitespace();
            this._verifyEnd();
            return result2;
          },
          /**
           * Parses an HTML style attribute: a set of CSS declarations
           * separated by semicolons.
           * @param {String} input The text to parse as a style attribute
           * @return {void}
           * @method parseStyleAttribute
           */
          parseStyleAttribute: function(input) {
            input += "}";
            this._tokenStream = new TokenStream(input, Tokens);
            this._readDeclarations();
          }
        };
        for (prop in additions) {
          if (Object.prototype.hasOwnProperty.call(additions, prop)) {
            proto[prop] = additions[prop];
          }
        }
        return proto;
      })();
      var Properties = {
        __proto__: null,
        //A
        "align-items": "flex-start | flex-end | center | baseline | stretch",
        "align-content": "flex-start | flex-end | center | space-between | space-around | stretch",
        "align-self": "auto | flex-start | flex-end | center | baseline | stretch",
        "-webkit-align-items": "flex-start | flex-end | center | baseline | stretch",
        "-webkit-align-content": "flex-start | flex-end | center | space-between | space-around | stretch",
        "-webkit-align-self": "auto | flex-start | flex-end | center | baseline | stretch",
        "alignment-adjust": "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical | <percentage> | <length>",
        "alignment-baseline": "baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
        "animation": 1,
        "animation-delay": { multi: "<time>", comma: true },
        "animation-direction": { multi: "normal | alternate", comma: true },
        "animation-duration": { multi: "<time>", comma: true },
        "animation-fill-mode": { multi: "none | forwards | backwards | both", comma: true },
        "animation-iteration-count": { multi: "<number> | infinite", comma: true },
        "animation-name": { multi: "none | <ident>", comma: true },
        "animation-play-state": { multi: "running | paused", comma: true },
        "animation-timing-function": 1,
        //vendor prefixed
        "-moz-animation-delay": { multi: "<time>", comma: true },
        "-moz-animation-direction": { multi: "normal | alternate", comma: true },
        "-moz-animation-duration": { multi: "<time>", comma: true },
        "-moz-animation-iteration-count": { multi: "<number> | infinite", comma: true },
        "-moz-animation-name": { multi: "none | <ident>", comma: true },
        "-moz-animation-play-state": { multi: "running | paused", comma: true },
        "-ms-animation-delay": { multi: "<time>", comma: true },
        "-ms-animation-direction": { multi: "normal | alternate", comma: true },
        "-ms-animation-duration": { multi: "<time>", comma: true },
        "-ms-animation-iteration-count": { multi: "<number> | infinite", comma: true },
        "-ms-animation-name": { multi: "none | <ident>", comma: true },
        "-ms-animation-play-state": { multi: "running | paused", comma: true },
        "-webkit-animation-delay": { multi: "<time>", comma: true },
        "-webkit-animation-direction": { multi: "normal | alternate", comma: true },
        "-webkit-animation-duration": { multi: "<time>", comma: true },
        "-webkit-animation-fill-mode": { multi: "none | forwards | backwards | both", comma: true },
        "-webkit-animation-iteration-count": { multi: "<number> | infinite", comma: true },
        "-webkit-animation-name": { multi: "none | <ident>", comma: true },
        "-webkit-animation-play-state": { multi: "running | paused", comma: true },
        "-o-animation-delay": { multi: "<time>", comma: true },
        "-o-animation-direction": { multi: "normal | alternate", comma: true },
        "-o-animation-duration": { multi: "<time>", comma: true },
        "-o-animation-iteration-count": { multi: "<number> | infinite", comma: true },
        "-o-animation-name": { multi: "none | <ident>", comma: true },
        "-o-animation-play-state": { multi: "running | paused", comma: true },
        "appearance": "icon | window | desktop | workspace | document | tooltip | dialog | button | push-button | hyperlink | radio | radio-button | checkbox | menu-item | tab | menu | menubar | pull-down-menu | pop-up-menu | list-menu | radio-group | checkbox-group | outline-tree | range | field | combo-box | signature | password | normal | none | inherit",
        "aspect-ratio": 1,
        "azimuth": function(expression) {
          var simple = "<angle> | leftwards | rightwards | inherit", direction = "left-side | far-left | left | center-left | center | center-right | right | far-right | right-side", behind = false, valid = false, part;
          if (!ValidationTypes.isAny(expression, simple)) {
            if (ValidationTypes.isAny(expression, "behind")) {
              behind = true;
              valid = true;
            }
            if (ValidationTypes.isAny(expression, direction)) {
              valid = true;
              if (!behind) {
                ValidationTypes.isAny(expression, "behind");
              }
            }
          }
          if (expression.hasNext()) {
            part = expression.next();
            if (valid) {
              throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
              throw new ValidationError("Expected (<'azimuth'>) but found '" + part + "'.", part.line, part.col);
            }
          }
        },
        //B
        "backface-visibility": "visible | hidden",
        "background": 1,
        "background-attachment": { multi: "<attachment>", comma: true },
        "background-clip": { multi: "<box>", comma: true },
        "background-color": "<color> | inherit",
        "background-image": { multi: "<bg-image>", comma: true },
        "background-origin": { multi: "<box>", comma: true },
        "background-position": { multi: "<bg-position>", comma: true },
        "background-repeat": { multi: "<repeat-style>" },
        "background-size": { multi: "<bg-size>", comma: true },
        "baseline-shift": "baseline | sub | super | <percentage> | <length>",
        "behavior": 1,
        "binding": 1,
        "bleed": "<length>",
        "bookmark-label": "<content> | <attr> | <string>",
        "bookmark-level": "none | <integer>",
        "bookmark-state": "open | closed",
        "bookmark-target": "none | <uri> | <attr>",
        "border": "<border-width> || <border-style> || <color>",
        "border-bottom": "<border-width> || <border-style> || <color>",
        "border-bottom-color": "<color> | inherit",
        "border-bottom-left-radius": "<x-one-radius>",
        "border-bottom-right-radius": "<x-one-radius>",
        "border-bottom-style": "<border-style>",
        "border-bottom-width": "<border-width>",
        "border-collapse": "collapse | separate | inherit",
        "border-color": { multi: "<color> | inherit", max: 4 },
        "border-image": 1,
        "border-image-outset": { multi: "<length> | <number>", max: 4 },
        "border-image-repeat": { multi: "stretch | repeat | round", max: 2 },
        "border-image-slice": function(expression) {
          var valid = false, numeric = "<number> | <percentage>", fill = false, count2 = 0, max = 4, part;
          if (ValidationTypes.isAny(expression, "fill")) {
            fill = true;
            valid = true;
          }
          while (expression.hasNext() && count2 < max) {
            valid = ValidationTypes.isAny(expression, numeric);
            if (!valid) {
              break;
            }
            count2++;
          }
          if (!fill) {
            ValidationTypes.isAny(expression, "fill");
          } else {
            valid = true;
          }
          if (expression.hasNext()) {
            part = expression.next();
            if (valid) {
              throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
              throw new ValidationError("Expected ([<number> | <percentage>]{1,4} && fill?) but found '" + part + "'.", part.line, part.col);
            }
          }
        },
        "border-image-source": "<image> | none",
        "border-image-width": { multi: "<length> | <percentage> | <number> | auto", max: 4 },
        "border-left": "<border-width> || <border-style> || <color>",
        "border-left-color": "<color> | inherit",
        "border-left-style": "<border-style>",
        "border-left-width": "<border-width>",
        "border-radius": function(expression) {
          var valid = false, simple = "<length> | <percentage> | inherit", slash = false, count2 = 0, max = 8, part;
          while (expression.hasNext() && count2 < max) {
            valid = ValidationTypes.isAny(expression, simple);
            if (!valid) {
              if (String(expression.peek()) === "/" && count2 > 0 && !slash) {
                slash = true;
                max = count2 + 5;
                expression.next();
              } else {
                break;
              }
            }
            count2++;
          }
          if (expression.hasNext()) {
            part = expression.next();
            if (valid) {
              throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
              throw new ValidationError("Expected (<'border-radius'>) but found '" + part + "'.", part.line, part.col);
            }
          }
        },
        "border-right": "<border-width> || <border-style> || <color>",
        "border-right-color": "<color> | inherit",
        "border-right-style": "<border-style>",
        "border-right-width": "<border-width>",
        "border-spacing": { multi: "<length> | inherit", max: 2 },
        "border-style": { multi: "<border-style>", max: 4 },
        "border-top": "<border-width> || <border-style> || <color>",
        "border-top-color": "<color> | inherit",
        "border-top-left-radius": "<x-one-radius>",
        "border-top-right-radius": "<x-one-radius>",
        "border-top-style": "<border-style>",
        "border-top-width": "<border-width>",
        "border-width": { multi: "<border-width>", max: 4 },
        "bottom": "<margin-width> | inherit",
        "-moz-box-align": "start | end | center | baseline | stretch",
        "-moz-box-decoration-break": "slice |clone",
        "-moz-box-direction": "normal | reverse | inherit",
        "-moz-box-flex": "<number>",
        "-moz-box-flex-group": "<integer>",
        "-moz-box-lines": "single | multiple",
        "-moz-box-ordinal-group": "<integer>",
        "-moz-box-orient": "horizontal | vertical | inline-axis | block-axis | inherit",
        "-moz-box-pack": "start | end | center | justify",
        "-o-box-decoration-break": "slice | clone",
        "-webkit-box-align": "start | end | center | baseline | stretch",
        "-webkit-box-decoration-break": "slice |clone",
        "-webkit-box-direction": "normal | reverse | inherit",
        "-webkit-box-flex": "<number>",
        "-webkit-box-flex-group": "<integer>",
        "-webkit-box-lines": "single | multiple",
        "-webkit-box-ordinal-group": "<integer>",
        "-webkit-box-orient": "horizontal | vertical | inline-axis | block-axis | inherit",
        "-webkit-box-pack": "start | end | center | justify",
        "box-decoration-break": "slice | clone",
        "box-shadow": function(expression) {
          var part;
          if (!ValidationTypes.isAny(expression, "none")) {
            Validation.multiProperty("<shadow>", expression, true, Infinity);
          } else {
            if (expression.hasNext()) {
              part = expression.next();
              throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            }
          }
        },
        "box-sizing": "content-box | border-box | inherit",
        "break-after": "auto | always | avoid | left | right | page | column | avoid-page | avoid-column",
        "break-before": "auto | always | avoid | left | right | page | column | avoid-page | avoid-column",
        "break-inside": "auto | avoid | avoid-page | avoid-column",
        //C
        "caption-side": "top | bottom | inherit",
        "clear": "none | right | left | both | inherit",
        "clip": 1,
        "color": "<color> | inherit",
        "color-profile": 1,
        "column-count": "<integer> | auto",
        //http://www.w3.org/TR/css3-multicol/
        "column-fill": "auto | balance",
        "column-gap": "<length> | normal",
        "column-rule": "<border-width> || <border-style> || <color>",
        "column-rule-color": "<color>",
        "column-rule-style": "<border-style>",
        "column-rule-width": "<border-width>",
        "column-span": "none | all",
        "column-width": "<length> | auto",
        "columns": 1,
        "content": 1,
        "counter-increment": 1,
        "counter-reset": 1,
        "crop": "<shape> | auto",
        "cue": "cue-after | cue-before | inherit",
        "cue-after": 1,
        "cue-before": 1,
        "cursor": 1,
        //D
        "direction": "ltr | rtl | inherit",
        "display": "inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | grid | inline-grid | run-in | ruby | ruby-base | ruby-text | ruby-base-container | ruby-text-container | contents | none | inherit | -moz-box | -moz-inline-block | -moz-inline-box | -moz-inline-grid | -moz-inline-stack | -moz-inline-table | -moz-grid | -moz-grid-group | -moz-grid-line | -moz-groupbox | -moz-deck | -moz-popup | -moz-stack | -moz-marker | -webkit-box | -webkit-inline-box | -ms-flexbox | -ms-inline-flexbox | flex | -webkit-flex | inline-flex | -webkit-inline-flex",
        "dominant-baseline": 1,
        "drop-initial-after-adjust": "central | middle | after-edge | text-after-edge | ideographic | alphabetic | mathematical | <percentage> | <length>",
        "drop-initial-after-align": "baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
        "drop-initial-before-adjust": "before-edge | text-before-edge | central | middle | hanging | mathematical | <percentage> | <length>",
        "drop-initial-before-align": "caps-height | baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical",
        "drop-initial-size": "auto | line | <length> | <percentage>",
        "drop-initial-value": "initial | <integer>",
        //E
        "elevation": "<angle> | below | level | above | higher | lower | inherit",
        "empty-cells": "show | hide | inherit",
        //F
        "filter": 1,
        "fit": "fill | hidden | meet | slice",
        "fit-position": 1,
        "flex": "<flex>",
        "flex-basis": "<width>",
        "flex-direction": "row | row-reverse | column | column-reverse",
        "flex-flow": "<flex-direction> || <flex-wrap>",
        "flex-grow": "<number>",
        "flex-shrink": "<number>",
        "flex-wrap": "nowrap | wrap | wrap-reverse",
        "-webkit-flex": "<flex>",
        "-webkit-flex-basis": "<width>",
        "-webkit-flex-direction": "row | row-reverse | column | column-reverse",
        "-webkit-flex-flow": "<flex-direction> || <flex-wrap>",
        "-webkit-flex-grow": "<number>",
        "-webkit-flex-shrink": "<number>",
        "-webkit-flex-wrap": "nowrap | wrap | wrap-reverse",
        "-ms-flex": "<flex>",
        "-ms-flex-align": "start | end | center | stretch | baseline",
        "-ms-flex-direction": "row | row-reverse | column | column-reverse | inherit",
        "-ms-flex-order": "<number>",
        "-ms-flex-pack": "start | end | center | justify",
        "-ms-flex-wrap": "nowrap | wrap | wrap-reverse",
        "float": "left | right | none | inherit",
        "float-offset": 1,
        "font": 1,
        "font-family": 1,
        "font-feature-settings": "<feature-tag-value> | normal | inherit",
        "font-kerning": "auto | normal | none | initial | inherit | unset",
        "font-size": "<absolute-size> | <relative-size> | <length> | <percentage> | inherit",
        "font-size-adjust": "<number> | none | inherit",
        "font-stretch": "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | inherit",
        "font-style": "normal | italic | oblique | inherit",
        "font-variant": "normal | small-caps | inherit",
        "font-variant-caps": "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
        "font-variant-position": "normal | sub | super | inherit | initial | unset",
        "font-weight": "normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 | inherit",
        //G
        "grid": 1,
        "grid-area": 1,
        "grid-auto-columns": 1,
        "grid-auto-flow": 1,
        "grid-auto-position": 1,
        "grid-auto-rows": 1,
        "grid-cell-stacking": "columns | rows | layer",
        "grid-column": 1,
        "grid-columns": 1,
        "grid-column-align": "start | end | center | stretch",
        "grid-column-sizing": 1,
        "grid-column-start": 1,
        "grid-column-end": 1,
        "grid-column-span": "<integer>",
        "grid-flow": "none | rows | columns",
        "grid-layer": "<integer>",
        "grid-row": 1,
        "grid-rows": 1,
        "grid-row-align": "start | end | center | stretch",
        "grid-row-start": 1,
        "grid-row-end": 1,
        "grid-row-span": "<integer>",
        "grid-row-sizing": 1,
        "grid-template": 1,
        "grid-template-areas": 1,
        "grid-template-columns": 1,
        "grid-template-rows": 1,
        //H
        "hanging-punctuation": 1,
        "height": "<margin-width> | <content-sizing> | inherit",
        "hyphenate-after": "<integer> | auto",
        "hyphenate-before": "<integer> | auto",
        "hyphenate-character": "<string> | auto",
        "hyphenate-lines": "no-limit | <integer>",
        "hyphenate-resource": 1,
        "hyphens": "none | manual | auto",
        //I
        "icon": 1,
        "image-orientation": "angle | auto",
        "image-rendering": 1,
        "image-resolution": 1,
        "ime-mode": "auto | normal | active | inactive | disabled | inherit",
        "inline-box-align": "initial | last | <integer>",
        //J
        "justify-content": "flex-start | flex-end | center | space-between | space-around",
        "-webkit-justify-content": "flex-start | flex-end | center | space-between | space-around",
        //L
        "left": "<margin-width> | inherit",
        "letter-spacing": "<length> | normal | inherit",
        "line-height": "<number> | <length> | <percentage> | normal | inherit",
        "line-break": "auto | loose | normal | strict",
        "line-stacking": 1,
        "line-stacking-ruby": "exclude-ruby | include-ruby",
        "line-stacking-shift": "consider-shifts | disregard-shifts",
        "line-stacking-strategy": "inline-line-height | block-line-height | max-height | grid-height",
        "list-style": 1,
        "list-style-image": "<uri> | none | inherit",
        "list-style-position": "inside | outside | inherit",
        "list-style-type": "disc | circle | square | decimal | decimal-leading-zero | lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | lower-alpha | upper-alpha | none | inherit",
        //M
        "margin": { multi: "<margin-width> | inherit", max: 4 },
        "margin-bottom": "<margin-width> | inherit",
        "margin-left": "<margin-width> | inherit",
        "margin-right": "<margin-width> | inherit",
        "margin-top": "<margin-width> | inherit",
        "mark": 1,
        "mark-after": 1,
        "mark-before": 1,
        "marks": 1,
        "marquee-direction": 1,
        "marquee-play-count": 1,
        "marquee-speed": 1,
        "marquee-style": 1,
        "max-height": "<length> | <percentage> | <content-sizing> | none | inherit",
        "max-width": "<length> | <percentage> | <content-sizing> | none | inherit",
        "min-height": "<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats | inherit",
        "min-width": "<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats | inherit",
        "move-to": 1,
        //N
        "nav-down": 1,
        "nav-index": 1,
        "nav-left": 1,
        "nav-right": 1,
        "nav-up": 1,
        //O
        "object-fit": "fill | contain | cover | none | scale-down",
        "object-position": "<bg-position>",
        "opacity": "<number> | inherit",
        "order": "<integer>",
        "-webkit-order": "<integer>",
        "orphans": "<integer> | inherit",
        "outline": 1,
        "outline-color": "<color> | invert | inherit",
        "outline-offset": 1,
        "outline-style": "<border-style> | inherit",
        "outline-width": "<border-width> | inherit",
        "overflow": "visible | hidden | scroll | auto | inherit",
        "overflow-style": 1,
        "overflow-wrap": "normal | break-word",
        "overflow-x": 1,
        "overflow-y": 1,
        //P
        "padding": { multi: "<padding-width> | inherit", max: 4 },
        "padding-bottom": "<padding-width> | inherit",
        "padding-left": "<padding-width> | inherit",
        "padding-right": "<padding-width> | inherit",
        "padding-top": "<padding-width> | inherit",
        "page": 1,
        "page-break-after": "auto | always | avoid | left | right | inherit",
        "page-break-before": "auto | always | avoid | left | right | inherit",
        "page-break-inside": "auto | avoid | inherit",
        "page-policy": 1,
        "pause": 1,
        "pause-after": 1,
        "pause-before": 1,
        "perspective": 1,
        "perspective-origin": 1,
        "phonemes": 1,
        "pitch": 1,
        "pitch-range": 1,
        "play-during": 1,
        "pointer-events": "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
        "position": "static | relative | absolute | fixed | inherit",
        "presentation-level": 1,
        "punctuation-trim": 1,
        //Q
        "quotes": 1,
        //R
        "rendering-intent": 1,
        "resize": 1,
        "rest": 1,
        "rest-after": 1,
        "rest-before": 1,
        "richness": 1,
        "right": "<margin-width> | inherit",
        "rotation": 1,
        "rotation-point": 1,
        "ruby-align": 1,
        "ruby-overhang": 1,
        "ruby-position": 1,
        "ruby-span": 1,
        //S
        "size": 1,
        "speak": "normal | none | spell-out | inherit",
        "speak-header": "once | always | inherit",
        "speak-numeral": "digits | continuous | inherit",
        "speak-punctuation": "code | none | inherit",
        "speech-rate": 1,
        "src": 1,
        "stress": 1,
        "string-set": 1,
        "table-layout": "auto | fixed | inherit",
        "tab-size": "<integer> | <length>",
        "target": 1,
        "target-name": 1,
        "target-new": 1,
        "target-position": 1,
        "text-align": "left | right | center | justify | match-parent | start | end | inherit",
        "text-align-last": 1,
        "text-decoration": 1,
        "text-emphasis": 1,
        "text-height": 1,
        "text-indent": "<length> | <percentage> | inherit",
        "text-justify": "auto | none | inter-word | inter-ideograph | inter-cluster | distribute | kashida",
        "text-outline": 1,
        "text-overflow": 1,
        "text-rendering": "auto | optimizeSpeed | optimizeLegibility | geometricPrecision | inherit",
        "text-shadow": 1,
        "text-transform": "capitalize | uppercase | lowercase | none | inherit",
        "text-wrap": "normal | none | avoid",
        "top": "<margin-width> | inherit",
        "-ms-touch-action": "auto | none | pan-x | pan-y | pan-left | pan-right | pan-up | pan-down | manipulation",
        "touch-action": "auto | none | pan-x | pan-y | pan-left | pan-right | pan-up | pan-down | manipulation",
        "transform": 1,
        "transform-origin": 1,
        "transform-style": 1,
        "transition": 1,
        "transition-delay": 1,
        "transition-duration": 1,
        "transition-property": 1,
        "transition-timing-function": 1,
        //U
        "unicode-bidi": "normal | embed | isolate | bidi-override | isolate-override | plaintext | inherit",
        "user-modify": "read-only | read-write | write-only | inherit",
        "user-select": "none | text | toggle | element | elements | all | inherit",
        //V
        "vertical-align": "auto | use-script | baseline | sub | super | top | text-top | central | middle | bottom | text-bottom | <percentage> | <length> | inherit",
        "visibility": "visible | hidden | collapse | inherit",
        "voice-balance": 1,
        "voice-duration": 1,
        "voice-family": 1,
        "voice-pitch": 1,
        "voice-pitch-range": 1,
        "voice-rate": 1,
        "voice-stress": 1,
        "voice-volume": 1,
        "volume": 1,
        //W
        "white-space": "normal | pre | nowrap | pre-wrap | pre-line | inherit | -pre-wrap | -o-pre-wrap | -moz-pre-wrap | -hp-pre-wrap",
        //http://perishablepress.com/wrapping-content/
        "white-space-collapse": 1,
        "widows": "<integer> | inherit",
        "width": "<length> | <percentage> | <content-sizing> | auto | inherit",
        "will-change": { multi: "<ident>", comma: true },
        "word-break": "normal | keep-all | break-all",
        "word-spacing": "<length> | normal | inherit",
        "word-wrap": "normal | break-word",
        "writing-mode": "horizontal-tb | vertical-rl | vertical-lr | lr-tb | rl-tb | tb-rl | bt-rl | tb-lr | bt-lr | lr-bt | rl-bt | lr | rl | tb | inherit",
        //Z
        "z-index": "<integer> | auto | inherit",
        "zoom": "<number> | <percentage> | normal"
      };
      function PropertyName(text, hack, line, col) {
        SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_NAME_TYPE);
        this.hack = hack;
      }
      PropertyName.prototype = new SyntaxUnit();
      PropertyName.prototype.constructor = PropertyName;
      PropertyName.prototype.toString = function() {
        return (this.hack ? this.hack : "") + this.text;
      };
      function PropertyValue(parts, line, col) {
        SyntaxUnit.call(this, parts.join(" "), line, col, Parser.PROPERTY_VALUE_TYPE);
        this.parts = parts;
      }
      PropertyValue.prototype = new SyntaxUnit();
      PropertyValue.prototype.constructor = PropertyValue;
      function PropertyValueIterator(value) {
        this._i = 0;
        this._parts = value.parts;
        this._marks = [];
        this.value = value;
      }
      PropertyValueIterator.prototype.count = function() {
        return this._parts.length;
      };
      PropertyValueIterator.prototype.isFirst = function() {
        return this._i === 0;
      };
      PropertyValueIterator.prototype.hasNext = function() {
        return this._i < this._parts.length;
      };
      PropertyValueIterator.prototype.mark = function() {
        this._marks.push(this._i);
      };
      PropertyValueIterator.prototype.peek = function(count2) {
        return this.hasNext() ? this._parts[this._i + (count2 || 0)] : null;
      };
      PropertyValueIterator.prototype.next = function() {
        return this.hasNext() ? this._parts[this._i++] : null;
      };
      PropertyValueIterator.prototype.previous = function() {
        return this._i > 0 ? this._parts[--this._i] : null;
      };
      PropertyValueIterator.prototype.restore = function() {
        if (this._marks.length) {
          this._i = this._marks.pop();
        }
      };
      function PropertyValuePart(text, line, col) {
        SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_VALUE_PART_TYPE);
        this.type = "unknown";
        var temp;
        if (/^([+\-]?[\d\.]+)([a-z]+)$/i.test(text)) {
          this.type = "dimension";
          this.value = +RegExp.$1;
          this.units = RegExp.$2;
          switch (this.units.toLowerCase()) {
            case "em":
            case "rem":
            case "ex":
            case "px":
            case "cm":
            case "mm":
            case "in":
            case "pt":
            case "pc":
            case "ch":
            case "vh":
            case "vw":
            case "vmax":
            case "vmin":
              this.type = "length";
              break;
            case "fr":
              this.type = "grid";
              break;
            case "deg":
            case "rad":
            case "grad":
              this.type = "angle";
              break;
            case "ms":
            case "s":
              this.type = "time";
              break;
            case "hz":
            case "khz":
              this.type = "frequency";
              break;
            case "dpi":
            case "dpcm":
              this.type = "resolution";
              break;
          }
        } else if (/^([+\-]?[\d\.]+)%$/i.test(text)) {
          this.type = "percentage";
          this.value = +RegExp.$1;
        } else if (/^([+\-]?\d+)$/i.test(text)) {
          this.type = "integer";
          this.value = +RegExp.$1;
        } else if (/^([+\-]?[\d\.]+)$/i.test(text)) {
          this.type = "number";
          this.value = +RegExp.$1;
        } else if (/^#([a-f0-9]{3,6})/i.test(text)) {
          this.type = "color";
          temp = RegExp.$1;
          if (temp.length === 3) {
            this.red = parseInt(temp.charAt(0) + temp.charAt(0), 16);
            this.green = parseInt(temp.charAt(1) + temp.charAt(1), 16);
            this.blue = parseInt(temp.charAt(2) + temp.charAt(2), 16);
          } else {
            this.red = parseInt(temp.substring(0, 2), 16);
            this.green = parseInt(temp.substring(2, 4), 16);
            this.blue = parseInt(temp.substring(4, 6), 16);
          }
        } else if (/^rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i.test(text)) {
          this.type = "color";
          this.red = +RegExp.$1;
          this.green = +RegExp.$2;
          this.blue = +RegExp.$3;
        } else if (/^rgb\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)) {
          this.type = "color";
          this.red = +RegExp.$1 * 255 / 100;
          this.green = +RegExp.$2 * 255 / 100;
          this.blue = +RegExp.$3 * 255 / 100;
        } else if (/^rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d\.]+)\s*\)/i.test(text)) {
          this.type = "color";
          this.red = +RegExp.$1;
          this.green = +RegExp.$2;
          this.blue = +RegExp.$3;
          this.alpha = +RegExp.$4;
        } else if (/^rgba\(\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d\.]+)\s*\)/i.test(text)) {
          this.type = "color";
          this.red = +RegExp.$1 * 255 / 100;
          this.green = +RegExp.$2 * 255 / 100;
          this.blue = +RegExp.$3 * 255 / 100;
          this.alpha = +RegExp.$4;
        } else if (/^hsl\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i.test(text)) {
          this.type = "color";
          this.hue = +RegExp.$1;
          this.saturation = +RegExp.$2 / 100;
          this.lightness = +RegExp.$3 / 100;
        } else if (/^hsla\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d\.]+)\s*\)/i.test(text)) {
          this.type = "color";
          this.hue = +RegExp.$1;
          this.saturation = +RegExp.$2 / 100;
          this.lightness = +RegExp.$3 / 100;
          this.alpha = +RegExp.$4;
        } else if (/^url\(["']?([^\)"']+)["']?\)/i.test(text)) {
          this.type = "uri";
          this.uri = RegExp.$1;
        } else if (/^([^\(]+)\(/i.test(text)) {
          this.type = "function";
          this.name = RegExp.$1;
          this.value = text;
        } else if (/^"([^\n\r\f\\"]|\\\r\n|\\[^\r0-9a-f]|\\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)*"/i.test(text)) {
          this.type = "string";
          this.value = PropertyValuePart.parseString(text);
        } else if (/^'([^\n\r\f\\']|\\\r\n|\\[^\r0-9a-f]|\\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)*'/i.test(text)) {
          this.type = "string";
          this.value = PropertyValuePart.parseString(text);
        } else if (Colors[text.toLowerCase()]) {
          this.type = "color";
          temp = Colors[text.toLowerCase()].substring(1);
          this.red = parseInt(temp.substring(0, 2), 16);
          this.green = parseInt(temp.substring(2, 4), 16);
          this.blue = parseInt(temp.substring(4, 6), 16);
        } else if (/^[\,\/]$/.test(text)) {
          this.type = "operator";
          this.value = text;
        } else if (/^[a-z\-_\u0080-\uFFFF][a-z0-9\-_\u0080-\uFFFF]*$/i.test(text)) {
          this.type = "identifier";
          this.value = text;
        }
      }
      PropertyValuePart.prototype = new SyntaxUnit();
      PropertyValuePart.prototype.constructor = PropertyValuePart;
      PropertyValuePart.parseString = function(str) {
        str = str.slice(1, -1);
        var replacer = function(match, esc) {
          if (/^(\n|\r\n|\r|\f)$/.test(esc)) {
            return "";
          }
          var m = /^[0-9a-f]{1,6}/i.exec(esc);
          if (m) {
            var codePoint = parseInt(m[0], 16);
            if (String.fromCodePoint) {
              return String.fromCodePoint(codePoint);
            } else {
              return String.fromCharCode(codePoint);
            }
          }
          return esc;
        };
        return str.replace(
          /\\(\r\n|[^\r0-9a-f]|[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?)/ig,
          replacer
        );
      };
      PropertyValuePart.serializeString = function(value) {
        var replacer = function(match, c) {
          if (c === '"') {
            return "\\" + c;
          }
          var cp = String.codePointAt ? String.codePointAt(0) : (
            // We only escape non-surrogate chars, so using charCodeAt
            // is harmless here.
            String.charCodeAt(0)
          );
          return "\\" + cp.toString(16) + " ";
        };
        return '"' + value.replace(/["\r\n\f]/g, replacer) + '"';
      };
      PropertyValuePart.fromToken = function(token) {
        return new PropertyValuePart(token.value, token.startLine, token.startCol);
      };
      var Pseudos = {
        __proto__: null,
        ":first-letter": 1,
        ":first-line": 1,
        ":before": 1,
        ":after": 1
      };
      Pseudos.ELEMENT = 1;
      Pseudos.CLASS = 2;
      Pseudos.isElement = function(pseudo) {
        return pseudo.indexOf("::") === 0 || Pseudos[pseudo.toLowerCase()] === Pseudos.ELEMENT;
      };
      function Selector(parts, line, col) {
        SyntaxUnit.call(this, parts.join(" "), line, col, Parser.SELECTOR_TYPE);
        this.parts = parts;
        this.specificity = Specificity.calculate(this);
      }
      Selector.prototype = new SyntaxUnit();
      Selector.prototype.constructor = Selector;
      function SelectorPart(elementName, modifiers, text, line, col) {
        SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_PART_TYPE);
        this.elementName = elementName;
        this.modifiers = modifiers;
      }
      SelectorPart.prototype = new SyntaxUnit();
      SelectorPart.prototype.constructor = SelectorPart;
      function SelectorSubPart(text, type, line, col) {
        SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_SUB_PART_TYPE);
        this.type = type;
        this.args = [];
      }
      SelectorSubPart.prototype = new SyntaxUnit();
      SelectorSubPart.prototype.constructor = SelectorSubPart;
      function Specificity(a, b, c, d) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
      }
      Specificity.prototype = {
        constructor: Specificity,
        /**
         * Compare this specificity to another.
         * @param {Specificity} other The other specificity to compare to.
         * @return {int} -1 if the other specificity is larger, 1 if smaller, 0 if equal.
         * @method compare
         */
        compare: function(other) {
          var comps = ["a", "b", "c", "d"], i, len;
          for (i = 0, len = comps.length; i < len; i++) {
            if (this[comps[i]] < other[comps[i]]) {
              return -1;
            } else if (this[comps[i]] > other[comps[i]]) {
              return 1;
            }
          }
          return 0;
        },
        /**
         * Creates a numeric value for the specificity.
         * @return {int} The numeric value for the specificity.
         * @method valueOf
         */
        valueOf: function() {
          return this.a * 1e3 + this.b * 100 + this.c * 10 + this.d;
        },
        /**
         * Returns a string representation for specificity.
         * @return {String} The string representation of specificity.
         * @method toString
         */
        toString: function() {
          return this.a + "," + this.b + "," + this.c + "," + this.d;
        }
      };
      Specificity.calculate = function(selector) {
        var i, len, part, b = 0, c = 0, d = 0;
        function updateValues(part2) {
          var i2, j, len2, num, elementName = part2.elementName ? part2.elementName.text : "", modifier;
          if (elementName && elementName.charAt(elementName.length - 1) !== "*") {
            d++;
          }
          for (i2 = 0, len2 = part2.modifiers.length; i2 < len2; i2++) {
            modifier = part2.modifiers[i2];
            switch (modifier.type) {
              case "class":
              case "attribute":
                c++;
                break;
              case "id":
                b++;
                break;
              case "pseudo":
                if (Pseudos.isElement(modifier.text)) {
                  d++;
                } else {
                  c++;
                }
                break;
              case "not":
                for (j = 0, num = modifier.args.length; j < num; j++) {
                  updateValues(modifier.args[j]);
                }
            }
          }
        }
        for (i = 0, len = selector.parts.length; i < len; i++) {
          part = selector.parts[i];
          if (part instanceof SelectorPart) {
            updateValues(part);
          }
        }
        return new Specificity(0, b, c, d);
      };
      var h = /^[0-9a-fA-F]$/, nl = /\n|\r\n|\r|\f/;
      function isHexDigit(c) {
        return c !== null && h.test(c);
      }
      function isDigit(c) {
        return c !== null && /\d/.test(c);
      }
      function isWhitespace(c) {
        return c !== null && /\s/.test(c);
      }
      function isNewLine(c) {
        return c !== null && nl.test(c);
      }
      function isNameStart(c) {
        return c !== null && /[a-z_\u0080-\uFFFF\\]/i.test(c);
      }
      function isNameChar(c) {
        return c !== null && (isNameStart(c) || /[0-9\-\\]/.test(c));
      }
      function isIdentStart(c) {
        return c !== null && (isNameStart(c) || /\-\\/.test(c));
      }
      function mix(receiver, supplier) {
        for (var prop in supplier) {
          if (Object.prototype.hasOwnProperty.call(supplier, prop)) {
            receiver[prop] = supplier[prop];
          }
        }
        return receiver;
      }
      function TokenStream(input) {
        TokenStreamBase.call(this, input, Tokens);
      }
      TokenStream.prototype = mix(new TokenStreamBase(), {
        /**
         * Overrides the TokenStreamBase method of the same name
         * to produce CSS tokens.
         * @param {variant} channel The name of the channel to use
         *      for the next token.
         * @return {Object} A token object representing the next token.
         * @method _getToken
         * @private
         */
        _getToken: function(channel) {
          var c, reader = this._reader, token = null, startLine = reader.getLine(), startCol = reader.getCol();
          c = reader.read();
          while (c) {
            switch (c) {
              /*
               * Potential tokens:
               * - COMMENT
               * - SLASH
               * - CHAR
               */
              case "/":
                if (reader.peek() === "*") {
                  token = this.commentToken(c, startLine, startCol);
                } else {
                  token = this.charToken(c, startLine, startCol);
                }
                break;
              /*
               * Potential tokens:
               * - DASHMATCH
               * - INCLUDES
               * - PREFIXMATCH
               * - SUFFIXMATCH
               * - SUBSTRINGMATCH
               * - CHAR
               */
              case "|":
              case "~":
              case "^":
              case "$":
              case "*":
                if (reader.peek() === "=") {
                  token = this.comparisonToken(c, startLine, startCol);
                } else {
                  token = this.charToken(c, startLine, startCol);
                }
                break;
              /*
               * Potential tokens:
               * - STRING
               * - INVALID
               */
              case '"':
              case "'":
                token = this.stringToken(c, startLine, startCol);
                break;
              /*
               * Potential tokens:
               * - HASH
               * - CHAR
               */
              case "#":
                if (isNameChar(reader.peek())) {
                  token = this.hashToken(c, startLine, startCol);
                } else {
                  token = this.charToken(c, startLine, startCol);
                }
                break;
              /*
               * Potential tokens:
               * - DOT
               * - NUMBER
               * - DIMENSION
               * - PERCENTAGE
               */
              case ".":
                if (isDigit(reader.peek())) {
                  token = this.numberToken(c, startLine, startCol);
                } else {
                  token = this.charToken(c, startLine, startCol);
                }
                break;
              /*
               * Potential tokens:
               * - CDC
               * - MINUS
               * - NUMBER
               * - DIMENSION
               * - PERCENTAGE
               */
              case "-":
                if (reader.peek() === "-") {
                  token = this.htmlCommentEndToken(c, startLine, startCol);
                } else if (isNameStart(reader.peek())) {
                  token = this.identOrFunctionToken(c, startLine, startCol);
                } else {
                  token = this.charToken(c, startLine, startCol);
                }
                break;
              /*
               * Potential tokens:
               * - IMPORTANT_SYM
               * - CHAR
               */
              case "!":
                token = this.importantToken(c, startLine, startCol);
                break;
              /*
               * Any at-keyword or CHAR
               */
              case "@":
                token = this.atRuleToken(c, startLine, startCol);
                break;
              /*
               * Potential tokens:
               * - NOT
               * - CHAR
               */
              case ":":
                token = this.notToken(c, startLine, startCol);
                break;
              /*
               * Potential tokens:
               * - CDO
               * - CHAR
               */
              case "<":
                token = this.htmlCommentStartToken(c, startLine, startCol);
                break;
              /*
               * Potential tokens:
               * - UNICODE_RANGE
               * - URL
               * - CHAR
               */
              case "U":
              case "u":
                if (reader.peek() === "+") {
                  token = this.unicodeRangeToken(c, startLine, startCol);
                  break;
                }
              /* falls through */
              default:
                if (isDigit(c)) {
                  token = this.numberToken(c, startLine, startCol);
                } else if (isWhitespace(c)) {
                  token = this.whitespaceToken(c, startLine, startCol);
                } else if (isIdentStart(c)) {
                  token = this.identOrFunctionToken(c, startLine, startCol);
                } else {
                  token = this.charToken(c, startLine, startCol);
                }
            }
            break;
          }
          if (!token && c === null) {
            token = this.createToken(Tokens.EOF, null, startLine, startCol);
          }
          return token;
        },
        //-------------------------------------------------------------------------
        // Methods to create tokens
        //-------------------------------------------------------------------------
        /**
         * Produces a token based on available data and the current
         * reader position information. This method is called by other
         * private methods to create tokens and is never called directly.
         * @param {int} tt The token type.
         * @param {String} value The text value of the token.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @param {Object} options (Optional) Specifies a channel property
         *      to indicate that a different channel should be scanned
         *      and/or a hide property indicating that the token should
         *      be hidden.
         * @return {Object} A token object.
         * @method createToken
         */
        createToken: function(tt, value, startLine, startCol, options) {
          var reader = this._reader;
          options = options || {};
          return {
            value,
            type: tt,
            channel: options.channel,
            endChar: options.endChar,
            hide: options.hide || false,
            startLine,
            startCol,
            endLine: reader.getLine(),
            endCol: reader.getCol()
          };
        },
        //-------------------------------------------------------------------------
        // Methods to create specific tokens
        //-------------------------------------------------------------------------
        /**
         * Produces a token for any at-rule. If the at-rule is unknown, then
         * the token is for a single "@" character.
         * @param {String} first The first character for the token.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @return {Object} A token object.
         * @method atRuleToken
         */
        atRuleToken: function(first, startLine, startCol) {
          var rule = first, reader = this._reader, tt = Tokens.CHAR, ident;
          reader.mark();
          ident = this.readName();
          rule = first + ident;
          tt = Tokens.type(rule.toLowerCase());
          if (tt === Tokens.CHAR || tt === Tokens.UNKNOWN) {
            if (rule.length > 1) {
              tt = Tokens.UNKNOWN_SYM;
            } else {
              tt = Tokens.CHAR;
              rule = first;
              reader.reset();
            }
          }
          return this.createToken(tt, rule, startLine, startCol);
        },
        /**
         * Produces a character token based on the given character
         * and location in the stream. If there's a special (non-standard)
         * token name, this is used; otherwise CHAR is used.
         * @param {String} c The character for the token.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @return {Object} A token object.
         * @method charToken
         */
        charToken: function(c, startLine, startCol) {
          var tt = Tokens.type(c);
          var opts = {};
          if (tt === -1) {
            tt = Tokens.CHAR;
          } else {
            opts.endChar = Tokens[tt].endChar;
          }
          return this.createToken(tt, c, startLine, startCol, opts);
        },
        /**
         * Produces a character token based on the given character
         * and location in the stream. If there's a special (non-standard)
         * token name, this is used; otherwise CHAR is used.
         * @param {String} first The first character for the token.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @return {Object} A token object.
         * @method commentToken
         */
        commentToken: function(first, startLine, startCol) {
          var comment = this.readComment(first);
          return this.createToken(Tokens.COMMENT, comment, startLine, startCol);
        },
        /**
         * Produces a comparison token based on the given character
         * and location in the stream. The next character must be
         * read and is already known to be an equals sign.
         * @param {String} c The character for the token.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @return {Object} A token object.
         * @method comparisonToken
         */
        comparisonToken: function(c, startLine, startCol) {
          var reader = this._reader, comparison = c + reader.read(), tt = Tokens.type(comparison) || Tokens.CHAR;
          return this.createToken(tt, comparison, startLine, startCol);
        },
        /**
         * Produces a hash token based on the specified information. The
         * first character provided is the pound sign (#) and then this
         * method reads a name afterward.
         * @param {String} first The first character (#) in the hash name.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @return {Object} A token object.
         * @method hashToken
         */
        hashToken: function(first, startLine, startCol) {
          var name = this.readName(first);
          return this.createToken(Tokens.HASH, name, startLine, startCol);
        },
        /**
         * Produces a CDO or CHAR token based on the specified information. The
         * first character is provided and the rest is read by the function to determine
         * the correct token to create.
         * @param {String} first The first character in the token.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @return {Object} A token object.
         * @method htmlCommentStartToken
         */
        htmlCommentStartToken: function(first, startLine, startCol) {
          var reader = this._reader, text = first;
          reader.mark();
          text += reader.readCount(3);
          if (text === "<!--") {
            return this.createToken(Tokens.CDO, text, startLine, startCol);
          } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
          }
        },
        /**
         * Produces a CDC or CHAR token based on the specified information. The
         * first character is provided and the rest is read by the function to determine
         * the correct token to create.
         * @param {String} first The first character in the token.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @return {Object} A token object.
         * @method htmlCommentEndToken
         */
        htmlCommentEndToken: function(first, startLine, startCol) {
          var reader = this._reader, text = first;
          reader.mark();
          text += reader.readCount(2);
          if (text === "-->") {
            return this.createToken(Tokens.CDC, text, startLine, startCol);
          } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
          }
        },
        /**
         * Produces an IDENT or FUNCTION token based on the specified information. The
         * first character is provided and the rest is read by the function to determine
         * the correct token to create.
         * @param {String} first The first character in the identifier.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @return {Object} A token object.
         * @method identOrFunctionToken
         */
        identOrFunctionToken: function(first, startLine, startCol) {
          var reader = this._reader, ident = this.readName(first), tt = Tokens.IDENT, uriFns = ["url(", "url-prefix(", "domain("];
          if (reader.peek() === "(") {
            ident += reader.read();
            if (uriFns.indexOf(ident.toLowerCase()) > -1) {
              tt = Tokens.URI;
              ident = this.readURI(ident);
              if (uriFns.indexOf(ident.toLowerCase()) > -1) {
                tt = Tokens.FUNCTION;
              }
            } else {
              tt = Tokens.FUNCTION;
            }
          } else if (reader.peek() === ":") {
            if (ident.toLowerCase() === "progid") {
              ident += reader.readTo("(");
              tt = Tokens.IE_FUNCTION;
            }
          }
          return this.createToken(tt, ident, startLine, startCol);
        },
        /**
         * Produces an IMPORTANT_SYM or CHAR token based on the specified information. The
         * first character is provided and the rest is read by the function to determine
         * the correct token to create.
         * @param {String} first The first character in the token.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @return {Object} A token object.
         * @method importantToken
         */
        importantToken: function(first, startLine, startCol) {
          var reader = this._reader, important = first, tt = Tokens.CHAR, temp, c;
          reader.mark();
          c = reader.read();
          while (c) {
            if (c === "/") {
              if (reader.peek() !== "*") {
                break;
              } else {
                temp = this.readComment(c);
                if (temp === "") {
                  break;
                }
              }
            } else if (isWhitespace(c)) {
              important += c + this.readWhitespace();
            } else if (/i/i.test(c)) {
              temp = reader.readCount(8);
              if (/mportant/i.test(temp)) {
                important += c + temp;
                tt = Tokens.IMPORTANT_SYM;
              }
              break;
            } else {
              break;
            }
            c = reader.read();
          }
          if (tt === Tokens.CHAR) {
            reader.reset();
            return this.charToken(first, startLine, startCol);
          } else {
            return this.createToken(tt, important, startLine, startCol);
          }
        },
        /**
         * Produces a NOT or CHAR token based on the specified information. The
         * first character is provided and the rest is read by the function to determine
         * the correct token to create.
         * @param {String} first The first character in the token.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @return {Object} A token object.
         * @method notToken
         */
        notToken: function(first, startLine, startCol) {
          var reader = this._reader, text = first;
          reader.mark();
          text += reader.readCount(4);
          if (text.toLowerCase() === ":not(") {
            return this.createToken(Tokens.NOT, text, startLine, startCol);
          } else {
            reader.reset();
            return this.charToken(first, startLine, startCol);
          }
        },
        /**
         * Produces a number token based on the given character
         * and location in the stream. This may return a token of
         * NUMBER, EMS, EXS, LENGTH, ANGLE, TIME, FREQ, DIMENSION,
         * or PERCENTAGE.
         * @param {String} first The first character for the token.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @return {Object} A token object.
         * @method numberToken
         */
        numberToken: function(first, startLine, startCol) {
          var reader = this._reader, value = this.readNumber(first), ident, tt = Tokens.NUMBER, c = reader.peek();
          if (isIdentStart(c)) {
            ident = this.readName(reader.read());
            value += ident;
            if (/^em$|^ex$|^px$|^gd$|^rem$|^vw$|^vh$|^vmax$|^vmin$|^ch$|^cm$|^mm$|^in$|^pt$|^pc$/i.test(ident)) {
              tt = Tokens.LENGTH;
            } else if (/^deg|^rad$|^grad$/i.test(ident)) {
              tt = Tokens.ANGLE;
            } else if (/^ms$|^s$/i.test(ident)) {
              tt = Tokens.TIME;
            } else if (/^hz$|^khz$/i.test(ident)) {
              tt = Tokens.FREQ;
            } else if (/^dpi$|^dpcm$/i.test(ident)) {
              tt = Tokens.RESOLUTION;
            } else {
              tt = Tokens.DIMENSION;
            }
          } else if (c === "%") {
            value += reader.read();
            tt = Tokens.PERCENTAGE;
          }
          return this.createToken(tt, value, startLine, startCol);
        },
        /**
         * Produces a string token based on the given character
         * and location in the stream. Since strings may be indicated
         * by single or double quotes, a failure to match starting
         * and ending quotes results in an INVALID token being generated.
         * The first character in the string is passed in and then
         * the rest are read up to and including the final quotation mark.
         * @param {String} first The first character in the string.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @return {Object} A token object.
         * @method stringToken
         */
        stringToken: function(first, startLine, startCol) {
          var delim = first, string = first, reader = this._reader, prev = first, tt = Tokens.STRING, c = reader.read();
          while (c) {
            string += c;
            if (c === delim && prev !== "\\") {
              break;
            }
            if (isNewLine(reader.peek()) && c !== "\\") {
              tt = Tokens.INVALID;
              break;
            }
            prev = c;
            c = reader.read();
          }
          if (c === null) {
            tt = Tokens.INVALID;
          }
          return this.createToken(tt, string, startLine, startCol);
        },
        unicodeRangeToken: function(first, startLine, startCol) {
          var reader = this._reader, value = first, temp, tt = Tokens.CHAR;
          if (reader.peek() === "+") {
            reader.mark();
            value += reader.read();
            value += this.readUnicodeRangePart(true);
            if (value.length === 2) {
              reader.reset();
            } else {
              tt = Tokens.UNICODE_RANGE;
              if (value.indexOf("?") === -1) {
                if (reader.peek() === "-") {
                  reader.mark();
                  temp = reader.read();
                  temp += this.readUnicodeRangePart(false);
                  if (temp.length === 1) {
                    reader.reset();
                  } else {
                    value += temp;
                  }
                }
              }
            }
          }
          return this.createToken(tt, value, startLine, startCol);
        },
        /**
         * Produces a S token based on the specified information. Since whitespace
         * may have multiple characters, this consumes all whitespace characters
         * into a single token.
         * @param {String} first The first character in the token.
         * @param {int} startLine The beginning line for the character.
         * @param {int} startCol The beginning column for the character.
         * @return {Object} A token object.
         * @method whitespaceToken
         */
        whitespaceToken: function(first, startLine, startCol) {
          var value = first + this.readWhitespace();
          return this.createToken(Tokens.S, value, startLine, startCol);
        },
        //-------------------------------------------------------------------------
        // Methods to read values from the string stream
        //-------------------------------------------------------------------------
        readUnicodeRangePart: function(allowQuestionMark) {
          var reader = this._reader, part = "", c = reader.peek();
          while (isHexDigit(c) && part.length < 6) {
            reader.read();
            part += c;
            c = reader.peek();
          }
          if (allowQuestionMark) {
            while (c === "?" && part.length < 6) {
              reader.read();
              part += c;
              c = reader.peek();
            }
          }
          return part;
        },
        readWhitespace: function() {
          var reader = this._reader, whitespace = "", c = reader.peek();
          while (isWhitespace(c)) {
            reader.read();
            whitespace += c;
            c = reader.peek();
          }
          return whitespace;
        },
        readNumber: function(first) {
          var reader = this._reader, number = first, hasDot = first === ".", c = reader.peek();
          while (c) {
            if (isDigit(c)) {
              number += reader.read();
            } else if (c === ".") {
              if (hasDot) {
                break;
              } else {
                hasDot = true;
                number += reader.read();
              }
            } else {
              break;
            }
            c = reader.peek();
          }
          return number;
        },
        readString: function() {
          var reader = this._reader, delim = reader.read(), string = delim, prev = delim, c = reader.peek();
          while (c) {
            c = reader.read();
            string += c;
            if (c === delim && prev !== "\\") {
              break;
            }
            if (isNewLine(reader.peek()) && c !== "\\") {
              string = "";
              break;
            }
            prev = c;
            c = reader.peek();
          }
          if (c === null) {
            string = "";
          }
          return string;
        },
        readURI: function(first) {
          var reader = this._reader, uri = first, inner = "", c = reader.peek();
          reader.mark();
          while (c && isWhitespace(c)) {
            reader.read();
            c = reader.peek();
          }
          if (c === "'" || c === '"') {
            inner = this.readString();
          } else {
            inner = this.readURL();
          }
          c = reader.peek();
          while (c && isWhitespace(c)) {
            reader.read();
            c = reader.peek();
          }
          if (inner === "" || c !== ")") {
            uri = first;
            reader.reset();
          } else {
            uri += inner + reader.read();
          }
          return uri;
        },
        readURL: function() {
          var reader = this._reader, url = "", c = reader.peek();
          while (/^[!#$%&\\*-~]$/.test(c)) {
            url += reader.read();
            c = reader.peek();
          }
          return url;
        },
        readName: function(first) {
          var reader = this._reader, ident = first || "", c = reader.peek();
          while (true) {
            if (c === "\\") {
              ident += this.readEscape(reader.read());
              c = reader.peek();
            } else if (c && isNameChar(c)) {
              ident += reader.read();
              c = reader.peek();
            } else {
              break;
            }
          }
          return ident;
        },
        readEscape: function(first) {
          var reader = this._reader, cssEscape = first || "", i = 0, c = reader.peek();
          if (isHexDigit(c)) {
            do {
              cssEscape += reader.read();
              c = reader.peek();
            } while (c && isHexDigit(c) && ++i < 6);
          }
          if (cssEscape.length === 3 && /\s/.test(c) || cssEscape.length === 7 || cssEscape.length === 1) {
            reader.read();
          } else {
            c = "";
          }
          return cssEscape + c;
        },
        readComment: function(first) {
          var reader = this._reader, comment = first || "", c = reader.read();
          if (c === "*") {
            while (c) {
              comment += c;
              if (comment.length > 2 && c === "*" && reader.peek() === "/") {
                comment += reader.read();
                break;
              }
              c = reader.read();
            }
            return comment;
          } else {
            return "";
          }
        }
      });
      var Tokens = [
        /*
         * The following token names are defined in CSS3 Grammar: http://www.w3.org/TR/css3-syntax/#lexical
         */
        //HTML-style comments
        { name: "CDO" },
        { name: "CDC" },
        //ignorables
        {
          name: "S",
          whitespace: true
          /*, channel: "ws"*/
        },
        { name: "COMMENT", comment: true, hide: true, channel: "comment" },
        //attribute equality
        { name: "INCLUDES", text: "~=" },
        { name: "DASHMATCH", text: "|=" },
        { name: "PREFIXMATCH", text: "^=" },
        { name: "SUFFIXMATCH", text: "$=" },
        { name: "SUBSTRINGMATCH", text: "*=" },
        //identifier types
        { name: "STRING" },
        { name: "IDENT" },
        { name: "HASH" },
        //at-keywords
        { name: "IMPORT_SYM", text: "@import" },
        { name: "PAGE_SYM", text: "@page" },
        { name: "MEDIA_SYM", text: "@media" },
        { name: "FONT_FACE_SYM", text: "@font-face" },
        { name: "CHARSET_SYM", text: "@charset" },
        { name: "NAMESPACE_SYM", text: "@namespace" },
        { name: "VIEWPORT_SYM", text: ["@viewport", "@-ms-viewport", "@-o-viewport"] },
        { name: "DOCUMENT_SYM", text: ["@document", "@-moz-document"] },
        { name: "UNKNOWN_SYM" },
        //{ name: "ATKEYWORD"},
        //CSS3 animations
        { name: "KEYFRAMES_SYM", text: ["@keyframes", "@-webkit-keyframes", "@-moz-keyframes", "@-o-keyframes"] },
        //important symbol
        { name: "IMPORTANT_SYM" },
        //measurements
        { name: "LENGTH" },
        { name: "ANGLE" },
        { name: "TIME" },
        { name: "FREQ" },
        { name: "DIMENSION" },
        { name: "PERCENTAGE" },
        { name: "NUMBER" },
        //functions
        { name: "URI" },
        { name: "FUNCTION" },
        //Unicode ranges
        { name: "UNICODE_RANGE" },
        /*
         * The following token names are defined in CSS3 Selectors: http://www.w3.org/TR/css3-selectors/#selector-syntax
         */
        //invalid string
        { name: "INVALID" },
        //combinators
        { name: "PLUS", text: "+" },
        { name: "GREATER", text: ">" },
        { name: "COMMA", text: "," },
        { name: "TILDE", text: "~" },
        //modifier
        { name: "NOT" },
        /*
         * Defined in CSS3 Paged Media
         */
        { name: "TOPLEFTCORNER_SYM", text: "@top-left-corner" },
        { name: "TOPLEFT_SYM", text: "@top-left" },
        { name: "TOPCENTER_SYM", text: "@top-center" },
        { name: "TOPRIGHT_SYM", text: "@top-right" },
        { name: "TOPRIGHTCORNER_SYM", text: "@top-right-corner" },
        { name: "BOTTOMLEFTCORNER_SYM", text: "@bottom-left-corner" },
        { name: "BOTTOMLEFT_SYM", text: "@bottom-left" },
        { name: "BOTTOMCENTER_SYM", text: "@bottom-center" },
        { name: "BOTTOMRIGHT_SYM", text: "@bottom-right" },
        { name: "BOTTOMRIGHTCORNER_SYM", text: "@bottom-right-corner" },
        { name: "LEFTTOP_SYM", text: "@left-top" },
        { name: "LEFTMIDDLE_SYM", text: "@left-middle" },
        { name: "LEFTBOTTOM_SYM", text: "@left-bottom" },
        { name: "RIGHTTOP_SYM", text: "@right-top" },
        { name: "RIGHTMIDDLE_SYM", text: "@right-middle" },
        { name: "RIGHTBOTTOM_SYM", text: "@right-bottom" },
        /*
         * The following token names are defined in CSS3 Media Queries: http://www.w3.org/TR/css3-mediaqueries/#syntax
         */
        /*{ name: "MEDIA_ONLY", state: "media"},
        { name: "MEDIA_NOT", state: "media"},
        { name: "MEDIA_AND", state: "media"},*/
        { name: "RESOLUTION", state: "media" },
        /*
         * The following token names are not defined in any CSS specification but are used by the lexer.
         */
        //not a real token, but useful for stupid IE filters
        { name: "IE_FUNCTION" },
        //part of CSS3 grammar but not the Flex code
        { name: "CHAR" },
        //TODO: Needed?
        //Not defined as tokens, but might as well be
        {
          name: "PIPE",
          text: "|"
        },
        {
          name: "SLASH",
          text: "/"
        },
        {
          name: "MINUS",
          text: "-"
        },
        {
          name: "STAR",
          text: "*"
        },
        {
          name: "LBRACE",
          endChar: "}",
          text: "{"
        },
        {
          name: "RBRACE",
          text: "}"
        },
        {
          name: "LBRACKET",
          endChar: "]",
          text: "["
        },
        {
          name: "RBRACKET",
          text: "]"
        },
        {
          name: "EQUALS",
          text: "="
        },
        {
          name: "COLON",
          text: ":"
        },
        {
          name: "SEMICOLON",
          text: ";"
        },
        {
          name: "LPAREN",
          endChar: ")",
          text: "("
        },
        {
          name: "RPAREN",
          text: ")"
        },
        {
          name: "DOT",
          text: "."
        }
      ];
      (function() {
        var nameMap = [], typeMap = /* @__PURE__ */ Object.create(null);
        Tokens.UNKNOWN = -1;
        Tokens.unshift({ name: "EOF" });
        for (var i = 0, len = Tokens.length; i < len; i++) {
          nameMap.push(Tokens[i].name);
          Tokens[Tokens[i].name] = i;
          if (Tokens[i].text) {
            if (Tokens[i].text instanceof Array) {
              for (var j = 0; j < Tokens[i].text.length; j++) {
                typeMap[Tokens[i].text[j]] = i;
              }
            } else {
              typeMap[Tokens[i].text] = i;
            }
          }
        }
        Tokens.name = function(tt) {
          return nameMap[tt];
        };
        Tokens.type = function(c) {
          return typeMap[c] || -1;
        };
      })();
      var Validation = {
        validate: function(property, value) {
          var name = property.toString().toLowerCase(), expression = new PropertyValueIterator(value), spec = Properties[name];
          if (!spec) {
            if (name.indexOf("-") !== 0) {
              throw new ValidationError("Unknown property '" + property + "'.", property.line, property.col);
            }
          } else if (typeof spec !== "number") {
            if (typeof spec === "string") {
              if (spec.indexOf("||") > -1) {
                this.groupProperty(spec, expression);
              } else {
                this.singleProperty(spec, expression, 1);
              }
            } else if (spec.multi) {
              this.multiProperty(spec.multi, expression, spec.comma, spec.max || Infinity);
            } else if (typeof spec === "function") {
              spec(expression);
            }
          }
        },
        singleProperty: function(types, expression, max, partial) {
          var result2 = false, value = expression.value, count2 = 0, part;
          while (expression.hasNext() && count2 < max) {
            result2 = ValidationTypes.isAny(expression, types);
            if (!result2) {
              break;
            }
            count2++;
          }
          if (!result2) {
            if (expression.hasNext() && !expression.isFirst()) {
              part = expression.peek();
              throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
              throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
            }
          } else if (expression.hasNext()) {
            part = expression.next();
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
          }
        },
        multiProperty: function(types, expression, comma, max) {
          var result2 = false, value = expression.value, count2 = 0, part;
          while (expression.hasNext() && !result2 && count2 < max) {
            if (ValidationTypes.isAny(expression, types)) {
              count2++;
              if (!expression.hasNext()) {
                result2 = true;
              } else if (comma) {
                if (String(expression.peek()) === ",") {
                  part = expression.next();
                } else {
                  break;
                }
              }
            } else {
              break;
            }
          }
          if (!result2) {
            if (expression.hasNext() && !expression.isFirst()) {
              part = expression.peek();
              throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
              part = expression.previous();
              if (comma && String(part) === ",") {
                throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
              } else {
                throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
              }
            }
          } else if (expression.hasNext()) {
            part = expression.next();
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
          }
        },
        groupProperty: function(types, expression, comma) {
          var result2 = false, value = expression.value, typeCount = types.split("||").length, groups = { count: 0 }, partial = false, name, part;
          while (expression.hasNext() && !result2) {
            name = ValidationTypes.isAnyOfGroup(expression, types);
            if (name) {
              if (groups[name]) {
                break;
              } else {
                groups[name] = 1;
                groups.count++;
                partial = true;
                if (groups.count === typeCount || !expression.hasNext()) {
                  result2 = true;
                }
              }
            } else {
              break;
            }
          }
          if (!result2) {
            if (partial && expression.hasNext()) {
              part = expression.peek();
              throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
            } else {
              throw new ValidationError("Expected (" + types + ") but found '" + value + "'.", value.line, value.col);
            }
          } else if (expression.hasNext()) {
            part = expression.next();
            throw new ValidationError("Expected end of value but found '" + part + "'.", part.line, part.col);
          }
        }
      };
      function ValidationError(message, line, col) {
        this.col = col;
        this.line = line;
        this.message = message;
      }
      ValidationError.prototype = new Error();
      var ValidationTypes = {
        isLiteral: function(part, literals) {
          var text = part.text.toString().toLowerCase(), args = literals.split(" | "), i, len, found = false;
          for (i = 0, len = args.length; i < len && !found; i++) {
            if (text === args[i].toLowerCase()) {
              found = true;
            }
          }
          return found;
        },
        isSimple: function(type) {
          return !!this.simple[type];
        },
        isComplex: function(type) {
          return !!this.complex[type];
        },
        /**
         * Determines if the next part(s) of the given expression
         * are any of the given types.
         */
        isAny: function(expression, types) {
          var args = types.split(" | "), i, len, found = false;
          for (i = 0, len = args.length; i < len && !found && expression.hasNext(); i++) {
            found = this.isType(expression, args[i]);
          }
          return found;
        },
        /**
         * Determines if the next part(s) of the given expression
         * are one of a group.
         */
        isAnyOfGroup: function(expression, types) {
          var args = types.split(" || "), i, len, found = false;
          for (i = 0, len = args.length; i < len && !found; i++) {
            found = this.isType(expression, args[i]);
          }
          return found ? args[i - 1] : false;
        },
        /**
         * Determines if the next part(s) of the given expression
         * are of a given type.
         */
        isType: function(expression, type) {
          var part = expression.peek(), result2 = false;
          if (type.charAt(0) !== "<") {
            result2 = this.isLiteral(part, type);
            if (result2) {
              expression.next();
            }
          } else if (this.simple[type]) {
            result2 = this.simple[type](part);
            if (result2) {
              expression.next();
            }
          } else {
            result2 = this.complex[type](expression);
          }
          return result2;
        },
        simple: {
          __proto__: null,
          "<absolute-size>": function(part) {
            return ValidationTypes.isLiteral(part, "xx-small | x-small | small | medium | large | x-large | xx-large");
          },
          "<attachment>": function(part) {
            return ValidationTypes.isLiteral(part, "scroll | fixed | local");
          },
          "<attr>": function(part) {
            return part.type === "function" && part.name === "attr";
          },
          "<bg-image>": function(part) {
            return this["<image>"](part) || this["<gradient>"](part) || String(part) === "none";
          },
          "<gradient>": function(part) {
            return part.type === "function" && /^(?:\-(?:ms|moz|o|webkit)\-)?(?:repeating\-)?(?:radial\-|linear\-)?gradient/i.test(part);
          },
          "<box>": function(part) {
            return ValidationTypes.isLiteral(part, "padding-box | border-box | content-box");
          },
          "<content>": function(part) {
            return part.type === "function" && part.name === "content";
          },
          "<relative-size>": function(part) {
            return ValidationTypes.isLiteral(part, "smaller | larger");
          },
          //any identifier
          "<ident>": function(part) {
            return part.type === "identifier";
          },
          "<length>": function(part) {
            if (part.type === "function" && /^(?:\-(?:ms|moz|o|webkit)\-)?calc/i.test(part)) {
              return true;
            } else {
              return part.type === "length" || part.type === "number" || part.type === "integer" || String(part) === "0";
            }
          },
          "<color>": function(part) {
            return part.type === "color" || String(part) === "transparent" || String(part) === "currentColor";
          },
          "<number>": function(part) {
            return part.type === "number" || this["<integer>"](part);
          },
          "<integer>": function(part) {
            return part.type === "integer";
          },
          "<line>": function(part) {
            return part.type === "integer";
          },
          "<angle>": function(part) {
            return part.type === "angle";
          },
          "<uri>": function(part) {
            return part.type === "uri";
          },
          "<image>": function(part) {
            return this["<uri>"](part);
          },
          "<percentage>": function(part) {
            return part.type === "percentage" || String(part) === "0";
          },
          "<border-width>": function(part) {
            return this["<length>"](part) || ValidationTypes.isLiteral(part, "thin | medium | thick");
          },
          "<border-style>": function(part) {
            return ValidationTypes.isLiteral(part, "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset");
          },
          "<content-sizing>": function(part) {
            return ValidationTypes.isLiteral(part, "fill-available | -moz-available | -webkit-fill-available | max-content | -moz-max-content | -webkit-max-content | min-content | -moz-min-content | -webkit-min-content | fit-content | -moz-fit-content | -webkit-fit-content");
          },
          "<margin-width>": function(part) {
            return this["<length>"](part) || this["<percentage>"](part) || ValidationTypes.isLiteral(part, "auto");
          },
          "<padding-width>": function(part) {
            return this["<length>"](part) || this["<percentage>"](part);
          },
          "<shape>": function(part) {
            return part.type === "function" && (part.name === "rect" || part.name === "inset-rect");
          },
          "<time>": function(part) {
            return part.type === "time";
          },
          "<flex-grow>": function(part) {
            return this["<number>"](part);
          },
          "<flex-shrink>": function(part) {
            return this["<number>"](part);
          },
          "<width>": function(part) {
            return this["<margin-width>"](part);
          },
          "<flex-basis>": function(part) {
            return this["<width>"](part);
          },
          "<flex-direction>": function(part) {
            return ValidationTypes.isLiteral(part, "row | row-reverse | column | column-reverse");
          },
          "<flex-wrap>": function(part) {
            return ValidationTypes.isLiteral(part, "nowrap | wrap | wrap-reverse");
          },
          "<feature-tag-value>": function(part) {
            return part.type === "function" && /^[A-Z0-9]{4}$/i.test(part);
          }
        },
        complex: {
          __proto__: null,
          "<bg-position>": function(expression) {
            var result2 = false, numeric = "<percentage> | <length>", xDir = "left | right", yDir = "top | bottom", count2 = 0;
            while (expression.peek(count2) && expression.peek(count2).text !== ",") {
              count2++;
            }
            if (count2 < 3) {
              if (ValidationTypes.isAny(expression, xDir + " | center | " + numeric)) {
                result2 = true;
                ValidationTypes.isAny(expression, yDir + " | center | " + numeric);
              } else if (ValidationTypes.isAny(expression, yDir)) {
                result2 = true;
                ValidationTypes.isAny(expression, xDir + " | center");
              }
            } else {
              if (ValidationTypes.isAny(expression, xDir)) {
                if (ValidationTypes.isAny(expression, yDir)) {
                  result2 = true;
                  ValidationTypes.isAny(expression, numeric);
                } else if (ValidationTypes.isAny(expression, numeric)) {
                  if (ValidationTypes.isAny(expression, yDir)) {
                    result2 = true;
                    ValidationTypes.isAny(expression, numeric);
                  } else if (ValidationTypes.isAny(expression, "center")) {
                    result2 = true;
                  }
                }
              } else if (ValidationTypes.isAny(expression, yDir)) {
                if (ValidationTypes.isAny(expression, xDir)) {
                  result2 = true;
                  ValidationTypes.isAny(expression, numeric);
                } else if (ValidationTypes.isAny(expression, numeric)) {
                  if (ValidationTypes.isAny(expression, xDir)) {
                    result2 = true;
                    ValidationTypes.isAny(expression, numeric);
                  } else if (ValidationTypes.isAny(expression, "center")) {
                    result2 = true;
                  }
                }
              } else if (ValidationTypes.isAny(expression, "center")) {
                if (ValidationTypes.isAny(expression, xDir + " | " + yDir)) {
                  result2 = true;
                  ValidationTypes.isAny(expression, numeric);
                }
              }
            }
            return result2;
          },
          "<bg-size>": function(expression) {
            var result2 = false, numeric = "<percentage> | <length> | auto";
            if (ValidationTypes.isAny(expression, "cover | contain")) {
              result2 = true;
            } else if (ValidationTypes.isAny(expression, numeric)) {
              result2 = true;
              ValidationTypes.isAny(expression, numeric);
            }
            return result2;
          },
          "<repeat-style>": function(expression) {
            var result2 = false, values = "repeat | space | round | no-repeat", part;
            if (expression.hasNext()) {
              part = expression.next();
              if (ValidationTypes.isLiteral(part, "repeat-x | repeat-y")) {
                result2 = true;
              } else if (ValidationTypes.isLiteral(part, values)) {
                result2 = true;
                if (expression.hasNext() && ValidationTypes.isLiteral(expression.peek(), values)) {
                  expression.next();
                }
              }
            }
            return result2;
          },
          "<shadow>": function(expression) {
            var result2 = false, count2 = 0, inset = false, color = false;
            if (expression.hasNext()) {
              if (ValidationTypes.isAny(expression, "inset")) {
                inset = true;
              }
              if (ValidationTypes.isAny(expression, "<color>")) {
                color = true;
              }
              while (ValidationTypes.isAny(expression, "<length>") && count2 < 4) {
                count2++;
              }
              if (expression.hasNext()) {
                if (!color) {
                  ValidationTypes.isAny(expression, "<color>");
                }
                if (!inset) {
                  ValidationTypes.isAny(expression, "inset");
                }
              }
              result2 = count2 >= 2 && count2 <= 4;
            }
            return result2;
          },
          "<x-one-radius>": function(expression) {
            var result2 = false, simple = "<length> | <percentage> | inherit";
            if (ValidationTypes.isAny(expression, simple)) {
              result2 = true;
              ValidationTypes.isAny(expression, simple);
            }
            return result2;
          },
          "<flex>": function(expression) {
            var part, result2 = false;
            if (ValidationTypes.isAny(expression, "none | inherit")) {
              result2 = true;
            } else {
              if (ValidationTypes.isType(expression, "<flex-grow>")) {
                if (expression.peek()) {
                  if (ValidationTypes.isType(expression, "<flex-shrink>")) {
                    if (expression.peek()) {
                      result2 = ValidationTypes.isType(expression, "<flex-basis>");
                    } else {
                      result2 = true;
                    }
                  } else if (ValidationTypes.isType(expression, "<flex-basis>")) {
                    result2 = expression.peek() === null;
                  }
                } else {
                  result2 = true;
                }
              } else if (ValidationTypes.isType(expression, "<flex-basis>")) {
                result2 = true;
              }
            }
            if (!result2) {
              part = expression.peek();
              throw new ValidationError("Expected (none | [ <flex-grow> <flex-shrink>? || <flex-basis> ]) but found '" + expression.value.text + "'.", part.line, part.col);
            }
            return result2;
          }
        }
      };
      parserlib.css = {
        __proto__: null,
        Colors,
        Combinator,
        Parser,
        PropertyName,
        PropertyValue,
        PropertyValuePart,
        MediaFeature,
        MediaQuery,
        Selector,
        SelectorPart,
        SelectorSubPart,
        Specificity,
        TokenStream,
        Tokens,
        ValidationError
      };
    })();
    (function() {
      for (var prop in parserlib) {
        exports[prop] = parserlib[prop];
      }
    })();
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/CSSStyleDeclaration.js
var require_CSSStyleDeclaration = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/CSSStyleDeclaration.js"(exports, module) {
    "use strict";
    var parserlib = require_cssparser();
    module.exports = CSSStyleDeclaration;
    function CSSStyleDeclaration(elt) {
      this._element = elt;
    }
    function parseStyles(s) {
      var parser = new parserlib.css.Parser();
      var result2 = { property: /* @__PURE__ */ Object.create(null), priority: /* @__PURE__ */ Object.create(null) };
      parser.addListener("property", function(e) {
        if (e.invalid) return;
        result2.property[e.property.text] = e.value.text;
        if (e.important) result2.priority[e.property.text] = "important";
      });
      s = ("" + s).replace(/^;/, "");
      parser.parseStyleAttribute(s);
      return result2;
    }
    var NO_CHANGE = {};
    CSSStyleDeclaration.prototype = Object.create(Object.prototype, {
      // Return the parsed form of the element's style attribute.
      // If the element's style attribute has never been parsed
      // or if it has changed since the last parse, then reparse it
      // Note that the styles don't get parsed until they're actually needed
      _parsed: { get: function() {
        if (!this._parsedStyles || this.cssText !== this._lastParsedText) {
          var text = this.cssText;
          this._parsedStyles = parseStyles(text);
          this._lastParsedText = text;
          delete this._names;
        }
        return this._parsedStyles;
      } },
      // Call this method any time the parsed representation of the
      // style changes.  It converts the style properties to a string and
      // sets cssText and the element's style attribute
      _serialize: { value: function() {
        var styles = this._parsed;
        var s = "";
        for (var name in styles.property) {
          if (s) s += " ";
          s += name + ": " + styles.property[name];
          if (styles.priority[name]) {
            s += " !" + styles.priority[name];
          }
          s += ";";
        }
        this.cssText = s;
        this._lastParsedText = s;
        delete this._names;
      } },
      cssText: {
        get: function() {
          return this._element.getAttribute("style");
        },
        set: function(value) {
          this._element.setAttribute("style", value);
        }
      },
      length: { get: function() {
        if (!this._names)
          this._names = Object.getOwnPropertyNames(this._parsed.property);
        return this._names.length;
      } },
      item: { value: function(n) {
        if (!this._names)
          this._names = Object.getOwnPropertyNames(this._parsed.property);
        return this._names[n];
      } },
      getPropertyValue: { value: function(property) {
        property = property.toLowerCase();
        return this._parsed.property[property] || "";
      } },
      getPropertyPriority: { value: function(property) {
        property = property.toLowerCase();
        return this._parsed.priority[property] || "";
      } },
      setProperty: { value: function(property, value, priority) {
        property = property.toLowerCase();
        if (value === null || value === void 0) {
          value = "";
        }
        if (priority === null || priority === void 0) {
          priority = "";
        }
        if (value !== NO_CHANGE) {
          value = "" + value;
        }
        if (value === "") {
          this.removeProperty(property);
          return;
        }
        if (priority !== "" && priority !== NO_CHANGE && !/^important$/i.test(priority)) {
          return;
        }
        var styles = this._parsed;
        if (value === NO_CHANGE) {
          if (!styles.property[property]) {
            return;
          }
          if (priority !== "") {
            styles.priority[property] = "important";
          } else {
            delete styles.priority[property];
          }
        } else {
          if (value.indexOf(";") !== -1) return;
          var newprops = parseStyles(property + ":" + value);
          if (Object.getOwnPropertyNames(newprops.property).length === 0) {
            return;
          }
          if (Object.getOwnPropertyNames(newprops.priority).length !== 0) {
            return;
          }
          for (var p in newprops.property) {
            styles.property[p] = newprops.property[p];
            if (priority === NO_CHANGE) {
              continue;
            } else if (priority !== "") {
              styles.priority[p] = "important";
            } else if (styles.priority[p]) {
              delete styles.priority[p];
            }
          }
        }
        this._serialize();
      } },
      setPropertyValue: { value: function(property, value) {
        return this.setProperty(property, value, NO_CHANGE);
      } },
      setPropertyPriority: { value: function(property, priority) {
        return this.setProperty(property, NO_CHANGE, priority);
      } },
      removeProperty: { value: function(property) {
        property = property.toLowerCase();
        var styles = this._parsed;
        if (property in styles.property) {
          delete styles.property[property];
          delete styles.priority[property];
          this._serialize();
        }
      } }
    });
    var cssProperties = {
      accentColor: "accent-color",
      additiveSymbols: "additive-symbols",
      alignContent: "align-content",
      alignItems: "align-items",
      alignSelf: "align-self",
      alignmentBaseline: "alignment-baseline",
      all: "all",
      animation: "animation",
      animationDelay: "animation-delay",
      animationDirection: "animation-direction",
      animationDuration: "animation-duration",
      animationFillMode: "animation-fill-mode",
      animationIterationCount: "animation-iteration-count",
      animationName: "animation-name",
      animationPlayState: "animation-play-state",
      animationTimingFunction: "animation-timing-function",
      appRegion: "app-region",
      appearance: "appearance",
      ascentOverride: "ascent-override",
      aspectRatio: "aspect-ratio",
      backdropFilter: "backdrop-filter",
      backfaceVisibility: "backface-visibility",
      background: "background",
      backgroundAttachment: "background-attachment",
      backgroundBlendMode: "background-blend-mode",
      backgroundClip: "background-clip",
      backgroundColor: "background-color",
      backgroundImage: "background-image",
      backgroundOrigin: "background-origin",
      backgroundPosition: "background-position",
      backgroundPositionX: "background-position-x",
      backgroundPositionY: "background-position-y",
      backgroundRepeat: "background-repeat",
      backgroundRepeatX: "background-repeat-x",
      backgroundRepeatY: "background-repeat-y",
      backgroundSize: "background-size",
      basePalette: "base-palette",
      baselineShift: "baseline-shift",
      blockSize: "block-size",
      border: "border",
      borderBlock: "border-block",
      borderBlockColor: "border-block-color",
      borderBlockEnd: "border-block-end",
      borderBlockEndColor: "border-block-end-color",
      borderBlockEndStyle: "border-block-end-style",
      borderBlockEndWidth: "border-block-end-width",
      borderBlockStart: "border-block-start",
      borderBlockStartColor: "border-block-start-color",
      borderBlockStartStyle: "border-block-start-style",
      borderBlockStartWidth: "border-block-start-width",
      borderBlockStyle: "border-block-style",
      borderBlockWidth: "border-block-width",
      borderBottom: "border-bottom",
      borderBottomColor: "border-bottom-color",
      borderBottomLeftRadius: "border-bottom-left-radius",
      borderBottomRightRadius: "border-bottom-right-radius",
      borderBottomStyle: "border-bottom-style",
      borderBottomWidth: "border-bottom-width",
      borderCollapse: "border-collapse",
      borderColor: "border-color",
      borderEndEndRadius: "border-end-end-radius",
      borderEndStartRadius: "border-end-start-radius",
      borderImage: "border-image",
      borderImageOutset: "border-image-outset",
      borderImageRepeat: "border-image-repeat",
      borderImageSlice: "border-image-slice",
      borderImageSource: "border-image-source",
      borderImageWidth: "border-image-width",
      borderInline: "border-inline",
      borderInlineColor: "border-inline-color",
      borderInlineEnd: "border-inline-end",
      borderInlineEndColor: "border-inline-end-color",
      borderInlineEndStyle: "border-inline-end-style",
      borderInlineEndWidth: "border-inline-end-width",
      borderInlineStart: "border-inline-start",
      borderInlineStartColor: "border-inline-start-color",
      borderInlineStartStyle: "border-inline-start-style",
      borderInlineStartWidth: "border-inline-start-width",
      borderInlineStyle: "border-inline-style",
      borderInlineWidth: "border-inline-width",
      borderLeft: "border-left",
      borderLeftColor: "border-left-color",
      borderLeftStyle: "border-left-style",
      borderLeftWidth: "border-left-width",
      borderRadius: "border-radius",
      borderRight: "border-right",
      borderRightColor: "border-right-color",
      borderRightStyle: "border-right-style",
      borderRightWidth: "border-right-width",
      borderSpacing: "border-spacing",
      borderStartEndRadius: "border-start-end-radius",
      borderStartStartRadius: "border-start-start-radius",
      borderStyle: "border-style",
      borderTop: "border-top",
      borderTopColor: "border-top-color",
      borderTopLeftRadius: "border-top-left-radius",
      borderTopRightRadius: "border-top-right-radius",
      borderTopStyle: "border-top-style",
      borderTopWidth: "border-top-width",
      borderWidth: "border-width",
      bottom: "bottom",
      boxShadow: "box-shadow",
      boxSizing: "box-sizing",
      breakAfter: "break-after",
      breakBefore: "break-before",
      breakInside: "break-inside",
      bufferedRendering: "buffered-rendering",
      captionSide: "caption-side",
      caretColor: "caret-color",
      clear: "clear",
      clip: "clip",
      clipPath: "clip-path",
      clipRule: "clip-rule",
      color: "color",
      colorInterpolation: "color-interpolation",
      colorInterpolationFilters: "color-interpolation-filters",
      colorRendering: "color-rendering",
      colorScheme: "color-scheme",
      columnCount: "column-count",
      columnFill: "column-fill",
      columnGap: "column-gap",
      columnRule: "column-rule",
      columnRuleColor: "column-rule-color",
      columnRuleStyle: "column-rule-style",
      columnRuleWidth: "column-rule-width",
      columnSpan: "column-span",
      columnWidth: "column-width",
      columns: "columns",
      contain: "contain",
      containIntrinsicBlockSize: "contain-intrinsic-block-size",
      containIntrinsicHeight: "contain-intrinsic-height",
      containIntrinsicInlineSize: "contain-intrinsic-inline-size",
      containIntrinsicSize: "contain-intrinsic-size",
      containIntrinsicWidth: "contain-intrinsic-width",
      container: "container",
      containerName: "container-name",
      containerType: "container-type",
      content: "content",
      contentVisibility: "content-visibility",
      counterIncrement: "counter-increment",
      counterReset: "counter-reset",
      counterSet: "counter-set",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      descentOverride: "descent-override",
      direction: "direction",
      display: "display",
      dominantBaseline: "dominant-baseline",
      emptyCells: "empty-cells",
      fallback: "fallback",
      fill: "fill",
      fillOpacity: "fill-opacity",
      fillRule: "fill-rule",
      filter: "filter",
      flex: "flex",
      flexBasis: "flex-basis",
      flexDirection: "flex-direction",
      flexFlow: "flex-flow",
      flexGrow: "flex-grow",
      flexShrink: "flex-shrink",
      flexWrap: "flex-wrap",
      float: "float",
      floodColor: "flood-color",
      floodOpacity: "flood-opacity",
      font: "font",
      fontDisplay: "font-display",
      fontFamily: "font-family",
      fontFeatureSettings: "font-feature-settings",
      fontKerning: "font-kerning",
      fontOpticalSizing: "font-optical-sizing",
      fontPalette: "font-palette",
      fontSize: "font-size",
      fontStretch: "font-stretch",
      fontStyle: "font-style",
      fontSynthesis: "font-synthesis",
      fontSynthesisSmallCaps: "font-synthesis-small-caps",
      fontSynthesisStyle: "font-synthesis-style",
      fontSynthesisWeight: "font-synthesis-weight",
      fontVariant: "font-variant",
      fontVariantCaps: "font-variant-caps",
      fontVariantEastAsian: "font-variant-east-asian",
      fontVariantLigatures: "font-variant-ligatures",
      fontVariantNumeric: "font-variant-numeric",
      fontVariationSettings: "font-variation-settings",
      fontWeight: "font-weight",
      forcedColorAdjust: "forced-color-adjust",
      gap: "gap",
      grid: "grid",
      gridArea: "grid-area",
      gridAutoColumns: "grid-auto-columns",
      gridAutoFlow: "grid-auto-flow",
      gridAutoRows: "grid-auto-rows",
      gridColumn: "grid-column",
      gridColumnEnd: "grid-column-end",
      gridColumnGap: "grid-column-gap",
      gridColumnStart: "grid-column-start",
      gridGap: "grid-gap",
      gridRow: "grid-row",
      gridRowEnd: "grid-row-end",
      gridRowGap: "grid-row-gap",
      gridRowStart: "grid-row-start",
      gridTemplate: "grid-template",
      gridTemplateAreas: "grid-template-areas",
      gridTemplateColumns: "grid-template-columns",
      gridTemplateRows: "grid-template-rows",
      height: "height",
      hyphenateCharacter: "hyphenate-character",
      hyphenateLimitChars: "hyphenate-limit-chars",
      hyphens: "hyphens",
      imageOrientation: "image-orientation",
      imageRendering: "image-rendering",
      inherits: "inherits",
      initialLetter: "initial-letter",
      initialValue: "initial-value",
      inlineSize: "inline-size",
      inset: "inset",
      insetBlock: "inset-block",
      insetBlockEnd: "inset-block-end",
      insetBlockStart: "inset-block-start",
      insetInline: "inset-inline",
      insetInlineEnd: "inset-inline-end",
      insetInlineStart: "inset-inline-start",
      isolation: "isolation",
      justifyContent: "justify-content",
      justifyItems: "justify-items",
      justifySelf: "justify-self",
      left: "left",
      letterSpacing: "letter-spacing",
      lightingColor: "lighting-color",
      lineBreak: "line-break",
      lineGapOverride: "line-gap-override",
      lineHeight: "line-height",
      listStyle: "list-style",
      listStyleImage: "list-style-image",
      listStylePosition: "list-style-position",
      listStyleType: "list-style-type",
      margin: "margin",
      marginBlock: "margin-block",
      marginBlockEnd: "margin-block-end",
      marginBlockStart: "margin-block-start",
      marginBottom: "margin-bottom",
      marginInline: "margin-inline",
      marginInlineEnd: "margin-inline-end",
      marginInlineStart: "margin-inline-start",
      marginLeft: "margin-left",
      marginRight: "margin-right",
      marginTop: "margin-top",
      marker: "marker",
      markerEnd: "marker-end",
      markerMid: "marker-mid",
      markerStart: "marker-start",
      mask: "mask",
      maskType: "mask-type",
      mathDepth: "math-depth",
      mathShift: "math-shift",
      mathStyle: "math-style",
      maxBlockSize: "max-block-size",
      maxHeight: "max-height",
      maxInlineSize: "max-inline-size",
      maxWidth: "max-width",
      minBlockSize: "min-block-size",
      minHeight: "min-height",
      minInlineSize: "min-inline-size",
      minWidth: "min-width",
      mixBlendMode: "mix-blend-mode",
      negative: "negative",
      objectFit: "object-fit",
      objectPosition: "object-position",
      objectViewBox: "object-view-box",
      offset: "offset",
      offsetDistance: "offset-distance",
      offsetPath: "offset-path",
      offsetRotate: "offset-rotate",
      opacity: "opacity",
      order: "order",
      orphans: "orphans",
      outline: "outline",
      outlineColor: "outline-color",
      outlineOffset: "outline-offset",
      outlineStyle: "outline-style",
      outlineWidth: "outline-width",
      overflow: "overflow",
      overflowAnchor: "overflow-anchor",
      overflowClipMargin: "overflow-clip-margin",
      overflowWrap: "overflow-wrap",
      overflowX: "overflow-x",
      overflowY: "overflow-y",
      overrideColors: "override-colors",
      overscrollBehavior: "overscroll-behavior",
      overscrollBehaviorBlock: "overscroll-behavior-block",
      overscrollBehaviorInline: "overscroll-behavior-inline",
      overscrollBehaviorX: "overscroll-behavior-x",
      overscrollBehaviorY: "overscroll-behavior-y",
      pad: "pad",
      padding: "padding",
      paddingBlock: "padding-block",
      paddingBlockEnd: "padding-block-end",
      paddingBlockStart: "padding-block-start",
      paddingBottom: "padding-bottom",
      paddingInline: "padding-inline",
      paddingInlineEnd: "padding-inline-end",
      paddingInlineStart: "padding-inline-start",
      paddingLeft: "padding-left",
      paddingRight: "padding-right",
      paddingTop: "padding-top",
      page: "page",
      pageBreakAfter: "page-break-after",
      pageBreakBefore: "page-break-before",
      pageBreakInside: "page-break-inside",
      pageOrientation: "page-orientation",
      paintOrder: "paint-order",
      perspective: "perspective",
      perspectiveOrigin: "perspective-origin",
      placeContent: "place-content",
      placeItems: "place-items",
      placeSelf: "place-self",
      pointerEvents: "pointer-events",
      position: "position",
      prefix: "prefix",
      quotes: "quotes",
      r: "r",
      range: "range",
      resize: "resize",
      right: "right",
      rotate: "rotate",
      rowGap: "row-gap",
      rubyPosition: "ruby-position",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      scrollBehavior: "scroll-behavior",
      scrollMargin: "scroll-margin",
      scrollMarginBlock: "scroll-margin-block",
      scrollMarginBlockEnd: "scroll-margin-block-end",
      scrollMarginBlockStart: "scroll-margin-block-start",
      scrollMarginBottom: "scroll-margin-bottom",
      scrollMarginInline: "scroll-margin-inline",
      scrollMarginInlineEnd: "scroll-margin-inline-end",
      scrollMarginInlineStart: "scroll-margin-inline-start",
      scrollMarginLeft: "scroll-margin-left",
      scrollMarginRight: "scroll-margin-right",
      scrollMarginTop: "scroll-margin-top",
      scrollPadding: "scroll-padding",
      scrollPaddingBlock: "scroll-padding-block",
      scrollPaddingBlockEnd: "scroll-padding-block-end",
      scrollPaddingBlockStart: "scroll-padding-block-start",
      scrollPaddingBottom: "scroll-padding-bottom",
      scrollPaddingInline: "scroll-padding-inline",
      scrollPaddingInlineEnd: "scroll-padding-inline-end",
      scrollPaddingInlineStart: "scroll-padding-inline-start",
      scrollPaddingLeft: "scroll-padding-left",
      scrollPaddingRight: "scroll-padding-right",
      scrollPaddingTop: "scroll-padding-top",
      scrollSnapAlign: "scroll-snap-align",
      scrollSnapStop: "scroll-snap-stop",
      scrollSnapType: "scroll-snap-type",
      scrollbarGutter: "scrollbar-gutter",
      shapeImageThreshold: "shape-image-threshold",
      shapeMargin: "shape-margin",
      shapeOutside: "shape-outside",
      shapeRendering: "shape-rendering",
      size: "size",
      sizeAdjust: "size-adjust",
      speak: "speak",
      speakAs: "speak-as",
      src: "src",
      stopColor: "stop-color",
      stopOpacity: "stop-opacity",
      stroke: "stroke",
      strokeDasharray: "stroke-dasharray",
      strokeDashoffset: "stroke-dashoffset",
      strokeLinecap: "stroke-linecap",
      strokeLinejoin: "stroke-linejoin",
      strokeMiterlimit: "stroke-miterlimit",
      strokeOpacity: "stroke-opacity",
      strokeWidth: "stroke-width",
      suffix: "suffix",
      symbols: "symbols",
      syntax: "syntax",
      system: "system",
      tabSize: "tab-size",
      tableLayout: "table-layout",
      textAlign: "text-align",
      textAlignLast: "text-align-last",
      textAnchor: "text-anchor",
      textCombineUpright: "text-combine-upright",
      textDecoration: "text-decoration",
      textDecorationColor: "text-decoration-color",
      textDecorationLine: "text-decoration-line",
      textDecorationSkipInk: "text-decoration-skip-ink",
      textDecorationStyle: "text-decoration-style",
      textDecorationThickness: "text-decoration-thickness",
      textEmphasis: "text-emphasis",
      textEmphasisColor: "text-emphasis-color",
      textEmphasisPosition: "text-emphasis-position",
      textEmphasisStyle: "text-emphasis-style",
      textIndent: "text-indent",
      textOrientation: "text-orientation",
      textOverflow: "text-overflow",
      textRendering: "text-rendering",
      textShadow: "text-shadow",
      textSizeAdjust: "text-size-adjust",
      textTransform: "text-transform",
      textUnderlineOffset: "text-underline-offset",
      textUnderlinePosition: "text-underline-position",
      top: "top",
      touchAction: "touch-action",
      transform: "transform",
      transformBox: "transform-box",
      transformOrigin: "transform-origin",
      transformStyle: "transform-style",
      transition: "transition",
      transitionDelay: "transition-delay",
      transitionDuration: "transition-duration",
      transitionProperty: "transition-property",
      transitionTimingFunction: "transition-timing-function",
      translate: "translate",
      unicodeBidi: "unicode-bidi",
      unicodeRange: "unicode-range",
      userSelect: "user-select",
      vectorEffect: "vector-effect",
      verticalAlign: "vertical-align",
      visibility: "visibility",
      webkitAlignContent: "-webkit-align-content",
      webkitAlignItems: "-webkit-align-items",
      webkitAlignSelf: "-webkit-align-self",
      webkitAnimation: "-webkit-animation",
      webkitAnimationDelay: "-webkit-animation-delay",
      webkitAnimationDirection: "-webkit-animation-direction",
      webkitAnimationDuration: "-webkit-animation-duration",
      webkitAnimationFillMode: "-webkit-animation-fill-mode",
      webkitAnimationIterationCount: "-webkit-animation-iteration-count",
      webkitAnimationName: "-webkit-animation-name",
      webkitAnimationPlayState: "-webkit-animation-play-state",
      webkitAnimationTimingFunction: "-webkit-animation-timing-function",
      webkitAppRegion: "-webkit-app-region",
      webkitAppearance: "-webkit-appearance",
      webkitBackfaceVisibility: "-webkit-backface-visibility",
      webkitBackgroundClip: "-webkit-background-clip",
      webkitBackgroundOrigin: "-webkit-background-origin",
      webkitBackgroundSize: "-webkit-background-size",
      webkitBorderAfter: "-webkit-border-after",
      webkitBorderAfterColor: "-webkit-border-after-color",
      webkitBorderAfterStyle: "-webkit-border-after-style",
      webkitBorderAfterWidth: "-webkit-border-after-width",
      webkitBorderBefore: "-webkit-border-before",
      webkitBorderBeforeColor: "-webkit-border-before-color",
      webkitBorderBeforeStyle: "-webkit-border-before-style",
      webkitBorderBeforeWidth: "-webkit-border-before-width",
      webkitBorderBottomLeftRadius: "-webkit-border-bottom-left-radius",
      webkitBorderBottomRightRadius: "-webkit-border-bottom-right-radius",
      webkitBorderEnd: "-webkit-border-end",
      webkitBorderEndColor: "-webkit-border-end-color",
      webkitBorderEndStyle: "-webkit-border-end-style",
      webkitBorderEndWidth: "-webkit-border-end-width",
      webkitBorderHorizontalSpacing: "-webkit-border-horizontal-spacing",
      webkitBorderImage: "-webkit-border-image",
      webkitBorderRadius: "-webkit-border-radius",
      webkitBorderStart: "-webkit-border-start",
      webkitBorderStartColor: "-webkit-border-start-color",
      webkitBorderStartStyle: "-webkit-border-start-style",
      webkitBorderStartWidth: "-webkit-border-start-width",
      webkitBorderTopLeftRadius: "-webkit-border-top-left-radius",
      webkitBorderTopRightRadius: "-webkit-border-top-right-radius",
      webkitBorderVerticalSpacing: "-webkit-border-vertical-spacing",
      webkitBoxAlign: "-webkit-box-align",
      webkitBoxDecorationBreak: "-webkit-box-decoration-break",
      webkitBoxDirection: "-webkit-box-direction",
      webkitBoxFlex: "-webkit-box-flex",
      webkitBoxOrdinalGroup: "-webkit-box-ordinal-group",
      webkitBoxOrient: "-webkit-box-orient",
      webkitBoxPack: "-webkit-box-pack",
      webkitBoxReflect: "-webkit-box-reflect",
      webkitBoxShadow: "-webkit-box-shadow",
      webkitBoxSizing: "-webkit-box-sizing",
      webkitClipPath: "-webkit-clip-path",
      webkitColumnBreakAfter: "-webkit-column-break-after",
      webkitColumnBreakBefore: "-webkit-column-break-before",
      webkitColumnBreakInside: "-webkit-column-break-inside",
      webkitColumnCount: "-webkit-column-count",
      webkitColumnGap: "-webkit-column-gap",
      webkitColumnRule: "-webkit-column-rule",
      webkitColumnRuleColor: "-webkit-column-rule-color",
      webkitColumnRuleStyle: "-webkit-column-rule-style",
      webkitColumnRuleWidth: "-webkit-column-rule-width",
      webkitColumnSpan: "-webkit-column-span",
      webkitColumnWidth: "-webkit-column-width",
      webkitColumns: "-webkit-columns",
      webkitFilter: "-webkit-filter",
      webkitFlex: "-webkit-flex",
      webkitFlexBasis: "-webkit-flex-basis",
      webkitFlexDirection: "-webkit-flex-direction",
      webkitFlexFlow: "-webkit-flex-flow",
      webkitFlexGrow: "-webkit-flex-grow",
      webkitFlexShrink: "-webkit-flex-shrink",
      webkitFlexWrap: "-webkit-flex-wrap",
      webkitFontFeatureSettings: "-webkit-font-feature-settings",
      webkitFontSmoothing: "-webkit-font-smoothing",
      webkitHighlight: "-webkit-highlight",
      webkitHyphenateCharacter: "-webkit-hyphenate-character",
      webkitJustifyContent: "-webkit-justify-content",
      webkitLineBreak: "-webkit-line-break",
      webkitLineClamp: "-webkit-line-clamp",
      webkitLocale: "-webkit-locale",
      webkitLogicalHeight: "-webkit-logical-height",
      webkitLogicalWidth: "-webkit-logical-width",
      webkitMarginAfter: "-webkit-margin-after",
      webkitMarginBefore: "-webkit-margin-before",
      webkitMarginEnd: "-webkit-margin-end",
      webkitMarginStart: "-webkit-margin-start",
      webkitMask: "-webkit-mask",
      webkitMaskBoxImage: "-webkit-mask-box-image",
      webkitMaskBoxImageOutset: "-webkit-mask-box-image-outset",
      webkitMaskBoxImageRepeat: "-webkit-mask-box-image-repeat",
      webkitMaskBoxImageSlice: "-webkit-mask-box-image-slice",
      webkitMaskBoxImageSource: "-webkit-mask-box-image-source",
      webkitMaskBoxImageWidth: "-webkit-mask-box-image-width",
      webkitMaskClip: "-webkit-mask-clip",
      webkitMaskComposite: "-webkit-mask-composite",
      webkitMaskImage: "-webkit-mask-image",
      webkitMaskOrigin: "-webkit-mask-origin",
      webkitMaskPosition: "-webkit-mask-position",
      webkitMaskPositionX: "-webkit-mask-position-x",
      webkitMaskPositionY: "-webkit-mask-position-y",
      webkitMaskRepeat: "-webkit-mask-repeat",
      webkitMaskRepeatX: "-webkit-mask-repeat-x",
      webkitMaskRepeatY: "-webkit-mask-repeat-y",
      webkitMaskSize: "-webkit-mask-size",
      webkitMaxLogicalHeight: "-webkit-max-logical-height",
      webkitMaxLogicalWidth: "-webkit-max-logical-width",
      webkitMinLogicalHeight: "-webkit-min-logical-height",
      webkitMinLogicalWidth: "-webkit-min-logical-width",
      webkitOpacity: "-webkit-opacity",
      webkitOrder: "-webkit-order",
      webkitPaddingAfter: "-webkit-padding-after",
      webkitPaddingBefore: "-webkit-padding-before",
      webkitPaddingEnd: "-webkit-padding-end",
      webkitPaddingStart: "-webkit-padding-start",
      webkitPerspective: "-webkit-perspective",
      webkitPerspectiveOrigin: "-webkit-perspective-origin",
      webkitPerspectiveOriginX: "-webkit-perspective-origin-x",
      webkitPerspectiveOriginY: "-webkit-perspective-origin-y",
      webkitPrintColorAdjust: "-webkit-print-color-adjust",
      webkitRtlOrdering: "-webkit-rtl-ordering",
      webkitRubyPosition: "-webkit-ruby-position",
      webkitShapeImageThreshold: "-webkit-shape-image-threshold",
      webkitShapeMargin: "-webkit-shape-margin",
      webkitShapeOutside: "-webkit-shape-outside",
      webkitTapHighlightColor: "-webkit-tap-highlight-color",
      webkitTextCombine: "-webkit-text-combine",
      webkitTextDecorationsInEffect: "-webkit-text-decorations-in-effect",
      webkitTextEmphasis: "-webkit-text-emphasis",
      webkitTextEmphasisColor: "-webkit-text-emphasis-color",
      webkitTextEmphasisPosition: "-webkit-text-emphasis-position",
      webkitTextEmphasisStyle: "-webkit-text-emphasis-style",
      webkitTextFillColor: "-webkit-text-fill-color",
      webkitTextOrientation: "-webkit-text-orientation",
      webkitTextSecurity: "-webkit-text-security",
      webkitTextSizeAdjust: "-webkit-text-size-adjust",
      webkitTextStroke: "-webkit-text-stroke",
      webkitTextStrokeColor: "-webkit-text-stroke-color",
      webkitTextStrokeWidth: "-webkit-text-stroke-width",
      webkitTransform: "-webkit-transform",
      webkitTransformOrigin: "-webkit-transform-origin",
      webkitTransformOriginX: "-webkit-transform-origin-x",
      webkitTransformOriginY: "-webkit-transform-origin-y",
      webkitTransformOriginZ: "-webkit-transform-origin-z",
      webkitTransformStyle: "-webkit-transform-style",
      webkitTransition: "-webkit-transition",
      webkitTransitionDelay: "-webkit-transition-delay",
      webkitTransitionDuration: "-webkit-transition-duration",
      webkitTransitionProperty: "-webkit-transition-property",
      webkitTransitionTimingFunction: "-webkit-transition-timing-function",
      webkitUserDrag: "-webkit-user-drag",
      webkitUserModify: "-webkit-user-modify",
      webkitUserSelect: "-webkit-user-select",
      webkitWritingMode: "-webkit-writing-mode",
      whiteSpace: "white-space",
      widows: "widows",
      width: "width",
      willChange: "will-change",
      wordBreak: "word-break",
      wordSpacing: "word-spacing",
      wordWrap: "word-wrap",
      writingMode: "writing-mode",
      x: "x",
      y: "y",
      zIndex: "z-index",
      zoom: "zoom"
    };
    for (prop in cssProperties) defineStyleProperty(prop);
    var prop;
    function defineStyleProperty(jsname) {
      var cssname = cssProperties[jsname];
      Object.defineProperty(CSSStyleDeclaration.prototype, jsname, {
        get: function() {
          return this.getPropertyValue(cssname);
        },
        set: function(value) {
          this.setProperty(cssname, value);
        }
      });
      if (!CSSStyleDeclaration.prototype.hasOwnProperty(cssname)) {
        Object.defineProperty(CSSStyleDeclaration.prototype, cssname, {
          get: function() {
            return this.getPropertyValue(cssname);
          },
          set: function(value) {
            this.setProperty(cssname, value);
          }
        });
      }
    }
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/URLUtils.js
var require_URLUtils = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/URLUtils.js"(exports, module) {
    "use strict";
    var URL2 = require_URL();
    module.exports = URLUtils;
    function URLUtils() {
    }
    URLUtils.prototype = Object.create(Object.prototype, {
      _url: { get: function() {
        return new URL2(this.href);
      } },
      protocol: {
        get: function() {
          var url = this._url;
          if (url && url.scheme) return url.scheme + ":";
          else return ":";
        },
        set: function(v) {
          var output = this.href;
          var url = new URL2(output);
          if (url.isAbsolute()) {
            v = v.replace(/:+$/, "");
            v = v.replace(/[^-+\.a-zA-Z0-9]/g, URL2.percentEncode);
            if (v.length > 0) {
              url.scheme = v;
              output = url.toString();
            }
          }
          this.href = output;
        }
      },
      host: {
        get: function() {
          var url = this._url;
          if (url.isAbsolute() && url.isAuthorityBased())
            return url.host + (url.port ? ":" + url.port : "");
          else
            return "";
        },
        set: function(v) {
          var output = this.href;
          var url = new URL2(output);
          if (url.isAbsolute() && url.isAuthorityBased()) {
            v = v.replace(/[^-+\._~!$&'()*,;:=a-zA-Z0-9]/g, URL2.percentEncode);
            if (v.length > 0) {
              url.host = v;
              delete url.port;
              output = url.toString();
            }
          }
          this.href = output;
        }
      },
      hostname: {
        get: function() {
          var url = this._url;
          if (url.isAbsolute() && url.isAuthorityBased())
            return url.host;
          else
            return "";
        },
        set: function(v) {
          var output = this.href;
          var url = new URL2(output);
          if (url.isAbsolute() && url.isAuthorityBased()) {
            v = v.replace(/^\/+/, "");
            v = v.replace(/[^-+\._~!$&'()*,;:=a-zA-Z0-9]/g, URL2.percentEncode);
            if (v.length > 0) {
              url.host = v;
              output = url.toString();
            }
          }
          this.href = output;
        }
      },
      port: {
        get: function() {
          var url = this._url;
          if (url.isAbsolute() && url.isAuthorityBased() && url.port !== void 0)
            return url.port;
          else
            return "";
        },
        set: function(v) {
          var output = this.href;
          var url = new URL2(output);
          if (url.isAbsolute() && url.isAuthorityBased()) {
            v = "" + v;
            v = v.replace(/[^0-9].*$/, "");
            v = v.replace(/^0+/, "");
            if (v.length === 0) v = "0";
            if (parseInt(v, 10) <= 65535) {
              url.port = v;
              output = url.toString();
            }
          }
          this.href = output;
        }
      },
      pathname: {
        get: function() {
          var url = this._url;
          if (url.isAbsolute() && url.isHierarchical())
            return url.path;
          else
            return "";
        },
        set: function(v) {
          var output = this.href;
          var url = new URL2(output);
          if (url.isAbsolute() && url.isHierarchical()) {
            if (v.charAt(0) !== "/")
              v = "/" + v;
            v = v.replace(/[^-+\._~!$&'()*,;:=@\/a-zA-Z0-9]/g, URL2.percentEncode);
            url.path = v;
            output = url.toString();
          }
          this.href = output;
        }
      },
      search: {
        get: function() {
          var url = this._url;
          if (url.isAbsolute() && url.isHierarchical() && url.query !== void 0)
            return "?" + url.query;
          else
            return "";
        },
        set: function(v) {
          var output = this.href;
          var url = new URL2(output);
          if (url.isAbsolute() && url.isHierarchical()) {
            if (v.charAt(0) === "?") v = v.substring(1);
            v = v.replace(/[^-+\._~!$&'()*,;:=@\/?a-zA-Z0-9]/g, URL2.percentEncode);
            url.query = v;
            output = url.toString();
          }
          this.href = output;
        }
      },
      hash: {
        get: function() {
          var url = this._url;
          if (url == null || url.fragment == null || url.fragment === "") {
            return "";
          } else {
            return "#" + url.fragment;
          }
        },
        set: function(v) {
          var output = this.href;
          var url = new URL2(output);
          if (v.charAt(0) === "#") v = v.substring(1);
          v = v.replace(/[^-+\._~!$&'()*,;:=@\/?a-zA-Z0-9]/g, URL2.percentEncode);
          url.fragment = v;
          output = url.toString();
          this.href = output;
        }
      },
      username: {
        get: function() {
          var url = this._url;
          return url.username || "";
        },
        set: function(v) {
          var output = this.href;
          var url = new URL2(output);
          if (url.isAbsolute()) {
            v = v.replace(/[\x00-\x1F\x7F-\uFFFF "#<>?`\/@\\:]/g, URL2.percentEncode);
            url.username = v;
            output = url.toString();
          }
          this.href = output;
        }
      },
      password: {
        get: function() {
          var url = this._url;
          return url.password || "";
        },
        set: function(v) {
          var output = this.href;
          var url = new URL2(output);
          if (url.isAbsolute()) {
            if (v === "") {
              url.password = null;
            } else {
              v = v.replace(/[\x00-\x1F\x7F-\uFFFF "#<>?`\/@\\]/g, URL2.percentEncode);
              url.password = v;
            }
            output = url.toString();
          }
          this.href = output;
        }
      },
      origin: { get: function() {
        var url = this._url;
        if (url == null) {
          return "";
        }
        var originForPort = function(defaultPort) {
          var origin = [url.scheme, url.host, +url.port || defaultPort];
          return origin[0] + "://" + origin[1] + (origin[2] === defaultPort ? "" : ":" + origin[2]);
        };
        switch (url.scheme) {
          case "ftp":
            return originForPort(21);
          case "gopher":
            return originForPort(70);
          case "http":
          case "ws":
            return originForPort(80);
          case "https":
          case "wss":
            return originForPort(443);
          default:
            return url.scheme + "://";
        }
      } }
      /*
      searchParams: {
        get: function() {
          var url = this._url;
          // XXX
        },
        set: function(v) {
          var output = this.href;
          var url = new URL(output);
          // XXX
          this.href = output;
        },
      },
      */
    });
    URLUtils._inherit = function(proto) {
      Object.getOwnPropertyNames(URLUtils.prototype).forEach(function(p) {
        if (p === "constructor" || p === "href") {
          return;
        }
        var desc = Object.getOwnPropertyDescriptor(URLUtils.prototype, p);
        Object.defineProperty(proto, p, desc);
      });
    };
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/defineElement.js
var require_defineElement = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/defineElement.js"(exports, module) {
    "use strict";
    var attributes = require_attributes();
    var isApiWritable = require_config().isApiWritable;
    module.exports = function(spec, defaultConstructor, tagList, tagNameToImpl) {
      var c = spec.ctor;
      if (c) {
        var props = spec.props || {};
        if (spec.attributes) {
          for (var n in spec.attributes) {
            var attr = spec.attributes[n];
            if (typeof attr !== "object" || Array.isArray(attr)) attr = { type: attr };
            if (!attr.name) attr.name = n.toLowerCase();
            props[n] = attributes.property(attr);
          }
        }
        props.constructor = { value: c, writable: isApiWritable };
        c.prototype = Object.create((spec.superclass || defaultConstructor).prototype, props);
        if (spec.events) {
          addEventHandlers(c, spec.events);
        }
        tagList[spec.name] = c;
      } else {
        c = defaultConstructor;
      }
      (spec.tags || spec.tag && [spec.tag] || []).forEach(function(tag) {
        tagNameToImpl[tag] = c;
      });
      return c;
    };
    function EventHandlerBuilder(body, document2, form, element) {
      this.body = body;
      this.document = document2;
      this.form = form;
      this.element = element;
    }
    EventHandlerBuilder.prototype.build = function() {
      return () => {
      };
    };
    function EventHandlerChangeHandler(elt, name, oldval, newval) {
      var doc2 = elt.ownerDocument || /* @__PURE__ */ Object.create(null);
      var form = elt.form || /* @__PURE__ */ Object.create(null);
      elt[name] = new EventHandlerBuilder(newval, doc2, form, elt).build();
    }
    function addEventHandlers(c, eventHandlerTypes) {
      var p = c.prototype;
      eventHandlerTypes.forEach(function(type) {
        Object.defineProperty(p, "on" + type, {
          get: function() {
            return this._getEventHandler(type);
          },
          set: function(v) {
            this._setEventHandler(type, v);
          }
        });
        attributes.registerChangeHandler(c, "on" + type, EventHandlerChangeHandler);
      });
    }
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/htmlelts.js
var require_htmlelts = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/htmlelts.js"(exports) {
    "use strict";
    var Node = require_Node();
    var Element = require_Element();
    var CSSStyleDeclaration = require_CSSStyleDeclaration();
    var utils = require_utils();
    var URLUtils = require_URLUtils();
    var defineElement = require_defineElement();
    var htmlElements = exports.elements = {};
    var htmlNameToImpl = /* @__PURE__ */ Object.create(null);
    exports.createElement = function(doc2, localName, prefix) {
      var impl = htmlNameToImpl[localName] || HTMLUnknownElement;
      return new impl(doc2, localName, prefix);
    };
    function define(spec) {
      return defineElement(spec, HTMLElement, htmlElements, htmlNameToImpl);
    }
    function URL2(attr) {
      return {
        get: function() {
          var v = this._getattr(attr);
          if (v === null) {
            return "";
          }
          var url = this.doc._resolve(v);
          return url === null ? v : url;
        },
        set: function(value) {
          this._setattr(attr, value);
        }
      };
    }
    function CORS(attr) {
      return {
        get: function() {
          var v = this._getattr(attr);
          if (v === null) {
            return null;
          }
          if (v.toLowerCase() === "use-credentials") {
            return "use-credentials";
          }
          return "anonymous";
        },
        set: function(value) {
          if (value === null || value === void 0) {
            this.removeAttribute(attr);
          } else {
            this._setattr(attr, value);
          }
        }
      };
    }
    var REFERRER = {
      type: ["", "no-referrer", "no-referrer-when-downgrade", "same-origin", "origin", "strict-origin", "origin-when-cross-origin", "strict-origin-when-cross-origin", "unsafe-url"],
      missing: ""
    };
    var focusableElements = {
      "A": true,
      "LINK": true,
      "BUTTON": true,
      "INPUT": true,
      "SELECT": true,
      "TEXTAREA": true,
      "COMMAND": true
    };
    var HTMLFormElement = function(doc2, localName, prefix) {
      HTMLElement.call(this, doc2, localName, prefix);
      this._form = null;
    };
    var HTMLElement = exports.HTMLElement = define({
      superclass: Element,
      name: "HTMLElement",
      ctor: function HTMLElement2(doc2, localName, prefix) {
        Element.call(this, doc2, localName, utils.NAMESPACE.HTML, prefix);
      },
      props: {
        dangerouslySetInnerHTML: {
          set: function(v) {
            this._innerHTML = v;
          }
        },
        innerHTML: {
          get: function() {
            return this.serialize();
          },
          set: function(v) {
            var parser = this.ownerDocument.implementation.mozHTMLParser(
              this.ownerDocument._address,
              this
            );
            parser.parse(v === null ? "" : String(v), true);
            var target = this instanceof htmlNameToImpl.template ? this.content : this;
            while (target.hasChildNodes())
              target.removeChild(target.firstChild);
            target.appendChild(parser._asDocumentFragment());
          }
        },
        style: { get: function() {
          if (!this._style)
            this._style = new CSSStyleDeclaration(this);
          return this._style;
        }, set: function(v) {
          if (v === null || v === void 0) {
            v = "";
          }
          this._setattr("style", String(v));
        } },
        // These can't really be implemented server-side in a reasonable way.
        blur: { value: function() {
        } },
        focus: { value: function() {
        } },
        forceSpellCheck: { value: function() {
        } },
        click: { value: function() {
          if (this._click_in_progress) return;
          this._click_in_progress = true;
          try {
            if (this._pre_click_activation_steps)
              this._pre_click_activation_steps();
            var event = this.ownerDocument.createEvent("MouseEvent");
            event.initMouseEvent(
              "click",
              true,
              true,
              this.ownerDocument.defaultView,
              1,
              0,
              0,
              0,
              0,
              // These 4 should be initialized with
              // the actually current keyboard state
              // somehow...
              false,
              false,
              false,
              false,
              0,
              null
            );
            var success = this.dispatchEvent(event);
            if (success) {
              if (this._post_click_activation_steps)
                this._post_click_activation_steps(event);
            } else {
              if (this._cancelled_activation_steps)
                this._cancelled_activation_steps();
            }
          } finally {
            this._click_in_progress = false;
          }
        } },
        submit: { value: utils.nyi }
      },
      attributes: {
        title: String,
        lang: String,
        dir: { type: ["ltr", "rtl", "auto"], missing: "" },
        accessKey: String,
        hidden: Boolean,
        tabIndex: { type: "long", default: function() {
          if (this.tagName in focusableElements || this.contentEditable)
            return 0;
          else
            return -1;
        } }
      },
      events: [
        "abort",
        "canplay",
        "canplaythrough",
        "change",
        "click",
        "contextmenu",
        "cuechange",
        "dblclick",
        "drag",
        "dragend",
        "dragenter",
        "dragleave",
        "dragover",
        "dragstart",
        "drop",
        "durationchange",
        "emptied",
        "ended",
        "input",
        "invalid",
        "keydown",
        "keypress",
        "keyup",
        "loadeddata",
        "loadedmetadata",
        "loadstart",
        "mousedown",
        "mousemove",
        "mouseout",
        "mouseover",
        "mouseup",
        "mousewheel",
        "pause",
        "play",
        "playing",
        "progress",
        "ratechange",
        "readystatechange",
        "reset",
        "seeked",
        "seeking",
        "select",
        "show",
        "stalled",
        "submit",
        "suspend",
        "timeupdate",
        "volumechange",
        "waiting",
        // These last 5 event types will be overriden by HTMLBodyElement
        "blur",
        "error",
        "focus",
        "load",
        "scroll"
      ]
    });
    var HTMLUnknownElement = define({
      name: "HTMLUnknownElement",
      ctor: function HTMLUnknownElement2(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      }
    });
    var formAssociatedProps = {
      // See http://www.w3.org/TR/html5/association-of-controls-and-forms.html#form-owner
      form: { get: function() {
        return this._form;
      } }
    };
    define({
      tag: "a",
      name: "HTMLAnchorElement",
      ctor: function HTMLAnchorElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      props: {
        _post_click_activation_steps: { value: function(e) {
          if (this.href) {
            this.ownerDocument.defaultView.location = this.href;
          }
        } }
      },
      attributes: {
        href: URL2,
        ping: String,
        download: String,
        target: String,
        rel: String,
        media: String,
        hreflang: String,
        type: String,
        referrerPolicy: REFERRER,
        // Obsolete
        coords: String,
        charset: String,
        name: String,
        rev: String,
        shape: String
      }
    });
    URLUtils._inherit(htmlNameToImpl.a.prototype);
    define({
      tag: "area",
      name: "HTMLAreaElement",
      ctor: function HTMLAreaElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        alt: String,
        target: String,
        download: String,
        rel: String,
        media: String,
        href: URL2,
        hreflang: String,
        type: String,
        shape: String,
        coords: String,
        ping: String,
        // XXX: also reflect relList
        referrerPolicy: REFERRER,
        // Obsolete
        noHref: Boolean
      }
    });
    URLUtils._inherit(htmlNameToImpl.area.prototype);
    define({
      tag: "br",
      name: "HTMLBRElement",
      ctor: function HTMLBRElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        // Obsolete
        clear: String
      }
    });
    define({
      tag: "base",
      name: "HTMLBaseElement",
      ctor: function HTMLBaseElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        "target": String
      }
    });
    define({
      tag: "body",
      name: "HTMLBodyElement",
      ctor: function HTMLBodyElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      // Certain event handler attributes on a <body> tag actually set
      // handlers for the window rather than just that element.  Define
      // getters and setters for those here.  Note that some of these override
      // properties on HTMLElement.prototype.
      // XXX: If I add support for <frameset>, these have to go there, too
      // XXX
      // When the Window object is implemented, these attribute will have
      // to work with the same-named attributes on the Window.
      events: [
        "afterprint",
        "beforeprint",
        "beforeunload",
        "blur",
        "error",
        "focus",
        "hashchange",
        "load",
        "message",
        "offline",
        "online",
        "pagehide",
        "pageshow",
        "popstate",
        "resize",
        "scroll",
        "storage",
        "unload"
      ],
      attributes: {
        // Obsolete
        text: { type: String, treatNullAsEmptyString: true },
        link: { type: String, treatNullAsEmptyString: true },
        vLink: { type: String, treatNullAsEmptyString: true },
        aLink: { type: String, treatNullAsEmptyString: true },
        bgColor: { type: String, treatNullAsEmptyString: true },
        background: String
      }
    });
    define({
      tag: "button",
      name: "HTMLButtonElement",
      ctor: function HTMLButtonElement(doc2, localName, prefix) {
        HTMLFormElement.call(this, doc2, localName, prefix);
      },
      props: formAssociatedProps,
      attributes: {
        name: String,
        value: String,
        disabled: Boolean,
        autofocus: Boolean,
        type: { type: ["submit", "reset", "button", "menu"], missing: "submit" },
        formTarget: String,
        formNoValidate: Boolean,
        formMethod: { type: ["get", "post", "dialog"], invalid: "get", missing: "" },
        formEnctype: { type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], invalid: "application/x-www-form-urlencoded", missing: "" }
      }
    });
    define({
      tag: "dl",
      name: "HTMLDListElement",
      ctor: function HTMLDListElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        // Obsolete
        compact: Boolean
      }
    });
    define({
      tag: "data",
      name: "HTMLDataElement",
      ctor: function HTMLDataElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        value: String
      }
    });
    define({
      tag: "datalist",
      name: "HTMLDataListElement",
      ctor: function HTMLDataListElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      }
    });
    define({
      tag: "details",
      name: "HTMLDetailsElement",
      ctor: function HTMLDetailsElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        "open": Boolean
      }
    });
    define({
      tag: "div",
      name: "HTMLDivElement",
      ctor: function HTMLDivElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        // Obsolete
        align: String
      }
    });
    define({
      tag: "embed",
      name: "HTMLEmbedElement",
      ctor: function HTMLEmbedElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        src: URL2,
        type: String,
        width: String,
        height: String,
        // Obsolete
        align: String,
        name: String
      }
    });
    define({
      tag: "fieldset",
      name: "HTMLFieldSetElement",
      ctor: function HTMLFieldSetElement(doc2, localName, prefix) {
        HTMLFormElement.call(this, doc2, localName, prefix);
      },
      props: formAssociatedProps,
      attributes: {
        disabled: Boolean,
        name: String
      }
    });
    define({
      tag: "form",
      name: "HTMLFormElement",
      ctor: function HTMLFormElement2(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        action: String,
        autocomplete: { type: ["on", "off"], missing: "on" },
        name: String,
        acceptCharset: { name: "accept-charset" },
        target: String,
        noValidate: Boolean,
        method: { type: ["get", "post", "dialog"], invalid: "get", missing: "get" },
        // Both enctype and encoding reflect the enctype content attribute
        enctype: { type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], invalid: "application/x-www-form-urlencoded", missing: "application/x-www-form-urlencoded" },
        encoding: { name: "enctype", type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], invalid: "application/x-www-form-urlencoded", missing: "application/x-www-form-urlencoded" }
      }
    });
    define({
      tag: "hr",
      name: "HTMLHRElement",
      ctor: function HTMLHRElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        // Obsolete
        align: String,
        color: String,
        noShade: Boolean,
        size: String,
        width: String
      }
    });
    define({
      tag: "head",
      name: "HTMLHeadElement",
      ctor: function HTMLHeadElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      }
    });
    define({
      tags: ["h1", "h2", "h3", "h4", "h5", "h6"],
      name: "HTMLHeadingElement",
      ctor: function HTMLHeadingElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        // Obsolete
        align: String
      }
    });
    define({
      tag: "html",
      name: "HTMLHtmlElement",
      ctor: function HTMLHtmlElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        // Obsolete
        version: String
      }
    });
    define({
      tag: "iframe",
      name: "HTMLIFrameElement",
      ctor: function HTMLIFrameElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        src: URL2,
        srcdoc: String,
        name: String,
        width: String,
        height: String,
        // XXX: sandbox is a reflected settable token list
        seamless: Boolean,
        allowFullscreen: Boolean,
        allowUserMedia: Boolean,
        allowPaymentRequest: Boolean,
        referrerPolicy: REFERRER,
        // Obsolete
        align: String,
        scrolling: String,
        frameBorder: String,
        longDesc: URL2,
        marginHeight: { type: String, treatNullAsEmptyString: true },
        marginWidth: { type: String, treatNullAsEmptyString: true }
      }
    });
    define({
      tag: "img",
      name: "HTMLImageElement",
      ctor: function HTMLImageElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        alt: String,
        src: URL2,
        srcset: String,
        crossOrigin: CORS,
        useMap: String,
        isMap: Boolean,
        height: { type: "unsigned long", default: 0 },
        width: { type: "unsigned long", default: 0 },
        referrerPolicy: REFERRER,
        // Obsolete:
        name: String,
        lowsrc: URL2,
        align: String,
        hspace: { type: "unsigned long", default: 0 },
        vspace: { type: "unsigned long", default: 0 },
        longDesc: URL2,
        border: { type: String, treatNullAsEmptyString: true }
      }
    });
    define({
      tag: "input",
      name: "HTMLInputElement",
      ctor: function HTMLInputElement(doc2, localName, prefix) {
        HTMLFormElement.call(this, doc2, localName, prefix);
      },
      props: {
        form: formAssociatedProps.form,
        _post_click_activation_steps: { value: function(e) {
          if (this.type === "checkbox") {
            this.checked = !this.checked;
          } else if (this.type === "radio") {
            var group = this.form.getElementsByName(this.name);
            for (var i = group.length - 1; i >= 0; i--) {
              var el = group[i];
              el.checked = el === this;
            }
          }
        } }
      },
      attributes: {
        name: String,
        disabled: Boolean,
        autofocus: Boolean,
        accept: String,
        alt: String,
        max: String,
        min: String,
        pattern: String,
        placeholder: String,
        step: String,
        dirName: String,
        defaultValue: { name: "value" },
        multiple: Boolean,
        required: Boolean,
        readOnly: Boolean,
        checked: Boolean,
        value: String,
        src: URL2,
        defaultChecked: { name: "checked", type: Boolean },
        size: { type: "unsigned long", default: 20, min: 1, setmin: 1 },
        width: { type: "unsigned long", min: 0, setmin: 0, default: 0 },
        height: { type: "unsigned long", min: 0, setmin: 0, default: 0 },
        minLength: { type: "unsigned long", min: 0, setmin: 0, default: -1 },
        maxLength: { type: "unsigned long", min: 0, setmin: 0, default: -1 },
        autocomplete: String,
        // It's complicated
        type: {
          type: [
            "text",
            "hidden",
            "search",
            "tel",
            "url",
            "email",
            "password",
            "datetime",
            "date",
            "month",
            "week",
            "time",
            "datetime-local",
            "number",
            "range",
            "color",
            "checkbox",
            "radio",
            "file",
            "submit",
            "image",
            "reset",
            "button"
          ],
          missing: "text"
        },
        formTarget: String,
        formNoValidate: Boolean,
        formMethod: { type: ["get", "post"], invalid: "get", missing: "" },
        formEnctype: { type: ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], invalid: "application/x-www-form-urlencoded", missing: "" },
        inputMode: { type: ["verbatim", "latin", "latin-name", "latin-prose", "full-width-latin", "kana", "kana-name", "katakana", "numeric", "tel", "email", "url"], missing: "" },
        // Obsolete
        align: String,
        useMap: String
      }
    });
    define({
      tag: "keygen",
      name: "HTMLKeygenElement",
      ctor: function HTMLKeygenElement(doc2, localName, prefix) {
        HTMLFormElement.call(this, doc2, localName, prefix);
      },
      props: formAssociatedProps,
      attributes: {
        name: String,
        disabled: Boolean,
        autofocus: Boolean,
        challenge: String,
        keytype: { type: ["rsa"], missing: "" }
      }
    });
    define({
      tag: "li",
      name: "HTMLLIElement",
      ctor: function HTMLLIElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        value: { type: "long", default: 0 },
        // Obsolete
        type: String
      }
    });
    define({
      tag: "label",
      name: "HTMLLabelElement",
      ctor: function HTMLLabelElement(doc2, localName, prefix) {
        HTMLFormElement.call(this, doc2, localName, prefix);
      },
      props: formAssociatedProps,
      attributes: {
        htmlFor: { name: "for", type: String }
      }
    });
    define({
      tag: "legend",
      name: "HTMLLegendElement",
      ctor: function HTMLLegendElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        // Obsolete
        align: String
      }
    });
    define({
      tag: "link",
      name: "HTMLLinkElement",
      ctor: function HTMLLinkElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        // XXX Reflect DOMSettableTokenList sizes also DOMTokenList relList
        href: URL2,
        rel: String,
        media: String,
        hreflang: String,
        type: String,
        crossOrigin: CORS,
        nonce: String,
        integrity: String,
        referrerPolicy: REFERRER,
        // Obsolete
        charset: String,
        rev: String,
        target: String
      }
    });
    define({
      tag: "map",
      name: "HTMLMapElement",
      ctor: function HTMLMapElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        name: String
      }
    });
    define({
      tag: "menu",
      name: "HTMLMenuElement",
      ctor: function HTMLMenuElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        // XXX: not quite right, default should be popup if parent element is
        // popup.
        type: { type: ["context", "popup", "toolbar"], missing: "toolbar" },
        label: String,
        // Obsolete
        compact: Boolean
      }
    });
    define({
      tag: "meta",
      name: "HTMLMetaElement",
      ctor: function HTMLMetaElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        name: String,
        content: String,
        httpEquiv: { name: "http-equiv", type: String },
        // Obsolete
        scheme: String
      }
    });
    define({
      tag: "meter",
      name: "HTMLMeterElement",
      ctor: function HTMLMeterElement(doc2, localName, prefix) {
        HTMLFormElement.call(this, doc2, localName, prefix);
      },
      props: formAssociatedProps
    });
    define({
      tags: ["ins", "del"],
      name: "HTMLModElement",
      ctor: function HTMLModElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        cite: URL2,
        dateTime: String
      }
    });
    define({
      tag: "ol",
      name: "HTMLOListElement",
      ctor: function HTMLOListElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      props: {
        // Utility function (see the start attribute default value). Returns
        // the number of <li> children of this element
        _numitems: { get: function() {
          var items = 0;
          this.childNodes.forEach(function(n) {
            if (n.nodeType === Node.ELEMENT_NODE && n.tagName === "LI")
              items++;
          });
          return items;
        } }
      },
      attributes: {
        type: String,
        reversed: Boolean,
        start: {
          type: "long",
          default: function() {
            if (this.reversed)
              return this._numitems;
            else
              return 1;
          }
        },
        // Obsolete
        compact: Boolean
      }
    });
    define({
      tag: "object",
      name: "HTMLObjectElement",
      ctor: function HTMLObjectElement(doc2, localName, prefix) {
        HTMLFormElement.call(this, doc2, localName, prefix);
      },
      props: formAssociatedProps,
      attributes: {
        data: URL2,
        type: String,
        name: String,
        useMap: String,
        typeMustMatch: Boolean,
        width: String,
        height: String,
        // Obsolete
        align: String,
        archive: String,
        code: String,
        declare: Boolean,
        hspace: { type: "unsigned long", default: 0 },
        standby: String,
        vspace: { type: "unsigned long", default: 0 },
        codeBase: URL2,
        codeType: String,
        border: { type: String, treatNullAsEmptyString: true }
      }
    });
    define({
      tag: "optgroup",
      name: "HTMLOptGroupElement",
      ctor: function HTMLOptGroupElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        disabled: Boolean,
        label: String
      }
    });
    define({
      tag: "option",
      name: "HTMLOptionElement",
      ctor: function HTMLOptionElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      props: {
        form: { get: function() {
          var p = this.parentNode;
          while (p && p.nodeType === Node.ELEMENT_NODE) {
            if (p.localName === "select") return p.form;
            p = p.parentNode;
          }
        } },
        value: {
          get: function() {
            return this._getattr("value") || this.text;
          },
          set: function(v) {
            this._setattr("value", v);
          }
        },
        text: {
          get: function() {
            return this.textContent.replace(/[ \t\n\f\r]+/g, " ").trim();
          },
          set: function(v) {
            this.textContent = v;
          }
        }
        // missing: index
      },
      attributes: {
        disabled: Boolean,
        defaultSelected: { name: "selected", type: Boolean },
        label: String
      }
    });
    define({
      tag: "output",
      name: "HTMLOutputElement",
      ctor: function HTMLOutputElement(doc2, localName, prefix) {
        HTMLFormElement.call(this, doc2, localName, prefix);
      },
      props: formAssociatedProps,
      attributes: {
        // XXX Reflect for/htmlFor as a settable token list
        name: String
      }
    });
    define({
      tag: "p",
      name: "HTMLParagraphElement",
      ctor: function HTMLParagraphElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        // Obsolete
        align: String
      }
    });
    define({
      tag: "param",
      name: "HTMLParamElement",
      ctor: function HTMLParamElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        name: String,
        value: String,
        // Obsolete
        type: String,
        valueType: String
      }
    });
    define({
      tags: [
        "pre",
        /*legacy elements:*/
        "listing",
        "xmp"
      ],
      name: "HTMLPreElement",
      ctor: function HTMLPreElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        // Obsolete
        width: { type: "long", default: 0 }
      }
    });
    define({
      tag: "progress",
      name: "HTMLProgressElement",
      ctor: function HTMLProgressElement(doc2, localName, prefix) {
        HTMLFormElement.call(this, doc2, localName, prefix);
      },
      props: formAssociatedProps,
      attributes: {
        max: { type: Number, float: true, default: 1, min: 0 }
      }
    });
    define({
      tags: ["q", "blockquote"],
      name: "HTMLQuoteElement",
      ctor: function HTMLQuoteElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        cite: URL2
      }
    });
    define({
      tag: "script",
      name: "HTMLScriptElement",
      ctor: function HTMLScriptElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      props: {
        text: {
          get: function() {
            var s = "";
            for (var i = 0, n = this.childNodes.length; i < n; i++) {
              var child = this.childNodes[i];
              if (child.nodeType === Node.TEXT_NODE)
                s += child._data;
            }
            return s;
          },
          set: function(value) {
            this.removeChildren();
            if (value !== null && value !== "") {
              this.appendChild(this.ownerDocument.createTextNode(value));
            }
          }
        }
      },
      attributes: {
        src: URL2,
        type: String,
        charset: String,
        defer: Boolean,
        async: Boolean,
        crossOrigin: CORS,
        nonce: String,
        integrity: String
      }
    });
    define({
      tag: "select",
      name: "HTMLSelectElement",
      ctor: function HTMLSelectElement(doc2, localName, prefix) {
        HTMLFormElement.call(this, doc2, localName, prefix);
      },
      props: {
        form: formAssociatedProps.form,
        options: { get: function() {
          return this.getElementsByTagName("option");
        } }
      },
      attributes: {
        autocomplete: String,
        // It's complicated
        name: String,
        disabled: Boolean,
        autofocus: Boolean,
        multiple: Boolean,
        required: Boolean,
        size: { type: "unsigned long", default: 0 }
      }
    });
    define({
      tag: "source",
      name: "HTMLSourceElement",
      ctor: function HTMLSourceElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        src: URL2,
        type: String,
        media: String
      }
    });
    define({
      tag: "span",
      name: "HTMLSpanElement",
      ctor: function HTMLSpanElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      }
    });
    define({
      tag: "style",
      name: "HTMLStyleElement",
      ctor: function HTMLStyleElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        media: String,
        type: String,
        scoped: Boolean
      }
    });
    define({
      tag: "caption",
      name: "HTMLTableCaptionElement",
      ctor: function HTMLTableCaptionElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        // Obsolete
        align: String
      }
    });
    define({
      name: "HTMLTableCellElement",
      ctor: function HTMLTableCellElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        colSpan: { type: "unsigned long", default: 1 },
        rowSpan: { type: "unsigned long", default: 1 },
        //XXX Also reflect settable token list headers
        scope: { type: ["row", "col", "rowgroup", "colgroup"], missing: "" },
        abbr: String,
        // Obsolete
        align: String,
        axis: String,
        height: String,
        width: String,
        ch: { name: "char", type: String },
        chOff: { name: "charoff", type: String },
        noWrap: Boolean,
        vAlign: String,
        bgColor: { type: String, treatNullAsEmptyString: true }
      }
    });
    define({
      tags: ["col", "colgroup"],
      name: "HTMLTableColElement",
      ctor: function HTMLTableColElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        span: { type: "limited unsigned long with fallback", default: 1, min: 1 },
        // Obsolete
        align: String,
        ch: { name: "char", type: String },
        chOff: { name: "charoff", type: String },
        vAlign: String,
        width: String
      }
    });
    define({
      tag: "table",
      name: "HTMLTableElement",
      ctor: function HTMLTableElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      props: {
        rows: { get: function() {
          return this.getElementsByTagName("tr");
        } }
      },
      attributes: {
        // Obsolete
        align: String,
        border: String,
        frame: String,
        rules: String,
        summary: String,
        width: String,
        bgColor: { type: String, treatNullAsEmptyString: true },
        cellPadding: { type: String, treatNullAsEmptyString: true },
        cellSpacing: { type: String, treatNullAsEmptyString: true }
      }
    });
    define({
      tag: "template",
      name: "HTMLTemplateElement",
      ctor: function HTMLTemplateElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
        this._contentFragment = doc2._templateDoc.createDocumentFragment();
      },
      props: {
        content: { get: function() {
          return this._contentFragment;
        } },
        serialize: { value: function() {
          return this.content.serialize();
        } }
      }
    });
    define({
      tag: "tr",
      name: "HTMLTableRowElement",
      ctor: function HTMLTableRowElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      props: {
        cells: { get: function() {
          return this.querySelectorAll("td,th");
        } }
      },
      attributes: {
        // Obsolete
        align: String,
        ch: { name: "char", type: String },
        chOff: { name: "charoff", type: String },
        vAlign: String,
        bgColor: { type: String, treatNullAsEmptyString: true }
      }
    });
    define({
      tags: ["thead", "tfoot", "tbody"],
      name: "HTMLTableSectionElement",
      ctor: function HTMLTableSectionElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      props: {
        rows: { get: function() {
          return this.getElementsByTagName("tr");
        } }
      },
      attributes: {
        // Obsolete
        align: String,
        ch: { name: "char", type: String },
        chOff: { name: "charoff", type: String },
        vAlign: String
      }
    });
    define({
      tag: "textarea",
      name: "HTMLTextAreaElement",
      ctor: function HTMLTextAreaElement(doc2, localName, prefix) {
        HTMLFormElement.call(this, doc2, localName, prefix);
      },
      props: {
        form: formAssociatedProps.form,
        type: { get: function() {
          return "textarea";
        } },
        defaultValue: {
          get: function() {
            return this.textContent;
          },
          set: function(v) {
            this.textContent = v;
          }
        },
        value: {
          get: function() {
            return this.defaultValue;
          },
          set: function(v) {
            this.defaultValue = v;
          }
        },
        textLength: { get: function() {
          return this.value.length;
        } }
      },
      attributes: {
        autocomplete: String,
        // It's complicated
        name: String,
        disabled: Boolean,
        autofocus: Boolean,
        placeholder: String,
        wrap: String,
        dirName: String,
        required: Boolean,
        readOnly: Boolean,
        rows: { type: "limited unsigned long with fallback", default: 2 },
        cols: { type: "limited unsigned long with fallback", default: 20 },
        maxLength: { type: "unsigned long", min: 0, setmin: 0, default: -1 },
        minLength: { type: "unsigned long", min: 0, setmin: 0, default: -1 },
        inputMode: { type: ["verbatim", "latin", "latin-name", "latin-prose", "full-width-latin", "kana", "kana-name", "katakana", "numeric", "tel", "email", "url"], missing: "" }
      }
    });
    define({
      tag: "time",
      name: "HTMLTimeElement",
      ctor: function HTMLTimeElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        dateTime: String,
        pubDate: Boolean
      }
    });
    define({
      tag: "title",
      name: "HTMLTitleElement",
      ctor: function HTMLTitleElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      props: {
        text: { get: function() {
          return this.textContent;
        } }
      }
    });
    define({
      tag: "ul",
      name: "HTMLUListElement",
      ctor: function HTMLUListElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        type: String,
        // Obsolete
        compact: Boolean
      }
    });
    define({
      name: "HTMLMediaElement",
      ctor: function HTMLMediaElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        src: URL2,
        crossOrigin: CORS,
        preload: { type: ["metadata", "none", "auto", { value: "", alias: "auto" }], missing: "auto" },
        loop: Boolean,
        autoplay: Boolean,
        mediaGroup: String,
        controls: Boolean,
        defaultMuted: { name: "muted", type: Boolean }
      }
    });
    define({
      tag: "audio",
      superclass: htmlElements.HTMLMediaElement,
      name: "HTMLAudioElement",
      ctor: function HTMLAudioElement(doc2, localName, prefix) {
        htmlElements.HTMLMediaElement.call(this, doc2, localName, prefix);
      }
    });
    define({
      tag: "video",
      superclass: htmlElements.HTMLMediaElement,
      name: "HTMLVideoElement",
      ctor: function HTMLVideoElement(doc2, localName, prefix) {
        htmlElements.HTMLMediaElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        poster: URL2,
        width: { type: "unsigned long", min: 0, default: 0 },
        height: { type: "unsigned long", min: 0, default: 0 }
      }
    });
    define({
      tag: "td",
      superclass: htmlElements.HTMLTableCellElement,
      name: "HTMLTableDataCellElement",
      ctor: function HTMLTableDataCellElement(doc2, localName, prefix) {
        htmlElements.HTMLTableCellElement.call(this, doc2, localName, prefix);
      }
    });
    define({
      tag: "th",
      superclass: htmlElements.HTMLTableCellElement,
      name: "HTMLTableHeaderCellElement",
      ctor: function HTMLTableHeaderCellElement(doc2, localName, prefix) {
        htmlElements.HTMLTableCellElement.call(this, doc2, localName, prefix);
      }
    });
    define({
      tag: "frameset",
      name: "HTMLFrameSetElement",
      ctor: function HTMLFrameSetElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      }
    });
    define({
      tag: "frame",
      name: "HTMLFrameElement",
      ctor: function HTMLFrameElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      }
    });
    define({
      tag: "canvas",
      name: "HTMLCanvasElement",
      ctor: function HTMLCanvasElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      props: {
        getContext: { value: utils.nyi },
        probablySupportsContext: { value: utils.nyi },
        setContext: { value: utils.nyi },
        transferControlToProxy: { value: utils.nyi },
        toDataURL: { value: utils.nyi },
        toBlob: { value: utils.nyi }
      },
      attributes: {
        width: { type: "unsigned long", default: 300 },
        height: { type: "unsigned long", default: 150 }
      }
    });
    define({
      tag: "dialog",
      name: "HTMLDialogElement",
      ctor: function HTMLDialogElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      props: {
        show: { value: utils.nyi },
        showModal: { value: utils.nyi },
        close: { value: utils.nyi }
      },
      attributes: {
        open: Boolean,
        returnValue: String
      }
    });
    define({
      tag: "menuitem",
      name: "HTMLMenuItemElement",
      ctor: function HTMLMenuItemElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      props: {
        // The menuitem's label
        _label: {
          get: function() {
            var val = this._getattr("label");
            if (val !== null && val !== "") {
              return val;
            }
            val = this.textContent;
            return val.replace(/[ \t\n\f\r]+/g, " ").trim();
          }
        },
        // The menuitem label IDL attribute
        label: {
          get: function() {
            var val = this._getattr("label");
            if (val !== null) {
              return val;
            }
            return this._label;
          },
          set: function(v) {
            this._setattr("label", v);
          }
        }
      },
      attributes: {
        type: { type: ["command", "checkbox", "radio"], missing: "command" },
        icon: URL2,
        disabled: Boolean,
        checked: Boolean,
        radiogroup: String,
        default: Boolean
      }
    });
    define({
      tag: "source",
      name: "HTMLSourceElement",
      ctor: function HTMLSourceElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        srcset: String,
        sizes: String,
        media: String,
        src: URL2,
        type: String
      }
    });
    define({
      tag: "track",
      name: "HTMLTrackElement",
      ctor: function HTMLTrackElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        src: URL2,
        srclang: String,
        label: String,
        default: Boolean,
        kind: { type: ["subtitles", "captions", "descriptions", "chapters", "metadata"], missing: "subtitles", invalid: "metadata" }
      },
      props: {
        NONE: { get: function() {
          return 0;
        } },
        LOADING: { get: function() {
          return 1;
        } },
        LOADED: { get: function() {
          return 2;
        } },
        ERROR: { get: function() {
          return 3;
        } },
        readyState: { get: utils.nyi },
        track: { get: utils.nyi }
      }
    });
    define({
      // obsolete
      tag: "font",
      name: "HTMLFontElement",
      ctor: function HTMLFontElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        color: { type: String, treatNullAsEmptyString: true },
        face: { type: String },
        size: { type: String }
      }
    });
    define({
      // obsolete
      tag: "dir",
      name: "HTMLDirectoryElement",
      ctor: function HTMLDirectoryElement(doc2, localName, prefix) {
        HTMLElement.call(this, doc2, localName, prefix);
      },
      attributes: {
        compact: Boolean
      }
    });
    define({
      tags: [
        "abbr",
        "address",
        "article",
        "aside",
        "b",
        "bdi",
        "bdo",
        "cite",
        "code",
        "dd",
        "dfn",
        "dt",
        "em",
        "figcaption",
        "figure",
        "footer",
        "header",
        "hgroup",
        "i",
        "kbd",
        "main",
        "mark",
        "nav",
        "noscript",
        "rb",
        "rp",
        "rt",
        "rtc",
        "ruby",
        "s",
        "samp",
        "section",
        "small",
        "strong",
        "sub",
        "summary",
        "sup",
        "u",
        "var",
        "wbr",
        // Legacy elements
        "acronym",
        "basefont",
        "big",
        "center",
        "nobr",
        "noembed",
        "noframes",
        "plaintext",
        "strike",
        "tt"
      ]
    });
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/svg.js
var require_svg = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/svg.js"(exports) {
    "use strict";
    var Element = require_Element();
    var defineElement = require_defineElement();
    var utils = require_utils();
    var CSSStyleDeclaration = require_CSSStyleDeclaration();
    var svgElements = exports.elements = {};
    var svgNameToImpl = /* @__PURE__ */ Object.create(null);
    exports.createElement = function(doc2, localName, prefix) {
      var impl = svgNameToImpl[localName] || SVGElement;
      return new impl(doc2, localName, prefix);
    };
    function define(spec) {
      return defineElement(spec, SVGElement, svgElements, svgNameToImpl);
    }
    var SVGElement = define({
      superclass: Element,
      name: "SVGElement",
      ctor: function SVGElement2(doc2, localName, prefix) {
        Element.call(this, doc2, localName, utils.NAMESPACE.SVG, prefix);
      },
      props: {
        style: { get: function() {
          if (!this._style)
            this._style = new CSSStyleDeclaration(this);
          return this._style;
        } }
      }
    });
    define({
      name: "SVGSVGElement",
      ctor: function SVGSVGElement(doc2, localName, prefix) {
        SVGElement.call(this, doc2, localName, prefix);
      },
      tag: "svg",
      props: {
        createSVGRect: { value: function() {
          return exports.createElement(this.ownerDocument, "rect", null);
        } }
      }
    });
    define({
      tags: [
        "a",
        "altGlyph",
        "altGlyphDef",
        "altGlyphItem",
        "animate",
        "animateColor",
        "animateMotion",
        "animateTransform",
        "circle",
        "clipPath",
        "color-profile",
        "cursor",
        "defs",
        "desc",
        "ellipse",
        "feBlend",
        "feColorMatrix",
        "feComponentTransfer",
        "feComposite",
        "feConvolveMatrix",
        "feDiffuseLighting",
        "feDisplacementMap",
        "feDistantLight",
        "feFlood",
        "feFuncA",
        "feFuncB",
        "feFuncG",
        "feFuncR",
        "feGaussianBlur",
        "feImage",
        "feMerge",
        "feMergeNode",
        "feMorphology",
        "feOffset",
        "fePointLight",
        "feSpecularLighting",
        "feSpotLight",
        "feTile",
        "feTurbulence",
        "filter",
        "font",
        "font-face",
        "font-face-format",
        "font-face-name",
        "font-face-src",
        "font-face-uri",
        "foreignObject",
        "g",
        "glyph",
        "glyphRef",
        "hkern",
        "image",
        "line",
        "linearGradient",
        "marker",
        "mask",
        "metadata",
        "missing-glyph",
        "mpath",
        "path",
        "pattern",
        "polygon",
        "polyline",
        "radialGradient",
        "rect",
        "script",
        "set",
        "stop",
        "style",
        "switch",
        "symbol",
        "text",
        "textPath",
        "title",
        "tref",
        "tspan",
        "use",
        "view",
        "vkern"
      ]
    });
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/MutationConstants.js
var require_MutationConstants = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/MutationConstants.js"(exports, module) {
    "use strict";
    module.exports = {
      VALUE: 1,
      // The value of a Text, Comment or PI node changed
      ATTR: 2,
      // A new attribute was added or an attribute value and/or prefix changed
      REMOVE_ATTR: 3,
      // An attribute was removed
      REMOVE: 4,
      // A node was removed
      MOVE: 5,
      // A node was moved
      INSERT: 6
      // A node (or a subtree of nodes) was inserted
    };
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/Document.js
var require_Document = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/Document.js"(exports, module) {
    "use strict";
    module.exports = Document;
    var Node = require_Node();
    var NodeList = require_NodeList();
    var ContainerNode = require_ContainerNode();
    var Element = require_Element();
    var Text = require_Text();
    var Comment = require_Comment();
    var Event2 = require_Event();
    var DocumentFragment = require_DocumentFragment();
    var ProcessingInstruction = require_ProcessingInstruction();
    var DOMImplementation = require_DOMImplementation();
    var TreeWalker = require_TreeWalker();
    var NodeIterator = require_NodeIterator();
    var NodeFilter2 = require_NodeFilter();
    var URL2 = require_URL();
    var select = require_select();
    var events = require_events();
    var xml = require_xmlnames();
    var html = require_htmlelts();
    var svg = require_svg();
    var utils = require_utils();
    var MUTATE = require_MutationConstants();
    var NAMESPACE = utils.NAMESPACE;
    var isApiWritable = require_config().isApiWritable;
    function Document(isHTML, address) {
      ContainerNode.call(this);
      this.nodeType = Node.DOCUMENT_NODE;
      this.isHTML = isHTML;
      this._address = address || "about:blank";
      this.readyState = "loading";
      this.implementation = new DOMImplementation(this);
      this.ownerDocument = null;
      this._contentType = isHTML ? "text/html" : "application/xml";
      this.doctype = null;
      this.documentElement = null;
      this._templateDocCache = null;
      this._nodeIterators = null;
      this._nid = 1;
      this._nextnid = 2;
      this._nodes = [null, this];
      this.byId = /* @__PURE__ */ Object.create(null);
      this.modclock = 0;
    }
    var supportedEvents = {
      event: "Event",
      customevent: "CustomEvent",
      uievent: "UIEvent",
      mouseevent: "MouseEvent"
    };
    var replacementEvent = {
      events: "event",
      htmlevents: "event",
      mouseevents: "mouseevent",
      mutationevents: "mutationevent",
      uievents: "uievent"
    };
    var mirrorAttr = function(f, name, defaultValue) {
      return {
        get: function() {
          var o = f.call(this);
          if (o) {
            return o[name];
          }
          return defaultValue;
        },
        set: function(value) {
          var o = f.call(this);
          if (o) {
            o[name] = value;
          }
        }
      };
    };
    function validateAndExtract(namespace, qualifiedName) {
      var prefix, localName, pos;
      if (namespace === "") {
        namespace = null;
      }
      if (!xml.isValidQName(qualifiedName)) {
        utils.InvalidCharacterError();
      }
      prefix = null;
      localName = qualifiedName;
      pos = qualifiedName.indexOf(":");
      if (pos >= 0) {
        prefix = qualifiedName.substring(0, pos);
        localName = qualifiedName.substring(pos + 1);
      }
      if (prefix !== null && namespace === null) {
        utils.NamespaceError();
      }
      if (prefix === "xml" && namespace !== NAMESPACE.XML) {
        utils.NamespaceError();
      }
      if ((prefix === "xmlns" || qualifiedName === "xmlns") && namespace !== NAMESPACE.XMLNS) {
        utils.NamespaceError();
      }
      if (namespace === NAMESPACE.XMLNS && !(prefix === "xmlns" || qualifiedName === "xmlns")) {
        utils.NamespaceError();
      }
      return { namespace, prefix, localName };
    }
    Document.prototype = Object.create(ContainerNode.prototype, {
      // This method allows dom.js to communicate with a renderer
      // that displays the document in some way
      // XXX: I should probably move this to the window object
      _setMutationHandler: { value: function(handler) {
        this.mutationHandler = handler;
      } },
      // This method allows dom.js to receive event notifications
      // from the renderer.
      // XXX: I should probably move this to the window object
      _dispatchRendererEvent: { value: function(targetNid, type, details) {
        var target = this._nodes[targetNid];
        if (!target) return;
        target._dispatchEvent(new Event2(type, details), true);
      } },
      nodeName: { value: "#document" },
      nodeValue: {
        get: function() {
          return null;
        },
        set: function() {
        }
      },
      // XXX: DOMCore may remove documentURI, so it is NYI for now
      documentURI: { get: function() {
        return this._address;
      }, set: utils.nyi },
      compatMode: { get: function() {
        return this._quirks ? "BackCompat" : "CSS1Compat";
      } },
      createTextNode: { value: function(data) {
        return new Text(this, String(data));
      } },
      createComment: { value: function(data) {
        return new Comment(this, data);
      } },
      createDocumentFragment: { value: function() {
        return new DocumentFragment(this);
      } },
      createProcessingInstruction: { value: function(target, data) {
        if (!xml.isValidName(target) || data.indexOf("?>") !== -1)
          utils.InvalidCharacterError();
        return new ProcessingInstruction(this, target, data);
      } },
      createAttribute: { value: function(localName) {
        localName = String(localName);
        if (!xml.isValidName(localName)) utils.InvalidCharacterError();
        if (this.isHTML) {
          localName = utils.toASCIILowerCase(localName);
        }
        return new Element._Attr(null, localName, null, null, "");
      } },
      createAttributeNS: { value: function(namespace, qualifiedName) {
        namespace = namespace === null || namespace === void 0 || namespace === "" ? null : String(namespace);
        qualifiedName = String(qualifiedName);
        var ve = validateAndExtract(namespace, qualifiedName);
        return new Element._Attr(null, ve.localName, ve.prefix, ve.namespace, "");
      } },
      createElement: { value: function(localName) {
        localName = String(localName);
        if (!xml.isValidName(localName)) utils.InvalidCharacterError();
        if (this.isHTML) {
          if (/[A-Z]/.test(localName))
            localName = utils.toASCIILowerCase(localName);
          return html.createElement(this, localName, null);
        } else if (this.contentType === "application/xhtml+xml") {
          return html.createElement(this, localName, null);
        } else {
          return new Element(this, localName, null, null);
        }
      }, writable: isApiWritable },
      createElementNS: { value: function(namespace, qualifiedName) {
        namespace = namespace === null || namespace === void 0 || namespace === "" ? null : String(namespace);
        qualifiedName = String(qualifiedName);
        var ve = validateAndExtract(namespace, qualifiedName);
        return this._createElementNS(ve.localName, ve.namespace, ve.prefix);
      }, writable: isApiWritable },
      // This is used directly by HTML parser, which allows it to create
      // elements with localNames containing ':' and non-default namespaces
      _createElementNS: { value: function(localName, namespace, prefix) {
        if (namespace === NAMESPACE.HTML) {
          return html.createElement(this, localName, prefix);
        } else if (namespace === NAMESPACE.SVG) {
          return svg.createElement(this, localName, prefix);
        }
        return new Element(this, localName, namespace, prefix);
      } },
      createEvent: { value: function createEvent(interfaceName) {
        interfaceName = interfaceName.toLowerCase();
        var name = replacementEvent[interfaceName] || interfaceName;
        var constructor = events[supportedEvents[name]];
        if (constructor) {
          var e = new constructor();
          e._initialized = false;
          return e;
        } else {
          utils.NotSupportedError();
        }
      } },
      // See: http://www.w3.org/TR/dom/#dom-document-createtreewalker
      createTreeWalker: { value: function(root2, whatToShow, filter) {
        if (!root2) {
          throw new TypeError("root argument is required");
        }
        if (!(root2 instanceof Node)) {
          throw new TypeError("root not a node");
        }
        whatToShow = whatToShow === void 0 ? NodeFilter2.SHOW_ALL : +whatToShow;
        filter = filter === void 0 ? null : filter;
        return new TreeWalker(root2, whatToShow, filter);
      } },
      // See: http://www.w3.org/TR/dom/#dom-document-createnodeiterator
      createNodeIterator: { value: function(root2, whatToShow, filter) {
        if (!root2) {
          throw new TypeError("root argument is required");
        }
        if (!(root2 instanceof Node)) {
          throw new TypeError("root not a node");
        }
        whatToShow = whatToShow === void 0 ? NodeFilter2.SHOW_ALL : +whatToShow;
        filter = filter === void 0 ? null : filter;
        return new NodeIterator(root2, whatToShow, filter);
      } },
      _attachNodeIterator: { value: function(ni) {
        if (!this._nodeIterators) {
          this._nodeIterators = [];
        }
        this._nodeIterators.push(ni);
      } },
      _detachNodeIterator: { value: function(ni) {
        var idx = this._nodeIterators.indexOf(ni);
        this._nodeIterators.splice(idx, 1);
      } },
      _preremoveNodeIterators: { value: function(toBeRemoved) {
        if (this._nodeIterators) {
          this._nodeIterators.forEach(function(ni) {
            ni._preremove(toBeRemoved);
          });
        }
      } },
      // Maintain the documentElement and
      // doctype properties of the document.  Each of the following
      // methods chains to the Node implementation of the method
      // to do the actual inserting, removal or replacement.
      _updateDocTypeElement: { value: function _updateDocTypeElement() {
        this.doctype = this.documentElement = null;
        for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {
          if (kid.nodeType === Node.DOCUMENT_TYPE_NODE)
            this.doctype = kid;
          else if (kid.nodeType === Node.ELEMENT_NODE)
            this.documentElement = kid;
        }
      } },
      insertBefore: { value: function insertBefore(child, refChild) {
        Node.prototype.insertBefore.call(this, child, refChild);
        this._updateDocTypeElement();
        return child;
      } },
      replaceChild: { value: function replaceChild(node, child) {
        Node.prototype.replaceChild.call(this, node, child);
        this._updateDocTypeElement();
        return child;
      } },
      removeChild: { value: function removeChild(child) {
        Node.prototype.removeChild.call(this, child);
        this._updateDocTypeElement();
        return child;
      } },
      getElementById: { value: function(id) {
        var n = this.byId[id];
        if (!n) return null;
        if (n instanceof MultiId) {
          return n.getFirst();
        }
        return n;
      } },
      _hasMultipleElementsWithId: { value: function(id) {
        return this.byId[id] instanceof MultiId;
      } },
      // Just copy this method from the Element prototype
      getElementsByName: { value: Element.prototype.getElementsByName },
      getElementsByTagName: { value: Element.prototype.getElementsByTagName },
      getElementsByTagNameNS: { value: Element.prototype.getElementsByTagNameNS },
      getElementsByClassName: { value: Element.prototype.getElementsByClassName },
      adoptNode: { value: function adoptNode(node) {
        if (node.nodeType === Node.DOCUMENT_NODE) utils.NotSupportedError();
        if (node.nodeType === Node.ATTRIBUTE_NODE) {
          return node;
        }
        if (node.parentNode) node.parentNode.removeChild(node);
        if (node.ownerDocument !== this)
          recursivelySetOwner(node, this);
        return node;
      } },
      importNode: { value: function importNode(node, deep) {
        return this.adoptNode(node.cloneNode(deep));
      }, writable: isApiWritable },
      // The following attributes and methods are from the HTML spec
      origin: { get: function origin() {
        return null;
      } },
      characterSet: { get: function characterSet() {
        return "UTF-8";
      } },
      contentType: { get: function contentType() {
        return this._contentType;
      } },
      URL: { get: function URL3() {
        return this._address;
      } },
      domain: { get: utils.nyi, set: utils.nyi },
      referrer: { get: utils.nyi },
      cookie: { get: utils.nyi, set: utils.nyi },
      lastModified: { get: utils.nyi },
      location: {
        get: function() {
          return this.defaultView ? this.defaultView.location : null;
        },
        set: utils.nyi
      },
      _titleElement: {
        get: function() {
          return this.getElementsByTagName("title").item(0) || null;
        }
      },
      title: {
        get: function() {
          var elt = this._titleElement;
          var value = elt ? elt.textContent : "";
          return value.replace(/[ \t\n\r\f]+/g, " ").replace(/(^ )|( $)/g, "");
        },
        set: function(value) {
          var elt = this._titleElement;
          var head = this.head;
          if (!elt && !head) {
            return;
          }
          if (!elt) {
            elt = this.createElement("title");
            head.appendChild(elt);
          }
          elt.textContent = value;
        }
      },
      dir: mirrorAttr(function() {
        var htmlElement = this.documentElement;
        if (htmlElement && htmlElement.tagName === "HTML") {
          return htmlElement;
        }
      }, "dir", ""),
      fgColor: mirrorAttr(function() {
        return this.body;
      }, "text", ""),
      linkColor: mirrorAttr(function() {
        return this.body;
      }, "link", ""),
      vlinkColor: mirrorAttr(function() {
        return this.body;
      }, "vLink", ""),
      alinkColor: mirrorAttr(function() {
        return this.body;
      }, "aLink", ""),
      bgColor: mirrorAttr(function() {
        return this.body;
      }, "bgColor", ""),
      // Historical aliases of Document#characterSet
      charset: { get: function() {
        return this.characterSet;
      } },
      inputEncoding: { get: function() {
        return this.characterSet;
      } },
      scrollingElement: {
        get: function() {
          return this._quirks ? this.body : this.documentElement;
        }
      },
      // Return the first <body> child of the document element.
      // XXX For now, setting this attribute is not implemented.
      body: {
        get: function() {
          return namedHTMLChild(this.documentElement, "body");
        },
        set: utils.nyi
      },
      // Return the first <head> child of the document element.
      head: { get: function() {
        return namedHTMLChild(this.documentElement, "head");
      } },
      images: { get: utils.nyi },
      embeds: { get: utils.nyi },
      plugins: { get: utils.nyi },
      links: { get: utils.nyi },
      forms: { get: utils.nyi },
      scripts: { get: utils.nyi },
      applets: { get: function() {
        return [];
      } },
      activeElement: { get: function() {
        return null;
      } },
      innerHTML: {
        get: function() {
          return this.serialize();
        },
        set: utils.nyi
      },
      outerHTML: {
        get: function() {
          return this.serialize();
        },
        set: utils.nyi
      },
      write: { value: function(args) {
        if (!this.isHTML) utils.InvalidStateError();
        if (!this._parser)
          return;
        if (!this._parser) {
        }
        var s = arguments.join("");
        this._parser.parse(s);
      } },
      writeln: { value: function writeln(args) {
        this.write(Array.prototype.join.call(arguments, "") + "\n");
      } },
      open: { value: function() {
        this.documentElement = null;
      } },
      close: { value: function() {
        this.readyState = "interactive";
        this._dispatchEvent(new Event2("readystatechange"), true);
        this._dispatchEvent(new Event2("DOMContentLoaded"), true);
        this.readyState = "complete";
        this._dispatchEvent(new Event2("readystatechange"), true);
        if (this.defaultView) {
          this.defaultView._dispatchEvent(new Event2("load"), true);
        }
      } },
      // Utility methods
      clone: { value: function clone() {
        var d = new Document(this.isHTML, this._address);
        d._quirks = this._quirks;
        d._contentType = this._contentType;
        return d;
      } },
      // We need to adopt the nodes if we do a deep clone
      cloneNode: { value: function cloneNode(deep) {
        var clone = Node.prototype.cloneNode.call(this, false);
        if (deep) {
          for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {
            clone._appendChild(clone.importNode(kid, true));
          }
        }
        clone._updateDocTypeElement();
        return clone;
      } },
      isEqual: { value: function isEqual(n) {
        return true;
      } },
      // Implementation-specific function.  Called when a text, comment,
      // or pi value changes.
      mutateValue: { value: function(node) {
        if (this.mutationHandler) {
          this.mutationHandler({
            type: MUTATE.VALUE,
            target: node,
            data: node.data
          });
        }
      } },
      // Invoked when an attribute's value changes. Attr holds the new
      // value.  oldval is the old value.  Attribute mutations can also
      // involve changes to the prefix (and therefore the qualified name)
      mutateAttr: { value: function(attr, oldval) {
        if (this.mutationHandler) {
          this.mutationHandler({
            type: MUTATE.ATTR,
            target: attr.ownerElement,
            attr
          });
        }
      } },
      // Used by removeAttribute and removeAttributeNS for attributes.
      mutateRemoveAttr: { value: function(attr) {
        if (this.mutationHandler) {
          this.mutationHandler({
            type: MUTATE.REMOVE_ATTR,
            target: attr.ownerElement,
            attr
          });
        }
      } },
      // Called by Node.removeChild, etc. to remove a rooted element from
      // the tree. Only needs to generate a single mutation event when a
      // node is removed, but must recursively mark all descendants as not
      // rooted.
      mutateRemove: { value: function(node) {
        if (this.mutationHandler) {
          this.mutationHandler({
            type: MUTATE.REMOVE,
            target: node.parentNode,
            node
          });
        }
        recursivelyUproot(node);
      } },
      // Called when a new element becomes rooted.  It must recursively
      // generate mutation events for each of the children, and mark them all
      // as rooted.
      mutateInsert: { value: function(node) {
        recursivelyRoot(node);
        if (this.mutationHandler) {
          this.mutationHandler({
            type: MUTATE.INSERT,
            target: node.parentNode,
            node
          });
        }
      } },
      // Called when a rooted element is moved within the document
      mutateMove: { value: function(node) {
        if (this.mutationHandler) {
          this.mutationHandler({
            type: MUTATE.MOVE,
            target: node
          });
        }
      } },
      // Add a mapping from  id to n for n.ownerDocument
      addId: { value: function addId(id, n) {
        var val = this.byId[id];
        if (!val) {
          this.byId[id] = n;
        } else {
          if (!(val instanceof MultiId)) {
            val = new MultiId(val);
            this.byId[id] = val;
          }
          val.add(n);
        }
      } },
      // Delete the mapping from id to n for n.ownerDocument
      delId: { value: function delId(id, n) {
        var val = this.byId[id];
        utils.assert(val);
        if (val instanceof MultiId) {
          val.del(n);
          if (val.length === 1) {
            this.byId[id] = val.downgrade();
          }
        } else {
          this.byId[id] = void 0;
        }
      } },
      _resolve: { value: function(href) {
        return new URL2(this._documentBaseURL).resolve(href);
      } },
      _documentBaseURL: { get: function() {
        var url = this._address;
        if (url === "about:blank") url = "/";
        var base2 = this.querySelector("base[href]");
        if (base2) {
          return new URL2(url).resolve(base2.getAttribute("href"));
        }
        return url;
      } },
      _templateDoc: { get: function() {
        if (!this._templateDocCache) {
          var newDoc = new Document(this.isHTML, this._address);
          this._templateDocCache = newDoc._templateDocCache = newDoc;
        }
        return this._templateDocCache;
      } },
      querySelector: { value: function(selector) {
        return select(selector, this)[0];
      } },
      querySelectorAll: { value: function(selector) {
        var nodes = select(selector, this);
        return nodes.item ? nodes : new NodeList(nodes);
      } }
    });
    var eventHandlerTypes = [
      "abort",
      "canplay",
      "canplaythrough",
      "change",
      "click",
      "contextmenu",
      "cuechange",
      "dblclick",
      "drag",
      "dragend",
      "dragenter",
      "dragleave",
      "dragover",
      "dragstart",
      "drop",
      "durationchange",
      "emptied",
      "ended",
      "input",
      "invalid",
      "keydown",
      "keypress",
      "keyup",
      "loadeddata",
      "loadedmetadata",
      "loadstart",
      "mousedown",
      "mousemove",
      "mouseout",
      "mouseover",
      "mouseup",
      "mousewheel",
      "pause",
      "play",
      "playing",
      "progress",
      "ratechange",
      "readystatechange",
      "reset",
      "seeked",
      "seeking",
      "select",
      "show",
      "stalled",
      "submit",
      "suspend",
      "timeupdate",
      "volumechange",
      "waiting",
      "blur",
      "error",
      "focus",
      "load",
      "scroll"
    ];
    eventHandlerTypes.forEach(function(type) {
      Object.defineProperty(Document.prototype, "on" + type, {
        get: function() {
          return this._getEventHandler(type);
        },
        set: function(v) {
          this._setEventHandler(type, v);
        }
      });
    });
    function namedHTMLChild(parent, name) {
      if (parent && parent.isHTML) {
        for (var kid = parent.firstChild; kid !== null; kid = kid.nextSibling) {
          if (kid.nodeType === Node.ELEMENT_NODE && kid.localName === name && kid.namespaceURI === NAMESPACE.HTML) {
            return kid;
          }
        }
      }
      return null;
    }
    function root(n) {
      n._nid = n.ownerDocument._nextnid++;
      n.ownerDocument._nodes[n._nid] = n;
      if (n.nodeType === Node.ELEMENT_NODE) {
        var id = n.getAttribute("id");
        if (id) n.ownerDocument.addId(id, n);
        if (n._roothook) n._roothook();
      }
    }
    function uproot(n) {
      if (n.nodeType === Node.ELEMENT_NODE) {
        var id = n.getAttribute("id");
        if (id) n.ownerDocument.delId(id, n);
      }
      n.ownerDocument._nodes[n._nid] = void 0;
      n._nid = void 0;
    }
    function recursivelyRoot(node) {
      root(node);
      if (node.nodeType === Node.ELEMENT_NODE) {
        for (var kid = node.firstChild; kid !== null; kid = kid.nextSibling)
          recursivelyRoot(kid);
      }
    }
    function recursivelyUproot(node) {
      uproot(node);
      for (var kid = node.firstChild; kid !== null; kid = kid.nextSibling)
        recursivelyUproot(kid);
    }
    function recursivelySetOwner(node, owner) {
      node.ownerDocument = owner;
      node._lastModTime = void 0;
      if (Object.prototype.hasOwnProperty.call(node, "_tagName")) {
        node._tagName = void 0;
      }
      for (var kid = node.firstChild; kid !== null; kid = kid.nextSibling)
        recursivelySetOwner(kid, owner);
    }
    function MultiId(node) {
      this.nodes = /* @__PURE__ */ Object.create(null);
      this.nodes[node._nid] = node;
      this.length = 1;
      this.firstNode = void 0;
    }
    MultiId.prototype.add = function(node) {
      if (!this.nodes[node._nid]) {
        this.nodes[node._nid] = node;
        this.length++;
        this.firstNode = void 0;
      }
    };
    MultiId.prototype.del = function(node) {
      if (this.nodes[node._nid]) {
        delete this.nodes[node._nid];
        this.length--;
        this.firstNode = void 0;
      }
    };
    MultiId.prototype.getFirst = function() {
      if (!this.firstNode) {
        var nid;
        for (nid in this.nodes) {
          if (this.firstNode === void 0 || this.firstNode.compareDocumentPosition(this.nodes[nid]) & Node.DOCUMENT_POSITION_PRECEDING) {
            this.firstNode = this.nodes[nid];
          }
        }
      }
      return this.firstNode;
    };
    MultiId.prototype.downgrade = function() {
      if (this.length === 1) {
        var nid;
        for (nid in this.nodes) {
          return this.nodes[nid];
        }
      }
      return this;
    };
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/DocumentType.js
var require_DocumentType = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/DocumentType.js"(exports, module) {
    "use strict";
    module.exports = DocumentType;
    var Node = require_Node();
    var Leaf = require_Leaf();
    var ChildNode = require_ChildNode();
    function DocumentType(ownerDocument, name, publicId, systemId) {
      Leaf.call(this);
      this.nodeType = Node.DOCUMENT_TYPE_NODE;
      this.ownerDocument = ownerDocument || null;
      this.name = name;
      this.publicId = publicId || "";
      this.systemId = systemId || "";
    }
    DocumentType.prototype = Object.create(Leaf.prototype, {
      nodeName: { get: function() {
        return this.name;
      } },
      nodeValue: {
        get: function() {
          return null;
        },
        set: function() {
        }
      },
      // Utility methods
      clone: { value: function clone() {
        return new DocumentType(this.ownerDocument, this.name, this.publicId, this.systemId);
      } },
      isEqual: { value: function isEqual(n) {
        return this.name === n.name && this.publicId === n.publicId && this.systemId === n.systemId;
      } }
    });
    Object.defineProperties(DocumentType.prototype, ChildNode);
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/HTMLParser.js
var require_HTMLParser = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/HTMLParser.js"(exports, module) {
    "use strict";
    module.exports = HTMLParser;
    var Document = require_Document();
    var DocumentType = require_DocumentType();
    var Node = require_Node();
    var NAMESPACE = require_utils().NAMESPACE;
    var html = require_htmlelts();
    var impl = html.elements;
    var pushAll = Function.prototype.apply.bind(Array.prototype.push);
    var EOF = -1;
    var TEXT = 1;
    var TAG = 2;
    var ENDTAG = 3;
    var COMMENT = 4;
    var DOCTYPE = 5;
    var NOATTRS = [];
    var quirkyPublicIds = /^HTML$|^-\/\/W3O\/\/DTD W3 HTML Strict 3\.0\/\/EN\/\/$|^-\/W3C\/DTD HTML 4\.0 Transitional\/EN$|^\+\/\/Silmaril\/\/dtd html Pro v0r11 19970101\/\/|^-\/\/AdvaSoft Ltd\/\/DTD HTML 3\.0 asWedit \+ extensions\/\/|^-\/\/AS\/\/DTD HTML 3\.0 asWedit \+ extensions\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Level 1\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Level 2\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict Level 1\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict Level 2\/\/|^-\/\/IETF\/\/DTD HTML 2\.0 Strict\/\/|^-\/\/IETF\/\/DTD HTML 2\.0\/\/|^-\/\/IETF\/\/DTD HTML 2\.1E\/\/|^-\/\/IETF\/\/DTD HTML 3\.0\/\/|^-\/\/IETF\/\/DTD HTML 3\.2 Final\/\/|^-\/\/IETF\/\/DTD HTML 3\.2\/\/|^-\/\/IETF\/\/DTD HTML 3\/\/|^-\/\/IETF\/\/DTD HTML Level 0\/\/|^-\/\/IETF\/\/DTD HTML Level 1\/\/|^-\/\/IETF\/\/DTD HTML Level 2\/\/|^-\/\/IETF\/\/DTD HTML Level 3\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 0\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 1\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 2\/\/|^-\/\/IETF\/\/DTD HTML Strict Level 3\/\/|^-\/\/IETF\/\/DTD HTML Strict\/\/|^-\/\/IETF\/\/DTD HTML\/\/|^-\/\/Metrius\/\/DTD Metrius Presentational\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 HTML Strict\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 HTML\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 2\.0 Tables\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 HTML Strict\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 HTML\/\/|^-\/\/Microsoft\/\/DTD Internet Explorer 3\.0 Tables\/\/|^-\/\/Netscape Comm\. Corp\.\/\/DTD HTML\/\/|^-\/\/Netscape Comm\. Corp\.\/\/DTD Strict HTML\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML 2\.0\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML Extended 1\.0\/\/|^-\/\/O'Reilly and Associates\/\/DTD HTML Extended Relaxed 1\.0\/\/|^-\/\/SoftQuad Software\/\/DTD HoTMetaL PRO 6\.0::19990601::extensions to HTML 4\.0\/\/|^-\/\/SoftQuad\/\/DTD HoTMetaL PRO 4\.0::19971010::extensions to HTML 4\.0\/\/|^-\/\/Spyglass\/\/DTD HTML 2\.0 Extended\/\/|^-\/\/SQ\/\/DTD HTML 2\.0 HoTMetaL \+ extensions\/\/|^-\/\/Sun Microsystems Corp\.\/\/DTD HotJava HTML\/\/|^-\/\/Sun Microsystems Corp\.\/\/DTD HotJava Strict HTML\/\/|^-\/\/W3C\/\/DTD HTML 3 1995-03-24\/\/|^-\/\/W3C\/\/DTD HTML 3\.2 Draft\/\/|^-\/\/W3C\/\/DTD HTML 3\.2 Final\/\/|^-\/\/W3C\/\/DTD HTML 3\.2\/\/|^-\/\/W3C\/\/DTD HTML 3\.2S Draft\/\/|^-\/\/W3C\/\/DTD HTML 4\.0 Frameset\/\/|^-\/\/W3C\/\/DTD HTML 4\.0 Transitional\/\/|^-\/\/W3C\/\/DTD HTML Experimental 19960712\/\/|^-\/\/W3C\/\/DTD HTML Experimental 970421\/\/|^-\/\/W3C\/\/DTD W3 HTML\/\/|^-\/\/W3O\/\/DTD W3 HTML 3\.0\/\/|^-\/\/WebTechs\/\/DTD Mozilla HTML 2\.0\/\/|^-\/\/WebTechs\/\/DTD Mozilla HTML\/\//i;
    var quirkySystemId = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";
    var conditionallyQuirkyPublicIds = /^-\/\/W3C\/\/DTD HTML 4\.01 Frameset\/\/|^-\/\/W3C\/\/DTD HTML 4\.01 Transitional\/\//i;
    var limitedQuirkyPublicIds = /^-\/\/W3C\/\/DTD XHTML 1\.0 Frameset\/\/|^-\/\/W3C\/\/DTD XHTML 1\.0 Transitional\/\//i;
    var specialSet = /* @__PURE__ */ Object.create(null);
    specialSet[NAMESPACE.HTML] = {
      __proto__: null,
      "address": true,
      "applet": true,
      "area": true,
      "article": true,
      "aside": true,
      "base": true,
      "basefont": true,
      "bgsound": true,
      "blockquote": true,
      "body": true,
      "br": true,
      "button": true,
      "caption": true,
      "center": true,
      "col": true,
      "colgroup": true,
      "dd": true,
      "details": true,
      "dir": true,
      "div": true,
      "dl": true,
      "dt": true,
      "embed": true,
      "fieldset": true,
      "figcaption": true,
      "figure": true,
      "footer": true,
      "form": true,
      "frame": true,
      "frameset": true,
      "h1": true,
      "h2": true,
      "h3": true,
      "h4": true,
      "h5": true,
      "h6": true,
      "head": true,
      "header": true,
      "hgroup": true,
      "hr": true,
      "html": true,
      "iframe": true,
      "img": true,
      "input": true,
      "li": true,
      "link": true,
      "listing": true,
      "main": true,
      "marquee": true,
      "menu": true,
      "meta": true,
      "nav": true,
      "noembed": true,
      "noframes": true,
      "noscript": true,
      "object": true,
      "ol": true,
      "p": true,
      "param": true,
      "plaintext": true,
      "pre": true,
      "script": true,
      "section": true,
      "select": true,
      "source": true,
      "style": true,
      "summary": true,
      "table": true,
      "tbody": true,
      "td": true,
      "template": true,
      "textarea": true,
      "tfoot": true,
      "th": true,
      "thead": true,
      "title": true,
      "tr": true,
      "track": true,
      // Note that "xmp" was removed from the "special" set in the latest
      // spec, apparently by accident; see
      // https://github.com/whatwg/html/pull/1919
      "ul": true,
      "wbr": true,
      "xmp": true
    };
    specialSet[NAMESPACE.SVG] = {
      __proto__: null,
      "foreignObject": true,
      "desc": true,
      "title": true
    };
    specialSet[NAMESPACE.MATHML] = {
      __proto__: null,
      "mi": true,
      "mo": true,
      "mn": true,
      "ms": true,
      "mtext": true,
      "annotation-xml": true
    };
    var addressdivpSet = /* @__PURE__ */ Object.create(null);
    addressdivpSet[NAMESPACE.HTML] = {
      __proto__: null,
      "address": true,
      "div": true,
      "p": true
    };
    var dddtSet = /* @__PURE__ */ Object.create(null);
    dddtSet[NAMESPACE.HTML] = {
      __proto__: null,
      "dd": true,
      "dt": true
    };
    var tablesectionrowSet = /* @__PURE__ */ Object.create(null);
    tablesectionrowSet[NAMESPACE.HTML] = {
      __proto__: null,
      "table": true,
      "thead": true,
      "tbody": true,
      "tfoot": true,
      "tr": true
    };
    var impliedEndTagsSet = /* @__PURE__ */ Object.create(null);
    impliedEndTagsSet[NAMESPACE.HTML] = {
      __proto__: null,
      "dd": true,
      "dt": true,
      "li": true,
      "menuitem": true,
      "optgroup": true,
      "option": true,
      "p": true,
      "rb": true,
      "rp": true,
      "rt": true,
      "rtc": true
    };
    var thoroughImpliedEndTagsSet = /* @__PURE__ */ Object.create(null);
    thoroughImpliedEndTagsSet[NAMESPACE.HTML] = {
      __proto__: null,
      "caption": true,
      "colgroup": true,
      "dd": true,
      "dt": true,
      "li": true,
      "optgroup": true,
      "option": true,
      "p": true,
      "rb": true,
      "rp": true,
      "rt": true,
      "rtc": true,
      "tbody": true,
      "td": true,
      "tfoot": true,
      "th": true,
      "thead": true,
      "tr": true
    };
    var tableContextSet = /* @__PURE__ */ Object.create(null);
    tableContextSet[NAMESPACE.HTML] = {
      __proto__: null,
      "table": true,
      "template": true,
      "html": true
    };
    var tableBodyContextSet = /* @__PURE__ */ Object.create(null);
    tableBodyContextSet[NAMESPACE.HTML] = {
      __proto__: null,
      "tbody": true,
      "tfoot": true,
      "thead": true,
      "template": true,
      "html": true
    };
    var tableRowContextSet = /* @__PURE__ */ Object.create(null);
    tableRowContextSet[NAMESPACE.HTML] = {
      __proto__: null,
      "tr": true,
      "template": true,
      "html": true
    };
    var formassociatedSet = /* @__PURE__ */ Object.create(null);
    formassociatedSet[NAMESPACE.HTML] = {
      __proto__: null,
      "button": true,
      "fieldset": true,
      "input": true,
      "keygen": true,
      "object": true,
      "output": true,
      "select": true,
      "textarea": true,
      "img": true
    };
    var inScopeSet = /* @__PURE__ */ Object.create(null);
    inScopeSet[NAMESPACE.HTML] = {
      __proto__: null,
      "applet": true,
      "caption": true,
      "html": true,
      "table": true,
      "td": true,
      "th": true,
      "marquee": true,
      "object": true,
      "template": true
    };
    inScopeSet[NAMESPACE.MATHML] = {
      __proto__: null,
      "mi": true,
      "mo": true,
      "mn": true,
      "ms": true,
      "mtext": true,
      "annotation-xml": true
    };
    inScopeSet[NAMESPACE.SVG] = {
      __proto__: null,
      "foreignObject": true,
      "desc": true,
      "title": true
    };
    var inListItemScopeSet = Object.create(inScopeSet);
    inListItemScopeSet[NAMESPACE.HTML] = Object.create(inScopeSet[NAMESPACE.HTML]);
    inListItemScopeSet[NAMESPACE.HTML].ol = true;
    inListItemScopeSet[NAMESPACE.HTML].ul = true;
    var inButtonScopeSet = Object.create(inScopeSet);
    inButtonScopeSet[NAMESPACE.HTML] = Object.create(inScopeSet[NAMESPACE.HTML]);
    inButtonScopeSet[NAMESPACE.HTML].button = true;
    var inTableScopeSet = /* @__PURE__ */ Object.create(null);
    inTableScopeSet[NAMESPACE.HTML] = {
      __proto__: null,
      "html": true,
      "table": true,
      "template": true
    };
    var invertedSelectScopeSet = /* @__PURE__ */ Object.create(null);
    invertedSelectScopeSet[NAMESPACE.HTML] = {
      __proto__: null,
      "optgroup": true,
      "option": true
    };
    var mathmlTextIntegrationPointSet = /* @__PURE__ */ Object.create(null);
    mathmlTextIntegrationPointSet[NAMESPACE.MATHML] = {
      __proto__: null,
      mi: true,
      mo: true,
      mn: true,
      ms: true,
      mtext: true
    };
    var htmlIntegrationPointSet = /* @__PURE__ */ Object.create(null);
    htmlIntegrationPointSet[NAMESPACE.SVG] = {
      __proto__: null,
      foreignObject: true,
      desc: true,
      title: true
    };
    var foreignAttributes = {
      __proto__: null,
      "xlink:actuate": NAMESPACE.XLINK,
      "xlink:arcrole": NAMESPACE.XLINK,
      "xlink:href": NAMESPACE.XLINK,
      "xlink:role": NAMESPACE.XLINK,
      "xlink:show": NAMESPACE.XLINK,
      "xlink:title": NAMESPACE.XLINK,
      "xlink:type": NAMESPACE.XLINK,
      "xml:base": NAMESPACE.XML,
      "xml:lang": NAMESPACE.XML,
      "xml:space": NAMESPACE.XML,
      "xmlns": NAMESPACE.XMLNS,
      "xmlns:xlink": NAMESPACE.XMLNS
    };
    var svgAttrAdjustments = {
      __proto__: null,
      attributename: "attributeName",
      attributetype: "attributeType",
      basefrequency: "baseFrequency",
      baseprofile: "baseProfile",
      calcmode: "calcMode",
      clippathunits: "clipPathUnits",
      diffuseconstant: "diffuseConstant",
      edgemode: "edgeMode",
      filterunits: "filterUnits",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      limitingconeangle: "limitingConeAngle",
      markerheight: "markerHeight",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      numoctaves: "numOctaves",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      refx: "refX",
      refy: "refY",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stitchtiles: "stitchTiles",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textlength: "textLength",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      xchannelselector: "xChannelSelector",
      ychannelselector: "yChannelSelector",
      zoomandpan: "zoomAndPan"
    };
    var svgTagNameAdjustments = {
      __proto__: null,
      altglyph: "altGlyph",
      altglyphdef: "altGlyphDef",
      altglyphitem: "altGlyphItem",
      animatecolor: "animateColor",
      animatemotion: "animateMotion",
      animatetransform: "animateTransform",
      clippath: "clipPath",
      feblend: "feBlend",
      fecolormatrix: "feColorMatrix",
      fecomponenttransfer: "feComponentTransfer",
      fecomposite: "feComposite",
      feconvolvematrix: "feConvolveMatrix",
      fediffuselighting: "feDiffuseLighting",
      fedisplacementmap: "feDisplacementMap",
      fedistantlight: "feDistantLight",
      feflood: "feFlood",
      fefunca: "feFuncA",
      fefuncb: "feFuncB",
      fefuncg: "feFuncG",
      fefuncr: "feFuncR",
      fegaussianblur: "feGaussianBlur",
      feimage: "feImage",
      femerge: "feMerge",
      femergenode: "feMergeNode",
      femorphology: "feMorphology",
      feoffset: "feOffset",
      fepointlight: "fePointLight",
      fespecularlighting: "feSpecularLighting",
      fespotlight: "feSpotLight",
      fetile: "feTile",
      feturbulence: "feTurbulence",
      foreignobject: "foreignObject",
      glyphref: "glyphRef",
      lineargradient: "linearGradient",
      radialgradient: "radialGradient",
      textpath: "textPath"
    };
    var numericCharRefReplacements = {
      __proto__: null,
      0: 65533,
      128: 8364,
      130: 8218,
      131: 402,
      132: 8222,
      133: 8230,
      134: 8224,
      135: 8225,
      136: 710,
      137: 8240,
      138: 352,
      139: 8249,
      140: 338,
      142: 381,
      145: 8216,
      146: 8217,
      147: 8220,
      148: 8221,
      149: 8226,
      150: 8211,
      151: 8212,
      152: 732,
      153: 8482,
      154: 353,
      155: 8250,
      156: 339,
      158: 382,
      159: 376
    };
    var namedCharRefs = {
      __proto__: null,
      "AElig": 198,
      "AElig;": 198,
      "AMP": 38,
      "AMP;": 38,
      "Aacute": 193,
      "Aacute;": 193,
      "Abreve;": 258,
      "Acirc": 194,
      "Acirc;": 194,
      "Acy;": 1040,
      "Afr;": [55349, 56580],
      "Agrave": 192,
      "Agrave;": 192,
      "Alpha;": 913,
      "Amacr;": 256,
      "And;": 10835,
      "Aogon;": 260,
      "Aopf;": [55349, 56632],
      "ApplyFunction;": 8289,
      "Aring": 197,
      "Aring;": 197,
      "Ascr;": [55349, 56476],
      "Assign;": 8788,
      "Atilde": 195,
      "Atilde;": 195,
      "Auml": 196,
      "Auml;": 196,
      "Backslash;": 8726,
      "Barv;": 10983,
      "Barwed;": 8966,
      "Bcy;": 1041,
      "Because;": 8757,
      "Bernoullis;": 8492,
      "Beta;": 914,
      "Bfr;": [55349, 56581],
      "Bopf;": [55349, 56633],
      "Breve;": 728,
      "Bscr;": 8492,
      "Bumpeq;": 8782,
      "CHcy;": 1063,
      "COPY": 169,
      "COPY;": 169,
      "Cacute;": 262,
      "Cap;": 8914,
      "CapitalDifferentialD;": 8517,
      "Cayleys;": 8493,
      "Ccaron;": 268,
      "Ccedil": 199,
      "Ccedil;": 199,
      "Ccirc;": 264,
      "Cconint;": 8752,
      "Cdot;": 266,
      "Cedilla;": 184,
      "CenterDot;": 183,
      "Cfr;": 8493,
      "Chi;": 935,
      "CircleDot;": 8857,
      "CircleMinus;": 8854,
      "CirclePlus;": 8853,
      "CircleTimes;": 8855,
      "ClockwiseContourIntegral;": 8754,
      "CloseCurlyDoubleQuote;": 8221,
      "CloseCurlyQuote;": 8217,
      "Colon;": 8759,
      "Colone;": 10868,
      "Congruent;": 8801,
      "Conint;": 8751,
      "ContourIntegral;": 8750,
      "Copf;": 8450,
      "Coproduct;": 8720,
      "CounterClockwiseContourIntegral;": 8755,
      "Cross;": 10799,
      "Cscr;": [55349, 56478],
      "Cup;": 8915,
      "CupCap;": 8781,
      "DD;": 8517,
      "DDotrahd;": 10513,
      "DJcy;": 1026,
      "DScy;": 1029,
      "DZcy;": 1039,
      "Dagger;": 8225,
      "Darr;": 8609,
      "Dashv;": 10980,
      "Dcaron;": 270,
      "Dcy;": 1044,
      "Del;": 8711,
      "Delta;": 916,
      "Dfr;": [55349, 56583],
      "DiacriticalAcute;": 180,
      "DiacriticalDot;": 729,
      "DiacriticalDoubleAcute;": 733,
      "DiacriticalGrave;": 96,
      "DiacriticalTilde;": 732,
      "Diamond;": 8900,
      "DifferentialD;": 8518,
      "Dopf;": [55349, 56635],
      "Dot;": 168,
      "DotDot;": 8412,
      "DotEqual;": 8784,
      "DoubleContourIntegral;": 8751,
      "DoubleDot;": 168,
      "DoubleDownArrow;": 8659,
      "DoubleLeftArrow;": 8656,
      "DoubleLeftRightArrow;": 8660,
      "DoubleLeftTee;": 10980,
      "DoubleLongLeftArrow;": 10232,
      "DoubleLongLeftRightArrow;": 10234,
      "DoubleLongRightArrow;": 10233,
      "DoubleRightArrow;": 8658,
      "DoubleRightTee;": 8872,
      "DoubleUpArrow;": 8657,
      "DoubleUpDownArrow;": 8661,
      "DoubleVerticalBar;": 8741,
      "DownArrow;": 8595,
      "DownArrowBar;": 10515,
      "DownArrowUpArrow;": 8693,
      "DownBreve;": 785,
      "DownLeftRightVector;": 10576,
      "DownLeftTeeVector;": 10590,
      "DownLeftVector;": 8637,
      "DownLeftVectorBar;": 10582,
      "DownRightTeeVector;": 10591,
      "DownRightVector;": 8641,
      "DownRightVectorBar;": 10583,
      "DownTee;": 8868,
      "DownTeeArrow;": 8615,
      "Downarrow;": 8659,
      "Dscr;": [55349, 56479],
      "Dstrok;": 272,
      "ENG;": 330,
      "ETH": 208,
      "ETH;": 208,
      "Eacute": 201,
      "Eacute;": 201,
      "Ecaron;": 282,
      "Ecirc": 202,
      "Ecirc;": 202,
      "Ecy;": 1069,
      "Edot;": 278,
      "Efr;": [55349, 56584],
      "Egrave": 200,
      "Egrave;": 200,
      "Element;": 8712,
      "Emacr;": 274,
      "EmptySmallSquare;": 9723,
      "EmptyVerySmallSquare;": 9643,
      "Eogon;": 280,
      "Eopf;": [55349, 56636],
      "Epsilon;": 917,
      "Equal;": 10869,
      "EqualTilde;": 8770,
      "Equilibrium;": 8652,
      "Escr;": 8496,
      "Esim;": 10867,
      "Eta;": 919,
      "Euml": 203,
      "Euml;": 203,
      "Exists;": 8707,
      "ExponentialE;": 8519,
      "Fcy;": 1060,
      "Ffr;": [55349, 56585],
      "FilledSmallSquare;": 9724,
      "FilledVerySmallSquare;": 9642,
      "Fopf;": [55349, 56637],
      "ForAll;": 8704,
      "Fouriertrf;": 8497,
      "Fscr;": 8497,
      "GJcy;": 1027,
      "GT": 62,
      "GT;": 62,
      "Gamma;": 915,
      "Gammad;": 988,
      "Gbreve;": 286,
      "Gcedil;": 290,
      "Gcirc;": 284,
      "Gcy;": 1043,
      "Gdot;": 288,
      "Gfr;": [55349, 56586],
      "Gg;": 8921,
      "Gopf;": [55349, 56638],
      "GreaterEqual;": 8805,
      "GreaterEqualLess;": 8923,
      "GreaterFullEqual;": 8807,
      "GreaterGreater;": 10914,
      "GreaterLess;": 8823,
      "GreaterSlantEqual;": 10878,
      "GreaterTilde;": 8819,
      "Gscr;": [55349, 56482],
      "Gt;": 8811,
      "HARDcy;": 1066,
      "Hacek;": 711,
      "Hat;": 94,
      "Hcirc;": 292,
      "Hfr;": 8460,
      "HilbertSpace;": 8459,
      "Hopf;": 8461,
      "HorizontalLine;": 9472,
      "Hscr;": 8459,
      "Hstrok;": 294,
      "HumpDownHump;": 8782,
      "HumpEqual;": 8783,
      "IEcy;": 1045,
      "IJlig;": 306,
      "IOcy;": 1025,
      "Iacute": 205,
      "Iacute;": 205,
      "Icirc": 206,
      "Icirc;": 206,
      "Icy;": 1048,
      "Idot;": 304,
      "Ifr;": 8465,
      "Igrave": 204,
      "Igrave;": 204,
      "Im;": 8465,
      "Imacr;": 298,
      "ImaginaryI;": 8520,
      "Implies;": 8658,
      "Int;": 8748,
      "Integral;": 8747,
      "Intersection;": 8898,
      "InvisibleComma;": 8291,
      "InvisibleTimes;": 8290,
      "Iogon;": 302,
      "Iopf;": [55349, 56640],
      "Iota;": 921,
      "Iscr;": 8464,
      "Itilde;": 296,
      "Iukcy;": 1030,
      "Iuml": 207,
      "Iuml;": 207,
      "Jcirc;": 308,
      "Jcy;": 1049,
      "Jfr;": [55349, 56589],
      "Jopf;": [55349, 56641],
      "Jscr;": [55349, 56485],
      "Jsercy;": 1032,
      "Jukcy;": 1028,
      "KHcy;": 1061,
      "KJcy;": 1036,
      "Kappa;": 922,
      "Kcedil;": 310,
      "Kcy;": 1050,
      "Kfr;": [55349, 56590],
      "Kopf;": [55349, 56642],
      "Kscr;": [55349, 56486],
      "LJcy;": 1033,
      "LT": 60,
      "LT;": 60,
      "Lacute;": 313,
      "Lambda;": 923,
      "Lang;": 10218,
      "Laplacetrf;": 8466,
      "Larr;": 8606,
      "Lcaron;": 317,
      "Lcedil;": 315,
      "Lcy;": 1051,
      "LeftAngleBracket;": 10216,
      "LeftArrow;": 8592,
      "LeftArrowBar;": 8676,
      "LeftArrowRightArrow;": 8646,
      "LeftCeiling;": 8968,
      "LeftDoubleBracket;": 10214,
      "LeftDownTeeVector;": 10593,
      "LeftDownVector;": 8643,
      "LeftDownVectorBar;": 10585,
      "LeftFloor;": 8970,
      "LeftRightArrow;": 8596,
      "LeftRightVector;": 10574,
      "LeftTee;": 8867,
      "LeftTeeArrow;": 8612,
      "LeftTeeVector;": 10586,
      "LeftTriangle;": 8882,
      "LeftTriangleBar;": 10703,
      "LeftTriangleEqual;": 8884,
      "LeftUpDownVector;": 10577,
      "LeftUpTeeVector;": 10592,
      "LeftUpVector;": 8639,
      "LeftUpVectorBar;": 10584,
      "LeftVector;": 8636,
      "LeftVectorBar;": 10578,
      "Leftarrow;": 8656,
      "Leftrightarrow;": 8660,
      "LessEqualGreater;": 8922,
      "LessFullEqual;": 8806,
      "LessGreater;": 8822,
      "LessLess;": 10913,
      "LessSlantEqual;": 10877,
      "LessTilde;": 8818,
      "Lfr;": [55349, 56591],
      "Ll;": 8920,
      "Lleftarrow;": 8666,
      "Lmidot;": 319,
      "LongLeftArrow;": 10229,
      "LongLeftRightArrow;": 10231,
      "LongRightArrow;": 10230,
      "Longleftarrow;": 10232,
      "Longleftrightarrow;": 10234,
      "Longrightarrow;": 10233,
      "Lopf;": [55349, 56643],
      "LowerLeftArrow;": 8601,
      "LowerRightArrow;": 8600,
      "Lscr;": 8466,
      "Lsh;": 8624,
      "Lstrok;": 321,
      "Lt;": 8810,
      "Map;": 10501,
      "Mcy;": 1052,
      "MediumSpace;": 8287,
      "Mellintrf;": 8499,
      "Mfr;": [55349, 56592],
      "MinusPlus;": 8723,
      "Mopf;": [55349, 56644],
      "Mscr;": 8499,
      "Mu;": 924,
      "NJcy;": 1034,
      "Nacute;": 323,
      "Ncaron;": 327,
      "Ncedil;": 325,
      "Ncy;": 1053,
      "NegativeMediumSpace;": 8203,
      "NegativeThickSpace;": 8203,
      "NegativeThinSpace;": 8203,
      "NegativeVeryThinSpace;": 8203,
      "NestedGreaterGreater;": 8811,
      "NestedLessLess;": 8810,
      "NewLine;": 10,
      "Nfr;": [55349, 56593],
      "NoBreak;": 8288,
      "NonBreakingSpace;": 160,
      "Nopf;": 8469,
      "Not;": 10988,
      "NotCongruent;": 8802,
      "NotCupCap;": 8813,
      "NotDoubleVerticalBar;": 8742,
      "NotElement;": 8713,
      "NotEqual;": 8800,
      "NotEqualTilde;": [8770, 824],
      "NotExists;": 8708,
      "NotGreater;": 8815,
      "NotGreaterEqual;": 8817,
      "NotGreaterFullEqual;": [8807, 824],
      "NotGreaterGreater;": [8811, 824],
      "NotGreaterLess;": 8825,
      "NotGreaterSlantEqual;": [10878, 824],
      "NotGreaterTilde;": 8821,
      "NotHumpDownHump;": [8782, 824],
      "NotHumpEqual;": [8783, 824],
      "NotLeftTriangle;": 8938,
      "NotLeftTriangleBar;": [10703, 824],
      "NotLeftTriangleEqual;": 8940,
      "NotLess;": 8814,
      "NotLessEqual;": 8816,
      "NotLessGreater;": 8824,
      "NotLessLess;": [8810, 824],
      "NotLessSlantEqual;": [10877, 824],
      "NotLessTilde;": 8820,
      "NotNestedGreaterGreater;": [10914, 824],
      "NotNestedLessLess;": [10913, 824],
      "NotPrecedes;": 8832,
      "NotPrecedesEqual;": [10927, 824],
      "NotPrecedesSlantEqual;": 8928,
      "NotReverseElement;": 8716,
      "NotRightTriangle;": 8939,
      "NotRightTriangleBar;": [10704, 824],
      "NotRightTriangleEqual;": 8941,
      "NotSquareSubset;": [8847, 824],
      "NotSquareSubsetEqual;": 8930,
      "NotSquareSuperset;": [8848, 824],
      "NotSquareSupersetEqual;": 8931,
      "NotSubset;": [8834, 8402],
      "NotSubsetEqual;": 8840,
      "NotSucceeds;": 8833,
      "NotSucceedsEqual;": [10928, 824],
      "NotSucceedsSlantEqual;": 8929,
      "NotSucceedsTilde;": [8831, 824],
      "NotSuperset;": [8835, 8402],
      "NotSupersetEqual;": 8841,
      "NotTilde;": 8769,
      "NotTildeEqual;": 8772,
      "NotTildeFullEqual;": 8775,
      "NotTildeTilde;": 8777,
      "NotVerticalBar;": 8740,
      "Nscr;": [55349, 56489],
      "Ntilde": 209,
      "Ntilde;": 209,
      "Nu;": 925,
      "OElig;": 338,
      "Oacute": 211,
      "Oacute;": 211,
      "Ocirc": 212,
      "Ocirc;": 212,
      "Ocy;": 1054,
      "Odblac;": 336,
      "Ofr;": [55349, 56594],
      "Ograve": 210,
      "Ograve;": 210,
      "Omacr;": 332,
      "Omega;": 937,
      "Omicron;": 927,
      "Oopf;": [55349, 56646],
      "OpenCurlyDoubleQuote;": 8220,
      "OpenCurlyQuote;": 8216,
      "Or;": 10836,
      "Oscr;": [55349, 56490],
      "Oslash": 216,
      "Oslash;": 216,
      "Otilde": 213,
      "Otilde;": 213,
      "Otimes;": 10807,
      "Ouml": 214,
      "Ouml;": 214,
      "OverBar;": 8254,
      "OverBrace;": 9182,
      "OverBracket;": 9140,
      "OverParenthesis;": 9180,
      "PartialD;": 8706,
      "Pcy;": 1055,
      "Pfr;": [55349, 56595],
      "Phi;": 934,
      "Pi;": 928,
      "PlusMinus;": 177,
      "Poincareplane;": 8460,
      "Popf;": 8473,
      "Pr;": 10939,
      "Precedes;": 8826,
      "PrecedesEqual;": 10927,
      "PrecedesSlantEqual;": 8828,
      "PrecedesTilde;": 8830,
      "Prime;": 8243,
      "Product;": 8719,
      "Proportion;": 8759,
      "Proportional;": 8733,
      "Pscr;": [55349, 56491],
      "Psi;": 936,
      "QUOT": 34,
      "QUOT;": 34,
      "Qfr;": [55349, 56596],
      "Qopf;": 8474,
      "Qscr;": [55349, 56492],
      "RBarr;": 10512,
      "REG": 174,
      "REG;": 174,
      "Racute;": 340,
      "Rang;": 10219,
      "Rarr;": 8608,
      "Rarrtl;": 10518,
      "Rcaron;": 344,
      "Rcedil;": 342,
      "Rcy;": 1056,
      "Re;": 8476,
      "ReverseElement;": 8715,
      "ReverseEquilibrium;": 8651,
      "ReverseUpEquilibrium;": 10607,
      "Rfr;": 8476,
      "Rho;": 929,
      "RightAngleBracket;": 10217,
      "RightArrow;": 8594,
      "RightArrowBar;": 8677,
      "RightArrowLeftArrow;": 8644,
      "RightCeiling;": 8969,
      "RightDoubleBracket;": 10215,
      "RightDownTeeVector;": 10589,
      "RightDownVector;": 8642,
      "RightDownVectorBar;": 10581,
      "RightFloor;": 8971,
      "RightTee;": 8866,
      "RightTeeArrow;": 8614,
      "RightTeeVector;": 10587,
      "RightTriangle;": 8883,
      "RightTriangleBar;": 10704,
      "RightTriangleEqual;": 8885,
      "RightUpDownVector;": 10575,
      "RightUpTeeVector;": 10588,
      "RightUpVector;": 8638,
      "RightUpVectorBar;": 10580,
      "RightVector;": 8640,
      "RightVectorBar;": 10579,
      "Rightarrow;": 8658,
      "Ropf;": 8477,
      "RoundImplies;": 10608,
      "Rrightarrow;": 8667,
      "Rscr;": 8475,
      "Rsh;": 8625,
      "RuleDelayed;": 10740,
      "SHCHcy;": 1065,
      "SHcy;": 1064,
      "SOFTcy;": 1068,
      "Sacute;": 346,
      "Sc;": 10940,
      "Scaron;": 352,
      "Scedil;": 350,
      "Scirc;": 348,
      "Scy;": 1057,
      "Sfr;": [55349, 56598],
      "ShortDownArrow;": 8595,
      "ShortLeftArrow;": 8592,
      "ShortRightArrow;": 8594,
      "ShortUpArrow;": 8593,
      "Sigma;": 931,
      "SmallCircle;": 8728,
      "Sopf;": [55349, 56650],
      "Sqrt;": 8730,
      "Square;": 9633,
      "SquareIntersection;": 8851,
      "SquareSubset;": 8847,
      "SquareSubsetEqual;": 8849,
      "SquareSuperset;": 8848,
      "SquareSupersetEqual;": 8850,
      "SquareUnion;": 8852,
      "Sscr;": [55349, 56494],
      "Star;": 8902,
      "Sub;": 8912,
      "Subset;": 8912,
      "SubsetEqual;": 8838,
      "Succeeds;": 8827,
      "SucceedsEqual;": 10928,
      "SucceedsSlantEqual;": 8829,
      "SucceedsTilde;": 8831,
      "SuchThat;": 8715,
      "Sum;": 8721,
      "Sup;": 8913,
      "Superset;": 8835,
      "SupersetEqual;": 8839,
      "Supset;": 8913,
      "THORN": 222,
      "THORN;": 222,
      "TRADE;": 8482,
      "TSHcy;": 1035,
      "TScy;": 1062,
      "Tab;": 9,
      "Tau;": 932,
      "Tcaron;": 356,
      "Tcedil;": 354,
      "Tcy;": 1058,
      "Tfr;": [55349, 56599],
      "Therefore;": 8756,
      "Theta;": 920,
      "ThickSpace;": [8287, 8202],
      "ThinSpace;": 8201,
      "Tilde;": 8764,
      "TildeEqual;": 8771,
      "TildeFullEqual;": 8773,
      "TildeTilde;": 8776,
      "Topf;": [55349, 56651],
      "TripleDot;": 8411,
      "Tscr;": [55349, 56495],
      "Tstrok;": 358,
      "Uacute": 218,
      "Uacute;": 218,
      "Uarr;": 8607,
      "Uarrocir;": 10569,
      "Ubrcy;": 1038,
      "Ubreve;": 364,
      "Ucirc": 219,
      "Ucirc;": 219,
      "Ucy;": 1059,
      "Udblac;": 368,
      "Ufr;": [55349, 56600],
      "Ugrave": 217,
      "Ugrave;": 217,
      "Umacr;": 362,
      "UnderBar;": 95,
      "UnderBrace;": 9183,
      "UnderBracket;": 9141,
      "UnderParenthesis;": 9181,
      "Union;": 8899,
      "UnionPlus;": 8846,
      "Uogon;": 370,
      "Uopf;": [55349, 56652],
      "UpArrow;": 8593,
      "UpArrowBar;": 10514,
      "UpArrowDownArrow;": 8645,
      "UpDownArrow;": 8597,
      "UpEquilibrium;": 10606,
      "UpTee;": 8869,
      "UpTeeArrow;": 8613,
      "Uparrow;": 8657,
      "Updownarrow;": 8661,
      "UpperLeftArrow;": 8598,
      "UpperRightArrow;": 8599,
      "Upsi;": 978,
      "Upsilon;": 933,
      "Uring;": 366,
      "Uscr;": [55349, 56496],
      "Utilde;": 360,
      "Uuml": 220,
      "Uuml;": 220,
      "VDash;": 8875,
      "Vbar;": 10987,
      "Vcy;": 1042,
      "Vdash;": 8873,
      "Vdashl;": 10982,
      "Vee;": 8897,
      "Verbar;": 8214,
      "Vert;": 8214,
      "VerticalBar;": 8739,
      "VerticalLine;": 124,
      "VerticalSeparator;": 10072,
      "VerticalTilde;": 8768,
      "VeryThinSpace;": 8202,
      "Vfr;": [55349, 56601],
      "Vopf;": [55349, 56653],
      "Vscr;": [55349, 56497],
      "Vvdash;": 8874,
      "Wcirc;": 372,
      "Wedge;": 8896,
      "Wfr;": [55349, 56602],
      "Wopf;": [55349, 56654],
      "Wscr;": [55349, 56498],
      "Xfr;": [55349, 56603],
      "Xi;": 926,
      "Xopf;": [55349, 56655],
      "Xscr;": [55349, 56499],
      "YAcy;": 1071,
      "YIcy;": 1031,
      "YUcy;": 1070,
      "Yacute": 221,
      "Yacute;": 221,
      "Ycirc;": 374,
      "Ycy;": 1067,
      "Yfr;": [55349, 56604],
      "Yopf;": [55349, 56656],
      "Yscr;": [55349, 56500],
      "Yuml;": 376,
      "ZHcy;": 1046,
      "Zacute;": 377,
      "Zcaron;": 381,
      "Zcy;": 1047,
      "Zdot;": 379,
      "ZeroWidthSpace;": 8203,
      "Zeta;": 918,
      "Zfr;": 8488,
      "Zopf;": 8484,
      "Zscr;": [55349, 56501],
      "aacute": 225,
      "aacute;": 225,
      "abreve;": 259,
      "ac;": 8766,
      "acE;": [8766, 819],
      "acd;": 8767,
      "acirc": 226,
      "acirc;": 226,
      "acute": 180,
      "acute;": 180,
      "acy;": 1072,
      "aelig": 230,
      "aelig;": 230,
      "af;": 8289,
      "afr;": [55349, 56606],
      "agrave": 224,
      "agrave;": 224,
      "alefsym;": 8501,
      "aleph;": 8501,
      "alpha;": 945,
      "amacr;": 257,
      "amalg;": 10815,
      "amp": 38,
      "amp;": 38,
      "and;": 8743,
      "andand;": 10837,
      "andd;": 10844,
      "andslope;": 10840,
      "andv;": 10842,
      "ang;": 8736,
      "ange;": 10660,
      "angle;": 8736,
      "angmsd;": 8737,
      "angmsdaa;": 10664,
      "angmsdab;": 10665,
      "angmsdac;": 10666,
      "angmsdad;": 10667,
      "angmsdae;": 10668,
      "angmsdaf;": 10669,
      "angmsdag;": 10670,
      "angmsdah;": 10671,
      "angrt;": 8735,
      "angrtvb;": 8894,
      "angrtvbd;": 10653,
      "angsph;": 8738,
      "angst;": 197,
      "angzarr;": 9084,
      "aogon;": 261,
      "aopf;": [55349, 56658],
      "ap;": 8776,
      "apE;": 10864,
      "apacir;": 10863,
      "ape;": 8778,
      "apid;": 8779,
      "apos;": 39,
      "approx;": 8776,
      "approxeq;": 8778,
      "aring": 229,
      "aring;": 229,
      "ascr;": [55349, 56502],
      "ast;": 42,
      "asymp;": 8776,
      "asympeq;": 8781,
      "atilde": 227,
      "atilde;": 227,
      "auml": 228,
      "auml;": 228,
      "awconint;": 8755,
      "awint;": 10769,
      "bNot;": 10989,
      "backcong;": 8780,
      "backepsilon;": 1014,
      "backprime;": 8245,
      "backsim;": 8765,
      "backsimeq;": 8909,
      "barvee;": 8893,
      "barwed;": 8965,
      "barwedge;": 8965,
      "bbrk;": 9141,
      "bbrktbrk;": 9142,
      "bcong;": 8780,
      "bcy;": 1073,
      "bdquo;": 8222,
      "becaus;": 8757,
      "because;": 8757,
      "bemptyv;": 10672,
      "bepsi;": 1014,
      "bernou;": 8492,
      "beta;": 946,
      "beth;": 8502,
      "between;": 8812,
      "bfr;": [55349, 56607],
      "bigcap;": 8898,
      "bigcirc;": 9711,
      "bigcup;": 8899,
      "bigodot;": 10752,
      "bigoplus;": 10753,
      "bigotimes;": 10754,
      "bigsqcup;": 10758,
      "bigstar;": 9733,
      "bigtriangledown;": 9661,
      "bigtriangleup;": 9651,
      "biguplus;": 10756,
      "bigvee;": 8897,
      "bigwedge;": 8896,
      "bkarow;": 10509,
      "blacklozenge;": 10731,
      "blacksquare;": 9642,
      "blacktriangle;": 9652,
      "blacktriangledown;": 9662,
      "blacktriangleleft;": 9666,
      "blacktriangleright;": 9656,
      "blank;": 9251,
      "blk12;": 9618,
      "blk14;": 9617,
      "blk34;": 9619,
      "block;": 9608,
      "bne;": [61, 8421],
      "bnequiv;": [8801, 8421],
      "bnot;": 8976,
      "bopf;": [55349, 56659],
      "bot;": 8869,
      "bottom;": 8869,
      "bowtie;": 8904,
      "boxDL;": 9559,
      "boxDR;": 9556,
      "boxDl;": 9558,
      "boxDr;": 9555,
      "boxH;": 9552,
      "boxHD;": 9574,
      "boxHU;": 9577,
      "boxHd;": 9572,
      "boxHu;": 9575,
      "boxUL;": 9565,
      "boxUR;": 9562,
      "boxUl;": 9564,
      "boxUr;": 9561,
      "boxV;": 9553,
      "boxVH;": 9580,
      "boxVL;": 9571,
      "boxVR;": 9568,
      "boxVh;": 9579,
      "boxVl;": 9570,
      "boxVr;": 9567,
      "boxbox;": 10697,
      "boxdL;": 9557,
      "boxdR;": 9554,
      "boxdl;": 9488,
      "boxdr;": 9484,
      "boxh;": 9472,
      "boxhD;": 9573,
      "boxhU;": 9576,
      "boxhd;": 9516,
      "boxhu;": 9524,
      "boxminus;": 8863,
      "boxplus;": 8862,
      "boxtimes;": 8864,
      "boxuL;": 9563,
      "boxuR;": 9560,
      "boxul;": 9496,
      "boxur;": 9492,
      "boxv;": 9474,
      "boxvH;": 9578,
      "boxvL;": 9569,
      "boxvR;": 9566,
      "boxvh;": 9532,
      "boxvl;": 9508,
      "boxvr;": 9500,
      "bprime;": 8245,
      "breve;": 728,
      "brvbar": 166,
      "brvbar;": 166,
      "bscr;": [55349, 56503],
      "bsemi;": 8271,
      "bsim;": 8765,
      "bsime;": 8909,
      "bsol;": 92,
      "bsolb;": 10693,
      "bsolhsub;": 10184,
      "bull;": 8226,
      "bullet;": 8226,
      "bump;": 8782,
      "bumpE;": 10926,
      "bumpe;": 8783,
      "bumpeq;": 8783,
      "cacute;": 263,
      "cap;": 8745,
      "capand;": 10820,
      "capbrcup;": 10825,
      "capcap;": 10827,
      "capcup;": 10823,
      "capdot;": 10816,
      "caps;": [8745, 65024],
      "caret;": 8257,
      "caron;": 711,
      "ccaps;": 10829,
      "ccaron;": 269,
      "ccedil": 231,
      "ccedil;": 231,
      "ccirc;": 265,
      "ccups;": 10828,
      "ccupssm;": 10832,
      "cdot;": 267,
      "cedil": 184,
      "cedil;": 184,
      "cemptyv;": 10674,
      "cent": 162,
      "cent;": 162,
      "centerdot;": 183,
      "cfr;": [55349, 56608],
      "chcy;": 1095,
      "check;": 10003,
      "checkmark;": 10003,
      "chi;": 967,
      "cir;": 9675,
      "cirE;": 10691,
      "circ;": 710,
      "circeq;": 8791,
      "circlearrowleft;": 8634,
      "circlearrowright;": 8635,
      "circledR;": 174,
      "circledS;": 9416,
      "circledast;": 8859,
      "circledcirc;": 8858,
      "circleddash;": 8861,
      "cire;": 8791,
      "cirfnint;": 10768,
      "cirmid;": 10991,
      "cirscir;": 10690,
      "clubs;": 9827,
      "clubsuit;": 9827,
      "colon;": 58,
      "colone;": 8788,
      "coloneq;": 8788,
      "comma;": 44,
      "commat;": 64,
      "comp;": 8705,
      "compfn;": 8728,
      "complement;": 8705,
      "complexes;": 8450,
      "cong;": 8773,
      "congdot;": 10861,
      "conint;": 8750,
      "copf;": [55349, 56660],
      "coprod;": 8720,
      "copy": 169,
      "copy;": 169,
      "copysr;": 8471,
      "crarr;": 8629,
      "cross;": 10007,
      "cscr;": [55349, 56504],
      "csub;": 10959,
      "csube;": 10961,
      "csup;": 10960,
      "csupe;": 10962,
      "ctdot;": 8943,
      "cudarrl;": 10552,
      "cudarrr;": 10549,
      "cuepr;": 8926,
      "cuesc;": 8927,
      "cularr;": 8630,
      "cularrp;": 10557,
      "cup;": 8746,
      "cupbrcap;": 10824,
      "cupcap;": 10822,
      "cupcup;": 10826,
      "cupdot;": 8845,
      "cupor;": 10821,
      "cups;": [8746, 65024],
      "curarr;": 8631,
      "curarrm;": 10556,
      "curlyeqprec;": 8926,
      "curlyeqsucc;": 8927,
      "curlyvee;": 8910,
      "curlywedge;": 8911,
      "curren": 164,
      "curren;": 164,
      "curvearrowleft;": 8630,
      "curvearrowright;": 8631,
      "cuvee;": 8910,
      "cuwed;": 8911,
      "cwconint;": 8754,
      "cwint;": 8753,
      "cylcty;": 9005,
      "dArr;": 8659,
      "dHar;": 10597,
      "dagger;": 8224,
      "daleth;": 8504,
      "darr;": 8595,
      "dash;": 8208,
      "dashv;": 8867,
      "dbkarow;": 10511,
      "dblac;": 733,
      "dcaron;": 271,
      "dcy;": 1076,
      "dd;": 8518,
      "ddagger;": 8225,
      "ddarr;": 8650,
      "ddotseq;": 10871,
      "deg": 176,
      "deg;": 176,
      "delta;": 948,
      "demptyv;": 10673,
      "dfisht;": 10623,
      "dfr;": [55349, 56609],
      "dharl;": 8643,
      "dharr;": 8642,
      "diam;": 8900,
      "diamond;": 8900,
      "diamondsuit;": 9830,
      "diams;": 9830,
      "die;": 168,
      "digamma;": 989,
      "disin;": 8946,
      "div;": 247,
      "divide": 247,
      "divide;": 247,
      "divideontimes;": 8903,
      "divonx;": 8903,
      "djcy;": 1106,
      "dlcorn;": 8990,
      "dlcrop;": 8973,
      "dollar;": 36,
      "dopf;": [55349, 56661],
      "dot;": 729,
      "doteq;": 8784,
      "doteqdot;": 8785,
      "dotminus;": 8760,
      "dotplus;": 8724,
      "dotsquare;": 8865,
      "doublebarwedge;": 8966,
      "downarrow;": 8595,
      "downdownarrows;": 8650,
      "downharpoonleft;": 8643,
      "downharpoonright;": 8642,
      "drbkarow;": 10512,
      "drcorn;": 8991,
      "drcrop;": 8972,
      "dscr;": [55349, 56505],
      "dscy;": 1109,
      "dsol;": 10742,
      "dstrok;": 273,
      "dtdot;": 8945,
      "dtri;": 9663,
      "dtrif;": 9662,
      "duarr;": 8693,
      "duhar;": 10607,
      "dwangle;": 10662,
      "dzcy;": 1119,
      "dzigrarr;": 10239,
      "eDDot;": 10871,
      "eDot;": 8785,
      "eacute": 233,
      "eacute;": 233,
      "easter;": 10862,
      "ecaron;": 283,
      "ecir;": 8790,
      "ecirc": 234,
      "ecirc;": 234,
      "ecolon;": 8789,
      "ecy;": 1101,
      "edot;": 279,
      "ee;": 8519,
      "efDot;": 8786,
      "efr;": [55349, 56610],
      "eg;": 10906,
      "egrave": 232,
      "egrave;": 232,
      "egs;": 10902,
      "egsdot;": 10904,
      "el;": 10905,
      "elinters;": 9191,
      "ell;": 8467,
      "els;": 10901,
      "elsdot;": 10903,
      "emacr;": 275,
      "empty;": 8709,
      "emptyset;": 8709,
      "emptyv;": 8709,
      "emsp13;": 8196,
      "emsp14;": 8197,
      "emsp;": 8195,
      "eng;": 331,
      "ensp;": 8194,
      "eogon;": 281,
      "eopf;": [55349, 56662],
      "epar;": 8917,
      "eparsl;": 10723,
      "eplus;": 10865,
      "epsi;": 949,
      "epsilon;": 949,
      "epsiv;": 1013,
      "eqcirc;": 8790,
      "eqcolon;": 8789,
      "eqsim;": 8770,
      "eqslantgtr;": 10902,
      "eqslantless;": 10901,
      "equals;": 61,
      "equest;": 8799,
      "equiv;": 8801,
      "equivDD;": 10872,
      "eqvparsl;": 10725,
      "erDot;": 8787,
      "erarr;": 10609,
      "escr;": 8495,
      "esdot;": 8784,
      "esim;": 8770,
      "eta;": 951,
      "eth": 240,
      "eth;": 240,
      "euml": 235,
      "euml;": 235,
      "euro;": 8364,
      "excl;": 33,
      "exist;": 8707,
      "expectation;": 8496,
      "exponentiale;": 8519,
      "fallingdotseq;": 8786,
      "fcy;": 1092,
      "female;": 9792,
      "ffilig;": 64259,
      "fflig;": 64256,
      "ffllig;": 64260,
      "ffr;": [55349, 56611],
      "filig;": 64257,
      "fjlig;": [102, 106],
      "flat;": 9837,
      "fllig;": 64258,
      "fltns;": 9649,
      "fnof;": 402,
      "fopf;": [55349, 56663],
      "forall;": 8704,
      "fork;": 8916,
      "forkv;": 10969,
      "fpartint;": 10765,
      "frac12": 189,
      "frac12;": 189,
      "frac13;": 8531,
      "frac14": 188,
      "frac14;": 188,
      "frac15;": 8533,
      "frac16;": 8537,
      "frac18;": 8539,
      "frac23;": 8532,
      "frac25;": 8534,
      "frac34": 190,
      "frac34;": 190,
      "frac35;": 8535,
      "frac38;": 8540,
      "frac45;": 8536,
      "frac56;": 8538,
      "frac58;": 8541,
      "frac78;": 8542,
      "frasl;": 8260,
      "frown;": 8994,
      "fscr;": [55349, 56507],
      "gE;": 8807,
      "gEl;": 10892,
      "gacute;": 501,
      "gamma;": 947,
      "gammad;": 989,
      "gap;": 10886,
      "gbreve;": 287,
      "gcirc;": 285,
      "gcy;": 1075,
      "gdot;": 289,
      "ge;": 8805,
      "gel;": 8923,
      "geq;": 8805,
      "geqq;": 8807,
      "geqslant;": 10878,
      "ges;": 10878,
      "gescc;": 10921,
      "gesdot;": 10880,
      "gesdoto;": 10882,
      "gesdotol;": 10884,
      "gesl;": [8923, 65024],
      "gesles;": 10900,
      "gfr;": [55349, 56612],
      "gg;": 8811,
      "ggg;": 8921,
      "gimel;": 8503,
      "gjcy;": 1107,
      "gl;": 8823,
      "glE;": 10898,
      "gla;": 10917,
      "glj;": 10916,
      "gnE;": 8809,
      "gnap;": 10890,
      "gnapprox;": 10890,
      "gne;": 10888,
      "gneq;": 10888,
      "gneqq;": 8809,
      "gnsim;": 8935,
      "gopf;": [55349, 56664],
      "grave;": 96,
      "gscr;": 8458,
      "gsim;": 8819,
      "gsime;": 10894,
      "gsiml;": 10896,
      "gt": 62,
      "gt;": 62,
      "gtcc;": 10919,
      "gtcir;": 10874,
      "gtdot;": 8919,
      "gtlPar;": 10645,
      "gtquest;": 10876,
      "gtrapprox;": 10886,
      "gtrarr;": 10616,
      "gtrdot;": 8919,
      "gtreqless;": 8923,
      "gtreqqless;": 10892,
      "gtrless;": 8823,
      "gtrsim;": 8819,
      "gvertneqq;": [8809, 65024],
      "gvnE;": [8809, 65024],
      "hArr;": 8660,
      "hairsp;": 8202,
      "half;": 189,
      "hamilt;": 8459,
      "hardcy;": 1098,
      "harr;": 8596,
      "harrcir;": 10568,
      "harrw;": 8621,
      "hbar;": 8463,
      "hcirc;": 293,
      "hearts;": 9829,
      "heartsuit;": 9829,
      "hellip;": 8230,
      "hercon;": 8889,
      "hfr;": [55349, 56613],
      "hksearow;": 10533,
      "hkswarow;": 10534,
      "hoarr;": 8703,
      "homtht;": 8763,
      "hookleftarrow;": 8617,
      "hookrightarrow;": 8618,
      "hopf;": [55349, 56665],
      "horbar;": 8213,
      "hscr;": [55349, 56509],
      "hslash;": 8463,
      "hstrok;": 295,
      "hybull;": 8259,
      "hyphen;": 8208,
      "iacute": 237,
      "iacute;": 237,
      "ic;": 8291,
      "icirc": 238,
      "icirc;": 238,
      "icy;": 1080,
      "iecy;": 1077,
      "iexcl": 161,
      "iexcl;": 161,
      "iff;": 8660,
      "ifr;": [55349, 56614],
      "igrave": 236,
      "igrave;": 236,
      "ii;": 8520,
      "iiiint;": 10764,
      "iiint;": 8749,
      "iinfin;": 10716,
      "iiota;": 8489,
      "ijlig;": 307,
      "imacr;": 299,
      "image;": 8465,
      "imagline;": 8464,
      "imagpart;": 8465,
      "imath;": 305,
      "imof;": 8887,
      "imped;": 437,
      "in;": 8712,
      "incare;": 8453,
      "infin;": 8734,
      "infintie;": 10717,
      "inodot;": 305,
      "int;": 8747,
      "intcal;": 8890,
      "integers;": 8484,
      "intercal;": 8890,
      "intlarhk;": 10775,
      "intprod;": 10812,
      "iocy;": 1105,
      "iogon;": 303,
      "iopf;": [55349, 56666],
      "iota;": 953,
      "iprod;": 10812,
      "iquest": 191,
      "iquest;": 191,
      "iscr;": [55349, 56510],
      "isin;": 8712,
      "isinE;": 8953,
      "isindot;": 8949,
      "isins;": 8948,
      "isinsv;": 8947,
      "isinv;": 8712,
      "it;": 8290,
      "itilde;": 297,
      "iukcy;": 1110,
      "iuml": 239,
      "iuml;": 239,
      "jcirc;": 309,
      "jcy;": 1081,
      "jfr;": [55349, 56615],
      "jmath;": 567,
      "jopf;": [55349, 56667],
      "jscr;": [55349, 56511],
      "jsercy;": 1112,
      "jukcy;": 1108,
      "kappa;": 954,
      "kappav;": 1008,
      "kcedil;": 311,
      "kcy;": 1082,
      "kfr;": [55349, 56616],
      "kgreen;": 312,
      "khcy;": 1093,
      "kjcy;": 1116,
      "kopf;": [55349, 56668],
      "kscr;": [55349, 56512],
      "lAarr;": 8666,
      "lArr;": 8656,
      "lAtail;": 10523,
      "lBarr;": 10510,
      "lE;": 8806,
      "lEg;": 10891,
      "lHar;": 10594,
      "lacute;": 314,
      "laemptyv;": 10676,
      "lagran;": 8466,
      "lambda;": 955,
      "lang;": 10216,
      "langd;": 10641,
      "langle;": 10216,
      "lap;": 10885,
      "laquo": 171,
      "laquo;": 171,
      "larr;": 8592,
      "larrb;": 8676,
      "larrbfs;": 10527,
      "larrfs;": 10525,
      "larrhk;": 8617,
      "larrlp;": 8619,
      "larrpl;": 10553,
      "larrsim;": 10611,
      "larrtl;": 8610,
      "lat;": 10923,
      "latail;": 10521,
      "late;": 10925,
      "lates;": [10925, 65024],
      "lbarr;": 10508,
      "lbbrk;": 10098,
      "lbrace;": 123,
      "lbrack;": 91,
      "lbrke;": 10635,
      "lbrksld;": 10639,
      "lbrkslu;": 10637,
      "lcaron;": 318,
      "lcedil;": 316,
      "lceil;": 8968,
      "lcub;": 123,
      "lcy;": 1083,
      "ldca;": 10550,
      "ldquo;": 8220,
      "ldquor;": 8222,
      "ldrdhar;": 10599,
      "ldrushar;": 10571,
      "ldsh;": 8626,
      "le;": 8804,
      "leftarrow;": 8592,
      "leftarrowtail;": 8610,
      "leftharpoondown;": 8637,
      "leftharpoonup;": 8636,
      "leftleftarrows;": 8647,
      "leftrightarrow;": 8596,
      "leftrightarrows;": 8646,
      "leftrightharpoons;": 8651,
      "leftrightsquigarrow;": 8621,
      "leftthreetimes;": 8907,
      "leg;": 8922,
      "leq;": 8804,
      "leqq;": 8806,
      "leqslant;": 10877,
      "les;": 10877,
      "lescc;": 10920,
      "lesdot;": 10879,
      "lesdoto;": 10881,
      "lesdotor;": 10883,
      "lesg;": [8922, 65024],
      "lesges;": 10899,
      "lessapprox;": 10885,
      "lessdot;": 8918,
      "lesseqgtr;": 8922,
      "lesseqqgtr;": 10891,
      "lessgtr;": 8822,
      "lesssim;": 8818,
      "lfisht;": 10620,
      "lfloor;": 8970,
      "lfr;": [55349, 56617],
      "lg;": 8822,
      "lgE;": 10897,
      "lhard;": 8637,
      "lharu;": 8636,
      "lharul;": 10602,
      "lhblk;": 9604,
      "ljcy;": 1113,
      "ll;": 8810,
      "llarr;": 8647,
      "llcorner;": 8990,
      "llhard;": 10603,
      "lltri;": 9722,
      "lmidot;": 320,
      "lmoust;": 9136,
      "lmoustache;": 9136,
      "lnE;": 8808,
      "lnap;": 10889,
      "lnapprox;": 10889,
      "lne;": 10887,
      "lneq;": 10887,
      "lneqq;": 8808,
      "lnsim;": 8934,
      "loang;": 10220,
      "loarr;": 8701,
      "lobrk;": 10214,
      "longleftarrow;": 10229,
      "longleftrightarrow;": 10231,
      "longmapsto;": 10236,
      "longrightarrow;": 10230,
      "looparrowleft;": 8619,
      "looparrowright;": 8620,
      "lopar;": 10629,
      "lopf;": [55349, 56669],
      "loplus;": 10797,
      "lotimes;": 10804,
      "lowast;": 8727,
      "lowbar;": 95,
      "loz;": 9674,
      "lozenge;": 9674,
      "lozf;": 10731,
      "lpar;": 40,
      "lparlt;": 10643,
      "lrarr;": 8646,
      "lrcorner;": 8991,
      "lrhar;": 8651,
      "lrhard;": 10605,
      "lrm;": 8206,
      "lrtri;": 8895,
      "lsaquo;": 8249,
      "lscr;": [55349, 56513],
      "lsh;": 8624,
      "lsim;": 8818,
      "lsime;": 10893,
      "lsimg;": 10895,
      "lsqb;": 91,
      "lsquo;": 8216,
      "lsquor;": 8218,
      "lstrok;": 322,
      "lt": 60,
      "lt;": 60,
      "ltcc;": 10918,
      "ltcir;": 10873,
      "ltdot;": 8918,
      "lthree;": 8907,
      "ltimes;": 8905,
      "ltlarr;": 10614,
      "ltquest;": 10875,
      "ltrPar;": 10646,
      "ltri;": 9667,
      "ltrie;": 8884,
      "ltrif;": 9666,
      "lurdshar;": 10570,
      "luruhar;": 10598,
      "lvertneqq;": [8808, 65024],
      "lvnE;": [8808, 65024],
      "mDDot;": 8762,
      "macr": 175,
      "macr;": 175,
      "male;": 9794,
      "malt;": 10016,
      "maltese;": 10016,
      "map;": 8614,
      "mapsto;": 8614,
      "mapstodown;": 8615,
      "mapstoleft;": 8612,
      "mapstoup;": 8613,
      "marker;": 9646,
      "mcomma;": 10793,
      "mcy;": 1084,
      "mdash;": 8212,
      "measuredangle;": 8737,
      "mfr;": [55349, 56618],
      "mho;": 8487,
      "micro": 181,
      "micro;": 181,
      "mid;": 8739,
      "midast;": 42,
      "midcir;": 10992,
      "middot": 183,
      "middot;": 183,
      "minus;": 8722,
      "minusb;": 8863,
      "minusd;": 8760,
      "minusdu;": 10794,
      "mlcp;": 10971,
      "mldr;": 8230,
      "mnplus;": 8723,
      "models;": 8871,
      "mopf;": [55349, 56670],
      "mp;": 8723,
      "mscr;": [55349, 56514],
      "mstpos;": 8766,
      "mu;": 956,
      "multimap;": 8888,
      "mumap;": 8888,
      "nGg;": [8921, 824],
      "nGt;": [8811, 8402],
      "nGtv;": [8811, 824],
      "nLeftarrow;": 8653,
      "nLeftrightarrow;": 8654,
      "nLl;": [8920, 824],
      "nLt;": [8810, 8402],
      "nLtv;": [8810, 824],
      "nRightarrow;": 8655,
      "nVDash;": 8879,
      "nVdash;": 8878,
      "nabla;": 8711,
      "nacute;": 324,
      "nang;": [8736, 8402],
      "nap;": 8777,
      "napE;": [10864, 824],
      "napid;": [8779, 824],
      "napos;": 329,
      "napprox;": 8777,
      "natur;": 9838,
      "natural;": 9838,
      "naturals;": 8469,
      "nbsp": 160,
      "nbsp;": 160,
      "nbump;": [8782, 824],
      "nbumpe;": [8783, 824],
      "ncap;": 10819,
      "ncaron;": 328,
      "ncedil;": 326,
      "ncong;": 8775,
      "ncongdot;": [10861, 824],
      "ncup;": 10818,
      "ncy;": 1085,
      "ndash;": 8211,
      "ne;": 8800,
      "neArr;": 8663,
      "nearhk;": 10532,
      "nearr;": 8599,
      "nearrow;": 8599,
      "nedot;": [8784, 824],
      "nequiv;": 8802,
      "nesear;": 10536,
      "nesim;": [8770, 824],
      "nexist;": 8708,
      "nexists;": 8708,
      "nfr;": [55349, 56619],
      "ngE;": [8807, 824],
      "nge;": 8817,
      "ngeq;": 8817,
      "ngeqq;": [8807, 824],
      "ngeqslant;": [10878, 824],
      "nges;": [10878, 824],
      "ngsim;": 8821,
      "ngt;": 8815,
      "ngtr;": 8815,
      "nhArr;": 8654,
      "nharr;": 8622,
      "nhpar;": 10994,
      "ni;": 8715,
      "nis;": 8956,
      "nisd;": 8954,
      "niv;": 8715,
      "njcy;": 1114,
      "nlArr;": 8653,
      "nlE;": [8806, 824],
      "nlarr;": 8602,
      "nldr;": 8229,
      "nle;": 8816,
      "nleftarrow;": 8602,
      "nleftrightarrow;": 8622,
      "nleq;": 8816,
      "nleqq;": [8806, 824],
      "nleqslant;": [10877, 824],
      "nles;": [10877, 824],
      "nless;": 8814,
      "nlsim;": 8820,
      "nlt;": 8814,
      "nltri;": 8938,
      "nltrie;": 8940,
      "nmid;": 8740,
      "nopf;": [55349, 56671],
      "not": 172,
      "not;": 172,
      "notin;": 8713,
      "notinE;": [8953, 824],
      "notindot;": [8949, 824],
      "notinva;": 8713,
      "notinvb;": 8951,
      "notinvc;": 8950,
      "notni;": 8716,
      "notniva;": 8716,
      "notnivb;": 8958,
      "notnivc;": 8957,
      "npar;": 8742,
      "nparallel;": 8742,
      "nparsl;": [11005, 8421],
      "npart;": [8706, 824],
      "npolint;": 10772,
      "npr;": 8832,
      "nprcue;": 8928,
      "npre;": [10927, 824],
      "nprec;": 8832,
      "npreceq;": [10927, 824],
      "nrArr;": 8655,
      "nrarr;": 8603,
      "nrarrc;": [10547, 824],
      "nrarrw;": [8605, 824],
      "nrightarrow;": 8603,
      "nrtri;": 8939,
      "nrtrie;": 8941,
      "nsc;": 8833,
      "nsccue;": 8929,
      "nsce;": [10928, 824],
      "nscr;": [55349, 56515],
      "nshortmid;": 8740,
      "nshortparallel;": 8742,
      "nsim;": 8769,
      "nsime;": 8772,
      "nsimeq;": 8772,
      "nsmid;": 8740,
      "nspar;": 8742,
      "nsqsube;": 8930,
      "nsqsupe;": 8931,
      "nsub;": 8836,
      "nsubE;": [10949, 824],
      "nsube;": 8840,
      "nsubset;": [8834, 8402],
      "nsubseteq;": 8840,
      "nsubseteqq;": [10949, 824],
      "nsucc;": 8833,
      "nsucceq;": [10928, 824],
      "nsup;": 8837,
      "nsupE;": [10950, 824],
      "nsupe;": 8841,
      "nsupset;": [8835, 8402],
      "nsupseteq;": 8841,
      "nsupseteqq;": [10950, 824],
      "ntgl;": 8825,
      "ntilde": 241,
      "ntilde;": 241,
      "ntlg;": 8824,
      "ntriangleleft;": 8938,
      "ntrianglelefteq;": 8940,
      "ntriangleright;": 8939,
      "ntrianglerighteq;": 8941,
      "nu;": 957,
      "num;": 35,
      "numero;": 8470,
      "numsp;": 8199,
      "nvDash;": 8877,
      "nvHarr;": 10500,
      "nvap;": [8781, 8402],
      "nvdash;": 8876,
      "nvge;": [8805, 8402],
      "nvgt;": [62, 8402],
      "nvinfin;": 10718,
      "nvlArr;": 10498,
      "nvle;": [8804, 8402],
      "nvlt;": [60, 8402],
      "nvltrie;": [8884, 8402],
      "nvrArr;": 10499,
      "nvrtrie;": [8885, 8402],
      "nvsim;": [8764, 8402],
      "nwArr;": 8662,
      "nwarhk;": 10531,
      "nwarr;": 8598,
      "nwarrow;": 8598,
      "nwnear;": 10535,
      "oS;": 9416,
      "oacute": 243,
      "oacute;": 243,
      "oast;": 8859,
      "ocir;": 8858,
      "ocirc": 244,
      "ocirc;": 244,
      "ocy;": 1086,
      "odash;": 8861,
      "odblac;": 337,
      "odiv;": 10808,
      "odot;": 8857,
      "odsold;": 10684,
      "oelig;": 339,
      "ofcir;": 10687,
      "ofr;": [55349, 56620],
      "ogon;": 731,
      "ograve": 242,
      "ograve;": 242,
      "ogt;": 10689,
      "ohbar;": 10677,
      "ohm;": 937,
      "oint;": 8750,
      "olarr;": 8634,
      "olcir;": 10686,
      "olcross;": 10683,
      "oline;": 8254,
      "olt;": 10688,
      "omacr;": 333,
      "omega;": 969,
      "omicron;": 959,
      "omid;": 10678,
      "ominus;": 8854,
      "oopf;": [55349, 56672],
      "opar;": 10679,
      "operp;": 10681,
      "oplus;": 8853,
      "or;": 8744,
      "orarr;": 8635,
      "ord;": 10845,
      "order;": 8500,
      "orderof;": 8500,
      "ordf": 170,
      "ordf;": 170,
      "ordm": 186,
      "ordm;": 186,
      "origof;": 8886,
      "oror;": 10838,
      "orslope;": 10839,
      "orv;": 10843,
      "oscr;": 8500,
      "oslash": 248,
      "oslash;": 248,
      "osol;": 8856,
      "otilde": 245,
      "otilde;": 245,
      "otimes;": 8855,
      "otimesas;": 10806,
      "ouml": 246,
      "ouml;": 246,
      "ovbar;": 9021,
      "par;": 8741,
      "para": 182,
      "para;": 182,
      "parallel;": 8741,
      "parsim;": 10995,
      "parsl;": 11005,
      "part;": 8706,
      "pcy;": 1087,
      "percnt;": 37,
      "period;": 46,
      "permil;": 8240,
      "perp;": 8869,
      "pertenk;": 8241,
      "pfr;": [55349, 56621],
      "phi;": 966,
      "phiv;": 981,
      "phmmat;": 8499,
      "phone;": 9742,
      "pi;": 960,
      "pitchfork;": 8916,
      "piv;": 982,
      "planck;": 8463,
      "planckh;": 8462,
      "plankv;": 8463,
      "plus;": 43,
      "plusacir;": 10787,
      "plusb;": 8862,
      "pluscir;": 10786,
      "plusdo;": 8724,
      "plusdu;": 10789,
      "pluse;": 10866,
      "plusmn": 177,
      "plusmn;": 177,
      "plussim;": 10790,
      "plustwo;": 10791,
      "pm;": 177,
      "pointint;": 10773,
      "popf;": [55349, 56673],
      "pound": 163,
      "pound;": 163,
      "pr;": 8826,
      "prE;": 10931,
      "prap;": 10935,
      "prcue;": 8828,
      "pre;": 10927,
      "prec;": 8826,
      "precapprox;": 10935,
      "preccurlyeq;": 8828,
      "preceq;": 10927,
      "precnapprox;": 10937,
      "precneqq;": 10933,
      "precnsim;": 8936,
      "precsim;": 8830,
      "prime;": 8242,
      "primes;": 8473,
      "prnE;": 10933,
      "prnap;": 10937,
      "prnsim;": 8936,
      "prod;": 8719,
      "profalar;": 9006,
      "profline;": 8978,
      "profsurf;": 8979,
      "prop;": 8733,
      "propto;": 8733,
      "prsim;": 8830,
      "prurel;": 8880,
      "pscr;": [55349, 56517],
      "psi;": 968,
      "puncsp;": 8200,
      "qfr;": [55349, 56622],
      "qint;": 10764,
      "qopf;": [55349, 56674],
      "qprime;": 8279,
      "qscr;": [55349, 56518],
      "quaternions;": 8461,
      "quatint;": 10774,
      "quest;": 63,
      "questeq;": 8799,
      "quot": 34,
      "quot;": 34,
      "rAarr;": 8667,
      "rArr;": 8658,
      "rAtail;": 10524,
      "rBarr;": 10511,
      "rHar;": 10596,
      "race;": [8765, 817],
      "racute;": 341,
      "radic;": 8730,
      "raemptyv;": 10675,
      "rang;": 10217,
      "rangd;": 10642,
      "range;": 10661,
      "rangle;": 10217,
      "raquo": 187,
      "raquo;": 187,
      "rarr;": 8594,
      "rarrap;": 10613,
      "rarrb;": 8677,
      "rarrbfs;": 10528,
      "rarrc;": 10547,
      "rarrfs;": 10526,
      "rarrhk;": 8618,
      "rarrlp;": 8620,
      "rarrpl;": 10565,
      "rarrsim;": 10612,
      "rarrtl;": 8611,
      "rarrw;": 8605,
      "ratail;": 10522,
      "ratio;": 8758,
      "rationals;": 8474,
      "rbarr;": 10509,
      "rbbrk;": 10099,
      "rbrace;": 125,
      "rbrack;": 93,
      "rbrke;": 10636,
      "rbrksld;": 10638,
      "rbrkslu;": 10640,
      "rcaron;": 345,
      "rcedil;": 343,
      "rceil;": 8969,
      "rcub;": 125,
      "rcy;": 1088,
      "rdca;": 10551,
      "rdldhar;": 10601,
      "rdquo;": 8221,
      "rdquor;": 8221,
      "rdsh;": 8627,
      "real;": 8476,
      "realine;": 8475,
      "realpart;": 8476,
      "reals;": 8477,
      "rect;": 9645,
      "reg": 174,
      "reg;": 174,
      "rfisht;": 10621,
      "rfloor;": 8971,
      "rfr;": [55349, 56623],
      "rhard;": 8641,
      "rharu;": 8640,
      "rharul;": 10604,
      "rho;": 961,
      "rhov;": 1009,
      "rightarrow;": 8594,
      "rightarrowtail;": 8611,
      "rightharpoondown;": 8641,
      "rightharpoonup;": 8640,
      "rightleftarrows;": 8644,
      "rightleftharpoons;": 8652,
      "rightrightarrows;": 8649,
      "rightsquigarrow;": 8605,
      "rightthreetimes;": 8908,
      "ring;": 730,
      "risingdotseq;": 8787,
      "rlarr;": 8644,
      "rlhar;": 8652,
      "rlm;": 8207,
      "rmoust;": 9137,
      "rmoustache;": 9137,
      "rnmid;": 10990,
      "roang;": 10221,
      "roarr;": 8702,
      "robrk;": 10215,
      "ropar;": 10630,
      "ropf;": [55349, 56675],
      "roplus;": 10798,
      "rotimes;": 10805,
      "rpar;": 41,
      "rpargt;": 10644,
      "rppolint;": 10770,
      "rrarr;": 8649,
      "rsaquo;": 8250,
      "rscr;": [55349, 56519],
      "rsh;": 8625,
      "rsqb;": 93,
      "rsquo;": 8217,
      "rsquor;": 8217,
      "rthree;": 8908,
      "rtimes;": 8906,
      "rtri;": 9657,
      "rtrie;": 8885,
      "rtrif;": 9656,
      "rtriltri;": 10702,
      "ruluhar;": 10600,
      "rx;": 8478,
      "sacute;": 347,
      "sbquo;": 8218,
      "sc;": 8827,
      "scE;": 10932,
      "scap;": 10936,
      "scaron;": 353,
      "sccue;": 8829,
      "sce;": 10928,
      "scedil;": 351,
      "scirc;": 349,
      "scnE;": 10934,
      "scnap;": 10938,
      "scnsim;": 8937,
      "scpolint;": 10771,
      "scsim;": 8831,
      "scy;": 1089,
      "sdot;": 8901,
      "sdotb;": 8865,
      "sdote;": 10854,
      "seArr;": 8664,
      "searhk;": 10533,
      "searr;": 8600,
      "searrow;": 8600,
      "sect": 167,
      "sect;": 167,
      "semi;": 59,
      "seswar;": 10537,
      "setminus;": 8726,
      "setmn;": 8726,
      "sext;": 10038,
      "sfr;": [55349, 56624],
      "sfrown;": 8994,
      "sharp;": 9839,
      "shchcy;": 1097,
      "shcy;": 1096,
      "shortmid;": 8739,
      "shortparallel;": 8741,
      "shy": 173,
      "shy;": 173,
      "sigma;": 963,
      "sigmaf;": 962,
      "sigmav;": 962,
      "sim;": 8764,
      "simdot;": 10858,
      "sime;": 8771,
      "simeq;": 8771,
      "simg;": 10910,
      "simgE;": 10912,
      "siml;": 10909,
      "simlE;": 10911,
      "simne;": 8774,
      "simplus;": 10788,
      "simrarr;": 10610,
      "slarr;": 8592,
      "smallsetminus;": 8726,
      "smashp;": 10803,
      "smeparsl;": 10724,
      "smid;": 8739,
      "smile;": 8995,
      "smt;": 10922,
      "smte;": 10924,
      "smtes;": [10924, 65024],
      "softcy;": 1100,
      "sol;": 47,
      "solb;": 10692,
      "solbar;": 9023,
      "sopf;": [55349, 56676],
      "spades;": 9824,
      "spadesuit;": 9824,
      "spar;": 8741,
      "sqcap;": 8851,
      "sqcaps;": [8851, 65024],
      "sqcup;": 8852,
      "sqcups;": [8852, 65024],
      "sqsub;": 8847,
      "sqsube;": 8849,
      "sqsubset;": 8847,
      "sqsubseteq;": 8849,
      "sqsup;": 8848,
      "sqsupe;": 8850,
      "sqsupset;": 8848,
      "sqsupseteq;": 8850,
      "squ;": 9633,
      "square;": 9633,
      "squarf;": 9642,
      "squf;": 9642,
      "srarr;": 8594,
      "sscr;": [55349, 56520],
      "ssetmn;": 8726,
      "ssmile;": 8995,
      "sstarf;": 8902,
      "star;": 9734,
      "starf;": 9733,
      "straightepsilon;": 1013,
      "straightphi;": 981,
      "strns;": 175,
      "sub;": 8834,
      "subE;": 10949,
      "subdot;": 10941,
      "sube;": 8838,
      "subedot;": 10947,
      "submult;": 10945,
      "subnE;": 10955,
      "subne;": 8842,
      "subplus;": 10943,
      "subrarr;": 10617,
      "subset;": 8834,
      "subseteq;": 8838,
      "subseteqq;": 10949,
      "subsetneq;": 8842,
      "subsetneqq;": 10955,
      "subsim;": 10951,
      "subsub;": 10965,
      "subsup;": 10963,
      "succ;": 8827,
      "succapprox;": 10936,
      "succcurlyeq;": 8829,
      "succeq;": 10928,
      "succnapprox;": 10938,
      "succneqq;": 10934,
      "succnsim;": 8937,
      "succsim;": 8831,
      "sum;": 8721,
      "sung;": 9834,
      "sup1": 185,
      "sup1;": 185,
      "sup2": 178,
      "sup2;": 178,
      "sup3": 179,
      "sup3;": 179,
      "sup;": 8835,
      "supE;": 10950,
      "supdot;": 10942,
      "supdsub;": 10968,
      "supe;": 8839,
      "supedot;": 10948,
      "suphsol;": 10185,
      "suphsub;": 10967,
      "suplarr;": 10619,
      "supmult;": 10946,
      "supnE;": 10956,
      "supne;": 8843,
      "supplus;": 10944,
      "supset;": 8835,
      "supseteq;": 8839,
      "supseteqq;": 10950,
      "supsetneq;": 8843,
      "supsetneqq;": 10956,
      "supsim;": 10952,
      "supsub;": 10964,
      "supsup;": 10966,
      "swArr;": 8665,
      "swarhk;": 10534,
      "swarr;": 8601,
      "swarrow;": 8601,
      "swnwar;": 10538,
      "szlig": 223,
      "szlig;": 223,
      "target;": 8982,
      "tau;": 964,
      "tbrk;": 9140,
      "tcaron;": 357,
      "tcedil;": 355,
      "tcy;": 1090,
      "tdot;": 8411,
      "telrec;": 8981,
      "tfr;": [55349, 56625],
      "there4;": 8756,
      "therefore;": 8756,
      "theta;": 952,
      "thetasym;": 977,
      "thetav;": 977,
      "thickapprox;": 8776,
      "thicksim;": 8764,
      "thinsp;": 8201,
      "thkap;": 8776,
      "thksim;": 8764,
      "thorn": 254,
      "thorn;": 254,
      "tilde;": 732,
      "times": 215,
      "times;": 215,
      "timesb;": 8864,
      "timesbar;": 10801,
      "timesd;": 10800,
      "tint;": 8749,
      "toea;": 10536,
      "top;": 8868,
      "topbot;": 9014,
      "topcir;": 10993,
      "topf;": [55349, 56677],
      "topfork;": 10970,
      "tosa;": 10537,
      "tprime;": 8244,
      "trade;": 8482,
      "triangle;": 9653,
      "triangledown;": 9663,
      "triangleleft;": 9667,
      "trianglelefteq;": 8884,
      "triangleq;": 8796,
      "triangleright;": 9657,
      "trianglerighteq;": 8885,
      "tridot;": 9708,
      "trie;": 8796,
      "triminus;": 10810,
      "triplus;": 10809,
      "trisb;": 10701,
      "tritime;": 10811,
      "trpezium;": 9186,
      "tscr;": [55349, 56521],
      "tscy;": 1094,
      "tshcy;": 1115,
      "tstrok;": 359,
      "twixt;": 8812,
      "twoheadleftarrow;": 8606,
      "twoheadrightarrow;": 8608,
      "uArr;": 8657,
      "uHar;": 10595,
      "uacute": 250,
      "uacute;": 250,
      "uarr;": 8593,
      "ubrcy;": 1118,
      "ubreve;": 365,
      "ucirc": 251,
      "ucirc;": 251,
      "ucy;": 1091,
      "udarr;": 8645,
      "udblac;": 369,
      "udhar;": 10606,
      "ufisht;": 10622,
      "ufr;": [55349, 56626],
      "ugrave": 249,
      "ugrave;": 249,
      "uharl;": 8639,
      "uharr;": 8638,
      "uhblk;": 9600,
      "ulcorn;": 8988,
      "ulcorner;": 8988,
      "ulcrop;": 8975,
      "ultri;": 9720,
      "umacr;": 363,
      "uml": 168,
      "uml;": 168,
      "uogon;": 371,
      "uopf;": [55349, 56678],
      "uparrow;": 8593,
      "updownarrow;": 8597,
      "upharpoonleft;": 8639,
      "upharpoonright;": 8638,
      "uplus;": 8846,
      "upsi;": 965,
      "upsih;": 978,
      "upsilon;": 965,
      "upuparrows;": 8648,
      "urcorn;": 8989,
      "urcorner;": 8989,
      "urcrop;": 8974,
      "uring;": 367,
      "urtri;": 9721,
      "uscr;": [55349, 56522],
      "utdot;": 8944,
      "utilde;": 361,
      "utri;": 9653,
      "utrif;": 9652,
      "uuarr;": 8648,
      "uuml": 252,
      "uuml;": 252,
      "uwangle;": 10663,
      "vArr;": 8661,
      "vBar;": 10984,
      "vBarv;": 10985,
      "vDash;": 8872,
      "vangrt;": 10652,
      "varepsilon;": 1013,
      "varkappa;": 1008,
      "varnothing;": 8709,
      "varphi;": 981,
      "varpi;": 982,
      "varpropto;": 8733,
      "varr;": 8597,
      "varrho;": 1009,
      "varsigma;": 962,
      "varsubsetneq;": [8842, 65024],
      "varsubsetneqq;": [10955, 65024],
      "varsupsetneq;": [8843, 65024],
      "varsupsetneqq;": [10956, 65024],
      "vartheta;": 977,
      "vartriangleleft;": 8882,
      "vartriangleright;": 8883,
      "vcy;": 1074,
      "vdash;": 8866,
      "vee;": 8744,
      "veebar;": 8891,
      "veeeq;": 8794,
      "vellip;": 8942,
      "verbar;": 124,
      "vert;": 124,
      "vfr;": [55349, 56627],
      "vltri;": 8882,
      "vnsub;": [8834, 8402],
      "vnsup;": [8835, 8402],
      "vopf;": [55349, 56679],
      "vprop;": 8733,
      "vrtri;": 8883,
      "vscr;": [55349, 56523],
      "vsubnE;": [10955, 65024],
      "vsubne;": [8842, 65024],
      "vsupnE;": [10956, 65024],
      "vsupne;": [8843, 65024],
      "vzigzag;": 10650,
      "wcirc;": 373,
      "wedbar;": 10847,
      "wedge;": 8743,
      "wedgeq;": 8793,
      "weierp;": 8472,
      "wfr;": [55349, 56628],
      "wopf;": [55349, 56680],
      "wp;": 8472,
      "wr;": 8768,
      "wreath;": 8768,
      "wscr;": [55349, 56524],
      "xcap;": 8898,
      "xcirc;": 9711,
      "xcup;": 8899,
      "xdtri;": 9661,
      "xfr;": [55349, 56629],
      "xhArr;": 10234,
      "xharr;": 10231,
      "xi;": 958,
      "xlArr;": 10232,
      "xlarr;": 10229,
      "xmap;": 10236,
      "xnis;": 8955,
      "xodot;": 10752,
      "xopf;": [55349, 56681],
      "xoplus;": 10753,
      "xotime;": 10754,
      "xrArr;": 10233,
      "xrarr;": 10230,
      "xscr;": [55349, 56525],
      "xsqcup;": 10758,
      "xuplus;": 10756,
      "xutri;": 9651,
      "xvee;": 8897,
      "xwedge;": 8896,
      "yacute": 253,
      "yacute;": 253,
      "yacy;": 1103,
      "ycirc;": 375,
      "ycy;": 1099,
      "yen": 165,
      "yen;": 165,
      "yfr;": [55349, 56630],
      "yicy;": 1111,
      "yopf;": [55349, 56682],
      "yscr;": [55349, 56526],
      "yucy;": 1102,
      "yuml": 255,
      "yuml;": 255,
      "zacute;": 378,
      "zcaron;": 382,
      "zcy;": 1079,
      "zdot;": 380,
      "zeetrf;": 8488,
      "zeta;": 950,
      "zfr;": [55349, 56631],
      "zhcy;": 1078,
      "zigrarr;": 8669,
      "zopf;": [55349, 56683],
      "zscr;": [55349, 56527],
      "zwj;": 8205,
      "zwnj;": 8204
    };
    var NAMEDCHARREF = /(A(?:Elig;?|MP;?|acute;?|breve;|c(?:irc;?|y;)|fr;|grave;?|lpha;|macr;|nd;|o(?:gon;|pf;)|pplyFunction;|ring;?|s(?:cr;|sign;)|tilde;?|uml;?)|B(?:a(?:ckslash;|r(?:v;|wed;))|cy;|e(?:cause;|rnoullis;|ta;)|fr;|opf;|reve;|scr;|umpeq;)|C(?:Hcy;|OPY;?|a(?:cute;|p(?:;|italDifferentialD;)|yleys;)|c(?:aron;|edil;?|irc;|onint;)|dot;|e(?:dilla;|nterDot;)|fr;|hi;|ircle(?:Dot;|Minus;|Plus;|Times;)|lo(?:ckwiseContourIntegral;|seCurly(?:DoubleQuote;|Quote;))|o(?:lon(?:;|e;)|n(?:gruent;|int;|tourIntegral;)|p(?:f;|roduct;)|unterClockwiseContourIntegral;)|ross;|scr;|up(?:;|Cap;))|D(?:D(?:;|otrahd;)|Jcy;|Scy;|Zcy;|a(?:gger;|rr;|shv;)|c(?:aron;|y;)|el(?:;|ta;)|fr;|i(?:a(?:critical(?:Acute;|Do(?:t;|ubleAcute;)|Grave;|Tilde;)|mond;)|fferentialD;)|o(?:pf;|t(?:;|Dot;|Equal;)|uble(?:ContourIntegral;|Do(?:t;|wnArrow;)|L(?:eft(?:Arrow;|RightArrow;|Tee;)|ong(?:Left(?:Arrow;|RightArrow;)|RightArrow;))|Right(?:Arrow;|Tee;)|Up(?:Arrow;|DownArrow;)|VerticalBar;)|wn(?:Arrow(?:;|Bar;|UpArrow;)|Breve;|Left(?:RightVector;|TeeVector;|Vector(?:;|Bar;))|Right(?:TeeVector;|Vector(?:;|Bar;))|Tee(?:;|Arrow;)|arrow;))|s(?:cr;|trok;))|E(?:NG;|TH;?|acute;?|c(?:aron;|irc;?|y;)|dot;|fr;|grave;?|lement;|m(?:acr;|pty(?:SmallSquare;|VerySmallSquare;))|o(?:gon;|pf;)|psilon;|qu(?:al(?:;|Tilde;)|ilibrium;)|s(?:cr;|im;)|ta;|uml;?|x(?:ists;|ponentialE;))|F(?:cy;|fr;|illed(?:SmallSquare;|VerySmallSquare;)|o(?:pf;|rAll;|uriertrf;)|scr;)|G(?:Jcy;|T;?|amma(?:;|d;)|breve;|c(?:edil;|irc;|y;)|dot;|fr;|g;|opf;|reater(?:Equal(?:;|Less;)|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;)|scr;|t;)|H(?:ARDcy;|a(?:cek;|t;)|circ;|fr;|ilbertSpace;|o(?:pf;|rizontalLine;)|s(?:cr;|trok;)|ump(?:DownHump;|Equal;))|I(?:Ecy;|Jlig;|Ocy;|acute;?|c(?:irc;?|y;)|dot;|fr;|grave;?|m(?:;|a(?:cr;|ginaryI;)|plies;)|n(?:t(?:;|e(?:gral;|rsection;))|visible(?:Comma;|Times;))|o(?:gon;|pf;|ta;)|scr;|tilde;|u(?:kcy;|ml;?))|J(?:c(?:irc;|y;)|fr;|opf;|s(?:cr;|ercy;)|ukcy;)|K(?:Hcy;|Jcy;|appa;|c(?:edil;|y;)|fr;|opf;|scr;)|L(?:Jcy;|T;?|a(?:cute;|mbda;|ng;|placetrf;|rr;)|c(?:aron;|edil;|y;)|e(?:ft(?:A(?:ngleBracket;|rrow(?:;|Bar;|RightArrow;))|Ceiling;|Do(?:ubleBracket;|wn(?:TeeVector;|Vector(?:;|Bar;)))|Floor;|Right(?:Arrow;|Vector;)|T(?:ee(?:;|Arrow;|Vector;)|riangle(?:;|Bar;|Equal;))|Up(?:DownVector;|TeeVector;|Vector(?:;|Bar;))|Vector(?:;|Bar;)|arrow;|rightarrow;)|ss(?:EqualGreater;|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;))|fr;|l(?:;|eftarrow;)|midot;|o(?:ng(?:Left(?:Arrow;|RightArrow;)|RightArrow;|left(?:arrow;|rightarrow;)|rightarrow;)|pf;|wer(?:LeftArrow;|RightArrow;))|s(?:cr;|h;|trok;)|t;)|M(?:ap;|cy;|e(?:diumSpace;|llintrf;)|fr;|inusPlus;|opf;|scr;|u;)|N(?:Jcy;|acute;|c(?:aron;|edil;|y;)|e(?:gative(?:MediumSpace;|Thi(?:ckSpace;|nSpace;)|VeryThinSpace;)|sted(?:GreaterGreater;|LessLess;)|wLine;)|fr;|o(?:Break;|nBreakingSpace;|pf;|t(?:;|C(?:ongruent;|upCap;)|DoubleVerticalBar;|E(?:lement;|qual(?:;|Tilde;)|xists;)|Greater(?:;|Equal;|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;)|Hump(?:DownHump;|Equal;)|Le(?:ftTriangle(?:;|Bar;|Equal;)|ss(?:;|Equal;|Greater;|Less;|SlantEqual;|Tilde;))|Nested(?:GreaterGreater;|LessLess;)|Precedes(?:;|Equal;|SlantEqual;)|R(?:everseElement;|ightTriangle(?:;|Bar;|Equal;))|S(?:quareSu(?:bset(?:;|Equal;)|perset(?:;|Equal;))|u(?:bset(?:;|Equal;)|cceeds(?:;|Equal;|SlantEqual;|Tilde;)|perset(?:;|Equal;)))|Tilde(?:;|Equal;|FullEqual;|Tilde;)|VerticalBar;))|scr;|tilde;?|u;)|O(?:Elig;|acute;?|c(?:irc;?|y;)|dblac;|fr;|grave;?|m(?:acr;|ega;|icron;)|opf;|penCurly(?:DoubleQuote;|Quote;)|r;|s(?:cr;|lash;?)|ti(?:lde;?|mes;)|uml;?|ver(?:B(?:ar;|rac(?:e;|ket;))|Parenthesis;))|P(?:artialD;|cy;|fr;|hi;|i;|lusMinus;|o(?:incareplane;|pf;)|r(?:;|ecedes(?:;|Equal;|SlantEqual;|Tilde;)|ime;|o(?:duct;|portion(?:;|al;)))|s(?:cr;|i;))|Q(?:UOT;?|fr;|opf;|scr;)|R(?:Barr;|EG;?|a(?:cute;|ng;|rr(?:;|tl;))|c(?:aron;|edil;|y;)|e(?:;|verse(?:E(?:lement;|quilibrium;)|UpEquilibrium;))|fr;|ho;|ight(?:A(?:ngleBracket;|rrow(?:;|Bar;|LeftArrow;))|Ceiling;|Do(?:ubleBracket;|wn(?:TeeVector;|Vector(?:;|Bar;)))|Floor;|T(?:ee(?:;|Arrow;|Vector;)|riangle(?:;|Bar;|Equal;))|Up(?:DownVector;|TeeVector;|Vector(?:;|Bar;))|Vector(?:;|Bar;)|arrow;)|o(?:pf;|undImplies;)|rightarrow;|s(?:cr;|h;)|uleDelayed;)|S(?:H(?:CHcy;|cy;)|OFTcy;|acute;|c(?:;|aron;|edil;|irc;|y;)|fr;|hort(?:DownArrow;|LeftArrow;|RightArrow;|UpArrow;)|igma;|mallCircle;|opf;|q(?:rt;|uare(?:;|Intersection;|Su(?:bset(?:;|Equal;)|perset(?:;|Equal;))|Union;))|scr;|tar;|u(?:b(?:;|set(?:;|Equal;))|c(?:ceeds(?:;|Equal;|SlantEqual;|Tilde;)|hThat;)|m;|p(?:;|erset(?:;|Equal;)|set;)))|T(?:HORN;?|RADE;|S(?:Hcy;|cy;)|a(?:b;|u;)|c(?:aron;|edil;|y;)|fr;|h(?:e(?:refore;|ta;)|i(?:ckSpace;|nSpace;))|ilde(?:;|Equal;|FullEqual;|Tilde;)|opf;|ripleDot;|s(?:cr;|trok;))|U(?:a(?:cute;?|rr(?:;|ocir;))|br(?:cy;|eve;)|c(?:irc;?|y;)|dblac;|fr;|grave;?|macr;|n(?:der(?:B(?:ar;|rac(?:e;|ket;))|Parenthesis;)|ion(?:;|Plus;))|o(?:gon;|pf;)|p(?:Arrow(?:;|Bar;|DownArrow;)|DownArrow;|Equilibrium;|Tee(?:;|Arrow;)|arrow;|downarrow;|per(?:LeftArrow;|RightArrow;)|si(?:;|lon;))|ring;|scr;|tilde;|uml;?)|V(?:Dash;|bar;|cy;|dash(?:;|l;)|e(?:e;|r(?:bar;|t(?:;|ical(?:Bar;|Line;|Separator;|Tilde;))|yThinSpace;))|fr;|opf;|scr;|vdash;)|W(?:circ;|edge;|fr;|opf;|scr;)|X(?:fr;|i;|opf;|scr;)|Y(?:Acy;|Icy;|Ucy;|acute;?|c(?:irc;|y;)|fr;|opf;|scr;|uml;)|Z(?:Hcy;|acute;|c(?:aron;|y;)|dot;|e(?:roWidthSpace;|ta;)|fr;|opf;|scr;)|a(?:acute;?|breve;|c(?:;|E;|d;|irc;?|ute;?|y;)|elig;?|f(?:;|r;)|grave;?|l(?:e(?:fsym;|ph;)|pha;)|m(?:a(?:cr;|lg;)|p;?)|n(?:d(?:;|and;|d;|slope;|v;)|g(?:;|e;|le;|msd(?:;|a(?:a;|b;|c;|d;|e;|f;|g;|h;))|rt(?:;|vb(?:;|d;))|s(?:ph;|t;)|zarr;))|o(?:gon;|pf;)|p(?:;|E;|acir;|e;|id;|os;|prox(?:;|eq;))|ring;?|s(?:cr;|t;|ymp(?:;|eq;))|tilde;?|uml;?|w(?:conint;|int;))|b(?:Not;|a(?:ck(?:cong;|epsilon;|prime;|sim(?:;|eq;))|r(?:vee;|wed(?:;|ge;)))|brk(?:;|tbrk;)|c(?:ong;|y;)|dquo;|e(?:caus(?:;|e;)|mptyv;|psi;|rnou;|t(?:a;|h;|ween;))|fr;|ig(?:c(?:ap;|irc;|up;)|o(?:dot;|plus;|times;)|s(?:qcup;|tar;)|triangle(?:down;|up;)|uplus;|vee;|wedge;)|karow;|l(?:a(?:ck(?:lozenge;|square;|triangle(?:;|down;|left;|right;))|nk;)|k(?:1(?:2;|4;)|34;)|ock;)|n(?:e(?:;|quiv;)|ot;)|o(?:pf;|t(?:;|tom;)|wtie;|x(?:D(?:L;|R;|l;|r;)|H(?:;|D;|U;|d;|u;)|U(?:L;|R;|l;|r;)|V(?:;|H;|L;|R;|h;|l;|r;)|box;|d(?:L;|R;|l;|r;)|h(?:;|D;|U;|d;|u;)|minus;|plus;|times;|u(?:L;|R;|l;|r;)|v(?:;|H;|L;|R;|h;|l;|r;)))|prime;|r(?:eve;|vbar;?)|s(?:cr;|emi;|im(?:;|e;)|ol(?:;|b;|hsub;))|u(?:ll(?:;|et;)|mp(?:;|E;|e(?:;|q;))))|c(?:a(?:cute;|p(?:;|and;|brcup;|c(?:ap;|up;)|dot;|s;)|r(?:et;|on;))|c(?:a(?:ps;|ron;)|edil;?|irc;|ups(?:;|sm;))|dot;|e(?:dil;?|mptyv;|nt(?:;|erdot;|))|fr;|h(?:cy;|eck(?:;|mark;)|i;)|ir(?:;|E;|c(?:;|eq;|le(?:arrow(?:left;|right;)|d(?:R;|S;|ast;|circ;|dash;)))|e;|fnint;|mid;|scir;)|lubs(?:;|uit;)|o(?:lon(?:;|e(?:;|q;))|m(?:ma(?:;|t;)|p(?:;|fn;|le(?:ment;|xes;)))|n(?:g(?:;|dot;)|int;)|p(?:f;|rod;|y(?:;|sr;|)))|r(?:arr;|oss;)|s(?:cr;|u(?:b(?:;|e;)|p(?:;|e;)))|tdot;|u(?:darr(?:l;|r;)|e(?:pr;|sc;)|larr(?:;|p;)|p(?:;|brcap;|c(?:ap;|up;)|dot;|or;|s;)|r(?:arr(?:;|m;)|ly(?:eq(?:prec;|succ;)|vee;|wedge;)|ren;?|vearrow(?:left;|right;))|vee;|wed;)|w(?:conint;|int;)|ylcty;)|d(?:Arr;|Har;|a(?:gger;|leth;|rr;|sh(?:;|v;))|b(?:karow;|lac;)|c(?:aron;|y;)|d(?:;|a(?:gger;|rr;)|otseq;)|e(?:g;?|lta;|mptyv;)|f(?:isht;|r;)|har(?:l;|r;)|i(?:am(?:;|ond(?:;|suit;)|s;)|e;|gamma;|sin;|v(?:;|ide(?:;|ontimes;|)|onx;))|jcy;|lc(?:orn;|rop;)|o(?:llar;|pf;|t(?:;|eq(?:;|dot;)|minus;|plus;|square;)|ublebarwedge;|wn(?:arrow;|downarrows;|harpoon(?:left;|right;)))|r(?:bkarow;|c(?:orn;|rop;))|s(?:c(?:r;|y;)|ol;|trok;)|t(?:dot;|ri(?:;|f;))|u(?:arr;|har;)|wangle;|z(?:cy;|igrarr;))|e(?:D(?:Dot;|ot;)|a(?:cute;?|ster;)|c(?:aron;|ir(?:;|c;?)|olon;|y;)|dot;|e;|f(?:Dot;|r;)|g(?:;|rave;?|s(?:;|dot;))|l(?:;|inters;|l;|s(?:;|dot;))|m(?:acr;|pty(?:;|set;|v;)|sp(?:1(?:3;|4;)|;))|n(?:g;|sp;)|o(?:gon;|pf;)|p(?:ar(?:;|sl;)|lus;|si(?:;|lon;|v;))|q(?:c(?:irc;|olon;)|s(?:im;|lant(?:gtr;|less;))|u(?:als;|est;|iv(?:;|DD;))|vparsl;)|r(?:Dot;|arr;)|s(?:cr;|dot;|im;)|t(?:a;|h;?)|u(?:ml;?|ro;)|x(?:cl;|ist;|p(?:ectation;|onentiale;)))|f(?:allingdotseq;|cy;|emale;|f(?:ilig;|l(?:ig;|lig;)|r;)|ilig;|jlig;|l(?:at;|lig;|tns;)|nof;|o(?:pf;|r(?:all;|k(?:;|v;)))|partint;|r(?:a(?:c(?:1(?:2;?|3;|4;?|5;|6;|8;)|2(?:3;|5;)|3(?:4;?|5;|8;)|45;|5(?:6;|8;)|78;)|sl;)|own;)|scr;)|g(?:E(?:;|l;)|a(?:cute;|mma(?:;|d;)|p;)|breve;|c(?:irc;|y;)|dot;|e(?:;|l;|q(?:;|q;|slant;)|s(?:;|cc;|dot(?:;|o(?:;|l;))|l(?:;|es;)))|fr;|g(?:;|g;)|imel;|jcy;|l(?:;|E;|a;|j;)|n(?:E;|ap(?:;|prox;)|e(?:;|q(?:;|q;))|sim;)|opf;|rave;|s(?:cr;|im(?:;|e;|l;))|t(?:;|c(?:c;|ir;)|dot;|lPar;|quest;|r(?:a(?:pprox;|rr;)|dot;|eq(?:less;|qless;)|less;|sim;)|)|v(?:ertneqq;|nE;))|h(?:Arr;|a(?:irsp;|lf;|milt;|r(?:dcy;|r(?:;|cir;|w;)))|bar;|circ;|e(?:arts(?:;|uit;)|llip;|rcon;)|fr;|ks(?:earow;|warow;)|o(?:arr;|mtht;|ok(?:leftarrow;|rightarrow;)|pf;|rbar;)|s(?:cr;|lash;|trok;)|y(?:bull;|phen;))|i(?:acute;?|c(?:;|irc;?|y;)|e(?:cy;|xcl;?)|f(?:f;|r;)|grave;?|i(?:;|i(?:int;|nt;)|nfin;|ota;)|jlig;|m(?:a(?:cr;|g(?:e;|line;|part;)|th;)|of;|ped;)|n(?:;|care;|fin(?:;|tie;)|odot;|t(?:;|cal;|e(?:gers;|rcal;)|larhk;|prod;))|o(?:cy;|gon;|pf;|ta;)|prod;|quest;?|s(?:cr;|in(?:;|E;|dot;|s(?:;|v;)|v;))|t(?:;|ilde;)|u(?:kcy;|ml;?))|j(?:c(?:irc;|y;)|fr;|math;|opf;|s(?:cr;|ercy;)|ukcy;)|k(?:appa(?:;|v;)|c(?:edil;|y;)|fr;|green;|hcy;|jcy;|opf;|scr;)|l(?:A(?:arr;|rr;|tail;)|Barr;|E(?:;|g;)|Har;|a(?:cute;|emptyv;|gran;|mbda;|ng(?:;|d;|le;)|p;|quo;?|rr(?:;|b(?:;|fs;)|fs;|hk;|lp;|pl;|sim;|tl;)|t(?:;|ail;|e(?:;|s;)))|b(?:arr;|brk;|r(?:ac(?:e;|k;)|k(?:e;|sl(?:d;|u;))))|c(?:aron;|e(?:dil;|il;)|ub;|y;)|d(?:ca;|quo(?:;|r;)|r(?:dhar;|ushar;)|sh;)|e(?:;|ft(?:arrow(?:;|tail;)|harpoon(?:down;|up;)|leftarrows;|right(?:arrow(?:;|s;)|harpoons;|squigarrow;)|threetimes;)|g;|q(?:;|q;|slant;)|s(?:;|cc;|dot(?:;|o(?:;|r;))|g(?:;|es;)|s(?:approx;|dot;|eq(?:gtr;|qgtr;)|gtr;|sim;)))|f(?:isht;|loor;|r;)|g(?:;|E;)|h(?:ar(?:d;|u(?:;|l;))|blk;)|jcy;|l(?:;|arr;|corner;|hard;|tri;)|m(?:idot;|oust(?:;|ache;))|n(?:E;|ap(?:;|prox;)|e(?:;|q(?:;|q;))|sim;)|o(?:a(?:ng;|rr;)|brk;|ng(?:left(?:arrow;|rightarrow;)|mapsto;|rightarrow;)|oparrow(?:left;|right;)|p(?:ar;|f;|lus;)|times;|w(?:ast;|bar;)|z(?:;|enge;|f;))|par(?:;|lt;)|r(?:arr;|corner;|har(?:;|d;)|m;|tri;)|s(?:aquo;|cr;|h;|im(?:;|e;|g;)|q(?:b;|uo(?:;|r;))|trok;)|t(?:;|c(?:c;|ir;)|dot;|hree;|imes;|larr;|quest;|r(?:Par;|i(?:;|e;|f;))|)|ur(?:dshar;|uhar;)|v(?:ertneqq;|nE;))|m(?:DDot;|a(?:cr;?|l(?:e;|t(?:;|ese;))|p(?:;|sto(?:;|down;|left;|up;))|rker;)|c(?:omma;|y;)|dash;|easuredangle;|fr;|ho;|i(?:cro;?|d(?:;|ast;|cir;|dot;?)|nus(?:;|b;|d(?:;|u;)))|l(?:cp;|dr;)|nplus;|o(?:dels;|pf;)|p;|s(?:cr;|tpos;)|u(?:;|ltimap;|map;))|n(?:G(?:g;|t(?:;|v;))|L(?:eft(?:arrow;|rightarrow;)|l;|t(?:;|v;))|Rightarrow;|V(?:Dash;|dash;)|a(?:bla;|cute;|ng;|p(?:;|E;|id;|os;|prox;)|tur(?:;|al(?:;|s;)))|b(?:sp;?|ump(?:;|e;))|c(?:a(?:p;|ron;)|edil;|ong(?:;|dot;)|up;|y;)|dash;|e(?:;|Arr;|ar(?:hk;|r(?:;|ow;))|dot;|quiv;|s(?:ear;|im;)|xist(?:;|s;))|fr;|g(?:E;|e(?:;|q(?:;|q;|slant;)|s;)|sim;|t(?:;|r;))|h(?:Arr;|arr;|par;)|i(?:;|s(?:;|d;)|v;)|jcy;|l(?:Arr;|E;|arr;|dr;|e(?:;|ft(?:arrow;|rightarrow;)|q(?:;|q;|slant;)|s(?:;|s;))|sim;|t(?:;|ri(?:;|e;)))|mid;|o(?:pf;|t(?:;|in(?:;|E;|dot;|v(?:a;|b;|c;))|ni(?:;|v(?:a;|b;|c;))|))|p(?:ar(?:;|allel;|sl;|t;)|olint;|r(?:;|cue;|e(?:;|c(?:;|eq;))))|r(?:Arr;|arr(?:;|c;|w;)|ightarrow;|tri(?:;|e;))|s(?:c(?:;|cue;|e;|r;)|hort(?:mid;|parallel;)|im(?:;|e(?:;|q;))|mid;|par;|qsu(?:be;|pe;)|u(?:b(?:;|E;|e;|set(?:;|eq(?:;|q;)))|cc(?:;|eq;)|p(?:;|E;|e;|set(?:;|eq(?:;|q;)))))|t(?:gl;|ilde;?|lg;|riangle(?:left(?:;|eq;)|right(?:;|eq;)))|u(?:;|m(?:;|ero;|sp;))|v(?:Dash;|Harr;|ap;|dash;|g(?:e;|t;)|infin;|l(?:Arr;|e;|t(?:;|rie;))|r(?:Arr;|trie;)|sim;)|w(?:Arr;|ar(?:hk;|r(?:;|ow;))|near;))|o(?:S;|a(?:cute;?|st;)|c(?:ir(?:;|c;?)|y;)|d(?:ash;|blac;|iv;|ot;|sold;)|elig;|f(?:cir;|r;)|g(?:on;|rave;?|t;)|h(?:bar;|m;)|int;|l(?:arr;|c(?:ir;|ross;)|ine;|t;)|m(?:acr;|ega;|i(?:cron;|d;|nus;))|opf;|p(?:ar;|erp;|lus;)|r(?:;|arr;|d(?:;|er(?:;|of;)|f;?|m;?)|igof;|or;|slope;|v;)|s(?:cr;|lash;?|ol;)|ti(?:lde;?|mes(?:;|as;))|uml;?|vbar;)|p(?:ar(?:;|a(?:;|llel;|)|s(?:im;|l;)|t;)|cy;|er(?:cnt;|iod;|mil;|p;|tenk;)|fr;|h(?:i(?:;|v;)|mmat;|one;)|i(?:;|tchfork;|v;)|l(?:an(?:ck(?:;|h;)|kv;)|us(?:;|acir;|b;|cir;|d(?:o;|u;)|e;|mn;?|sim;|two;))|m;|o(?:intint;|pf;|und;?)|r(?:;|E;|ap;|cue;|e(?:;|c(?:;|approx;|curlyeq;|eq;|n(?:approx;|eqq;|sim;)|sim;))|ime(?:;|s;)|n(?:E;|ap;|sim;)|o(?:d;|f(?:alar;|line;|surf;)|p(?:;|to;))|sim;|urel;)|s(?:cr;|i;)|uncsp;)|q(?:fr;|int;|opf;|prime;|scr;|u(?:at(?:ernions;|int;)|est(?:;|eq;)|ot;?))|r(?:A(?:arr;|rr;|tail;)|Barr;|Har;|a(?:c(?:e;|ute;)|dic;|emptyv;|ng(?:;|d;|e;|le;)|quo;?|rr(?:;|ap;|b(?:;|fs;)|c;|fs;|hk;|lp;|pl;|sim;|tl;|w;)|t(?:ail;|io(?:;|nals;)))|b(?:arr;|brk;|r(?:ac(?:e;|k;)|k(?:e;|sl(?:d;|u;))))|c(?:aron;|e(?:dil;|il;)|ub;|y;)|d(?:ca;|ldhar;|quo(?:;|r;)|sh;)|e(?:al(?:;|ine;|part;|s;)|ct;|g;?)|f(?:isht;|loor;|r;)|h(?:ar(?:d;|u(?:;|l;))|o(?:;|v;))|i(?:ght(?:arrow(?:;|tail;)|harpoon(?:down;|up;)|left(?:arrows;|harpoons;)|rightarrows;|squigarrow;|threetimes;)|ng;|singdotseq;)|l(?:arr;|har;|m;)|moust(?:;|ache;)|nmid;|o(?:a(?:ng;|rr;)|brk;|p(?:ar;|f;|lus;)|times;)|p(?:ar(?:;|gt;)|polint;)|rarr;|s(?:aquo;|cr;|h;|q(?:b;|uo(?:;|r;)))|t(?:hree;|imes;|ri(?:;|e;|f;|ltri;))|uluhar;|x;)|s(?:acute;|bquo;|c(?:;|E;|a(?:p;|ron;)|cue;|e(?:;|dil;)|irc;|n(?:E;|ap;|sim;)|polint;|sim;|y;)|dot(?:;|b;|e;)|e(?:Arr;|ar(?:hk;|r(?:;|ow;))|ct;?|mi;|swar;|tm(?:inus;|n;)|xt;)|fr(?:;|own;)|h(?:arp;|c(?:hcy;|y;)|ort(?:mid;|parallel;)|y;?)|i(?:gma(?:;|f;|v;)|m(?:;|dot;|e(?:;|q;)|g(?:;|E;)|l(?:;|E;)|ne;|plus;|rarr;))|larr;|m(?:a(?:llsetminus;|shp;)|eparsl;|i(?:d;|le;)|t(?:;|e(?:;|s;)))|o(?:ftcy;|l(?:;|b(?:;|ar;))|pf;)|pa(?:des(?:;|uit;)|r;)|q(?:c(?:ap(?:;|s;)|up(?:;|s;))|su(?:b(?:;|e;|set(?:;|eq;))|p(?:;|e;|set(?:;|eq;)))|u(?:;|ar(?:e;|f;)|f;))|rarr;|s(?:cr;|etmn;|mile;|tarf;)|t(?:ar(?:;|f;)|r(?:aight(?:epsilon;|phi;)|ns;))|u(?:b(?:;|E;|dot;|e(?:;|dot;)|mult;|n(?:E;|e;)|plus;|rarr;|s(?:et(?:;|eq(?:;|q;)|neq(?:;|q;))|im;|u(?:b;|p;)))|cc(?:;|approx;|curlyeq;|eq;|n(?:approx;|eqq;|sim;)|sim;)|m;|ng;|p(?:1;?|2;?|3;?|;|E;|d(?:ot;|sub;)|e(?:;|dot;)|hs(?:ol;|ub;)|larr;|mult;|n(?:E;|e;)|plus;|s(?:et(?:;|eq(?:;|q;)|neq(?:;|q;))|im;|u(?:b;|p;))))|w(?:Arr;|ar(?:hk;|r(?:;|ow;))|nwar;)|zlig;?)|t(?:a(?:rget;|u;)|brk;|c(?:aron;|edil;|y;)|dot;|elrec;|fr;|h(?:e(?:re(?:4;|fore;)|ta(?:;|sym;|v;))|i(?:ck(?:approx;|sim;)|nsp;)|k(?:ap;|sim;)|orn;?)|i(?:lde;|mes(?:;|b(?:;|ar;)|d;|)|nt;)|o(?:ea;|p(?:;|bot;|cir;|f(?:;|ork;))|sa;)|prime;|r(?:ade;|i(?:angle(?:;|down;|left(?:;|eq;)|q;|right(?:;|eq;))|dot;|e;|minus;|plus;|sb;|time;)|pezium;)|s(?:c(?:r;|y;)|hcy;|trok;)|w(?:ixt;|ohead(?:leftarrow;|rightarrow;)))|u(?:Arr;|Har;|a(?:cute;?|rr;)|br(?:cy;|eve;)|c(?:irc;?|y;)|d(?:arr;|blac;|har;)|f(?:isht;|r;)|grave;?|h(?:ar(?:l;|r;)|blk;)|l(?:c(?:orn(?:;|er;)|rop;)|tri;)|m(?:acr;|l;?)|o(?:gon;|pf;)|p(?:arrow;|downarrow;|harpoon(?:left;|right;)|lus;|si(?:;|h;|lon;)|uparrows;)|r(?:c(?:orn(?:;|er;)|rop;)|ing;|tri;)|scr;|t(?:dot;|ilde;|ri(?:;|f;))|u(?:arr;|ml;?)|wangle;)|v(?:Arr;|Bar(?:;|v;)|Dash;|a(?:ngrt;|r(?:epsilon;|kappa;|nothing;|p(?:hi;|i;|ropto;)|r(?:;|ho;)|s(?:igma;|u(?:bsetneq(?:;|q;)|psetneq(?:;|q;)))|t(?:heta;|riangle(?:left;|right;))))|cy;|dash;|e(?:e(?:;|bar;|eq;)|llip;|r(?:bar;|t;))|fr;|ltri;|nsu(?:b;|p;)|opf;|prop;|rtri;|s(?:cr;|u(?:bn(?:E;|e;)|pn(?:E;|e;)))|zigzag;)|w(?:circ;|e(?:d(?:bar;|ge(?:;|q;))|ierp;)|fr;|opf;|p;|r(?:;|eath;)|scr;)|x(?:c(?:ap;|irc;|up;)|dtri;|fr;|h(?:Arr;|arr;)|i;|l(?:Arr;|arr;)|map;|nis;|o(?:dot;|p(?:f;|lus;)|time;)|r(?:Arr;|arr;)|s(?:cr;|qcup;)|u(?:plus;|tri;)|vee;|wedge;)|y(?:ac(?:ute;?|y;)|c(?:irc;|y;)|en;?|fr;|icy;|opf;|scr;|u(?:cy;|ml;?))|z(?:acute;|c(?:aron;|y;)|dot;|e(?:etrf;|ta;)|fr;|hcy;|igrarr;|opf;|scr;|w(?:j;|nj;)))|[\s\S]/g;
    var NAMEDCHARREF_MAXLEN = 32;
    var DBLQUOTEATTRVAL = /[^\r"&\u0000]+/g;
    var SINGLEQUOTEATTRVAL = /[^\r'&\u0000]+/g;
    var UNQUOTEDATTRVAL = /[^\r\t\n\f &>\u0000]+/g;
    var TAGNAME = /[^\r\t\n\f \/>A-Z\u0000]+/g;
    var ATTRNAME = /[^\r\t\n\f \/=>A-Z\u0000]+/g;
    var CDATATEXT = /[^\]\r\u0000\uffff]*/g;
    var DATATEXT = /[^&<\r\u0000\uffff]*/g;
    var RAWTEXT = /[^<\r\u0000\uffff]*/g;
    var PLAINTEXT = /[^\r\u0000\uffff]*/g;
    var SIMPLETAG = /(?:(\/)?([a-z]+)>)|[\s\S]/g;
    var SIMPLEATTR = /(?:([-a-z]+)[ \t\n\f]*=[ \t\n\f]*('[^'&\r\u0000]*'|"[^"&\r\u0000]*"|[^\t\n\r\f "&'\u0000>][^&> \t\n\r\f\u0000]*[ \t\n\f]))|[\s\S]/g;
    var NONWS = /[^\x09\x0A\x0C\x0D\x20]/;
    var ALLNONWS = /[^\x09\x0A\x0C\x0D\x20]/g;
    var NONWSNONNUL = /[^\x00\x09\x0A\x0C\x0D\x20]/;
    var LEADINGWS = /^[\x09\x0A\x0C\x0D\x20]+/;
    var NULCHARS = /\x00/g;
    function buf2str(buf) {
      var CHUNKSIZE = 16384;
      if (buf.length < CHUNKSIZE) {
        return String.fromCharCode.apply(String, buf);
      }
      var result2 = "";
      for (var i = 0; i < buf.length; i += CHUNKSIZE) {
        result2 += String.fromCharCode.apply(String, buf.slice(i, i + CHUNKSIZE));
      }
      return result2;
    }
    function str2buf(s) {
      var result2 = [];
      for (var i = 0; i < s.length; i++) {
        result2[i] = s.charCodeAt(i);
      }
      return result2;
    }
    function isA(elt, set) {
      if (typeof set === "string") {
        return elt.namespaceURI === NAMESPACE.HTML && elt.localName === set;
      }
      var tagnames = set[elt.namespaceURI];
      return tagnames && tagnames[elt.localName];
    }
    function isMathmlTextIntegrationPoint(n) {
      return isA(n, mathmlTextIntegrationPointSet);
    }
    function isHTMLIntegrationPoint(n) {
      if (isA(n, htmlIntegrationPointSet)) return true;
      if (n.namespaceURI === NAMESPACE.MATHML && n.localName === "annotation-xml") {
        var encoding = n.getAttribute("encoding");
        if (encoding) encoding = encoding.toLowerCase();
        if (encoding === "text/html" || encoding === "application/xhtml+xml")
          return true;
      }
      return false;
    }
    function adjustSVGTagName(name) {
      if (name in svgTagNameAdjustments)
        return svgTagNameAdjustments[name];
      else
        return name;
    }
    function adjustSVGAttributes(attrs) {
      for (var i = 0, n = attrs.length; i < n; i++) {
        if (attrs[i][0] in svgAttrAdjustments) {
          attrs[i][0] = svgAttrAdjustments[attrs[i][0]];
        }
      }
    }
    function adjustMathMLAttributes(attrs) {
      for (var i = 0, n = attrs.length; i < n; i++) {
        if (attrs[i][0] === "definitionurl") {
          attrs[i][0] = "definitionURL";
          break;
        }
      }
    }
    function adjustForeignAttributes(attrs) {
      for (var i = 0, n = attrs.length; i < n; i++) {
        if (attrs[i][0] in foreignAttributes) {
          attrs[i].push(foreignAttributes[attrs[i][0]]);
        }
      }
    }
    function transferAttributes(attrs, elt) {
      for (var i = 0, n = attrs.length; i < n; i++) {
        var name = attrs[i][0], value = attrs[i][1];
        if (elt.hasAttribute(name)) continue;
        elt._setAttribute(name, value);
      }
    }
    HTMLParser.ElementStack = function ElementStack() {
      this.elements = [];
      this.top = null;
    };
    HTMLParser.ElementStack.prototype.push = function(e) {
      this.elements.push(e);
      this.top = e;
    };
    HTMLParser.ElementStack.prototype.pop = function(e) {
      this.elements.pop();
      this.top = this.elements[this.elements.length - 1];
    };
    HTMLParser.ElementStack.prototype.popTag = function(tag) {
      for (var i = this.elements.length - 1; i > 0; i--) {
        var e = this.elements[i];
        if (isA(e, tag)) break;
      }
      this.elements.length = i;
      this.top = this.elements[i - 1];
    };
    HTMLParser.ElementStack.prototype.popElementType = function(type) {
      for (var i = this.elements.length - 1; i > 0; i--) {
        if (this.elements[i] instanceof type) break;
      }
      this.elements.length = i;
      this.top = this.elements[i - 1];
    };
    HTMLParser.ElementStack.prototype.popElement = function(e) {
      for (var i = this.elements.length - 1; i > 0; i--) {
        if (this.elements[i] === e) break;
      }
      this.elements.length = i;
      this.top = this.elements[i - 1];
    };
    HTMLParser.ElementStack.prototype.removeElement = function(e) {
      if (this.top === e) this.pop();
      else {
        var idx = this.elements.lastIndexOf(e);
        if (idx !== -1)
          this.elements.splice(idx, 1);
      }
    };
    HTMLParser.ElementStack.prototype.clearToContext = function(set) {
      for (var i = this.elements.length - 1; i > 0; i--) {
        if (isA(this.elements[i], set)) break;
      }
      this.elements.length = i + 1;
      this.top = this.elements[i];
    };
    HTMLParser.ElementStack.prototype.contains = function(tag) {
      return this.inSpecificScope(tag, /* @__PURE__ */ Object.create(null));
    };
    HTMLParser.ElementStack.prototype.inSpecificScope = function(tag, set) {
      for (var i = this.elements.length - 1; i >= 0; i--) {
        var elt = this.elements[i];
        if (isA(elt, tag)) return true;
        if (isA(elt, set)) return false;
      }
      return false;
    };
    HTMLParser.ElementStack.prototype.elementInSpecificScope = function(target, set) {
      for (var i = this.elements.length - 1; i >= 0; i--) {
        var elt = this.elements[i];
        if (elt === target) return true;
        if (isA(elt, set)) return false;
      }
      return false;
    };
    HTMLParser.ElementStack.prototype.elementTypeInSpecificScope = function(target, set) {
      for (var i = this.elements.length - 1; i >= 0; i--) {
        var elt = this.elements[i];
        if (elt instanceof target) return true;
        if (isA(elt, set)) return false;
      }
      return false;
    };
    HTMLParser.ElementStack.prototype.inScope = function(tag) {
      return this.inSpecificScope(tag, inScopeSet);
    };
    HTMLParser.ElementStack.prototype.elementInScope = function(e) {
      return this.elementInSpecificScope(e, inScopeSet);
    };
    HTMLParser.ElementStack.prototype.elementTypeInScope = function(type) {
      return this.elementTypeInSpecificScope(type, inScopeSet);
    };
    HTMLParser.ElementStack.prototype.inButtonScope = function(tag) {
      return this.inSpecificScope(tag, inButtonScopeSet);
    };
    HTMLParser.ElementStack.prototype.inListItemScope = function(tag) {
      return this.inSpecificScope(tag, inListItemScopeSet);
    };
    HTMLParser.ElementStack.prototype.inTableScope = function(tag) {
      return this.inSpecificScope(tag, inTableScopeSet);
    };
    HTMLParser.ElementStack.prototype.inSelectScope = function(tag) {
      for (var i = this.elements.length - 1; i >= 0; i--) {
        var elt = this.elements[i];
        if (elt.namespaceURI !== NAMESPACE.HTML) return false;
        var localname = elt.localName;
        if (localname === tag) return true;
        if (localname !== "optgroup" && localname !== "option")
          return false;
      }
      return false;
    };
    HTMLParser.ElementStack.prototype.generateImpliedEndTags = function(butnot, thorough) {
      var endTagSet = thorough ? thoroughImpliedEndTagsSet : impliedEndTagsSet;
      for (var i = this.elements.length - 1; i >= 0; i--) {
        var e = this.elements[i];
        if (butnot && isA(e, butnot)) break;
        if (!isA(this.elements[i], endTagSet)) break;
      }
      this.elements.length = i + 1;
      this.top = this.elements[i];
    };
    HTMLParser.ActiveFormattingElements = function AFE() {
      this.list = [];
      this.attrs = [];
    };
    HTMLParser.ActiveFormattingElements.prototype.MARKER = { localName: "|" };
    HTMLParser.ActiveFormattingElements.prototype.insertMarker = function() {
      this.list.push(this.MARKER);
      this.attrs.push(this.MARKER);
    };
    HTMLParser.ActiveFormattingElements.prototype.push = function(elt, attrs) {
      var count2 = 0;
      for (var i = this.list.length - 1; i >= 0; i--) {
        if (this.list[i] === this.MARKER) break;
        if (equal(elt, this.list[i], this.attrs[i])) {
          count2++;
          if (count2 === 3) {
            this.list.splice(i, 1);
            this.attrs.splice(i, 1);
            break;
          }
        }
      }
      this.list.push(elt);
      var attrcopy = [];
      for (var ii = 0; ii < attrs.length; ii++) {
        attrcopy[ii] = attrs[ii];
      }
      this.attrs.push(attrcopy);
      function equal(newelt, oldelt, oldattrs) {
        if (newelt.localName !== oldelt.localName) return false;
        if (newelt._numattrs !== oldattrs.length) return false;
        for (var i2 = 0, n = oldattrs.length; i2 < n; i2++) {
          var oldname = oldattrs[i2][0];
          var oldval = oldattrs[i2][1];
          if (!newelt.hasAttribute(oldname)) return false;
          if (newelt.getAttribute(oldname) !== oldval) return false;
        }
        return true;
      }
    };
    HTMLParser.ActiveFormattingElements.prototype.clearToMarker = function() {
      for (var i = this.list.length - 1; i >= 0; i--) {
        if (this.list[i] === this.MARKER) break;
      }
      if (i < 0) i = 0;
      this.list.length = i;
      this.attrs.length = i;
    };
    HTMLParser.ActiveFormattingElements.prototype.findElementByTag = function(tag) {
      for (var i = this.list.length - 1; i >= 0; i--) {
        var elt = this.list[i];
        if (elt === this.MARKER) break;
        if (elt.localName === tag) return elt;
      }
      return null;
    };
    HTMLParser.ActiveFormattingElements.prototype.indexOf = function(e) {
      return this.list.lastIndexOf(e);
    };
    HTMLParser.ActiveFormattingElements.prototype.remove = function(e) {
      var idx = this.list.lastIndexOf(e);
      if (idx !== -1) {
        this.list.splice(idx, 1);
        this.attrs.splice(idx, 1);
      }
    };
    HTMLParser.ActiveFormattingElements.prototype.replace = function(a, b, attrs) {
      var idx = this.list.lastIndexOf(a);
      if (idx !== -1) {
        this.list[idx] = b;
        this.attrs[idx] = attrs;
      }
    };
    HTMLParser.ActiveFormattingElements.prototype.insertAfter = function(a, b) {
      var idx = this.list.lastIndexOf(a);
      if (idx !== -1) {
        this.list.splice(idx, 0, b);
        this.attrs.splice(idx, 0, b);
      }
    };
    function HTMLParser(address, fragmentContext, options) {
      var chars = null;
      var numchars = 0;
      var nextchar = 0;
      var input_complete = false;
      var scanner_skip_newline = false;
      var reentrant_invocations = 0;
      var saved_scanner_state = [];
      var leftovers = "";
      var first_batch = true;
      var paused = 0;
      var tokenizer = data_state;
      var return_state;
      var character_reference_code;
      var tagnamebuf = "";
      var lasttagname = "";
      var tempbuf = [];
      var attrnamebuf = "";
      var attrvaluebuf = "";
      var commentbuf = [];
      var doctypenamebuf = [];
      var doctypepublicbuf = [];
      var doctypesystembuf = [];
      var attributes = [];
      var is_end_tag = false;
      var parser = initial_mode;
      var originalInsertionMode = null;
      var templateInsertionModes = [];
      var stack2 = new HTMLParser.ElementStack();
      var afe = new HTMLParser.ActiveFormattingElements();
      var fragment = fragmentContext !== void 0;
      var head_element_pointer = null;
      var form_element_pointer = null;
      var scripting_enabled = true;
      if (fragmentContext) {
        scripting_enabled = fragmentContext.ownerDocument._scripting_enabled;
      }
      if (options && options.scripting_enabled === false)
        scripting_enabled = false;
      var frameset_ok = true;
      var force_quirks = false;
      var pending_table_text;
      var text_integration_mode;
      var textrun = [];
      var textIncludesNUL = false;
      var ignore_linefeed = false;
      var htmlparser = {
        document: function() {
          return doc2;
        },
        // Convenience function for internal use. Can only be called once,
        // as it removes the nodes from `doc` to add them to fragment.
        _asDocumentFragment: function() {
          var frag = doc2.createDocumentFragment();
          var root2 = doc2.firstChild;
          while (root2.hasChildNodes()) {
            frag.appendChild(root2.firstChild);
          }
          return frag;
        },
        // Internal function used from HTMLScriptElement to pause the
        // parser while a script is being loaded from the network
        pause: function() {
          paused++;
        },
        // Called when a script finishes loading
        resume: function() {
          paused--;
          this.parse("");
        },
        // Parse the HTML text s.
        // The second argument should be true if there is no more
        // text to be parsed, and should be false or omitted otherwise.
        // The second argument must not be set for recursive invocations
        // from document.write()
        parse: function(s, end, shouldPauseFunc) {
          var moreToDo;
          if (paused > 0) {
            leftovers += s;
            return true;
          }
          if (reentrant_invocations === 0) {
            if (leftovers) {
              s = leftovers + s;
              leftovers = "";
            }
            if (end) {
              s += "\uFFFF";
              input_complete = true;
            }
            chars = s;
            numchars = s.length;
            nextchar = 0;
            if (first_batch) {
              first_batch = false;
              if (chars.charCodeAt(0) === 65279) nextchar = 1;
            }
            reentrant_invocations++;
            moreToDo = scanChars(shouldPauseFunc);
            leftovers = chars.substring(nextchar, numchars);
            reentrant_invocations--;
          } else {
            reentrant_invocations++;
            saved_scanner_state.push(chars, numchars, nextchar);
            chars = s;
            numchars = s.length;
            nextchar = 0;
            scanChars();
            moreToDo = false;
            leftovers = chars.substring(nextchar, numchars);
            nextchar = saved_scanner_state.pop();
            numchars = saved_scanner_state.pop();
            chars = saved_scanner_state.pop();
            if (leftovers) {
              chars = leftovers + chars.substring(nextchar);
              numchars = chars.length;
              nextchar = 0;
              leftovers = "";
            }
            reentrant_invocations--;
          }
          return moreToDo;
        }
      };
      var doc2 = new Document(true, address);
      doc2._parser = htmlparser;
      doc2._scripting_enabled = scripting_enabled;
      if (fragmentContext) {
        if (fragmentContext.ownerDocument._quirks)
          doc2._quirks = true;
        if (fragmentContext.ownerDocument._limitedQuirks)
          doc2._limitedQuirks = true;
        if (fragmentContext.namespaceURI === NAMESPACE.HTML) {
          switch (fragmentContext.localName) {
            case "title":
            case "textarea":
              tokenizer = rcdata_state;
              break;
            case "style":
            case "xmp":
            case "iframe":
            case "noembed":
            case "noframes":
            case "script":
            case "plaintext":
              tokenizer = plaintext_state;
              break;
            case "noscript":
              if (scripting_enabled)
                tokenizer = plaintext_state;
          }
        }
        var root = doc2.createElement("html");
        doc2._appendChild(root);
        stack2.push(root);
        if (fragmentContext instanceof impl.HTMLTemplateElement) {
          templateInsertionModes.push(in_template_mode);
        }
        resetInsertionMode();
        for (var e = fragmentContext; e !== null; e = e.parentElement) {
          if (e instanceof impl.HTMLFormElement) {
            form_element_pointer = e;
            break;
          }
        }
      }
      function scanChars(shouldPauseFunc) {
        var codepoint, s, pattern, eof;
        while (nextchar < numchars) {
          if (paused > 0 || shouldPauseFunc && shouldPauseFunc()) {
            return true;
          }
          switch (typeof tokenizer.lookahead) {
            case "undefined":
              codepoint = chars.charCodeAt(nextchar++);
              if (scanner_skip_newline) {
                scanner_skip_newline = false;
                if (codepoint === 10) {
                  nextchar++;
                  continue;
                }
              }
              switch (codepoint) {
                case 13:
                  if (nextchar < numchars) {
                    if (chars.charCodeAt(nextchar) === 10)
                      nextchar++;
                  } else {
                    scanner_skip_newline = true;
                  }
                  tokenizer(10);
                  break;
                case 65535:
                  if (input_complete && nextchar === numchars) {
                    tokenizer(EOF);
                    break;
                  }
                /* falls through */
                default:
                  tokenizer(codepoint);
                  break;
              }
              break;
            case "number":
              codepoint = chars.charCodeAt(nextchar);
              var n = tokenizer.lookahead;
              var needsString = true;
              if (n < 0) {
                needsString = false;
                n = -n;
              }
              if (n < numchars - nextchar) {
                s = needsString ? chars.substring(nextchar, nextchar + n) : null;
                eof = false;
              } else {
                if (input_complete) {
                  s = needsString ? chars.substring(nextchar, numchars) : null;
                  eof = true;
                  if (codepoint === 65535 && nextchar === numchars - 1)
                    codepoint = EOF;
                } else {
                  return true;
                }
              }
              tokenizer(codepoint, s, eof);
              break;
            case "string":
              codepoint = chars.charCodeAt(nextchar);
              pattern = tokenizer.lookahead;
              var pos = chars.indexOf(pattern, nextchar);
              if (pos !== -1) {
                s = chars.substring(nextchar, pos + pattern.length);
                eof = false;
              } else {
                if (!input_complete) return true;
                s = chars.substring(nextchar, numchars);
                if (codepoint === 65535 && nextchar === numchars - 1)
                  codepoint = EOF;
                eof = true;
              }
              tokenizer(codepoint, s, eof);
              break;
          }
        }
        return false;
      }
      function addAttribute(name, value) {
        for (var i = 0; i < attributes.length; i++) {
          if (attributes[i][0] === name) return;
        }
        if (value !== void 0) {
          attributes.push([name, value]);
        } else {
          attributes.push([name]);
        }
      }
      function handleSimpleAttribute() {
        SIMPLEATTR.lastIndex = nextchar - 1;
        var matched = SIMPLEATTR.exec(chars);
        if (!matched) throw new Error("should never happen");
        var name = matched[1];
        if (!name) return false;
        var value = matched[2];
        var len = value.length;
        switch (value[0]) {
          case '"':
          case "'":
            value = value.substring(1, len - 1);
            nextchar += matched[0].length - 1;
            tokenizer = after_attribute_value_quoted_state;
            break;
          default:
            tokenizer = before_attribute_name_state;
            nextchar += matched[0].length - 1;
            value = value.substring(0, len - 1);
            break;
        }
        for (var i = 0; i < attributes.length; i++) {
          if (attributes[i][0] === name) return true;
        }
        attributes.push([name, value]);
        return true;
      }
      function beginTagName() {
        is_end_tag = false;
        tagnamebuf = "";
        attributes.length = 0;
      }
      function beginEndTagName() {
        is_end_tag = true;
        tagnamebuf = "";
        attributes.length = 0;
      }
      function beginTempBuf() {
        tempbuf.length = 0;
      }
      function beginAttrName() {
        attrnamebuf = "";
      }
      function beginAttrValue() {
        attrvaluebuf = "";
      }
      function beginComment() {
        commentbuf.length = 0;
      }
      function beginDoctype() {
        doctypenamebuf.length = 0;
        doctypepublicbuf = null;
        doctypesystembuf = null;
      }
      function beginDoctypePublicId() {
        doctypepublicbuf = [];
      }
      function beginDoctypeSystemId() {
        doctypesystembuf = [];
      }
      function forcequirks() {
        force_quirks = true;
      }
      function cdataAllowed() {
        return stack2.top && stack2.top.namespaceURI !== "http://www.w3.org/1999/xhtml";
      }
      function appropriateEndTag(buf) {
        return lasttagname === buf;
      }
      function flushText() {
        if (textrun.length > 0) {
          var s = buf2str(textrun);
          textrun.length = 0;
          if (ignore_linefeed) {
            ignore_linefeed = false;
            if (s[0] === "\n") s = s.substring(1);
            if (s.length === 0) return;
          }
          insertToken(TEXT, s);
          textIncludesNUL = false;
        }
        ignore_linefeed = false;
      }
      function getMatchingChars(pattern) {
        pattern.lastIndex = nextchar - 1;
        var match = pattern.exec(chars);
        if (match && match.index === nextchar - 1) {
          match = match[0];
          nextchar += match.length - 1;
          if (input_complete && nextchar === numchars) {
            match = match.slice(0, -1);
            nextchar--;
          }
          return match;
        } else {
          throw new Error("should never happen");
        }
      }
      function emitCharsWhile(pattern) {
        pattern.lastIndex = nextchar - 1;
        var match = pattern.exec(chars)[0];
        if (!match) return false;
        emitCharString(match);
        nextchar += match.length - 1;
        return true;
      }
      function emitCharString(s) {
        if (textrun.length > 0) flushText();
        if (ignore_linefeed) {
          ignore_linefeed = false;
          if (s[0] === "\n") s = s.substring(1);
          if (s.length === 0) return;
        }
        insertToken(TEXT, s);
      }
      function emitTag() {
        if (is_end_tag) insertToken(ENDTAG, tagnamebuf);
        else {
          var tagname = tagnamebuf;
          tagnamebuf = "";
          lasttagname = tagname;
          insertToken(TAG, tagname, attributes);
        }
      }
      function emitSimpleTag() {
        if (nextchar === numchars) {
          return false;
        }
        SIMPLETAG.lastIndex = nextchar;
        var matched = SIMPLETAG.exec(chars);
        if (!matched) throw new Error("should never happen");
        var tagname = matched[2];
        if (!tagname) return false;
        var endtag = matched[1];
        if (endtag) {
          nextchar += tagname.length + 2;
          insertToken(ENDTAG, tagname);
        } else {
          nextchar += tagname.length + 1;
          lasttagname = tagname;
          insertToken(TAG, tagname, NOATTRS);
        }
        return true;
      }
      function emitSelfClosingTag() {
        if (is_end_tag) insertToken(ENDTAG, tagnamebuf, null, true);
        else {
          insertToken(TAG, tagnamebuf, attributes, true);
        }
      }
      function emitDoctype() {
        insertToken(
          DOCTYPE,
          buf2str(doctypenamebuf),
          doctypepublicbuf ? buf2str(doctypepublicbuf) : void 0,
          doctypesystembuf ? buf2str(doctypesystembuf) : void 0
        );
      }
      function emitEOF() {
        flushText();
        parser(EOF);
        doc2.modclock = 1;
      }
      var insertToken = htmlparser.insertToken = function insertToken2(t, value, arg3, arg4) {
        flushText();
        var current = stack2.top;
        if (!current || current.namespaceURI === NAMESPACE.HTML) {
          parser(t, value, arg3, arg4);
        } else {
          if (t !== TAG && t !== TEXT) {
            insertForeignToken(t, value, arg3, arg4);
          } else {
            if (isMathmlTextIntegrationPoint(current) && (t === TEXT || t === TAG && value !== "mglyph" && value !== "malignmark") || t === TAG && value === "svg" && current.namespaceURI === NAMESPACE.MATHML && current.localName === "annotation-xml" || isHTMLIntegrationPoint(current)) {
              text_integration_mode = true;
              parser(t, value, arg3, arg4);
              text_integration_mode = false;
            } else {
              insertForeignToken(t, value, arg3, arg4);
            }
          }
        }
      };
      function insertComment(data) {
        var parent = stack2.top;
        if (foster_parent_mode && isA(parent, tablesectionrowSet)) {
          fosterParent(function(doc3) {
            return doc3.createComment(data);
          });
        } else {
          if (parent instanceof impl.HTMLTemplateElement) {
            parent = parent.content;
          }
          parent._appendChild(parent.ownerDocument.createComment(data));
        }
      }
      function insertText(s) {
        var parent = stack2.top;
        if (foster_parent_mode && isA(parent, tablesectionrowSet)) {
          fosterParent(function(doc3) {
            return doc3.createTextNode(s);
          });
        } else {
          if (parent instanceof impl.HTMLTemplateElement) {
            parent = parent.content;
          }
          var lastChild = parent.lastChild;
          if (lastChild && lastChild.nodeType === Node.TEXT_NODE) {
            lastChild.appendData(s);
          } else {
            parent._appendChild(parent.ownerDocument.createTextNode(s));
          }
        }
      }
      function createHTMLElt(doc3, name, attrs) {
        var elt = html.createElement(doc3, name, null);
        if (attrs) {
          for (var i = 0, n = attrs.length; i < n; i++) {
            elt._setAttribute(attrs[i][0], attrs[i][1]);
          }
        }
        return elt;
      }
      var foster_parent_mode = false;
      function insertHTMLElement(name, attrs) {
        var elt = insertElement(function(doc3) {
          return createHTMLElt(doc3, name, attrs);
        });
        if (isA(elt, formassociatedSet)) {
          elt._form = form_element_pointer;
        }
        return elt;
      }
      function insertElement(eltFunc) {
        var elt;
        if (foster_parent_mode && isA(stack2.top, tablesectionrowSet)) {
          elt = fosterParent(eltFunc);
        } else if (stack2.top instanceof impl.HTMLTemplateElement) {
          elt = eltFunc(stack2.top.content.ownerDocument);
          stack2.top.content._appendChild(elt);
        } else {
          elt = eltFunc(stack2.top.ownerDocument);
          stack2.top._appendChild(elt);
        }
        stack2.push(elt);
        return elt;
      }
      function insertForeignElement(name, attrs, ns) {
        return insertElement(function(doc3) {
          var elt = doc3._createElementNS(name, ns, null);
          if (attrs) {
            for (var i = 0, n = attrs.length; i < n; i++) {
              var attr = attrs[i];
              if (attr.length === 2)
                elt._setAttribute(attr[0], attr[1]);
              else {
                elt._setAttributeNS(attr[2], attr[0], attr[1]);
              }
            }
          }
          return elt;
        });
      }
      function lastElementOfType(type) {
        for (var i = stack2.elements.length - 1; i >= 0; i--) {
          if (stack2.elements[i] instanceof type) {
            return i;
          }
        }
        return -1;
      }
      function fosterParent(eltFunc) {
        var parent, before, lastTable = -1, lastTemplate = -1, elt;
        lastTable = lastElementOfType(impl.HTMLTableElement);
        lastTemplate = lastElementOfType(impl.HTMLTemplateElement);
        if (lastTemplate >= 0 && (lastTable < 0 || lastTemplate > lastTable)) {
          parent = stack2.elements[lastTemplate];
        } else if (lastTable >= 0) {
          parent = stack2.elements[lastTable].parentNode;
          if (parent) {
            before = stack2.elements[lastTable];
          } else {
            parent = stack2.elements[lastTable - 1];
          }
        }
        if (!parent) parent = stack2.elements[0];
        if (parent instanceof impl.HTMLTemplateElement) {
          parent = parent.content;
        }
        elt = eltFunc(parent.ownerDocument);
        if (elt.nodeType === Node.TEXT_NODE) {
          var prev;
          if (before) prev = before.previousSibling;
          else prev = parent.lastChild;
          if (prev && prev.nodeType === Node.TEXT_NODE) {
            prev.appendData(elt.data);
            return elt;
          }
        }
        if (before)
          parent.insertBefore(elt, before);
        else
          parent._appendChild(elt);
        return elt;
      }
      function resetInsertionMode() {
        var last = false;
        for (var i = stack2.elements.length - 1; i >= 0; i--) {
          var node = stack2.elements[i];
          if (i === 0) {
            last = true;
            if (fragment) {
              node = fragmentContext;
            }
          }
          if (node.namespaceURI === NAMESPACE.HTML) {
            var tag = node.localName;
            switch (tag) {
              case "select":
                for (var j = i; j > 0; ) {
                  var ancestor = stack2.elements[--j];
                  if (ancestor instanceof impl.HTMLTemplateElement) {
                    break;
                  } else if (ancestor instanceof impl.HTMLTableElement) {
                    parser = in_select_in_table_mode;
                    return;
                  }
                }
                parser = in_select_mode;
                return;
              case "tr":
                parser = in_row_mode;
                return;
              case "tbody":
              case "tfoot":
              case "thead":
                parser = in_table_body_mode;
                return;
              case "caption":
                parser = in_caption_mode;
                return;
              case "colgroup":
                parser = in_column_group_mode;
                return;
              case "table":
                parser = in_table_mode;
                return;
              case "template":
                parser = templateInsertionModes[templateInsertionModes.length - 1];
                return;
              case "body":
                parser = in_body_mode;
                return;
              case "frameset":
                parser = in_frameset_mode;
                return;
              case "html":
                if (head_element_pointer === null) {
                  parser = before_head_mode;
                } else {
                  parser = after_head_mode;
                }
                return;
              default:
                if (!last) {
                  if (tag === "head") {
                    parser = in_head_mode;
                    return;
                  }
                  if (tag === "td" || tag === "th") {
                    parser = in_cell_mode;
                    return;
                  }
                }
            }
          }
          if (last) {
            parser = in_body_mode;
            return;
          }
        }
      }
      function parseRawText(name, attrs) {
        insertHTMLElement(name, attrs);
        tokenizer = rawtext_state;
        originalInsertionMode = parser;
        parser = text_mode;
      }
      function parseRCDATA(name, attrs) {
        insertHTMLElement(name, attrs);
        tokenizer = rcdata_state;
        originalInsertionMode = parser;
        parser = text_mode;
      }
      function afeclone(doc3, i) {
        return {
          elt: createHTMLElt(doc3, afe.list[i].localName, afe.attrs[i]),
          attrs: afe.attrs[i]
        };
      }
      function afereconstruct() {
        if (afe.list.length === 0) return;
        var entry = afe.list[afe.list.length - 1];
        if (entry === afe.MARKER) return;
        if (stack2.elements.lastIndexOf(entry) !== -1) return;
        for (var i = afe.list.length - 2; i >= 0; i--) {
          entry = afe.list[i];
          if (entry === afe.MARKER) break;
          if (stack2.elements.lastIndexOf(entry) !== -1) break;
        }
        for (i = i + 1; i < afe.list.length; i++) {
          var newelt = insertElement(function(doc3) {
            return afeclone(doc3, i).elt;
          });
          afe.list[i] = newelt;
        }
      }
      var BOOKMARK = { localName: "BM" };
      function adoptionAgency(tag) {
        if (isA(stack2.top, tag) && afe.indexOf(stack2.top) === -1) {
          stack2.pop();
          return true;
        }
        var outer = 0;
        while (outer < 8) {
          outer++;
          var fmtelt = afe.findElementByTag(tag);
          if (!fmtelt) {
            return false;
          }
          var index = stack2.elements.lastIndexOf(fmtelt);
          if (index === -1) {
            afe.remove(fmtelt);
            return true;
          }
          if (!stack2.elementInScope(fmtelt)) {
            return true;
          }
          var furthestblock = null, furthestblockindex;
          for (var i = index + 1; i < stack2.elements.length; i++) {
            if (isA(stack2.elements[i], specialSet)) {
              furthestblock = stack2.elements[i];
              furthestblockindex = i;
              break;
            }
          }
          if (!furthestblock) {
            stack2.popElement(fmtelt);
            afe.remove(fmtelt);
            return true;
          } else {
            var ancestor = stack2.elements[index - 1];
            afe.insertAfter(fmtelt, BOOKMARK);
            var node = furthestblock;
            var lastnode = furthestblock;
            var nodeindex = furthestblockindex;
            var nodeafeindex;
            var inner = 0;
            while (true) {
              inner++;
              node = stack2.elements[--nodeindex];
              if (node === fmtelt) break;
              nodeafeindex = afe.indexOf(node);
              if (inner > 3 && nodeafeindex !== -1) {
                afe.remove(node);
                nodeafeindex = -1;
              }
              if (nodeafeindex === -1) {
                stack2.removeElement(node);
                continue;
              }
              var newelt = afeclone(ancestor.ownerDocument, nodeafeindex);
              afe.replace(node, newelt.elt, newelt.attrs);
              stack2.elements[nodeindex] = newelt.elt;
              node = newelt.elt;
              if (lastnode === furthestblock) {
                afe.remove(BOOKMARK);
                afe.insertAfter(newelt.elt, BOOKMARK);
              }
              node._appendChild(lastnode);
              lastnode = node;
            }
            if (foster_parent_mode && isA(ancestor, tablesectionrowSet)) {
              fosterParent(function() {
                return lastnode;
              });
            } else if (ancestor instanceof impl.HTMLTemplateElement) {
              ancestor.content._appendChild(lastnode);
            } else {
              ancestor._appendChild(lastnode);
            }
            var newelt2 = afeclone(furthestblock.ownerDocument, afe.indexOf(fmtelt));
            while (furthestblock.hasChildNodes()) {
              newelt2.elt._appendChild(furthestblock.firstChild);
            }
            furthestblock._appendChild(newelt2.elt);
            afe.remove(fmtelt);
            afe.replace(BOOKMARK, newelt2.elt, newelt2.attrs);
            stack2.removeElement(fmtelt);
            var pos = stack2.elements.lastIndexOf(furthestblock);
            stack2.elements.splice(pos + 1, 0, newelt2.elt);
          }
        }
        return true;
      }
      function handleScriptEnd() {
        stack2.pop();
        parser = originalInsertionMode;
        return;
      }
      function stopParsing() {
        delete doc2._parser;
        stack2.elements.length = 0;
        if (doc2.defaultView) {
          doc2.defaultView.dispatchEvent(new impl.Event("load", {}));
        }
      }
      function reconsume(c, new_state) {
        tokenizer = new_state;
        nextchar--;
      }
      function data_state(c) {
        switch (c) {
          case 38:
            return_state = data_state;
            tokenizer = character_reference_state;
            break;
          case 60:
            if (emitSimpleTag())
              break;
            tokenizer = tag_open_state;
            break;
          case 0:
            textrun.push(c);
            textIncludesNUL = true;
            break;
          case -1:
            emitEOF();
            break;
          default:
            emitCharsWhile(DATATEXT) || textrun.push(c);
            break;
        }
      }
      function rcdata_state(c) {
        switch (c) {
          case 38:
            return_state = rcdata_state;
            tokenizer = character_reference_state;
            break;
          case 60:
            tokenizer = rcdata_less_than_sign_state;
            break;
          case 0:
            textrun.push(65533);
            textIncludesNUL = true;
            break;
          case -1:
            emitEOF();
            break;
          default:
            textrun.push(c);
            break;
        }
      }
      function rawtext_state(c) {
        switch (c) {
          case 60:
            tokenizer = rawtext_less_than_sign_state;
            break;
          case 0:
            textrun.push(65533);
            break;
          case -1:
            emitEOF();
            break;
          default:
            emitCharsWhile(RAWTEXT) || textrun.push(c);
            break;
        }
      }
      function script_data_state(c) {
        switch (c) {
          case 60:
            tokenizer = script_data_less_than_sign_state;
            break;
          case 0:
            textrun.push(65533);
            break;
          case -1:
            emitEOF();
            break;
          default:
            emitCharsWhile(RAWTEXT) || textrun.push(c);
            break;
        }
      }
      function plaintext_state(c) {
        switch (c) {
          case 0:
            textrun.push(65533);
            break;
          case -1:
            emitEOF();
            break;
          default:
            emitCharsWhile(PLAINTEXT) || textrun.push(c);
            break;
        }
      }
      function tag_open_state(c) {
        switch (c) {
          case 33:
            tokenizer = markup_declaration_open_state;
            break;
          case 47:
            tokenizer = end_tag_open_state;
            break;
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
          case 97:
          // [a-z]
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            beginTagName();
            reconsume(c, tag_name_state);
            break;
          case 63:
            reconsume(c, bogus_comment_state);
            break;
          default:
            textrun.push(60);
            reconsume(c, data_state);
            break;
        }
      }
      function end_tag_open_state(c) {
        switch (c) {
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
          case 97:
          // [a-z]
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            beginEndTagName();
            reconsume(c, tag_name_state);
            break;
          case 62:
            tokenizer = data_state;
            break;
          case -1:
            textrun.push(60);
            textrun.push(47);
            emitEOF();
            break;
          default:
            reconsume(c, bogus_comment_state);
            break;
        }
      }
      function tag_name_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            tokenizer = before_attribute_name_state;
            break;
          case 47:
            tokenizer = self_closing_start_tag_state;
            break;
          case 62:
            tokenizer = data_state;
            emitTag();
            break;
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
            tagnamebuf += String.fromCharCode(c + 32);
            break;
          case 0:
            tagnamebuf += String.fromCharCode(
              65533
              /* REPLACEMENT CHARACTER */
            );
            break;
          case -1:
            emitEOF();
            break;
          default:
            tagnamebuf += getMatchingChars(TAGNAME);
            break;
        }
      }
      function rcdata_less_than_sign_state(c) {
        if (c === 47) {
          beginTempBuf();
          tokenizer = rcdata_end_tag_open_state;
        } else {
          textrun.push(60);
          reconsume(c, rcdata_state);
        }
      }
      function rcdata_end_tag_open_state(c) {
        switch (c) {
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
          case 97:
          // [a-z]
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            beginEndTagName();
            reconsume(c, rcdata_end_tag_name_state);
            break;
          default:
            textrun.push(60);
            textrun.push(47);
            reconsume(c, rcdata_state);
            break;
        }
      }
      function rcdata_end_tag_name_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            if (appropriateEndTag(tagnamebuf)) {
              tokenizer = before_attribute_name_state;
              return;
            }
            break;
          case 47:
            if (appropriateEndTag(tagnamebuf)) {
              tokenizer = self_closing_start_tag_state;
              return;
            }
            break;
          case 62:
            if (appropriateEndTag(tagnamebuf)) {
              tokenizer = data_state;
              emitTag();
              return;
            }
            break;
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
            tagnamebuf += String.fromCharCode(c + 32);
            tempbuf.push(c);
            return;
          case 97:
          // [a-z]
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            tagnamebuf += String.fromCharCode(c);
            tempbuf.push(c);
            return;
          default:
            break;
        }
        textrun.push(60);
        textrun.push(47);
        pushAll(textrun, tempbuf);
        reconsume(c, rcdata_state);
      }
      function rawtext_less_than_sign_state(c) {
        if (c === 47) {
          beginTempBuf();
          tokenizer = rawtext_end_tag_open_state;
        } else {
          textrun.push(60);
          reconsume(c, rawtext_state);
        }
      }
      function rawtext_end_tag_open_state(c) {
        switch (c) {
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
          case 97:
          // [a-z]
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            beginEndTagName();
            reconsume(c, rawtext_end_tag_name_state);
            break;
          default:
            textrun.push(60);
            textrun.push(47);
            reconsume(c, rawtext_state);
            break;
        }
      }
      function rawtext_end_tag_name_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            if (appropriateEndTag(tagnamebuf)) {
              tokenizer = before_attribute_name_state;
              return;
            }
            break;
          case 47:
            if (appropriateEndTag(tagnamebuf)) {
              tokenizer = self_closing_start_tag_state;
              return;
            }
            break;
          case 62:
            if (appropriateEndTag(tagnamebuf)) {
              tokenizer = data_state;
              emitTag();
              return;
            }
            break;
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
            tagnamebuf += String.fromCharCode(c + 32);
            tempbuf.push(c);
            return;
          case 97:
          // [a-z]
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            tagnamebuf += String.fromCharCode(c);
            tempbuf.push(c);
            return;
          default:
            break;
        }
        textrun.push(60);
        textrun.push(47);
        pushAll(textrun, tempbuf);
        reconsume(c, rawtext_state);
      }
      function script_data_less_than_sign_state(c) {
        switch (c) {
          case 47:
            beginTempBuf();
            tokenizer = script_data_end_tag_open_state;
            break;
          case 33:
            tokenizer = script_data_escape_start_state;
            textrun.push(60);
            textrun.push(33);
            break;
          default:
            textrun.push(60);
            reconsume(c, script_data_state);
            break;
        }
      }
      function script_data_end_tag_open_state(c) {
        switch (c) {
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
          case 97:
          // [a-z]
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            beginEndTagName();
            reconsume(c, script_data_end_tag_name_state);
            break;
          default:
            textrun.push(60);
            textrun.push(47);
            reconsume(c, script_data_state);
            break;
        }
      }
      function script_data_end_tag_name_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            if (appropriateEndTag(tagnamebuf)) {
              tokenizer = before_attribute_name_state;
              return;
            }
            break;
          case 47:
            if (appropriateEndTag(tagnamebuf)) {
              tokenizer = self_closing_start_tag_state;
              return;
            }
            break;
          case 62:
            if (appropriateEndTag(tagnamebuf)) {
              tokenizer = data_state;
              emitTag();
              return;
            }
            break;
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
            tagnamebuf += String.fromCharCode(c + 32);
            tempbuf.push(c);
            return;
          case 97:
          // [a-z]
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            tagnamebuf += String.fromCharCode(c);
            tempbuf.push(c);
            return;
          default:
            break;
        }
        textrun.push(60);
        textrun.push(47);
        pushAll(textrun, tempbuf);
        reconsume(c, script_data_state);
      }
      function script_data_escape_start_state(c) {
        if (c === 45) {
          tokenizer = script_data_escape_start_dash_state;
          textrun.push(45);
        } else {
          reconsume(c, script_data_state);
        }
      }
      function script_data_escape_start_dash_state(c) {
        if (c === 45) {
          tokenizer = script_data_escaped_dash_dash_state;
          textrun.push(45);
        } else {
          reconsume(c, script_data_state);
        }
      }
      function script_data_escaped_state(c) {
        switch (c) {
          case 45:
            tokenizer = script_data_escaped_dash_state;
            textrun.push(45);
            break;
          case 60:
            tokenizer = script_data_escaped_less_than_sign_state;
            break;
          case 0:
            textrun.push(65533);
            break;
          case -1:
            emitEOF();
            break;
          default:
            textrun.push(c);
            break;
        }
      }
      function script_data_escaped_dash_state(c) {
        switch (c) {
          case 45:
            tokenizer = script_data_escaped_dash_dash_state;
            textrun.push(45);
            break;
          case 60:
            tokenizer = script_data_escaped_less_than_sign_state;
            break;
          case 0:
            tokenizer = script_data_escaped_state;
            textrun.push(65533);
            break;
          case -1:
            emitEOF();
            break;
          default:
            tokenizer = script_data_escaped_state;
            textrun.push(c);
            break;
        }
      }
      function script_data_escaped_dash_dash_state(c) {
        switch (c) {
          case 45:
            textrun.push(45);
            break;
          case 60:
            tokenizer = script_data_escaped_less_than_sign_state;
            break;
          case 62:
            tokenizer = script_data_state;
            textrun.push(62);
            break;
          case 0:
            tokenizer = script_data_escaped_state;
            textrun.push(65533);
            break;
          case -1:
            emitEOF();
            break;
          default:
            tokenizer = script_data_escaped_state;
            textrun.push(c);
            break;
        }
      }
      function script_data_escaped_less_than_sign_state(c) {
        switch (c) {
          case 47:
            beginTempBuf();
            tokenizer = script_data_escaped_end_tag_open_state;
            break;
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
          case 97:
          // [a-z]
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            beginTempBuf();
            textrun.push(60);
            reconsume(c, script_data_double_escape_start_state);
            break;
          default:
            textrun.push(60);
            reconsume(c, script_data_escaped_state);
            break;
        }
      }
      function script_data_escaped_end_tag_open_state(c) {
        switch (c) {
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
          case 97:
          // [a-z]
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            beginEndTagName();
            reconsume(c, script_data_escaped_end_tag_name_state);
            break;
          default:
            textrun.push(60);
            textrun.push(47);
            reconsume(c, script_data_escaped_state);
            break;
        }
      }
      function script_data_escaped_end_tag_name_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            if (appropriateEndTag(tagnamebuf)) {
              tokenizer = before_attribute_name_state;
              return;
            }
            break;
          case 47:
            if (appropriateEndTag(tagnamebuf)) {
              tokenizer = self_closing_start_tag_state;
              return;
            }
            break;
          case 62:
            if (appropriateEndTag(tagnamebuf)) {
              tokenizer = data_state;
              emitTag();
              return;
            }
            break;
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
            tagnamebuf += String.fromCharCode(c + 32);
            tempbuf.push(c);
            return;
          case 97:
          // [a-z]
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            tagnamebuf += String.fromCharCode(c);
            tempbuf.push(c);
            return;
          default:
            break;
        }
        textrun.push(60);
        textrun.push(47);
        pushAll(textrun, tempbuf);
        reconsume(c, script_data_escaped_state);
      }
      function script_data_double_escape_start_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
          // SPACE
          case 47:
          // SOLIDUS
          case 62:
            if (buf2str(tempbuf) === "script") {
              tokenizer = script_data_double_escaped_state;
            } else {
              tokenizer = script_data_escaped_state;
            }
            textrun.push(c);
            break;
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
            tempbuf.push(c + 32);
            textrun.push(c);
            break;
          case 97:
          // [a-z]
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            tempbuf.push(c);
            textrun.push(c);
            break;
          default:
            reconsume(c, script_data_escaped_state);
            break;
        }
      }
      function script_data_double_escaped_state(c) {
        switch (c) {
          case 45:
            tokenizer = script_data_double_escaped_dash_state;
            textrun.push(45);
            break;
          case 60:
            tokenizer = script_data_double_escaped_less_than_sign_state;
            textrun.push(60);
            break;
          case 0:
            textrun.push(65533);
            break;
          case -1:
            emitEOF();
            break;
          default:
            textrun.push(c);
            break;
        }
      }
      function script_data_double_escaped_dash_state(c) {
        switch (c) {
          case 45:
            tokenizer = script_data_double_escaped_dash_dash_state;
            textrun.push(45);
            break;
          case 60:
            tokenizer = script_data_double_escaped_less_than_sign_state;
            textrun.push(60);
            break;
          case 0:
            tokenizer = script_data_double_escaped_state;
            textrun.push(65533);
            break;
          case -1:
            emitEOF();
            break;
          default:
            tokenizer = script_data_double_escaped_state;
            textrun.push(c);
            break;
        }
      }
      function script_data_double_escaped_dash_dash_state(c) {
        switch (c) {
          case 45:
            textrun.push(45);
            break;
          case 60:
            tokenizer = script_data_double_escaped_less_than_sign_state;
            textrun.push(60);
            break;
          case 62:
            tokenizer = script_data_state;
            textrun.push(62);
            break;
          case 0:
            tokenizer = script_data_double_escaped_state;
            textrun.push(65533);
            break;
          case -1:
            emitEOF();
            break;
          default:
            tokenizer = script_data_double_escaped_state;
            textrun.push(c);
            break;
        }
      }
      function script_data_double_escaped_less_than_sign_state(c) {
        if (c === 47) {
          beginTempBuf();
          tokenizer = script_data_double_escape_end_state;
          textrun.push(47);
        } else {
          reconsume(c, script_data_double_escaped_state);
        }
      }
      function script_data_double_escape_end_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
          // SPACE
          case 47:
          // SOLIDUS
          case 62:
            if (buf2str(tempbuf) === "script") {
              tokenizer = script_data_escaped_state;
            } else {
              tokenizer = script_data_double_escaped_state;
            }
            textrun.push(c);
            break;
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
            tempbuf.push(c + 32);
            textrun.push(c);
            break;
          case 97:
          // [a-z]
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            tempbuf.push(c);
            textrun.push(c);
            break;
          default:
            reconsume(c, script_data_double_escaped_state);
            break;
        }
      }
      function before_attribute_name_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            break;
          // For SOLIDUS, GREATER-THAN SIGN, and EOF, spec says "reconsume in
          // the after attribute name state", but in our implementation that
          // state always has an active attribute in attrnamebuf.  Just clone
          // the rules here, without the addAttribute business.
          case 47:
            tokenizer = self_closing_start_tag_state;
            break;
          case 62:
            tokenizer = data_state;
            emitTag();
            break;
          case -1:
            emitEOF();
            break;
          case 61:
            beginAttrName();
            attrnamebuf += String.fromCharCode(c);
            tokenizer = attribute_name_state;
            break;
          default:
            if (handleSimpleAttribute()) break;
            beginAttrName();
            reconsume(c, attribute_name_state);
            break;
        }
      }
      function attribute_name_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
          // SPACE
          case 47:
          // SOLIDUS
          case 62:
          // GREATER-THAN SIGN
          case -1:
            reconsume(c, after_attribute_name_state);
            break;
          case 61:
            tokenizer = before_attribute_value_state;
            break;
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
            attrnamebuf += String.fromCharCode(c + 32);
            break;
          case 0:
            attrnamebuf += String.fromCharCode(
              65533
              /* REPLACEMENT CHARACTER */
            );
            break;
          case 34:
          // QUOTATION MARK
          case 39:
          // APOSTROPHE
          case 60:
          // LESS-THAN SIGN
          /* falls through */
          default:
            attrnamebuf += getMatchingChars(ATTRNAME);
            break;
        }
      }
      function after_attribute_name_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            break;
          case 47:
            addAttribute(attrnamebuf);
            tokenizer = self_closing_start_tag_state;
            break;
          case 61:
            tokenizer = before_attribute_value_state;
            break;
          case 62:
            tokenizer = data_state;
            addAttribute(attrnamebuf);
            emitTag();
            break;
          case -1:
            addAttribute(attrnamebuf);
            emitEOF();
            break;
          default:
            addAttribute(attrnamebuf);
            beginAttrName();
            reconsume(c, attribute_name_state);
            break;
        }
      }
      function before_attribute_value_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            break;
          case 34:
            beginAttrValue();
            tokenizer = attribute_value_double_quoted_state;
            break;
          case 39:
            beginAttrValue();
            tokenizer = attribute_value_single_quoted_state;
            break;
          case 62:
          // GREATER-THAN SIGN
          /* falls through */
          default:
            beginAttrValue();
            reconsume(c, attribute_value_unquoted_state);
            break;
        }
      }
      function attribute_value_double_quoted_state(c) {
        switch (c) {
          case 34:
            addAttribute(attrnamebuf, attrvaluebuf);
            tokenizer = after_attribute_value_quoted_state;
            break;
          case 38:
            return_state = attribute_value_double_quoted_state;
            tokenizer = character_reference_state;
            break;
          case 0:
            attrvaluebuf += String.fromCharCode(
              65533
              /* REPLACEMENT CHARACTER */
            );
            break;
          case -1:
            emitEOF();
            break;
          case 10:
            attrvaluebuf += String.fromCharCode(c);
            break;
          default:
            attrvaluebuf += getMatchingChars(DBLQUOTEATTRVAL);
            break;
        }
      }
      function attribute_value_single_quoted_state(c) {
        switch (c) {
          case 39:
            addAttribute(attrnamebuf, attrvaluebuf);
            tokenizer = after_attribute_value_quoted_state;
            break;
          case 38:
            return_state = attribute_value_single_quoted_state;
            tokenizer = character_reference_state;
            break;
          case 0:
            attrvaluebuf += String.fromCharCode(
              65533
              /* REPLACEMENT CHARACTER */
            );
            break;
          case -1:
            emitEOF();
            break;
          case 10:
            attrvaluebuf += String.fromCharCode(c);
            break;
          default:
            attrvaluebuf += getMatchingChars(SINGLEQUOTEATTRVAL);
            break;
        }
      }
      function attribute_value_unquoted_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            addAttribute(attrnamebuf, attrvaluebuf);
            tokenizer = before_attribute_name_state;
            break;
          case 38:
            return_state = attribute_value_unquoted_state;
            tokenizer = character_reference_state;
            break;
          case 62:
            addAttribute(attrnamebuf, attrvaluebuf);
            tokenizer = data_state;
            emitTag();
            break;
          case 0:
            attrvaluebuf += String.fromCharCode(
              65533
              /* REPLACEMENT CHARACTER */
            );
            break;
          case -1:
            nextchar--;
            tokenizer = data_state;
            break;
          case 34:
          // QUOTATION MARK
          case 39:
          // APOSTROPHE
          case 60:
          // LESS-THAN SIGN
          case 61:
          // EQUALS SIGN
          case 96:
          // GRAVE ACCENT
          /* falls through */
          default:
            attrvaluebuf += getMatchingChars(UNQUOTEDATTRVAL);
            break;
        }
      }
      function after_attribute_value_quoted_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            tokenizer = before_attribute_name_state;
            break;
          case 47:
            tokenizer = self_closing_start_tag_state;
            break;
          case 62:
            tokenizer = data_state;
            emitTag();
            break;
          case -1:
            emitEOF();
            break;
          default:
            reconsume(c, before_attribute_name_state);
            break;
        }
      }
      function self_closing_start_tag_state(c) {
        switch (c) {
          case 62:
            tokenizer = data_state;
            emitSelfClosingTag(true);
            break;
          case -1:
            emitEOF();
            break;
          default:
            reconsume(c, before_attribute_name_state);
            break;
        }
      }
      function bogus_comment_state(c, lookahead, eof) {
        var len = lookahead.length;
        if (eof) {
          nextchar += len - 1;
        } else {
          nextchar += len;
        }
        var comment = lookahead.substring(0, len - 1);
        comment = comment.replace(/\u0000/g, "\uFFFD");
        comment = comment.replace(/\u000D\u000A/g, "\n");
        comment = comment.replace(/\u000D/g, "\n");
        insertToken(COMMENT, comment);
        tokenizer = data_state;
      }
      bogus_comment_state.lookahead = ">";
      function markup_declaration_open_state(c, lookahead, eof) {
        if (lookahead[0] === "-" && lookahead[1] === "-") {
          nextchar += 2;
          beginComment();
          tokenizer = comment_start_state;
          return;
        }
        if (lookahead.toUpperCase() === "DOCTYPE") {
          nextchar += 7;
          tokenizer = doctype_state;
        } else if (lookahead === "[CDATA[" && cdataAllowed()) {
          nextchar += 7;
          tokenizer = cdata_section_state;
        } else {
          tokenizer = bogus_comment_state;
        }
      }
      markup_declaration_open_state.lookahead = 7;
      function comment_start_state(c) {
        beginComment();
        switch (c) {
          case 45:
            tokenizer = comment_start_dash_state;
            break;
          case 62:
            tokenizer = data_state;
            insertToken(COMMENT, buf2str(commentbuf));
            break;
          /* see comment in comment end state */
          default:
            reconsume(c, comment_state);
            break;
        }
      }
      function comment_start_dash_state(c) {
        switch (c) {
          case 45:
            tokenizer = comment_end_state;
            break;
          case 62:
            tokenizer = data_state;
            insertToken(COMMENT, buf2str(commentbuf));
            break;
          case -1:
            insertToken(COMMENT, buf2str(commentbuf));
            emitEOF();
            break;
          /* see comment in comment end state */
          default:
            commentbuf.push(
              45
              /* HYPHEN-MINUS */
            );
            reconsume(c, comment_state);
            break;
        }
      }
      function comment_state(c) {
        switch (c) {
          case 60:
            commentbuf.push(c);
            tokenizer = comment_less_than_sign_state;
            break;
          case 45:
            tokenizer = comment_end_dash_state;
            break;
          case 0:
            commentbuf.push(
              65533
              /* REPLACEMENT CHARACTER */
            );
            break;
          case -1:
            insertToken(COMMENT, buf2str(commentbuf));
            emitEOF();
            break;
          /* see comment in comment end state */
          default:
            commentbuf.push(c);
            break;
        }
      }
      function comment_less_than_sign_state(c) {
        switch (c) {
          case 33:
            commentbuf.push(c);
            tokenizer = comment_less_than_sign_bang_state;
            break;
          case 60:
            commentbuf.push(c);
            break;
          default:
            reconsume(c, comment_state);
            break;
        }
      }
      function comment_less_than_sign_bang_state(c) {
        switch (c) {
          case 45:
            tokenizer = comment_less_than_sign_bang_dash_state;
            break;
          default:
            reconsume(c, comment_state);
            break;
        }
      }
      function comment_less_than_sign_bang_dash_state(c) {
        switch (c) {
          case 45:
            tokenizer = comment_less_than_sign_bang_dash_dash_state;
            break;
          default:
            reconsume(c, comment_end_dash_state);
            break;
        }
      }
      function comment_less_than_sign_bang_dash_dash_state(c) {
        switch (c) {
          case 62:
          // GREATER-THAN SIGN
          case -1:
            reconsume(c, comment_end_state);
            break;
          default:
            reconsume(c, comment_end_state);
            break;
        }
      }
      function comment_end_dash_state(c) {
        switch (c) {
          case 45:
            tokenizer = comment_end_state;
            break;
          case -1:
            insertToken(COMMENT, buf2str(commentbuf));
            emitEOF();
            break;
          /* see comment in comment end state */
          default:
            commentbuf.push(
              45
              /* HYPHEN-MINUS */
            );
            reconsume(c, comment_state);
            break;
        }
      }
      function comment_end_state(c) {
        switch (c) {
          case 62:
            tokenizer = data_state;
            insertToken(COMMENT, buf2str(commentbuf));
            break;
          case 33:
            tokenizer = comment_end_bang_state;
            break;
          case 45:
            commentbuf.push(45);
            break;
          case -1:
            insertToken(COMMENT, buf2str(commentbuf));
            emitEOF();
            break;
          /* For security reasons: otherwise, hostile user could put a script in a comment e.g. in a blog comment and then DOS the server so that the end tag isn't read, and then the commented script tag would be treated as live code */
          default:
            commentbuf.push(45);
            commentbuf.push(45);
            reconsume(c, comment_state);
            break;
        }
      }
      function comment_end_bang_state(c) {
        switch (c) {
          case 45:
            commentbuf.push(45);
            commentbuf.push(45);
            commentbuf.push(33);
            tokenizer = comment_end_dash_state;
            break;
          case 62:
            tokenizer = data_state;
            insertToken(COMMENT, buf2str(commentbuf));
            break;
          case -1:
            insertToken(COMMENT, buf2str(commentbuf));
            emitEOF();
            break;
          /* see comment in comment end state */
          default:
            commentbuf.push(45);
            commentbuf.push(45);
            commentbuf.push(33);
            reconsume(c, comment_state);
            break;
        }
      }
      function doctype_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            tokenizer = before_doctype_name_state;
            break;
          case -1:
            beginDoctype();
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            reconsume(c, before_doctype_name_state);
            break;
        }
      }
      function before_doctype_name_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            break;
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
            beginDoctype();
            doctypenamebuf.push(c + 32);
            tokenizer = doctype_name_state;
            break;
          case 0:
            beginDoctype();
            doctypenamebuf.push(65533);
            tokenizer = doctype_name_state;
            break;
          case 62:
            beginDoctype();
            forcequirks();
            tokenizer = data_state;
            emitDoctype();
            break;
          case -1:
            beginDoctype();
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            beginDoctype();
            doctypenamebuf.push(c);
            tokenizer = doctype_name_state;
            break;
        }
      }
      function doctype_name_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            tokenizer = after_doctype_name_state;
            break;
          case 62:
            tokenizer = data_state;
            emitDoctype();
            break;
          case 65:
          // [A-Z]
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
            doctypenamebuf.push(c + 32);
            break;
          case 0:
            doctypenamebuf.push(
              65533
              /* REPLACEMENT CHARACTER */
            );
            break;
          case -1:
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            doctypenamebuf.push(c);
            break;
        }
      }
      function after_doctype_name_state(c, lookahead, eof) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            nextchar += 1;
            break;
          case 62:
            tokenizer = data_state;
            nextchar += 1;
            emitDoctype();
            break;
          case -1:
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            lookahead = lookahead.toUpperCase();
            if (lookahead === "PUBLIC") {
              nextchar += 6;
              tokenizer = after_doctype_public_keyword_state;
            } else if (lookahead === "SYSTEM") {
              nextchar += 6;
              tokenizer = after_doctype_system_keyword_state;
            } else {
              forcequirks();
              tokenizer = bogus_doctype_state;
            }
            break;
        }
      }
      after_doctype_name_state.lookahead = 6;
      function after_doctype_public_keyword_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            tokenizer = before_doctype_public_identifier_state;
            break;
          case 34:
            beginDoctypePublicId();
            tokenizer = doctype_public_identifier_double_quoted_state;
            break;
          case 39:
            beginDoctypePublicId();
            tokenizer = doctype_public_identifier_single_quoted_state;
            break;
          case 62:
            forcequirks();
            tokenizer = data_state;
            emitDoctype();
            break;
          case -1:
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            forcequirks();
            tokenizer = bogus_doctype_state;
            break;
        }
      }
      function before_doctype_public_identifier_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            break;
          case 34:
            beginDoctypePublicId();
            tokenizer = doctype_public_identifier_double_quoted_state;
            break;
          case 39:
            beginDoctypePublicId();
            tokenizer = doctype_public_identifier_single_quoted_state;
            break;
          case 62:
            forcequirks();
            tokenizer = data_state;
            emitDoctype();
            break;
          case -1:
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            forcequirks();
            tokenizer = bogus_doctype_state;
            break;
        }
      }
      function doctype_public_identifier_double_quoted_state(c) {
        switch (c) {
          case 34:
            tokenizer = after_doctype_public_identifier_state;
            break;
          case 0:
            doctypepublicbuf.push(
              65533
              /* REPLACEMENT CHARACTER */
            );
            break;
          case 62:
            forcequirks();
            tokenizer = data_state;
            emitDoctype();
            break;
          case -1:
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            doctypepublicbuf.push(c);
            break;
        }
      }
      function doctype_public_identifier_single_quoted_state(c) {
        switch (c) {
          case 39:
            tokenizer = after_doctype_public_identifier_state;
            break;
          case 0:
            doctypepublicbuf.push(
              65533
              /* REPLACEMENT CHARACTER */
            );
            break;
          case 62:
            forcequirks();
            tokenizer = data_state;
            emitDoctype();
            break;
          case -1:
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            doctypepublicbuf.push(c);
            break;
        }
      }
      function after_doctype_public_identifier_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            tokenizer = between_doctype_public_and_system_identifiers_state;
            break;
          case 62:
            tokenizer = data_state;
            emitDoctype();
            break;
          case 34:
            beginDoctypeSystemId();
            tokenizer = doctype_system_identifier_double_quoted_state;
            break;
          case 39:
            beginDoctypeSystemId();
            tokenizer = doctype_system_identifier_single_quoted_state;
            break;
          case -1:
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            forcequirks();
            tokenizer = bogus_doctype_state;
            break;
        }
      }
      function between_doctype_public_and_system_identifiers_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            break;
          case 62:
            tokenizer = data_state;
            emitDoctype();
            break;
          case 34:
            beginDoctypeSystemId();
            tokenizer = doctype_system_identifier_double_quoted_state;
            break;
          case 39:
            beginDoctypeSystemId();
            tokenizer = doctype_system_identifier_single_quoted_state;
            break;
          case -1:
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            forcequirks();
            tokenizer = bogus_doctype_state;
            break;
        }
      }
      function after_doctype_system_keyword_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            tokenizer = before_doctype_system_identifier_state;
            break;
          case 34:
            beginDoctypeSystemId();
            tokenizer = doctype_system_identifier_double_quoted_state;
            break;
          case 39:
            beginDoctypeSystemId();
            tokenizer = doctype_system_identifier_single_quoted_state;
            break;
          case 62:
            forcequirks();
            tokenizer = data_state;
            emitDoctype();
            break;
          case -1:
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            forcequirks();
            tokenizer = bogus_doctype_state;
            break;
        }
      }
      function before_doctype_system_identifier_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            break;
          case 34:
            beginDoctypeSystemId();
            tokenizer = doctype_system_identifier_double_quoted_state;
            break;
          case 39:
            beginDoctypeSystemId();
            tokenizer = doctype_system_identifier_single_quoted_state;
            break;
          case 62:
            forcequirks();
            tokenizer = data_state;
            emitDoctype();
            break;
          case -1:
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            forcequirks();
            tokenizer = bogus_doctype_state;
            break;
        }
      }
      function doctype_system_identifier_double_quoted_state(c) {
        switch (c) {
          case 34:
            tokenizer = after_doctype_system_identifier_state;
            break;
          case 0:
            doctypesystembuf.push(
              65533
              /* REPLACEMENT CHARACTER */
            );
            break;
          case 62:
            forcequirks();
            tokenizer = data_state;
            emitDoctype();
            break;
          case -1:
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            doctypesystembuf.push(c);
            break;
        }
      }
      function doctype_system_identifier_single_quoted_state(c) {
        switch (c) {
          case 39:
            tokenizer = after_doctype_system_identifier_state;
            break;
          case 0:
            doctypesystembuf.push(
              65533
              /* REPLACEMENT CHARACTER */
            );
            break;
          case 62:
            forcequirks();
            tokenizer = data_state;
            emitDoctype();
            break;
          case -1:
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            doctypesystembuf.push(c);
            break;
        }
      }
      function after_doctype_system_identifier_state(c) {
        switch (c) {
          case 9:
          // CHARACTER TABULATION (tab)
          case 10:
          // LINE FEED (LF)
          case 12:
          // FORM FEED (FF)
          case 32:
            break;
          case 62:
            tokenizer = data_state;
            emitDoctype();
            break;
          case -1:
            forcequirks();
            emitDoctype();
            emitEOF();
            break;
          default:
            tokenizer = bogus_doctype_state;
            break;
        }
      }
      function bogus_doctype_state(c) {
        switch (c) {
          case 62:
            tokenizer = data_state;
            emitDoctype();
            break;
          case -1:
            emitDoctype();
            emitEOF();
            break;
          default:
            break;
        }
      }
      function cdata_section_state(c) {
        switch (c) {
          case 93:
            tokenizer = cdata_section_bracket_state;
            break;
          case -1:
            emitEOF();
            break;
          case 0:
            textIncludesNUL = true;
          /* fall through */
          default:
            emitCharsWhile(CDATATEXT) || textrun.push(c);
            break;
        }
      }
      function cdata_section_bracket_state(c) {
        switch (c) {
          case 93:
            tokenizer = cdata_section_end_state;
            break;
          default:
            textrun.push(93);
            reconsume(c, cdata_section_state);
            break;
        }
      }
      function cdata_section_end_state(c) {
        switch (c) {
          case 93:
            textrun.push(93);
            break;
          case 62:
            flushText();
            tokenizer = data_state;
            break;
          default:
            textrun.push(93);
            textrun.push(93);
            reconsume(c, cdata_section_state);
            break;
        }
      }
      function character_reference_state(c) {
        beginTempBuf();
        tempbuf.push(38);
        switch (c) {
          case 9:
          // TAB
          case 10:
          // LINE FEED
          case 12:
          // FORM FEED
          case 32:
          // SPACE
          case 60:
          // LESS-THAN SIGN
          case 38:
          // AMPERSAND
          case -1:
            reconsume(c, character_reference_end_state);
            break;
          case 35:
            tempbuf.push(c);
            tokenizer = numeric_character_reference_state;
            break;
          default:
            reconsume(c, named_character_reference_state);
            break;
        }
      }
      function named_character_reference_state(c) {
        NAMEDCHARREF.lastIndex = nextchar;
        var matched = NAMEDCHARREF.exec(chars);
        if (!matched) throw new Error("should never happen");
        var name = matched[1];
        if (!name) {
          tokenizer = character_reference_end_state;
          return;
        }
        nextchar += name.length;
        pushAll(tempbuf, str2buf(name));
        switch (return_state) {
          case attribute_value_double_quoted_state:
          case attribute_value_single_quoted_state:
          case attribute_value_unquoted_state:
            if (name[name.length - 1] !== ";") {
              if (/[=A-Za-z0-9]/.test(chars[nextchar])) {
                tokenizer = character_reference_end_state;
                return;
              }
            }
            break;
          default:
            break;
        }
        beginTempBuf();
        var rv = namedCharRefs[name];
        if (typeof rv === "number") {
          tempbuf.push(rv);
        } else {
          pushAll(tempbuf, rv);
        }
        tokenizer = character_reference_end_state;
      }
      named_character_reference_state.lookahead = -NAMEDCHARREF_MAXLEN;
      function numeric_character_reference_state(c) {
        character_reference_code = 0;
        switch (c) {
          case 120:
          // x
          case 88:
            tempbuf.push(c);
            tokenizer = hexadecimal_character_reference_start_state;
            break;
          default:
            reconsume(c, decimal_character_reference_start_state);
            break;
        }
      }
      function hexadecimal_character_reference_start_state(c) {
        switch (c) {
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
          // [0-9]
          case 65:
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          // [A-F]
          case 97:
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
            reconsume(c, hexadecimal_character_reference_state);
            break;
          default:
            reconsume(c, character_reference_end_state);
            break;
        }
      }
      function decimal_character_reference_start_state(c) {
        switch (c) {
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            reconsume(c, decimal_character_reference_state);
            break;
          default:
            reconsume(c, character_reference_end_state);
            break;
        }
      }
      function hexadecimal_character_reference_state(c) {
        switch (c) {
          case 65:
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
            character_reference_code *= 16;
            character_reference_code += c - 55;
            break;
          case 97:
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
            character_reference_code *= 16;
            character_reference_code += c - 87;
            break;
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            character_reference_code *= 16;
            character_reference_code += c - 48;
            break;
          case 59:
            tokenizer = numeric_character_reference_end_state;
            break;
          default:
            reconsume(c, numeric_character_reference_end_state);
            break;
        }
      }
      function decimal_character_reference_state(c) {
        switch (c) {
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            character_reference_code *= 10;
            character_reference_code += c - 48;
            break;
          case 59:
            tokenizer = numeric_character_reference_end_state;
            break;
          default:
            reconsume(c, numeric_character_reference_end_state);
            break;
        }
      }
      function numeric_character_reference_end_state(c) {
        if (character_reference_code in numericCharRefReplacements) {
          character_reference_code = numericCharRefReplacements[character_reference_code];
        } else if (character_reference_code > 1114111 || character_reference_code >= 55296 && character_reference_code < 57344) {
          character_reference_code = 65533;
        }
        beginTempBuf();
        if (character_reference_code <= 65535) {
          tempbuf.push(character_reference_code);
        } else {
          character_reference_code = character_reference_code - 65536;
          tempbuf.push(55296 + (character_reference_code >> 10));
          tempbuf.push(56320 + (character_reference_code & 1023));
        }
        reconsume(c, character_reference_end_state);
      }
      function character_reference_end_state(c) {
        switch (return_state) {
          case attribute_value_double_quoted_state:
          case attribute_value_single_quoted_state:
          case attribute_value_unquoted_state:
            attrvaluebuf += buf2str(tempbuf);
            break;
          default:
            pushAll(textrun, tempbuf);
            break;
        }
        reconsume(c, return_state);
      }
      function initial_mode(t, value, arg3, arg4) {
        switch (t) {
          case 1:
            value = value.replace(LEADINGWS, "");
            if (value.length === 0) return;
            break;
          // Handle anything non-space text below
          case 4:
            doc2._appendChild(doc2.createComment(value));
            return;
          case 5:
            var name = value;
            var publicid = arg3;
            var systemid = arg4;
            doc2.appendChild(new DocumentType(doc2, name, publicid, systemid));
            if (force_quirks || name.toLowerCase() !== "html" || quirkyPublicIds.test(publicid) || systemid && systemid.toLowerCase() === quirkySystemId || systemid === void 0 && conditionallyQuirkyPublicIds.test(publicid))
              doc2._quirks = true;
            else if (limitedQuirkyPublicIds.test(publicid) || systemid !== void 0 && conditionallyQuirkyPublicIds.test(publicid))
              doc2._limitedQuirks = true;
            parser = before_html_mode;
            return;
        }
        doc2._quirks = true;
        parser = before_html_mode;
        parser(t, value, arg3, arg4);
      }
      function before_html_mode(t, value, arg3, arg4) {
        var elt;
        switch (t) {
          case 1:
            value = value.replace(LEADINGWS, "");
            if (value.length === 0) return;
            break;
          // Handle anything non-space text below
          case 5:
            return;
          case 4:
            doc2._appendChild(doc2.createComment(value));
            return;
          case 2:
            if (value === "html") {
              elt = createHTMLElt(doc2, value, arg3);
              stack2.push(elt);
              doc2.appendChild(elt);
              parser = before_head_mode;
              return;
            }
            break;
          case 3:
            switch (value) {
              case "html":
              case "head":
              case "body":
              case "br":
                break;
              // fall through on these
              default:
                return;
            }
        }
        elt = createHTMLElt(doc2, "html", null);
        stack2.push(elt);
        doc2.appendChild(elt);
        parser = before_head_mode;
        parser(t, value, arg3, arg4);
      }
      function before_head_mode(t, value, arg3, arg4) {
        switch (t) {
          case 1:
            value = value.replace(LEADINGWS, "");
            if (value.length === 0) return;
            break;
          // Handle anything non-space text below
          case 5:
            return;
          case 4:
            insertComment(value);
            return;
          case 2:
            switch (value) {
              case "html":
                in_body_mode(t, value, arg3, arg4);
                return;
              case "head":
                var elt = insertHTMLElement(value, arg3);
                head_element_pointer = elt;
                parser = in_head_mode;
                return;
            }
            break;
          case 3:
            switch (value) {
              case "html":
              case "head":
              case "body":
              case "br":
                break;
              default:
                return;
            }
        }
        before_head_mode(TAG, "head", null);
        parser(t, value, arg3, arg4);
      }
      function in_head_mode(t, value, arg3, arg4) {
        switch (t) {
          case 1:
            var ws = value.match(LEADINGWS);
            if (ws) {
              insertText(ws[0]);
              value = value.substring(ws[0].length);
            }
            if (value.length === 0) return;
            break;
          // Handle non-whitespace below
          case 4:
            insertComment(value);
            return;
          case 5:
            return;
          case 2:
            switch (value) {
              case "html":
                in_body_mode(t, value, arg3, arg4);
                return;
              case "meta":
              // XXX:
              // May need to change the encoding based on this tag
              /* falls through */
              case "base":
              case "basefont":
              case "bgsound":
              case "link":
                insertHTMLElement(value, arg3);
                stack2.pop();
                return;
              case "title":
                parseRCDATA(value, arg3);
                return;
              case "noscript":
                if (!scripting_enabled) {
                  insertHTMLElement(value, arg3);
                  parser = in_head_noscript_mode;
                  return;
                }
              // Otherwise, if scripting is enabled...
              /* falls through */
              case "noframes":
              case "style":
                parseRawText(value, arg3);
                return;
              case "script":
                insertElement(function(doc3) {
                  var elt = createHTMLElt(doc3, value, arg3);
                  elt._parser_inserted = true;
                  elt._force_async = false;
                  if (fragment) elt._already_started = true;
                  flushText();
                  return elt;
                });
                tokenizer = script_data_state;
                originalInsertionMode = parser;
                parser = text_mode;
                return;
              case "template":
                insertHTMLElement(value, arg3);
                afe.insertMarker();
                frameset_ok = false;
                parser = in_template_mode;
                templateInsertionModes.push(parser);
                return;
              case "head":
                return;
            }
            break;
          case 3:
            switch (value) {
              case "head":
                stack2.pop();
                parser = after_head_mode;
                return;
              case "body":
              case "html":
              case "br":
                break;
              // handle these at the bottom of the function
              case "template":
                if (!stack2.contains("template")) {
                  return;
                }
                stack2.generateImpliedEndTags(null, "thorough");
                stack2.popTag("template");
                afe.clearToMarker();
                templateInsertionModes.pop();
                resetInsertionMode();
                return;
              default:
                return;
            }
            break;
        }
        in_head_mode(ENDTAG, "head", null);
        parser(t, value, arg3, arg4);
      }
      function in_head_noscript_mode(t, value, arg3, arg4) {
        switch (t) {
          case 5:
            return;
          case 4:
            in_head_mode(t, value);
            return;
          case 1:
            var ws = value.match(LEADINGWS);
            if (ws) {
              in_head_mode(t, ws[0]);
              value = value.substring(ws[0].length);
            }
            if (value.length === 0) return;
            break;
          // Handle non-whitespace below
          case 2:
            switch (value) {
              case "html":
                in_body_mode(t, value, arg3, arg4);
                return;
              case "basefont":
              case "bgsound":
              case "link":
              case "meta":
              case "noframes":
              case "style":
                in_head_mode(t, value, arg3);
                return;
              case "head":
              case "noscript":
                return;
            }
            break;
          case 3:
            switch (value) {
              case "noscript":
                stack2.pop();
                parser = in_head_mode;
                return;
              case "br":
                break;
              // goes to the outer default
              default:
                return;
            }
            break;
        }
        in_head_noscript_mode(ENDTAG, "noscript", null);
        parser(t, value, arg3, arg4);
      }
      function after_head_mode(t, value, arg3, arg4) {
        switch (t) {
          case 1:
            var ws = value.match(LEADINGWS);
            if (ws) {
              insertText(ws[0]);
              value = value.substring(ws[0].length);
            }
            if (value.length === 0) return;
            break;
          // Handle non-whitespace below
          case 4:
            insertComment(value);
            return;
          case 5:
            return;
          case 2:
            switch (value) {
              case "html":
                in_body_mode(t, value, arg3, arg4);
                return;
              case "body":
                insertHTMLElement(value, arg3);
                frameset_ok = false;
                parser = in_body_mode;
                return;
              case "frameset":
                insertHTMLElement(value, arg3);
                parser = in_frameset_mode;
                return;
              case "base":
              case "basefont":
              case "bgsound":
              case "link":
              case "meta":
              case "noframes":
              case "script":
              case "style":
              case "template":
              case "title":
                stack2.push(head_element_pointer);
                in_head_mode(TAG, value, arg3);
                stack2.removeElement(head_element_pointer);
                return;
              case "head":
                return;
            }
            break;
          case 3:
            switch (value) {
              case "template":
                return in_head_mode(t, value, arg3, arg4);
              case "body":
              case "html":
              case "br":
                break;
              default:
                return;
            }
            break;
        }
        after_head_mode(TAG, "body", null);
        frameset_ok = true;
        parser(t, value, arg3, arg4);
      }
      function in_body_mode(t, value, arg3, arg4) {
        var body, i, node, elt;
        switch (t) {
          case 1:
            if (textIncludesNUL) {
              value = value.replace(NULCHARS, "");
              if (value.length === 0) return;
            }
            if (frameset_ok && NONWS.test(value))
              frameset_ok = false;
            afereconstruct();
            insertText(value);
            return;
          case 5:
            return;
          case 4:
            insertComment(value);
            return;
          case -1:
            if (templateInsertionModes.length) {
              return in_template_mode(t);
            }
            stopParsing();
            return;
          case 2:
            switch (value) {
              case "html":
                if (stack2.contains("template")) {
                  return;
                }
                transferAttributes(arg3, stack2.elements[0]);
                return;
              case "base":
              case "basefont":
              case "bgsound":
              case "link":
              case "meta":
              case "noframes":
              case "script":
              case "style":
              case "template":
              case "title":
                in_head_mode(TAG, value, arg3);
                return;
              case "body":
                body = stack2.elements[1];
                if (!body || !(body instanceof impl.HTMLBodyElement) || stack2.contains("template"))
                  return;
                frameset_ok = false;
                transferAttributes(arg3, body);
                return;
              case "frameset":
                if (!frameset_ok) return;
                body = stack2.elements[1];
                if (!body || !(body instanceof impl.HTMLBodyElement))
                  return;
                if (body.parentNode) body.parentNode.removeChild(body);
                while (!(stack2.top instanceof impl.HTMLHtmlElement))
                  stack2.pop();
                insertHTMLElement(value, arg3);
                parser = in_frameset_mode;
                return;
              case "address":
              case "article":
              case "aside":
              case "blockquote":
              case "center":
              case "details":
              case "dialog":
              case "dir":
              case "div":
              case "dl":
              case "fieldset":
              case "figcaption":
              case "figure":
              case "footer":
              case "header":
              case "hgroup":
              case "main":
              case "nav":
              case "ol":
              case "p":
              case "section":
              case "summary":
              case "ul":
                if (stack2.inButtonScope("p")) in_body_mode(ENDTAG, "p");
                insertHTMLElement(value, arg3);
                return;
              case "menu":
                if (stack2.inButtonScope("p")) in_body_mode(ENDTAG, "p");
                if (isA(stack2.top, "menuitem")) {
                  stack2.pop();
                }
                insertHTMLElement(value, arg3);
                return;
              case "h1":
              case "h2":
              case "h3":
              case "h4":
              case "h5":
              case "h6":
                if (stack2.inButtonScope("p")) in_body_mode(ENDTAG, "p");
                if (stack2.top instanceof impl.HTMLHeadingElement)
                  stack2.pop();
                insertHTMLElement(value, arg3);
                return;
              case "pre":
              case "listing":
                if (stack2.inButtonScope("p")) in_body_mode(ENDTAG, "p");
                insertHTMLElement(value, arg3);
                ignore_linefeed = true;
                frameset_ok = false;
                return;
              case "form":
                if (form_element_pointer && !stack2.contains("template")) return;
                if (stack2.inButtonScope("p")) in_body_mode(ENDTAG, "p");
                elt = insertHTMLElement(value, arg3);
                if (!stack2.contains("template"))
                  form_element_pointer = elt;
                return;
              case "li":
                frameset_ok = false;
                for (i = stack2.elements.length - 1; i >= 0; i--) {
                  node = stack2.elements[i];
                  if (node instanceof impl.HTMLLIElement) {
                    in_body_mode(ENDTAG, "li");
                    break;
                  }
                  if (isA(node, specialSet) && !isA(node, addressdivpSet))
                    break;
                }
                if (stack2.inButtonScope("p")) in_body_mode(ENDTAG, "p");
                insertHTMLElement(value, arg3);
                return;
              case "dd":
              case "dt":
                frameset_ok = false;
                for (i = stack2.elements.length - 1; i >= 0; i--) {
                  node = stack2.elements[i];
                  if (isA(node, dddtSet)) {
                    in_body_mode(ENDTAG, node.localName);
                    break;
                  }
                  if (isA(node, specialSet) && !isA(node, addressdivpSet))
                    break;
                }
                if (stack2.inButtonScope("p")) in_body_mode(ENDTAG, "p");
                insertHTMLElement(value, arg3);
                return;
              case "plaintext":
                if (stack2.inButtonScope("p")) in_body_mode(ENDTAG, "p");
                insertHTMLElement(value, arg3);
                tokenizer = plaintext_state;
                return;
              case "button":
                if (stack2.inScope("button")) {
                  in_body_mode(ENDTAG, "button");
                  parser(t, value, arg3, arg4);
                } else {
                  afereconstruct();
                  insertHTMLElement(value, arg3);
                  frameset_ok = false;
                }
                return;
              case "a":
                var activeElement = afe.findElementByTag("a");
                if (activeElement) {
                  in_body_mode(ENDTAG, value);
                  afe.remove(activeElement);
                  stack2.removeElement(activeElement);
                }
              /* falls through */
              case "b":
              case "big":
              case "code":
              case "em":
              case "font":
              case "i":
              case "s":
              case "small":
              case "strike":
              case "strong":
              case "tt":
              case "u":
                afereconstruct();
                afe.push(insertHTMLElement(value, arg3), arg3);
                return;
              case "nobr":
                afereconstruct();
                if (stack2.inScope(value)) {
                  in_body_mode(ENDTAG, value);
                  afereconstruct();
                }
                afe.push(insertHTMLElement(value, arg3), arg3);
                return;
              case "applet":
              case "marquee":
              case "object":
                afereconstruct();
                insertHTMLElement(value, arg3);
                afe.insertMarker();
                frameset_ok = false;
                return;
              case "table":
                if (!doc2._quirks && stack2.inButtonScope("p")) {
                  in_body_mode(ENDTAG, "p");
                }
                insertHTMLElement(value, arg3);
                frameset_ok = false;
                parser = in_table_mode;
                return;
              case "area":
              case "br":
              case "embed":
              case "img":
              case "keygen":
              case "wbr":
                afereconstruct();
                insertHTMLElement(value, arg3);
                stack2.pop();
                frameset_ok = false;
                return;
              case "input":
                afereconstruct();
                elt = insertHTMLElement(value, arg3);
                stack2.pop();
                var type = elt.getAttribute("type");
                if (!type || type.toLowerCase() !== "hidden")
                  frameset_ok = false;
                return;
              case "param":
              case "source":
              case "track":
                insertHTMLElement(value, arg3);
                stack2.pop();
                return;
              case "hr":
                if (stack2.inButtonScope("p")) in_body_mode(ENDTAG, "p");
                if (isA(stack2.top, "menuitem")) {
                  stack2.pop();
                }
                insertHTMLElement(value, arg3);
                stack2.pop();
                frameset_ok = false;
                return;
              case "image":
                in_body_mode(TAG, "img", arg3, arg4);
                return;
              case "textarea":
                insertHTMLElement(value, arg3);
                ignore_linefeed = true;
                frameset_ok = false;
                tokenizer = rcdata_state;
                originalInsertionMode = parser;
                parser = text_mode;
                return;
              case "xmp":
                if (stack2.inButtonScope("p")) in_body_mode(ENDTAG, "p");
                afereconstruct();
                frameset_ok = false;
                parseRawText(value, arg3);
                return;
              case "iframe":
                frameset_ok = false;
                parseRawText(value, arg3);
                return;
              case "noembed":
                parseRawText(value, arg3);
                return;
              case "noscript":
                if (scripting_enabled) {
                  parseRawText(value, arg3);
                  return;
                }
                break;
              // XXX Otherwise treat it as any other open tag?
              case "select":
                afereconstruct();
                insertHTMLElement(value, arg3);
                frameset_ok = false;
                if (parser === in_table_mode || parser === in_caption_mode || parser === in_table_body_mode || parser === in_row_mode || parser === in_cell_mode)
                  parser = in_select_in_table_mode;
                else
                  parser = in_select_mode;
                return;
              case "optgroup":
              case "option":
                if (stack2.top instanceof impl.HTMLOptionElement) {
                  in_body_mode(ENDTAG, "option");
                }
                afereconstruct();
                insertHTMLElement(value, arg3);
                return;
              case "menuitem":
                if (isA(stack2.top, "menuitem")) {
                  stack2.pop();
                }
                afereconstruct();
                insertHTMLElement(value, arg3);
                return;
              case "rb":
              case "rtc":
                if (stack2.inScope("ruby")) {
                  stack2.generateImpliedEndTags();
                }
                insertHTMLElement(value, arg3);
                return;
              case "rp":
              case "rt":
                if (stack2.inScope("ruby")) {
                  stack2.generateImpliedEndTags("rtc");
                }
                insertHTMLElement(value, arg3);
                return;
              case "math":
                afereconstruct();
                adjustMathMLAttributes(arg3);
                adjustForeignAttributes(arg3);
                insertForeignElement(value, arg3, NAMESPACE.MATHML);
                if (arg4)
                  stack2.pop();
                return;
              case "svg":
                afereconstruct();
                adjustSVGAttributes(arg3);
                adjustForeignAttributes(arg3);
                insertForeignElement(value, arg3, NAMESPACE.SVG);
                if (arg4)
                  stack2.pop();
                return;
              case "caption":
              case "col":
              case "colgroup":
              case "frame":
              case "head":
              case "tbody":
              case "td":
              case "tfoot":
              case "th":
              case "thead":
              case "tr":
                return;
            }
            afereconstruct();
            insertHTMLElement(value, arg3);
            return;
          case 3:
            switch (value) {
              case "template":
                in_head_mode(ENDTAG, value, arg3);
                return;
              case "body":
                if (!stack2.inScope("body")) return;
                parser = after_body_mode;
                return;
              case "html":
                if (!stack2.inScope("body")) return;
                parser = after_body_mode;
                parser(t, value, arg3);
                return;
              case "address":
              case "article":
              case "aside":
              case "blockquote":
              case "button":
              case "center":
              case "details":
              case "dialog":
              case "dir":
              case "div":
              case "dl":
              case "fieldset":
              case "figcaption":
              case "figure":
              case "footer":
              case "header":
              case "hgroup":
              case "listing":
              case "main":
              case "menu":
              case "nav":
              case "ol":
              case "pre":
              case "section":
              case "summary":
              case "ul":
                if (!stack2.inScope(value)) return;
                stack2.generateImpliedEndTags();
                stack2.popTag(value);
                return;
              case "form":
                if (!stack2.contains("template")) {
                  var openform = form_element_pointer;
                  form_element_pointer = null;
                  if (!openform || !stack2.elementInScope(openform)) return;
                  stack2.generateImpliedEndTags();
                  stack2.removeElement(openform);
                } else {
                  if (!stack2.inScope("form")) return;
                  stack2.generateImpliedEndTags();
                  stack2.popTag("form");
                }
                return;
              case "p":
                if (!stack2.inButtonScope(value)) {
                  in_body_mode(TAG, value, null);
                  parser(t, value, arg3, arg4);
                } else {
                  stack2.generateImpliedEndTags(value);
                  stack2.popTag(value);
                }
                return;
              case "li":
                if (!stack2.inListItemScope(value)) return;
                stack2.generateImpliedEndTags(value);
                stack2.popTag(value);
                return;
              case "dd":
              case "dt":
                if (!stack2.inScope(value)) return;
                stack2.generateImpliedEndTags(value);
                stack2.popTag(value);
                return;
              case "h1":
              case "h2":
              case "h3":
              case "h4":
              case "h5":
              case "h6":
                if (!stack2.elementTypeInScope(impl.HTMLHeadingElement)) return;
                stack2.generateImpliedEndTags();
                stack2.popElementType(impl.HTMLHeadingElement);
                return;
              case "sarcasm":
                break;
              case "a":
              case "b":
              case "big":
              case "code":
              case "em":
              case "font":
              case "i":
              case "nobr":
              case "s":
              case "small":
              case "strike":
              case "strong":
              case "tt":
              case "u":
                var result2 = adoptionAgency(value);
                if (result2) return;
                break;
              // Go to the "any other end tag" case
              case "applet":
              case "marquee":
              case "object":
                if (!stack2.inScope(value)) return;
                stack2.generateImpliedEndTags();
                stack2.popTag(value);
                afe.clearToMarker();
                return;
              case "br":
                in_body_mode(TAG, value, null);
                return;
            }
            for (i = stack2.elements.length - 1; i >= 0; i--) {
              node = stack2.elements[i];
              if (isA(node, value)) {
                stack2.generateImpliedEndTags(value);
                stack2.popElement(node);
                break;
              } else if (isA(node, specialSet)) {
                return;
              }
            }
            return;
        }
      }
      function text_mode(t, value, arg3, arg4) {
        switch (t) {
          case 1:
            insertText(value);
            return;
          case -1:
            if (stack2.top instanceof impl.HTMLScriptElement)
              stack2.top._already_started = true;
            stack2.pop();
            parser = originalInsertionMode;
            parser(t);
            return;
          case 3:
            if (value === "script") {
              handleScriptEnd();
            } else {
              stack2.pop();
              parser = originalInsertionMode;
            }
            return;
          default:
            return;
        }
      }
      function in_table_mode(t, value, arg3, arg4) {
        function getTypeAttr(attrs) {
          for (var i = 0, n = attrs.length; i < n; i++) {
            if (attrs[i][0] === "type")
              return attrs[i][1].toLowerCase();
          }
          return null;
        }
        switch (t) {
          case 1:
            if (text_integration_mode) {
              in_body_mode(t, value, arg3, arg4);
              return;
            } else if (isA(stack2.top, tablesectionrowSet)) {
              pending_table_text = [];
              originalInsertionMode = parser;
              parser = in_table_text_mode;
              parser(t, value, arg3, arg4);
              return;
            }
            break;
          case 4:
            insertComment(value);
            return;
          case 5:
            return;
          case 2:
            switch (value) {
              case "caption":
                stack2.clearToContext(tableContextSet);
                afe.insertMarker();
                insertHTMLElement(value, arg3);
                parser = in_caption_mode;
                return;
              case "colgroup":
                stack2.clearToContext(tableContextSet);
                insertHTMLElement(value, arg3);
                parser = in_column_group_mode;
                return;
              case "col":
                in_table_mode(TAG, "colgroup", null);
                parser(t, value, arg3, arg4);
                return;
              case "tbody":
              case "tfoot":
              case "thead":
                stack2.clearToContext(tableContextSet);
                insertHTMLElement(value, arg3);
                parser = in_table_body_mode;
                return;
              case "td":
              case "th":
              case "tr":
                in_table_mode(TAG, "tbody", null);
                parser(t, value, arg3, arg4);
                return;
              case "table":
                if (!stack2.inTableScope(value)) {
                  return;
                }
                in_table_mode(ENDTAG, value);
                parser(t, value, arg3, arg4);
                return;
              case "style":
              case "script":
              case "template":
                in_head_mode(t, value, arg3, arg4);
                return;
              case "input":
                var type = getTypeAttr(arg3);
                if (type !== "hidden") break;
                insertHTMLElement(value, arg3);
                stack2.pop();
                return;
              case "form":
                if (form_element_pointer || stack2.contains("template")) return;
                form_element_pointer = insertHTMLElement(value, arg3);
                stack2.popElement(form_element_pointer);
                return;
            }
            break;
          case 3:
            switch (value) {
              case "table":
                if (!stack2.inTableScope(value)) return;
                stack2.popTag(value);
                resetInsertionMode();
                return;
              case "body":
              case "caption":
              case "col":
              case "colgroup":
              case "html":
              case "tbody":
              case "td":
              case "tfoot":
              case "th":
              case "thead":
              case "tr":
                return;
              case "template":
                in_head_mode(t, value, arg3, arg4);
                return;
            }
            break;
          case -1:
            in_body_mode(t, value, arg3, arg4);
            return;
        }
        foster_parent_mode = true;
        in_body_mode(t, value, arg3, arg4);
        foster_parent_mode = false;
      }
      function in_table_text_mode(t, value, arg3, arg4) {
        if (t === TEXT) {
          if (textIncludesNUL) {
            value = value.replace(NULCHARS, "");
            if (value.length === 0) return;
          }
          pending_table_text.push(value);
        } else {
          var s = pending_table_text.join("");
          pending_table_text.length = 0;
          if (NONWS.test(s)) {
            foster_parent_mode = true;
            in_body_mode(TEXT, s);
            foster_parent_mode = false;
          } else {
            insertText(s);
          }
          parser = originalInsertionMode;
          parser(t, value, arg3, arg4);
        }
      }
      function in_caption_mode(t, value, arg3, arg4) {
        function end_caption() {
          if (!stack2.inTableScope("caption")) return false;
          stack2.generateImpliedEndTags();
          stack2.popTag("caption");
          afe.clearToMarker();
          parser = in_table_mode;
          return true;
        }
        switch (t) {
          case 2:
            switch (value) {
              case "caption":
              case "col":
              case "colgroup":
              case "tbody":
              case "td":
              case "tfoot":
              case "th":
              case "thead":
              case "tr":
                if (end_caption()) parser(t, value, arg3, arg4);
                return;
            }
            break;
          case 3:
            switch (value) {
              case "caption":
                end_caption();
                return;
              case "table":
                if (end_caption()) parser(t, value, arg3, arg4);
                return;
              case "body":
              case "col":
              case "colgroup":
              case "html":
              case "tbody":
              case "td":
              case "tfoot":
              case "th":
              case "thead":
              case "tr":
                return;
            }
            break;
        }
        in_body_mode(t, value, arg3, arg4);
      }
      function in_column_group_mode(t, value, arg3, arg4) {
        switch (t) {
          case 1:
            var ws = value.match(LEADINGWS);
            if (ws) {
              insertText(ws[0]);
              value = value.substring(ws[0].length);
            }
            if (value.length === 0) return;
            break;
          // Handle non-whitespace below
          case 4:
            insertComment(value);
            return;
          case 5:
            return;
          case 2:
            switch (value) {
              case "html":
                in_body_mode(t, value, arg3, arg4);
                return;
              case "col":
                insertHTMLElement(value, arg3);
                stack2.pop();
                return;
              case "template":
                in_head_mode(t, value, arg3, arg4);
                return;
            }
            break;
          case 3:
            switch (value) {
              case "colgroup":
                if (!isA(stack2.top, "colgroup")) {
                  return;
                }
                stack2.pop();
                parser = in_table_mode;
                return;
              case "col":
                return;
              case "template":
                in_head_mode(t, value, arg3, arg4);
                return;
            }
            break;
          case -1:
            in_body_mode(t, value, arg3, arg4);
            return;
        }
        if (!isA(stack2.top, "colgroup")) {
          return;
        }
        in_column_group_mode(ENDTAG, "colgroup");
        parser(t, value, arg3, arg4);
      }
      function in_table_body_mode(t, value, arg3, arg4) {
        function endsect() {
          if (!stack2.inTableScope("tbody") && !stack2.inTableScope("thead") && !stack2.inTableScope("tfoot"))
            return;
          stack2.clearToContext(tableBodyContextSet);
          in_table_body_mode(ENDTAG, stack2.top.localName, null);
          parser(t, value, arg3, arg4);
        }
        switch (t) {
          case 2:
            switch (value) {
              case "tr":
                stack2.clearToContext(tableBodyContextSet);
                insertHTMLElement(value, arg3);
                parser = in_row_mode;
                return;
              case "th":
              case "td":
                in_table_body_mode(TAG, "tr", null);
                parser(t, value, arg3, arg4);
                return;
              case "caption":
              case "col":
              case "colgroup":
              case "tbody":
              case "tfoot":
              case "thead":
                endsect();
                return;
            }
            break;
          case 3:
            switch (value) {
              case "table":
                endsect();
                return;
              case "tbody":
              case "tfoot":
              case "thead":
                if (stack2.inTableScope(value)) {
                  stack2.clearToContext(tableBodyContextSet);
                  stack2.pop();
                  parser = in_table_mode;
                }
                return;
              case "body":
              case "caption":
              case "col":
              case "colgroup":
              case "html":
              case "td":
              case "th":
              case "tr":
                return;
            }
            break;
        }
        in_table_mode(t, value, arg3, arg4);
      }
      function in_row_mode(t, value, arg3, arg4) {
        function endrow() {
          if (!stack2.inTableScope("tr")) return false;
          stack2.clearToContext(tableRowContextSet);
          stack2.pop();
          parser = in_table_body_mode;
          return true;
        }
        switch (t) {
          case 2:
            switch (value) {
              case "th":
              case "td":
                stack2.clearToContext(tableRowContextSet);
                insertHTMLElement(value, arg3);
                parser = in_cell_mode;
                afe.insertMarker();
                return;
              case "caption":
              case "col":
              case "colgroup":
              case "tbody":
              case "tfoot":
              case "thead":
              case "tr":
                if (endrow()) parser(t, value, arg3, arg4);
                return;
            }
            break;
          case 3:
            switch (value) {
              case "tr":
                endrow();
                return;
              case "table":
                if (endrow()) parser(t, value, arg3, arg4);
                return;
              case "tbody":
              case "tfoot":
              case "thead":
                if (stack2.inTableScope(value)) {
                  if (endrow()) parser(t, value, arg3, arg4);
                }
                return;
              case "body":
              case "caption":
              case "col":
              case "colgroup":
              case "html":
              case "td":
              case "th":
                return;
            }
            break;
        }
        in_table_mode(t, value, arg3, arg4);
      }
      function in_cell_mode(t, value, arg3, arg4) {
        switch (t) {
          case 2:
            switch (value) {
              case "caption":
              case "col":
              case "colgroup":
              case "tbody":
              case "td":
              case "tfoot":
              case "th":
              case "thead":
              case "tr":
                if (stack2.inTableScope("td")) {
                  in_cell_mode(ENDTAG, "td");
                  parser(t, value, arg3, arg4);
                } else if (stack2.inTableScope("th")) {
                  in_cell_mode(ENDTAG, "th");
                  parser(t, value, arg3, arg4);
                }
                return;
            }
            break;
          case 3:
            switch (value) {
              case "td":
              case "th":
                if (!stack2.inTableScope(value)) return;
                stack2.generateImpliedEndTags();
                stack2.popTag(value);
                afe.clearToMarker();
                parser = in_row_mode;
                return;
              case "body":
              case "caption":
              case "col":
              case "colgroup":
              case "html":
                return;
              case "table":
              case "tbody":
              case "tfoot":
              case "thead":
              case "tr":
                if (!stack2.inTableScope(value)) return;
                in_cell_mode(ENDTAG, stack2.inTableScope("td") ? "td" : "th");
                parser(t, value, arg3, arg4);
                return;
            }
            break;
        }
        in_body_mode(t, value, arg3, arg4);
      }
      function in_select_mode(t, value, arg3, arg4) {
        switch (t) {
          case 1:
            if (textIncludesNUL) {
              value = value.replace(NULCHARS, "");
              if (value.length === 0) return;
            }
            insertText(value);
            return;
          case 4:
            insertComment(value);
            return;
          case 5:
            return;
          case -1:
            in_body_mode(t, value, arg3, arg4);
            return;
          case 2:
            switch (value) {
              case "html":
                in_body_mode(t, value, arg3, arg4);
                return;
              case "option":
                if (stack2.top instanceof impl.HTMLOptionElement)
                  in_select_mode(ENDTAG, value);
                insertHTMLElement(value, arg3);
                return;
              case "optgroup":
                if (stack2.top instanceof impl.HTMLOptionElement)
                  in_select_mode(ENDTAG, "option");
                if (stack2.top instanceof impl.HTMLOptGroupElement)
                  in_select_mode(ENDTAG, value);
                insertHTMLElement(value, arg3);
                return;
              case "select":
                in_select_mode(ENDTAG, value);
                return;
              case "input":
              case "keygen":
              case "textarea":
                if (!stack2.inSelectScope("select")) return;
                in_select_mode(ENDTAG, "select");
                parser(t, value, arg3, arg4);
                return;
              case "script":
              case "template":
                in_head_mode(t, value, arg3, arg4);
                return;
            }
            break;
          case 3:
            switch (value) {
              case "optgroup":
                if (stack2.top instanceof impl.HTMLOptionElement && stack2.elements[stack2.elements.length - 2] instanceof impl.HTMLOptGroupElement) {
                  in_select_mode(ENDTAG, "option");
                }
                if (stack2.top instanceof impl.HTMLOptGroupElement)
                  stack2.pop();
                return;
              case "option":
                if (stack2.top instanceof impl.HTMLOptionElement)
                  stack2.pop();
                return;
              case "select":
                if (!stack2.inSelectScope(value)) return;
                stack2.popTag(value);
                resetInsertionMode();
                return;
              case "template":
                in_head_mode(t, value, arg3, arg4);
                return;
            }
            break;
        }
      }
      function in_select_in_table_mode(t, value, arg3, arg4) {
        switch (value) {
          case "caption":
          case "table":
          case "tbody":
          case "tfoot":
          case "thead":
          case "tr":
          case "td":
          case "th":
            switch (t) {
              case 2:
                in_select_in_table_mode(ENDTAG, "select");
                parser(t, value, arg3, arg4);
                return;
              case 3:
                if (stack2.inTableScope(value)) {
                  in_select_in_table_mode(ENDTAG, "select");
                  parser(t, value, arg3, arg4);
                }
                return;
            }
        }
        in_select_mode(t, value, arg3, arg4);
      }
      function in_template_mode(t, value, arg3, arg4) {
        function switchModeAndReprocess(mode) {
          parser = mode;
          templateInsertionModes[templateInsertionModes.length - 1] = parser;
          parser(t, value, arg3, arg4);
        }
        switch (t) {
          case 1:
          // TEXT
          case 4:
          // COMMENT
          case 5:
            in_body_mode(t, value, arg3, arg4);
            return;
          case -1:
            if (!stack2.contains("template")) {
              stopParsing();
            } else {
              stack2.popTag("template");
              afe.clearToMarker();
              templateInsertionModes.pop();
              resetInsertionMode();
              parser(t, value, arg3, arg4);
            }
            return;
          case 2:
            switch (value) {
              case "base":
              case "basefont":
              case "bgsound":
              case "link":
              case "meta":
              case "noframes":
              case "script":
              case "style":
              case "template":
              case "title":
                in_head_mode(t, value, arg3, arg4);
                return;
              case "caption":
              case "colgroup":
              case "tbody":
              case "tfoot":
              case "thead":
                switchModeAndReprocess(in_table_mode);
                return;
              case "col":
                switchModeAndReprocess(in_column_group_mode);
                return;
              case "tr":
                switchModeAndReprocess(in_table_body_mode);
                return;
              case "td":
              case "th":
                switchModeAndReprocess(in_row_mode);
                return;
            }
            switchModeAndReprocess(in_body_mode);
            return;
          case 3:
            switch (value) {
              case "template":
                in_head_mode(t, value, arg3, arg4);
                return;
              default:
                return;
            }
        }
      }
      function after_body_mode(t, value, arg3, arg4) {
        switch (t) {
          case 1:
            if (NONWS.test(value)) break;
            in_body_mode(t, value);
            return;
          case 4:
            stack2.elements[0]._appendChild(doc2.createComment(value));
            return;
          case 5:
            return;
          case -1:
            stopParsing();
            return;
          case 2:
            if (value === "html") {
              in_body_mode(t, value, arg3, arg4);
              return;
            }
            break;
          // for any other tags
          case 3:
            if (value === "html") {
              if (fragment) return;
              parser = after_after_body_mode;
              return;
            }
            break;
        }
        parser = in_body_mode;
        parser(t, value, arg3, arg4);
      }
      function in_frameset_mode(t, value, arg3, arg4) {
        switch (t) {
          case 1:
            value = value.replace(ALLNONWS, "");
            if (value.length > 0) insertText(value);
            return;
          case 4:
            insertComment(value);
            return;
          case 5:
            return;
          case -1:
            stopParsing();
            return;
          case 2:
            switch (value) {
              case "html":
                in_body_mode(t, value, arg3, arg4);
                return;
              case "frameset":
                insertHTMLElement(value, arg3);
                return;
              case "frame":
                insertHTMLElement(value, arg3);
                stack2.pop();
                return;
              case "noframes":
                in_head_mode(t, value, arg3, arg4);
                return;
            }
            break;
          case 3:
            if (value === "frameset") {
              if (fragment && stack2.top instanceof impl.HTMLHtmlElement)
                return;
              stack2.pop();
              if (!fragment && !(stack2.top instanceof impl.HTMLFrameSetElement))
                parser = after_frameset_mode;
              return;
            }
            break;
        }
      }
      function after_frameset_mode(t, value, arg3, arg4) {
        switch (t) {
          case 1:
            value = value.replace(ALLNONWS, "");
            if (value.length > 0) insertText(value);
            return;
          case 4:
            insertComment(value);
            return;
          case 5:
            return;
          case -1:
            stopParsing();
            return;
          case 2:
            switch (value) {
              case "html":
                in_body_mode(t, value, arg3, arg4);
                return;
              case "noframes":
                in_head_mode(t, value, arg3, arg4);
                return;
            }
            break;
          case 3:
            if (value === "html") {
              parser = after_after_frameset_mode;
              return;
            }
            break;
        }
      }
      function after_after_body_mode(t, value, arg3, arg4) {
        switch (t) {
          case 1:
            if (NONWS.test(value)) break;
            in_body_mode(t, value, arg3, arg4);
            return;
          case 4:
            doc2._appendChild(doc2.createComment(value));
            return;
          case 5:
            in_body_mode(t, value, arg3, arg4);
            return;
          case -1:
            stopParsing();
            return;
          case 2:
            if (value === "html") {
              in_body_mode(t, value, arg3, arg4);
              return;
            }
            break;
        }
        parser = in_body_mode;
        parser(t, value, arg3, arg4);
      }
      function after_after_frameset_mode(t, value, arg3, arg4) {
        switch (t) {
          case 1:
            value = value.replace(ALLNONWS, "");
            if (value.length > 0)
              in_body_mode(t, value, arg3, arg4);
            return;
          case 4:
            doc2._appendChild(doc2.createComment(value));
            return;
          case 5:
            in_body_mode(t, value, arg3, arg4);
            return;
          case -1:
            stopParsing();
            return;
          case 2:
            switch (value) {
              case "html":
                in_body_mode(t, value, arg3, arg4);
                return;
              case "noframes":
                in_head_mode(t, value, arg3, arg4);
                return;
            }
            break;
        }
      }
      function insertForeignToken(t, value, arg3, arg4) {
        function isHTMLFont(attrs) {
          for (var i2 = 0, n = attrs.length; i2 < n; i2++) {
            switch (attrs[i2][0]) {
              case "color":
              case "face":
              case "size":
                return true;
            }
          }
          return false;
        }
        var current;
        switch (t) {
          case 1:
            if (frameset_ok && NONWSNONNUL.test(value))
              frameset_ok = false;
            if (textIncludesNUL) {
              value = value.replace(NULCHARS, "\uFFFD");
            }
            insertText(value);
            return;
          case 4:
            insertComment(value);
            return;
          case 5:
            return;
          case 2:
            switch (value) {
              case "font":
                if (!isHTMLFont(arg3)) break;
              /* falls through */
              case "b":
              case "big":
              case "blockquote":
              case "body":
              case "br":
              case "center":
              case "code":
              case "dd":
              case "div":
              case "dl":
              case "dt":
              case "em":
              case "embed":
              case "h1":
              case "h2":
              case "h3":
              case "h4":
              case "h5":
              case "h6":
              case "head":
              case "hr":
              case "i":
              case "img":
              case "li":
              case "listing":
              case "menu":
              case "meta":
              case "nobr":
              case "ol":
              case "p":
              case "pre":
              case "ruby":
              case "s":
              case "small":
              case "span":
              case "strong":
              case "strike":
              case "sub":
              case "sup":
              case "table":
              case "tt":
              case "u":
              case "ul":
              case "var":
                if (fragment) {
                  break;
                }
                do {
                  stack2.pop();
                  current = stack2.top;
                } while (current.namespaceURI !== NAMESPACE.HTML && !isMathmlTextIntegrationPoint(current) && !isHTMLIntegrationPoint(current));
                insertToken(t, value, arg3, arg4);
                return;
            }
            current = stack2.elements.length === 1 && fragment ? fragmentContext : stack2.top;
            if (current.namespaceURI === NAMESPACE.MATHML) {
              adjustMathMLAttributes(arg3);
            } else if (current.namespaceURI === NAMESPACE.SVG) {
              value = adjustSVGTagName(value);
              adjustSVGAttributes(arg3);
            }
            adjustForeignAttributes(arg3);
            insertForeignElement(value, arg3, current.namespaceURI);
            if (arg4) {
              if (value === "script" && current.namespaceURI === NAMESPACE.SVG) {
              }
              stack2.pop();
            }
            return;
          case 3:
            current = stack2.top;
            if (value === "script" && current.namespaceURI === NAMESPACE.SVG && current.localName === "script") {
              stack2.pop();
            } else {
              var i = stack2.elements.length - 1;
              var node = stack2.elements[i];
              for (; ; ) {
                if (node.localName.toLowerCase() === value) {
                  stack2.popElement(node);
                  break;
                }
                node = stack2.elements[--i];
                if (node.namespaceURI !== NAMESPACE.HTML)
                  continue;
                parser(t, value, arg3, arg4);
                break;
              }
            }
            return;
        }
      }
      htmlparser.testTokenizer = function(input, initialState, lastStartTag, charbychar) {
        var tokens = [];
        switch (initialState) {
          case "PCDATA state":
            tokenizer = data_state;
            break;
          case "RCDATA state":
            tokenizer = rcdata_state;
            break;
          case "RAWTEXT state":
            tokenizer = rawtext_state;
            break;
          case "PLAINTEXT state":
            tokenizer = plaintext_state;
            break;
        }
        if (lastStartTag) {
          lasttagname = lastStartTag;
        }
        insertToken = function(t, value, arg3, arg4) {
          flushText();
          switch (t) {
            case 1:
              if (tokens.length > 0 && tokens[tokens.length - 1][0] === "Character") {
                tokens[tokens.length - 1][1] += value;
              } else tokens.push(["Character", value]);
              break;
            case 4:
              tokens.push(["Comment", value]);
              break;
            case 5:
              tokens.push([
                "DOCTYPE",
                value,
                arg3 === void 0 ? null : arg3,
                arg4 === void 0 ? null : arg4,
                !force_quirks
              ]);
              break;
            case 2:
              var attrs = /* @__PURE__ */ Object.create(null);
              for (var i2 = 0; i2 < arg3.length; i2++) {
                var a = arg3[i2];
                if (a.length === 1) {
                  attrs[a[0]] = "";
                } else {
                  attrs[a[0]] = a[1];
                }
              }
              var token = ["StartTag", value, attrs];
              if (arg4) token.push(true);
              tokens.push(token);
              break;
            case 3:
              tokens.push(["EndTag", value]);
              break;
            case -1:
              break;
          }
        };
        if (!charbychar) {
          this.parse(input, true);
        } else {
          for (var i = 0; i < input.length; i++) {
            this.parse(input[i]);
          }
          this.parse("", true);
        }
        return tokens;
      };
      return htmlparser;
    }
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/DOMImplementation.js
var require_DOMImplementation = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/DOMImplementation.js"(exports, module) {
    "use strict";
    module.exports = DOMImplementation;
    var Document = require_Document();
    var DocumentType = require_DocumentType();
    var HTMLParser = require_HTMLParser();
    var utils = require_utils();
    var xml = require_xmlnames();
    function DOMImplementation(contextObject) {
      this.contextObject = contextObject;
    }
    var supportedFeatures = {
      "xml": { "": true, "1.0": true, "2.0": true },
      // DOM Core
      "core": { "": true, "2.0": true },
      // DOM Core
      "html": { "": true, "1.0": true, "2.0": true },
      // HTML
      "xhtml": { "": true, "1.0": true, "2.0": true }
      // HTML
    };
    DOMImplementation.prototype = {
      hasFeature: function hasFeature(feature, version2) {
        var f = supportedFeatures[(feature || "").toLowerCase()];
        return f && f[version2 || ""] || false;
      },
      createDocumentType: function createDocumentType(qualifiedName, publicId, systemId) {
        if (!xml.isValidQName(qualifiedName)) utils.InvalidCharacterError();
        return new DocumentType(this.contextObject, qualifiedName, publicId, systemId);
      },
      createDocument: function createDocument2(namespace, qualifiedName, doctype) {
        var d = new Document(false, null);
        var e;
        if (qualifiedName)
          e = d.createElementNS(namespace, qualifiedName);
        else
          e = null;
        if (doctype) {
          d.appendChild(doctype);
        }
        if (e) d.appendChild(e);
        if (namespace === utils.NAMESPACE.HTML) {
          d._contentType = "application/xhtml+xml";
        } else if (namespace === utils.NAMESPACE.SVG) {
          d._contentType = "image/svg+xml";
        } else {
          d._contentType = "application/xml";
        }
        return d;
      },
      createHTMLDocument: function createHTMLDocument(titleText) {
        var d = new Document(true, null);
        d.appendChild(new DocumentType(d, "html"));
        var html = d.createElement("html");
        d.appendChild(html);
        var head = d.createElement("head");
        html.appendChild(head);
        if (titleText !== void 0) {
          var title = d.createElement("title");
          head.appendChild(title);
          title.appendChild(d.createTextNode(titleText));
        }
        html.appendChild(d.createElement("body"));
        d.modclock = 1;
        return d;
      },
      mozSetOutputMutationHandler: function(doc2, handler) {
        doc2.mutationHandler = handler;
      },
      mozGetInputMutationHandler: function(doc2) {
        utils.nyi();
      },
      mozHTMLParser: HTMLParser
    };
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/Location.js
var require_Location = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/Location.js"(exports, module) {
    "use strict";
    var URL2 = require_URL();
    var URLUtils = require_URLUtils();
    module.exports = Location;
    function Location(window2, href) {
      this._window = window2;
      this._href = href;
    }
    Location.prototype = Object.create(URLUtils.prototype, {
      constructor: { value: Location },
      // Special behavior when href is set
      href: {
        get: function() {
          return this._href;
        },
        set: function(v) {
          this.assign(v);
        }
      },
      assign: { value: function(url) {
        var current = new URL2(this._href);
        var newurl = current.resolve(url);
        this._href = newurl;
      } },
      replace: { value: function(url) {
        this.assign(url);
      } },
      reload: { value: function() {
        this.assign(this.href);
      } },
      toString: { value: function() {
        return this.href;
      } }
    });
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/NavigatorID.js
var require_NavigatorID = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/NavigatorID.js"(exports, module) {
    "use strict";
    var NavigatorID = Object.create(null, {
      appCodeName: { value: "Mozilla" },
      appName: { value: "Netscape" },
      appVersion: { value: "4.0" },
      platform: { value: "" },
      product: { value: "Gecko" },
      productSub: { value: "20100101" },
      userAgent: { value: "" },
      vendor: { value: "" },
      vendorSub: { value: "" },
      taintEnabled: { value: function() {
        return false;
      } }
    });
    module.exports = NavigatorID;
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/WindowTimers.js
var require_WindowTimers = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/WindowTimers.js"(exports, module) {
    "use strict";
    var WindowTimers = {
      setTimeout,
      clearTimeout,
      setInterval,
      clearInterval
    };
    module.exports = WindowTimers;
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/impl.js
var require_impl = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/impl.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    exports = module.exports = {
      CSSStyleDeclaration: require_CSSStyleDeclaration(),
      CharacterData: require_CharacterData(),
      Comment: require_Comment(),
      DOMException: require_DOMException(),
      DOMImplementation: require_DOMImplementation(),
      DOMTokenList: require_DOMTokenList(),
      Document: require_Document(),
      DocumentFragment: require_DocumentFragment(),
      DocumentType: require_DocumentType(),
      Element: require_Element(),
      HTMLParser: require_HTMLParser(),
      NamedNodeMap: require_NamedNodeMap(),
      Node: require_Node(),
      NodeList: require_NodeList(),
      NodeFilter: require_NodeFilter(),
      ProcessingInstruction: require_ProcessingInstruction(),
      Text: require_Text(),
      Window: require_Window()
    };
    utils.merge(exports, require_events());
    utils.merge(exports, require_htmlelts().elements);
    utils.merge(exports, require_svg().elements);
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/Window.js
var require_Window = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/Window.js"(exports, module) {
    "use strict";
    var DOMImplementation = require_DOMImplementation();
    var EventTarget = require_EventTarget();
    var Location = require_Location();
    var utils = require_utils();
    module.exports = Window;
    function Window(document2) {
      this.document = document2 || new DOMImplementation(null).createHTMLDocument("");
      this.document._scripting_enabled = true;
      this.document.defaultView = this;
      this.location = new Location(this, this.document._address || "about:blank");
    }
    Window.prototype = Object.create(EventTarget.prototype, {
      console: { value: console },
      history: { value: {
        back: utils.nyi,
        forward: utils.nyi,
        go: utils.nyi
      } },
      navigator: { value: require_NavigatorID() },
      // Self-referential properties
      window: { get: function() {
        return this;
      } },
      self: { get: function() {
        return this;
      } },
      frames: { get: function() {
        return this;
      } },
      // Self-referential properties for a top-level window
      parent: { get: function() {
        return this;
      } },
      top: { get: function() {
        return this;
      } },
      // We don't support any other windows for now
      length: { value: 0 },
      // no frames
      frameElement: { value: null },
      // not part of a frame
      opener: { value: null },
      // not opened by another window
      // The onload event handler.
      // XXX: need to support a bunch of other event types, too,
      // and have them interoperate with document.body.
      onload: {
        get: function() {
          return this._getEventHandler("load");
        },
        set: function(v) {
          this._setEventHandler("load", v);
        }
      },
      // XXX This is a completely broken implementation
      getComputedStyle: { value: function getComputedStyle(elt) {
        return elt.style;
      } }
    });
    utils.expose(require_WindowTimers(), Window);
    utils.expose(require_impl(), Window);
  }
});

// node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/index.js
var require_lib = __commonJS({
  "node_modules/.pnpm/domino@2.1.6_patch_hash=cfc92e4c7200dc9749feafd71636da4534f892821d01a38afe3025620807877d/node_modules/domino/lib/index.js"(exports) {
    "use strict";
    var DOMImplementation = require_DOMImplementation();
    var HTMLParser = require_HTMLParser();
    var Window = require_Window();
    exports.createDOMImplementation = function() {
      return new DOMImplementation(null);
    };
    exports.createDocument = function(html, force) {
      if (html || force) {
        var parser = new HTMLParser();
        parser.parse(html || "", true);
        return parser.document();
      }
      return new DOMImplementation(null).createHTMLDocument("");
    };
    exports.createIncrementalHTMLParser = function() {
      var parser = new HTMLParser();
      return {
        /** Provide an additional chunk of text to be parsed. */
        write: function(s) {
          if (s.length > 0) {
            parser.parse(s, false, function() {
              return true;
            });
          }
        },
        /**
         * Signal that we are done providing input text, optionally
         * providing one last chunk as a parameter.
         */
        end: function(s) {
          parser.parse(s || "", true, function() {
            return true;
          });
        },
        /**
         * Performs a chunk of parsing work, returning at the end of
         * the next token as soon as shouldPauseFunc() returns true.
         * Returns true iff there is more work to do.
         *
         * For example:
         * ```
         *  var incrParser = domino.createIncrementalHTMLParser();
         *  incrParser.end('...long html document...');
         *  while (true) {
         *    // Pause every 10ms
         *    var start = Date.now();
         *    var pauseIn10 = function() { return (Date.now() - start) >= 10; };
         *    if (!incrParser.process(pauseIn10)) {
         *      break;
         *    }
         *    ...yield to other tasks, do other housekeeping, etc...
         *  }
         * ```
         */
        process: function(shouldPauseFunc) {
          return parser.parse("", false, shouldPauseFunc);
        },
        /**
         * Returns the result of the incremental parse.  Valid after
         * `this.end()` has been called and `this.process()` has returned
         * false.
         */
        document: function() {
          return parser.document();
        }
      };
    };
    exports.impl = require_impl();
  }
});

// node_modules/.pnpm/esbuild@0.25.10/node_modules/esbuild/lib/main.js
var require_main = __commonJS({
  "node_modules/.pnpm/esbuild@0.25.10/node_modules/esbuild/lib/main.js"(exports, module) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var node_exports = {};
    __export(node_exports, {
      analyzeMetafile: () => analyzeMetafile,
      analyzeMetafileSync: () => analyzeMetafileSync,
      build: () => build,
      buildSync: () => buildSync,
      context: () => context,
      default: () => node_default,
      formatMessages: () => formatMessages,
      formatMessagesSync: () => formatMessagesSync,
      initialize: () => initialize,
      stop: () => stop,
      transform: () => transform,
      transformSync: () => transformSync2,
      version: () => version2
    });
    module.exports = __toCommonJS(node_exports);
    function encodePacket(packet) {
      let visit = (value) => {
        if (value === null) {
          bb.write8(0);
        } else if (typeof value === "boolean") {
          bb.write8(1);
          bb.write8(+value);
        } else if (typeof value === "number") {
          bb.write8(2);
          bb.write32(value | 0);
        } else if (typeof value === "string") {
          bb.write8(3);
          bb.write(encodeUTF8(value));
        } else if (value instanceof Uint8Array) {
          bb.write8(4);
          bb.write(value);
        } else if (value instanceof Array) {
          bb.write8(5);
          bb.write32(value.length);
          for (let item of value) {
            visit(item);
          }
        } else {
          let keys = Object.keys(value);
          bb.write8(6);
          bb.write32(keys.length);
          for (let key of keys) {
            bb.write(encodeUTF8(key));
            visit(value[key]);
          }
        }
      };
      let bb = new ByteBuffer();
      bb.write32(0);
      bb.write32(packet.id << 1 | +!packet.isRequest);
      visit(packet.value);
      writeUInt32LE(bb.buf, bb.len - 4, 0);
      return bb.buf.subarray(0, bb.len);
    }
    function decodePacket(bytes) {
      let visit = () => {
        switch (bb.read8()) {
          case 0:
            return null;
          case 1:
            return !!bb.read8();
          case 2:
            return bb.read32();
          case 3:
            return decodeUTF8(bb.read());
          case 4:
            return bb.read();
          case 5: {
            let count2 = bb.read32();
            let value2 = [];
            for (let i = 0; i < count2; i++) {
              value2.push(visit());
            }
            return value2;
          }
          case 6: {
            let count2 = bb.read32();
            let value2 = {};
            for (let i = 0; i < count2; i++) {
              value2[decodeUTF8(bb.read())] = visit();
            }
            return value2;
          }
          default:
            throw new Error("Invalid packet");
        }
      };
      let bb = new ByteBuffer(bytes);
      let id = bb.read32();
      let isRequest = (id & 1) === 0;
      id >>>= 1;
      let value = visit();
      if (bb.ptr !== bytes.length) {
        throw new Error("Invalid packet");
      }
      return { id, isRequest, value };
    }
    var ByteBuffer = class {
      constructor(buf = new Uint8Array(1024)) {
        this.buf = buf;
        this.len = 0;
        this.ptr = 0;
      }
      _write(delta) {
        if (this.len + delta > this.buf.length) {
          let clone = new Uint8Array((this.len + delta) * 2);
          clone.set(this.buf);
          this.buf = clone;
        }
        this.len += delta;
        return this.len - delta;
      }
      write8(value) {
        let offset = this._write(1);
        this.buf[offset] = value;
      }
      write32(value) {
        let offset = this._write(4);
        writeUInt32LE(this.buf, value, offset);
      }
      write(bytes) {
        let offset = this._write(4 + bytes.length);
        writeUInt32LE(this.buf, bytes.length, offset);
        this.buf.set(bytes, offset + 4);
      }
      _read(delta) {
        if (this.ptr + delta > this.buf.length) {
          throw new Error("Invalid packet");
        }
        this.ptr += delta;
        return this.ptr - delta;
      }
      read8() {
        return this.buf[this._read(1)];
      }
      read32() {
        return readUInt32LE(this.buf, this._read(4));
      }
      read() {
        let length = this.read32();
        let bytes = new Uint8Array(length);
        let ptr = this._read(bytes.length);
        bytes.set(this.buf.subarray(ptr, ptr + length));
        return bytes;
      }
    };
    var encodeUTF8;
    var decodeUTF8;
    var encodeInvariant;
    if (typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined") {
      let encoder = new TextEncoder();
      let decoder = new TextDecoder();
      encodeUTF8 = (text) => encoder.encode(text);
      decodeUTF8 = (bytes) => decoder.decode(bytes);
      encodeInvariant = 'new TextEncoder().encode("")';
    } else if (typeof Buffer !== "undefined") {
      encodeUTF8 = (text) => Buffer.from(text);
      decodeUTF8 = (bytes) => {
        let { buffer, byteOffset, byteLength } = bytes;
        return Buffer.from(buffer, byteOffset, byteLength).toString();
      };
      encodeInvariant = 'Buffer.from("")';
    } else {
      throw new Error("No UTF-8 codec found");
    }
    if (!(encodeUTF8("") instanceof Uint8Array))
      throw new Error(`Invariant violation: "${encodeInvariant} instanceof Uint8Array" is incorrectly false

This indicates that your JavaScript environment is broken. You cannot use
esbuild in this environment because esbuild relies on this invariant. This
is not a problem with esbuild. You need to fix your environment instead.
`);
    function readUInt32LE(buffer, offset) {
      return buffer[offset++] | buffer[offset++] << 8 | buffer[offset++] << 16 | buffer[offset++] << 24;
    }
    function writeUInt32LE(buffer, value, offset) {
      buffer[offset++] = value;
      buffer[offset++] = value >> 8;
      buffer[offset++] = value >> 16;
      buffer[offset++] = value >> 24;
    }
    var quote = JSON.stringify;
    var buildLogLevelDefault = "warning";
    var transformLogLevelDefault = "silent";
    function validateAndJoinStringArray(values, what) {
      const toJoin = [];
      for (const value of values) {
        validateStringValue(value, what);
        if (value.indexOf(",") >= 0) throw new Error(`Invalid ${what}: ${value}`);
        toJoin.push(value);
      }
      return toJoin.join(",");
    }
    var canBeAnything = () => null;
    var mustBeBoolean = (value) => typeof value === "boolean" ? null : "a boolean";
    var mustBeString = (value) => typeof value === "string" ? null : "a string";
    var mustBeRegExp = (value) => value instanceof RegExp ? null : "a RegExp object";
    var mustBeInteger = (value) => typeof value === "number" && value === (value | 0) ? null : "an integer";
    var mustBeValidPortNumber = (value) => typeof value === "number" && value === (value | 0) && value >= 0 && value <= 65535 ? null : "a valid port number";
    var mustBeFunction = (value) => typeof value === "function" ? null : "a function";
    var mustBeArray = (value) => Array.isArray(value) ? null : "an array";
    var mustBeArrayOfStrings = (value) => Array.isArray(value) && value.every((x) => typeof x === "string") ? null : "an array of strings";
    var mustBeObject = (value) => typeof value === "object" && value !== null && !Array.isArray(value) ? null : "an object";
    var mustBeEntryPoints = (value) => typeof value === "object" && value !== null ? null : "an array or an object";
    var mustBeWebAssemblyModule = (value) => value instanceof WebAssembly.Module ? null : "a WebAssembly.Module";
    var mustBeObjectOrNull = (value) => typeof value === "object" && !Array.isArray(value) ? null : "an object or null";
    var mustBeStringOrBoolean = (value) => typeof value === "string" || typeof value === "boolean" ? null : "a string or a boolean";
    var mustBeStringOrObject = (value) => typeof value === "string" || typeof value === "object" && value !== null && !Array.isArray(value) ? null : "a string or an object";
    var mustBeStringOrArrayOfStrings = (value) => typeof value === "string" || Array.isArray(value) && value.every((x) => typeof x === "string") ? null : "a string or an array of strings";
    var mustBeStringOrUint8Array = (value) => typeof value === "string" || value instanceof Uint8Array ? null : "a string or a Uint8Array";
    var mustBeStringOrURL = (value) => typeof value === "string" || value instanceof URL ? null : "a string or a URL";
    function getFlag(object, keys, key, mustBeFn) {
      let value = object[key];
      keys[key + ""] = true;
      if (value === void 0) return void 0;
      let mustBe = mustBeFn(value);
      if (mustBe !== null) throw new Error(`${quote(key)} must be ${mustBe}`);
      return value;
    }
    function checkForInvalidFlags(object, keys, where) {
      for (let key in object) {
        if (!(key in keys)) {
          throw new Error(`Invalid option ${where}: ${quote(key)}`);
        }
      }
    }
    function validateInitializeOptions(options) {
      let keys = /* @__PURE__ */ Object.create(null);
      let wasmURL = getFlag(options, keys, "wasmURL", mustBeStringOrURL);
      let wasmModule = getFlag(options, keys, "wasmModule", mustBeWebAssemblyModule);
      let worker = getFlag(options, keys, "worker", mustBeBoolean);
      checkForInvalidFlags(options, keys, "in initialize() call");
      return {
        wasmURL,
        wasmModule,
        worker
      };
    }
    function validateMangleCache(mangleCache) {
      let validated;
      if (mangleCache !== void 0) {
        validated = /* @__PURE__ */ Object.create(null);
        for (let key in mangleCache) {
          let value = mangleCache[key];
          if (typeof value === "string" || value === false) {
            validated[key] = value;
          } else {
            throw new Error(`Expected ${quote(key)} in mangle cache to map to either a string or false`);
          }
        }
      }
      return validated;
    }
    function pushLogFlags(flags, options, keys, isTTY2, logLevelDefault) {
      let color = getFlag(options, keys, "color", mustBeBoolean);
      let logLevel = getFlag(options, keys, "logLevel", mustBeString);
      let logLimit = getFlag(options, keys, "logLimit", mustBeInteger);
      if (color !== void 0) flags.push(`--color=${color}`);
      else if (isTTY2) flags.push(`--color=true`);
      flags.push(`--log-level=${logLevel || logLevelDefault}`);
      flags.push(`--log-limit=${logLimit || 0}`);
    }
    function validateStringValue(value, what, key) {
      if (typeof value !== "string") {
        throw new Error(`Expected value for ${what}${key !== void 0 ? " " + quote(key) : ""} to be a string, got ${typeof value} instead`);
      }
      return value;
    }
    function pushCommonFlags(flags, options, keys) {
      let legalComments = getFlag(options, keys, "legalComments", mustBeString);
      let sourceRoot = getFlag(options, keys, "sourceRoot", mustBeString);
      let sourcesContent = getFlag(options, keys, "sourcesContent", mustBeBoolean);
      let target = getFlag(options, keys, "target", mustBeStringOrArrayOfStrings);
      let format3 = getFlag(options, keys, "format", mustBeString);
      let globalName = getFlag(options, keys, "globalName", mustBeString);
      let mangleProps = getFlag(options, keys, "mangleProps", mustBeRegExp);
      let reserveProps = getFlag(options, keys, "reserveProps", mustBeRegExp);
      let mangleQuoted = getFlag(options, keys, "mangleQuoted", mustBeBoolean);
      let minify = getFlag(options, keys, "minify", mustBeBoolean);
      let minifySyntax = getFlag(options, keys, "minifySyntax", mustBeBoolean);
      let minifyWhitespace = getFlag(options, keys, "minifyWhitespace", mustBeBoolean);
      let minifyIdentifiers = getFlag(options, keys, "minifyIdentifiers", mustBeBoolean);
      let lineLimit = getFlag(options, keys, "lineLimit", mustBeInteger);
      let drop = getFlag(options, keys, "drop", mustBeArrayOfStrings);
      let dropLabels = getFlag(options, keys, "dropLabels", mustBeArrayOfStrings);
      let charset = getFlag(options, keys, "charset", mustBeString);
      let treeShaking = getFlag(options, keys, "treeShaking", mustBeBoolean);
      let ignoreAnnotations = getFlag(options, keys, "ignoreAnnotations", mustBeBoolean);
      let jsx2 = getFlag(options, keys, "jsx", mustBeString);
      let jsxFactory = getFlag(options, keys, "jsxFactory", mustBeString);
      let jsxFragment = getFlag(options, keys, "jsxFragment", mustBeString);
      let jsxImportSource = getFlag(options, keys, "jsxImportSource", mustBeString);
      let jsxDev = getFlag(options, keys, "jsxDev", mustBeBoolean);
      let jsxSideEffects = getFlag(options, keys, "jsxSideEffects", mustBeBoolean);
      let define = getFlag(options, keys, "define", mustBeObject);
      let logOverride = getFlag(options, keys, "logOverride", mustBeObject);
      let supported = getFlag(options, keys, "supported", mustBeObject);
      let pure = getFlag(options, keys, "pure", mustBeArrayOfStrings);
      let keepNames = getFlag(options, keys, "keepNames", mustBeBoolean);
      let platform = getFlag(options, keys, "platform", mustBeString);
      let tsconfigRaw = getFlag(options, keys, "tsconfigRaw", mustBeStringOrObject);
      let absPaths = getFlag(options, keys, "absPaths", mustBeArrayOfStrings);
      if (legalComments) flags.push(`--legal-comments=${legalComments}`);
      if (sourceRoot !== void 0) flags.push(`--source-root=${sourceRoot}`);
      if (sourcesContent !== void 0) flags.push(`--sources-content=${sourcesContent}`);
      if (target) flags.push(`--target=${validateAndJoinStringArray(Array.isArray(target) ? target : [target], "target")}`);
      if (format3) flags.push(`--format=${format3}`);
      if (globalName) flags.push(`--global-name=${globalName}`);
      if (platform) flags.push(`--platform=${platform}`);
      if (tsconfigRaw) flags.push(`--tsconfig-raw=${typeof tsconfigRaw === "string" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);
      if (minify) flags.push("--minify");
      if (minifySyntax) flags.push("--minify-syntax");
      if (minifyWhitespace) flags.push("--minify-whitespace");
      if (minifyIdentifiers) flags.push("--minify-identifiers");
      if (lineLimit) flags.push(`--line-limit=${lineLimit}`);
      if (charset) flags.push(`--charset=${charset}`);
      if (treeShaking !== void 0) flags.push(`--tree-shaking=${treeShaking}`);
      if (ignoreAnnotations) flags.push(`--ignore-annotations`);
      if (drop) for (let what of drop) flags.push(`--drop:${validateStringValue(what, "drop")}`);
      if (dropLabels) flags.push(`--drop-labels=${validateAndJoinStringArray(dropLabels, "drop label")}`);
      if (absPaths) flags.push(`--abs-paths=${validateAndJoinStringArray(absPaths, "abs paths")}`);
      if (mangleProps) flags.push(`--mangle-props=${jsRegExpToGoRegExp(mangleProps)}`);
      if (reserveProps) flags.push(`--reserve-props=${jsRegExpToGoRegExp(reserveProps)}`);
      if (mangleQuoted !== void 0) flags.push(`--mangle-quoted=${mangleQuoted}`);
      if (jsx2) flags.push(`--jsx=${jsx2}`);
      if (jsxFactory) flags.push(`--jsx-factory=${jsxFactory}`);
      if (jsxFragment) flags.push(`--jsx-fragment=${jsxFragment}`);
      if (jsxImportSource) flags.push(`--jsx-import-source=${jsxImportSource}`);
      if (jsxDev) flags.push(`--jsx-dev`);
      if (jsxSideEffects) flags.push(`--jsx-side-effects`);
      if (define) {
        for (let key in define) {
          if (key.indexOf("=") >= 0) throw new Error(`Invalid define: ${key}`);
          flags.push(`--define:${key}=${validateStringValue(define[key], "define", key)}`);
        }
      }
      if (logOverride) {
        for (let key in logOverride) {
          if (key.indexOf("=") >= 0) throw new Error(`Invalid log override: ${key}`);
          flags.push(`--log-override:${key}=${validateStringValue(logOverride[key], "log override", key)}`);
        }
      }
      if (supported) {
        for (let key in supported) {
          if (key.indexOf("=") >= 0) throw new Error(`Invalid supported: ${key}`);
          const value = supported[key];
          if (typeof value !== "boolean") throw new Error(`Expected value for supported ${quote(key)} to be a boolean, got ${typeof value} instead`);
          flags.push(`--supported:${key}=${value}`);
        }
      }
      if (pure) for (let fn of pure) flags.push(`--pure:${validateStringValue(fn, "pure")}`);
      if (keepNames) flags.push(`--keep-names`);
    }
    function flagsForBuildOptions(callName, options, isTTY2, logLevelDefault, writeDefault) {
      var _a22;
      let flags = [];
      let entries = [];
      let keys = /* @__PURE__ */ Object.create(null);
      let stdinContents = null;
      let stdinResolveDir = null;
      pushLogFlags(flags, options, keys, isTTY2, logLevelDefault);
      pushCommonFlags(flags, options, keys);
      let sourcemap = getFlag(options, keys, "sourcemap", mustBeStringOrBoolean);
      let bundle = getFlag(options, keys, "bundle", mustBeBoolean);
      let splitting = getFlag(options, keys, "splitting", mustBeBoolean);
      let preserveSymlinks = getFlag(options, keys, "preserveSymlinks", mustBeBoolean);
      let metafile = getFlag(options, keys, "metafile", mustBeBoolean);
      let outfile = getFlag(options, keys, "outfile", mustBeString);
      let outdir = getFlag(options, keys, "outdir", mustBeString);
      let outbase = getFlag(options, keys, "outbase", mustBeString);
      let tsconfig = getFlag(options, keys, "tsconfig", mustBeString);
      let resolveExtensions = getFlag(options, keys, "resolveExtensions", mustBeArrayOfStrings);
      let nodePathsInput = getFlag(options, keys, "nodePaths", mustBeArrayOfStrings);
      let mainFields = getFlag(options, keys, "mainFields", mustBeArrayOfStrings);
      let conditions = getFlag(options, keys, "conditions", mustBeArrayOfStrings);
      let external = getFlag(options, keys, "external", mustBeArrayOfStrings);
      let packages = getFlag(options, keys, "packages", mustBeString);
      let alias = getFlag(options, keys, "alias", mustBeObject);
      let loader = getFlag(options, keys, "loader", mustBeObject);
      let outExtension = getFlag(options, keys, "outExtension", mustBeObject);
      let publicPath = getFlag(options, keys, "publicPath", mustBeString);
      let entryNames = getFlag(options, keys, "entryNames", mustBeString);
      let chunkNames = getFlag(options, keys, "chunkNames", mustBeString);
      let assetNames = getFlag(options, keys, "assetNames", mustBeString);
      let inject = getFlag(options, keys, "inject", mustBeArrayOfStrings);
      let banner = getFlag(options, keys, "banner", mustBeObject);
      let footer = getFlag(options, keys, "footer", mustBeObject);
      let entryPoints = getFlag(options, keys, "entryPoints", mustBeEntryPoints);
      let absWorkingDir = getFlag(options, keys, "absWorkingDir", mustBeString);
      let stdin = getFlag(options, keys, "stdin", mustBeObject);
      let write = (_a22 = getFlag(options, keys, "write", mustBeBoolean)) != null ? _a22 : writeDefault;
      let allowOverwrite = getFlag(options, keys, "allowOverwrite", mustBeBoolean);
      let mangleCache = getFlag(options, keys, "mangleCache", mustBeObject);
      keys.plugins = true;
      checkForInvalidFlags(options, keys, `in ${callName}() call`);
      if (sourcemap) flags.push(`--sourcemap${sourcemap === true ? "" : `=${sourcemap}`}`);
      if (bundle) flags.push("--bundle");
      if (allowOverwrite) flags.push("--allow-overwrite");
      if (splitting) flags.push("--splitting");
      if (preserveSymlinks) flags.push("--preserve-symlinks");
      if (metafile) flags.push(`--metafile`);
      if (outfile) flags.push(`--outfile=${outfile}`);
      if (outdir) flags.push(`--outdir=${outdir}`);
      if (outbase) flags.push(`--outbase=${outbase}`);
      if (tsconfig) flags.push(`--tsconfig=${tsconfig}`);
      if (packages) flags.push(`--packages=${packages}`);
      if (resolveExtensions) flags.push(`--resolve-extensions=${validateAndJoinStringArray(resolveExtensions, "resolve extension")}`);
      if (publicPath) flags.push(`--public-path=${publicPath}`);
      if (entryNames) flags.push(`--entry-names=${entryNames}`);
      if (chunkNames) flags.push(`--chunk-names=${chunkNames}`);
      if (assetNames) flags.push(`--asset-names=${assetNames}`);
      if (mainFields) flags.push(`--main-fields=${validateAndJoinStringArray(mainFields, "main field")}`);
      if (conditions) flags.push(`--conditions=${validateAndJoinStringArray(conditions, "condition")}`);
      if (external) for (let name of external) flags.push(`--external:${validateStringValue(name, "external")}`);
      if (alias) {
        for (let old in alias) {
          if (old.indexOf("=") >= 0) throw new Error(`Invalid package name in alias: ${old}`);
          flags.push(`--alias:${old}=${validateStringValue(alias[old], "alias", old)}`);
        }
      }
      if (banner) {
        for (let type in banner) {
          if (type.indexOf("=") >= 0) throw new Error(`Invalid banner file type: ${type}`);
          flags.push(`--banner:${type}=${validateStringValue(banner[type], "banner", type)}`);
        }
      }
      if (footer) {
        for (let type in footer) {
          if (type.indexOf("=") >= 0) throw new Error(`Invalid footer file type: ${type}`);
          flags.push(`--footer:${type}=${validateStringValue(footer[type], "footer", type)}`);
        }
      }
      if (inject) for (let path3 of inject) flags.push(`--inject:${validateStringValue(path3, "inject")}`);
      if (loader) {
        for (let ext in loader) {
          if (ext.indexOf("=") >= 0) throw new Error(`Invalid loader extension: ${ext}`);
          flags.push(`--loader:${ext}=${validateStringValue(loader[ext], "loader", ext)}`);
        }
      }
      if (outExtension) {
        for (let ext in outExtension) {
          if (ext.indexOf("=") >= 0) throw new Error(`Invalid out extension: ${ext}`);
          flags.push(`--out-extension:${ext}=${validateStringValue(outExtension[ext], "out extension", ext)}`);
        }
      }
      if (entryPoints) {
        if (Array.isArray(entryPoints)) {
          for (let i = 0, n = entryPoints.length; i < n; i++) {
            let entryPoint = entryPoints[i];
            if (typeof entryPoint === "object" && entryPoint !== null) {
              let entryPointKeys = /* @__PURE__ */ Object.create(null);
              let input = getFlag(entryPoint, entryPointKeys, "in", mustBeString);
              let output = getFlag(entryPoint, entryPointKeys, "out", mustBeString);
              checkForInvalidFlags(entryPoint, entryPointKeys, "in entry point at index " + i);
              if (input === void 0) throw new Error('Missing property "in" for entry point at index ' + i);
              if (output === void 0) throw new Error('Missing property "out" for entry point at index ' + i);
              entries.push([output, input]);
            } else {
              entries.push(["", validateStringValue(entryPoint, "entry point at index " + i)]);
            }
          }
        } else {
          for (let key in entryPoints) {
            entries.push([key, validateStringValue(entryPoints[key], "entry point", key)]);
          }
        }
      }
      if (stdin) {
        let stdinKeys = /* @__PURE__ */ Object.create(null);
        let contents = getFlag(stdin, stdinKeys, "contents", mustBeStringOrUint8Array);
        let resolveDir = getFlag(stdin, stdinKeys, "resolveDir", mustBeString);
        let sourcefile = getFlag(stdin, stdinKeys, "sourcefile", mustBeString);
        let loader2 = getFlag(stdin, stdinKeys, "loader", mustBeString);
        checkForInvalidFlags(stdin, stdinKeys, 'in "stdin" object');
        if (sourcefile) flags.push(`--sourcefile=${sourcefile}`);
        if (loader2) flags.push(`--loader=${loader2}`);
        if (resolveDir) stdinResolveDir = resolveDir;
        if (typeof contents === "string") stdinContents = encodeUTF8(contents);
        else if (contents instanceof Uint8Array) stdinContents = contents;
      }
      let nodePaths = [];
      if (nodePathsInput) {
        for (let value of nodePathsInput) {
          value += "";
          nodePaths.push(value);
        }
      }
      return {
        entries,
        flags,
        write,
        stdinContents,
        stdinResolveDir,
        absWorkingDir,
        nodePaths,
        mangleCache: validateMangleCache(mangleCache)
      };
    }
    function flagsForTransformOptions(callName, options, isTTY2, logLevelDefault) {
      let flags = [];
      let keys = /* @__PURE__ */ Object.create(null);
      pushLogFlags(flags, options, keys, isTTY2, logLevelDefault);
      pushCommonFlags(flags, options, keys);
      let sourcemap = getFlag(options, keys, "sourcemap", mustBeStringOrBoolean);
      let sourcefile = getFlag(options, keys, "sourcefile", mustBeString);
      let loader = getFlag(options, keys, "loader", mustBeString);
      let banner = getFlag(options, keys, "banner", mustBeString);
      let footer = getFlag(options, keys, "footer", mustBeString);
      let mangleCache = getFlag(options, keys, "mangleCache", mustBeObject);
      checkForInvalidFlags(options, keys, `in ${callName}() call`);
      if (sourcemap) flags.push(`--sourcemap=${sourcemap === true ? "external" : sourcemap}`);
      if (sourcefile) flags.push(`--sourcefile=${sourcefile}`);
      if (loader) flags.push(`--loader=${loader}`);
      if (banner) flags.push(`--banner=${banner}`);
      if (footer) flags.push(`--footer=${footer}`);
      return {
        flags,
        mangleCache: validateMangleCache(mangleCache)
      };
    }
    function createChannel(streamIn) {
      const requestCallbacksByKey = {};
      const closeData = { didClose: false, reason: "" };
      let responseCallbacks = {};
      let nextRequestID = 0;
      let nextBuildKey = 0;
      let stdout = new Uint8Array(16 * 1024);
      let stdoutUsed = 0;
      let readFromStdout = (chunk) => {
        let limit = stdoutUsed + chunk.length;
        if (limit > stdout.length) {
          let swap = new Uint8Array(limit * 2);
          swap.set(stdout);
          stdout = swap;
        }
        stdout.set(chunk, stdoutUsed);
        stdoutUsed += chunk.length;
        let offset = 0;
        while (offset + 4 <= stdoutUsed) {
          let length = readUInt32LE(stdout, offset);
          if (offset + 4 + length > stdoutUsed) {
            break;
          }
          offset += 4;
          handleIncomingPacket(stdout.subarray(offset, offset + length));
          offset += length;
        }
        if (offset > 0) {
          stdout.copyWithin(0, offset, stdoutUsed);
          stdoutUsed -= offset;
        }
      };
      let afterClose = (error) => {
        closeData.didClose = true;
        if (error) closeData.reason = ": " + (error.message || error);
        const text = "The service was stopped" + closeData.reason;
        for (let id in responseCallbacks) {
          responseCallbacks[id](text, null);
        }
        responseCallbacks = {};
      };
      let sendRequest = (refs, value, callback) => {
        if (closeData.didClose) return callback("The service is no longer running" + closeData.reason, null);
        let id = nextRequestID++;
        responseCallbacks[id] = (error, response) => {
          try {
            callback(error, response);
          } finally {
            if (refs) refs.unref();
          }
        };
        if (refs) refs.ref();
        streamIn.writeToStdin(encodePacket({ id, isRequest: true, value }));
      };
      let sendResponse = (id, value) => {
        if (closeData.didClose) throw new Error("The service is no longer running" + closeData.reason);
        streamIn.writeToStdin(encodePacket({ id, isRequest: false, value }));
      };
      let handleRequest = async (id, request) => {
        try {
          if (request.command === "ping") {
            sendResponse(id, {});
            return;
          }
          if (typeof request.key === "number") {
            const requestCallbacks = requestCallbacksByKey[request.key];
            if (!requestCallbacks) {
              return;
            }
            const callback = requestCallbacks[request.command];
            if (callback) {
              await callback(id, request);
              return;
            }
          }
          throw new Error(`Invalid command: ` + request.command);
        } catch (e) {
          const errors = [extractErrorMessageV8(e, streamIn, null, void 0, "")];
          try {
            sendResponse(id, { errors });
          } catch {
          }
        }
      };
      let isFirstPacket = true;
      let handleIncomingPacket = (bytes) => {
        if (isFirstPacket) {
          isFirstPacket = false;
          let binaryVersion = String.fromCharCode(...bytes);
          if (binaryVersion !== "0.25.10") {
            throw new Error(`Cannot start service: Host version "${"0.25.10"}" does not match binary version ${quote(binaryVersion)}`);
          }
          return;
        }
        let packet = decodePacket(bytes);
        if (packet.isRequest) {
          handleRequest(packet.id, packet.value);
        } else {
          let callback = responseCallbacks[packet.id];
          delete responseCallbacks[packet.id];
          if (packet.value.error) callback(packet.value.error, {});
          else callback(null, packet.value);
        }
      };
      let buildOrContext = ({ callName, refs, options, isTTY: isTTY2, defaultWD: defaultWD2, callback }) => {
        let refCount = 0;
        const buildKey = nextBuildKey++;
        const requestCallbacks = {};
        const buildRefs = {
          ref() {
            if (++refCount === 1) {
              if (refs) refs.ref();
            }
          },
          unref() {
            if (--refCount === 0) {
              delete requestCallbacksByKey[buildKey];
              if (refs) refs.unref();
            }
          }
        };
        requestCallbacksByKey[buildKey] = requestCallbacks;
        buildRefs.ref();
        buildOrContextImpl(
          callName,
          buildKey,
          sendRequest,
          sendResponse,
          buildRefs,
          streamIn,
          requestCallbacks,
          options,
          isTTY2,
          defaultWD2,
          (err, res) => {
            try {
              callback(err, res);
            } finally {
              buildRefs.unref();
            }
          }
        );
      };
      let transform2 = ({ callName, refs, input, options, isTTY: isTTY2, fs: fs3, callback }) => {
        const details = createObjectStash();
        let start = (inputPath) => {
          try {
            if (typeof input !== "string" && !(input instanceof Uint8Array))
              throw new Error('The input to "transform" must be a string or a Uint8Array');
            let {
              flags,
              mangleCache
            } = flagsForTransformOptions(callName, options, isTTY2, transformLogLevelDefault);
            let request = {
              command: "transform",
              flags,
              inputFS: inputPath !== null,
              input: inputPath !== null ? encodeUTF8(inputPath) : typeof input === "string" ? encodeUTF8(input) : input
            };
            if (mangleCache) request.mangleCache = mangleCache;
            sendRequest(refs, request, (error, response) => {
              if (error) return callback(new Error(error), null);
              let errors = replaceDetailsInMessages(response.errors, details);
              let warnings = replaceDetailsInMessages(response.warnings, details);
              let outstanding = 1;
              let next = () => {
                if (--outstanding === 0) {
                  let result2 = {
                    warnings,
                    code: response.code,
                    map: response.map,
                    mangleCache: void 0,
                    legalComments: void 0
                  };
                  if ("legalComments" in response) result2.legalComments = response == null ? void 0 : response.legalComments;
                  if (response.mangleCache) result2.mangleCache = response == null ? void 0 : response.mangleCache;
                  callback(null, result2);
                }
              };
              if (errors.length > 0) return callback(failureErrorWithLog("Transform failed", errors, warnings), null);
              if (response.codeFS) {
                outstanding++;
                fs3.readFile(response.code, (err, contents) => {
                  if (err !== null) {
                    callback(err, null);
                  } else {
                    response.code = contents;
                    next();
                  }
                });
              }
              if (response.mapFS) {
                outstanding++;
                fs3.readFile(response.map, (err, contents) => {
                  if (err !== null) {
                    callback(err, null);
                  } else {
                    response.map = contents;
                    next();
                  }
                });
              }
              next();
            });
          } catch (e) {
            let flags = [];
            try {
              pushLogFlags(flags, options, {}, isTTY2, transformLogLevelDefault);
            } catch {
            }
            const error = extractErrorMessageV8(e, streamIn, details, void 0, "");
            sendRequest(refs, { command: "error", flags, error }, () => {
              error.detail = details.load(error.detail);
              callback(failureErrorWithLog("Transform failed", [error], []), null);
            });
          }
        };
        if ((typeof input === "string" || input instanceof Uint8Array) && input.length > 1024 * 1024) {
          let next = start;
          start = () => fs3.writeFile(input, next);
        }
        start(null);
      };
      let formatMessages2 = ({ callName, refs, messages, options, callback }) => {
        if (!options) throw new Error(`Missing second argument in ${callName}() call`);
        let keys = {};
        let kind = getFlag(options, keys, "kind", mustBeString);
        let color = getFlag(options, keys, "color", mustBeBoolean);
        let terminalWidth = getFlag(options, keys, "terminalWidth", mustBeInteger);
        checkForInvalidFlags(options, keys, `in ${callName}() call`);
        if (kind === void 0) throw new Error(`Missing "kind" in ${callName}() call`);
        if (kind !== "error" && kind !== "warning") throw new Error(`Expected "kind" to be "error" or "warning" in ${callName}() call`);
        let request = {
          command: "format-msgs",
          messages: sanitizeMessages(messages, "messages", null, "", terminalWidth),
          isWarning: kind === "warning"
        };
        if (color !== void 0) request.color = color;
        if (terminalWidth !== void 0) request.terminalWidth = terminalWidth;
        sendRequest(refs, request, (error, response) => {
          if (error) return callback(new Error(error), null);
          callback(null, response.messages);
        });
      };
      let analyzeMetafile2 = ({ callName, refs, metafile, options, callback }) => {
        if (options === void 0) options = {};
        let keys = {};
        let color = getFlag(options, keys, "color", mustBeBoolean);
        let verbose = getFlag(options, keys, "verbose", mustBeBoolean);
        checkForInvalidFlags(options, keys, `in ${callName}() call`);
        let request = {
          command: "analyze-metafile",
          metafile
        };
        if (color !== void 0) request.color = color;
        if (verbose !== void 0) request.verbose = verbose;
        sendRequest(refs, request, (error, response) => {
          if (error) return callback(new Error(error), null);
          callback(null, response.result);
        });
      };
      return {
        readFromStdout,
        afterClose,
        service: {
          buildOrContext,
          transform: transform2,
          formatMessages: formatMessages2,
          analyzeMetafile: analyzeMetafile2
        }
      };
    }
    function buildOrContextImpl(callName, buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, options, isTTY2, defaultWD2, callback) {
      const details = createObjectStash();
      const isContext = callName === "context";
      const handleError = (e, pluginName) => {
        const flags = [];
        try {
          pushLogFlags(flags, options, {}, isTTY2, buildLogLevelDefault);
        } catch {
        }
        const message = extractErrorMessageV8(e, streamIn, details, void 0, pluginName);
        sendRequest(refs, { command: "error", flags, error: message }, () => {
          message.detail = details.load(message.detail);
          callback(failureErrorWithLog(isContext ? "Context failed" : "Build failed", [message], []), null);
        });
      };
      let plugins;
      if (typeof options === "object") {
        const value = options.plugins;
        if (value !== void 0) {
          if (!Array.isArray(value)) return handleError(new Error(`"plugins" must be an array`), "");
          plugins = value;
        }
      }
      if (plugins && plugins.length > 0) {
        if (streamIn.isSync) return handleError(new Error("Cannot use plugins in synchronous API calls"), "");
        handlePlugins(
          buildKey,
          sendRequest,
          sendResponse,
          refs,
          streamIn,
          requestCallbacks,
          options,
          plugins,
          details
        ).then(
          (result2) => {
            if (!result2.ok) return handleError(result2.error, result2.pluginName);
            try {
              buildOrContextContinue(result2.requestPlugins, result2.runOnEndCallbacks, result2.scheduleOnDisposeCallbacks);
            } catch (e) {
              handleError(e, "");
            }
          },
          (e) => handleError(e, "")
        );
        return;
      }
      try {
        buildOrContextContinue(null, (result2, done) => done([], []), () => {
        });
      } catch (e) {
        handleError(e, "");
      }
      function buildOrContextContinue(requestPlugins, runOnEndCallbacks, scheduleOnDisposeCallbacks) {
        const writeDefault = streamIn.hasFS;
        const {
          entries,
          flags,
          write,
          stdinContents,
          stdinResolveDir,
          absWorkingDir,
          nodePaths,
          mangleCache
        } = flagsForBuildOptions(callName, options, isTTY2, buildLogLevelDefault, writeDefault);
        if (write && !streamIn.hasFS) throw new Error(`The "write" option is unavailable in this environment`);
        const request = {
          command: "build",
          key: buildKey,
          entries,
          flags,
          write,
          stdinContents,
          stdinResolveDir,
          absWorkingDir: absWorkingDir || defaultWD2,
          nodePaths,
          context: isContext
        };
        if (requestPlugins) request.plugins = requestPlugins;
        if (mangleCache) request.mangleCache = mangleCache;
        const buildResponseToResult = (response, callback2) => {
          const result2 = {
            errors: replaceDetailsInMessages(response.errors, details),
            warnings: replaceDetailsInMessages(response.warnings, details),
            outputFiles: void 0,
            metafile: void 0,
            mangleCache: void 0
          };
          const originalErrors = result2.errors.slice();
          const originalWarnings = result2.warnings.slice();
          if (response.outputFiles) result2.outputFiles = response.outputFiles.map(convertOutputFiles);
          if (response.metafile) result2.metafile = JSON.parse(response.metafile);
          if (response.mangleCache) result2.mangleCache = response.mangleCache;
          if (response.writeToStdout !== void 0) console.log(decodeUTF8(response.writeToStdout).replace(/\n$/, ""));
          runOnEndCallbacks(result2, (onEndErrors, onEndWarnings) => {
            if (originalErrors.length > 0 || onEndErrors.length > 0) {
              const error = failureErrorWithLog("Build failed", originalErrors.concat(onEndErrors), originalWarnings.concat(onEndWarnings));
              return callback2(error, null, onEndErrors, onEndWarnings);
            }
            callback2(null, result2, onEndErrors, onEndWarnings);
          });
        };
        let latestResultPromise;
        let provideLatestResult;
        if (isContext)
          requestCallbacks["on-end"] = (id, request2) => new Promise((resolve) => {
            buildResponseToResult(request2, (err, result2, onEndErrors, onEndWarnings) => {
              const response = {
                errors: onEndErrors,
                warnings: onEndWarnings
              };
              if (provideLatestResult) provideLatestResult(err, result2);
              latestResultPromise = void 0;
              provideLatestResult = void 0;
              sendResponse(id, response);
              resolve();
            });
          });
        sendRequest(refs, request, (error, response) => {
          if (error) return callback(new Error(error), null);
          if (!isContext) {
            return buildResponseToResult(response, (err, res) => {
              scheduleOnDisposeCallbacks();
              return callback(err, res);
            });
          }
          if (response.errors.length > 0) {
            return callback(failureErrorWithLog("Context failed", response.errors, response.warnings), null);
          }
          let didDispose = false;
          const result2 = {
            rebuild: () => {
              if (!latestResultPromise) latestResultPromise = new Promise((resolve, reject) => {
                let settlePromise;
                provideLatestResult = (err, result22) => {
                  if (!settlePromise) settlePromise = () => err ? reject(err) : resolve(result22);
                };
                const triggerAnotherBuild = () => {
                  const request2 = {
                    command: "rebuild",
                    key: buildKey
                  };
                  sendRequest(refs, request2, (error2, response2) => {
                    if (error2) {
                      reject(new Error(error2));
                    } else if (settlePromise) {
                      settlePromise();
                    } else {
                      triggerAnotherBuild();
                    }
                  });
                };
                triggerAnotherBuild();
              });
              return latestResultPromise;
            },
            watch: (options2 = {}) => new Promise((resolve, reject) => {
              if (!streamIn.hasFS) throw new Error(`Cannot use the "watch" API in this environment`);
              const keys = {};
              const delay2 = getFlag(options2, keys, "delay", mustBeInteger);
              checkForInvalidFlags(options2, keys, `in watch() call`);
              const request2 = {
                command: "watch",
                key: buildKey
              };
              if (delay2) request2.delay = delay2;
              sendRequest(refs, request2, (error2) => {
                if (error2) reject(new Error(error2));
                else resolve(void 0);
              });
            }),
            serve: (options2 = {}) => new Promise((resolve, reject) => {
              if (!streamIn.hasFS) throw new Error(`Cannot use the "serve" API in this environment`);
              const keys = {};
              const port = getFlag(options2, keys, "port", mustBeValidPortNumber);
              const host = getFlag(options2, keys, "host", mustBeString);
              const servedir = getFlag(options2, keys, "servedir", mustBeString);
              const keyfile = getFlag(options2, keys, "keyfile", mustBeString);
              const certfile = getFlag(options2, keys, "certfile", mustBeString);
              const fallback = getFlag(options2, keys, "fallback", mustBeString);
              const cors = getFlag(options2, keys, "cors", mustBeObject);
              const onRequest = getFlag(options2, keys, "onRequest", mustBeFunction);
              checkForInvalidFlags(options2, keys, `in serve() call`);
              const request2 = {
                command: "serve",
                key: buildKey,
                onRequest: !!onRequest
              };
              if (port !== void 0) request2.port = port;
              if (host !== void 0) request2.host = host;
              if (servedir !== void 0) request2.servedir = servedir;
              if (keyfile !== void 0) request2.keyfile = keyfile;
              if (certfile !== void 0) request2.certfile = certfile;
              if (fallback !== void 0) request2.fallback = fallback;
              if (cors) {
                const corsKeys = {};
                const origin = getFlag(cors, corsKeys, "origin", mustBeStringOrArrayOfStrings);
                checkForInvalidFlags(cors, corsKeys, `on "cors" object`);
                if (Array.isArray(origin)) request2.corsOrigin = origin;
                else if (origin !== void 0) request2.corsOrigin = [origin];
              }
              sendRequest(refs, request2, (error2, response2) => {
                if (error2) return reject(new Error(error2));
                if (onRequest) {
                  requestCallbacks["serve-request"] = (id, request3) => {
                    onRequest(request3.args);
                    sendResponse(id, {});
                  };
                }
                resolve(response2);
              });
            }),
            cancel: () => new Promise((resolve) => {
              if (didDispose) return resolve();
              const request2 = {
                command: "cancel",
                key: buildKey
              };
              sendRequest(refs, request2, () => {
                resolve();
              });
            }),
            dispose: () => new Promise((resolve) => {
              if (didDispose) return resolve();
              didDispose = true;
              const request2 = {
                command: "dispose",
                key: buildKey
              };
              sendRequest(refs, request2, () => {
                resolve();
                scheduleOnDisposeCallbacks();
                refs.unref();
              });
            })
          };
          refs.ref();
          callback(null, result2);
        });
      }
    }
    var handlePlugins = async (buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, initialOptions, plugins, details) => {
      let onStartCallbacks = [];
      let onEndCallbacks = [];
      let onResolveCallbacks = {};
      let onLoadCallbacks = {};
      let onDisposeCallbacks = [];
      let nextCallbackID = 0;
      let i = 0;
      let requestPlugins = [];
      let isSetupDone = false;
      plugins = [...plugins];
      for (let item of plugins) {
        let keys = {};
        if (typeof item !== "object") throw new Error(`Plugin at index ${i} must be an object`);
        const name = getFlag(item, keys, "name", mustBeString);
        if (typeof name !== "string" || name === "") throw new Error(`Plugin at index ${i} is missing a name`);
        try {
          let setup = getFlag(item, keys, "setup", mustBeFunction);
          if (typeof setup !== "function") throw new Error(`Plugin is missing a setup function`);
          checkForInvalidFlags(item, keys, `on plugin ${quote(name)}`);
          let plugin = {
            name,
            onStart: false,
            onEnd: false,
            onResolve: [],
            onLoad: []
          };
          i++;
          let resolve = (path3, options = {}) => {
            if (!isSetupDone) throw new Error('Cannot call "resolve" before plugin setup has completed');
            if (typeof path3 !== "string") throw new Error(`The path to resolve must be a string`);
            let keys2 = /* @__PURE__ */ Object.create(null);
            let pluginName = getFlag(options, keys2, "pluginName", mustBeString);
            let importer = getFlag(options, keys2, "importer", mustBeString);
            let namespace = getFlag(options, keys2, "namespace", mustBeString);
            let resolveDir = getFlag(options, keys2, "resolveDir", mustBeString);
            let kind = getFlag(options, keys2, "kind", mustBeString);
            let pluginData = getFlag(options, keys2, "pluginData", canBeAnything);
            let importAttributes = getFlag(options, keys2, "with", mustBeObject);
            checkForInvalidFlags(options, keys2, "in resolve() call");
            return new Promise((resolve2, reject) => {
              const request = {
                command: "resolve",
                path: path3,
                key: buildKey,
                pluginName: name
              };
              if (pluginName != null) request.pluginName = pluginName;
              if (importer != null) request.importer = importer;
              if (namespace != null) request.namespace = namespace;
              if (resolveDir != null) request.resolveDir = resolveDir;
              if (kind != null) request.kind = kind;
              else throw new Error(`Must specify "kind" when calling "resolve"`);
              if (pluginData != null) request.pluginData = details.store(pluginData);
              if (importAttributes != null) request.with = sanitizeStringMap(importAttributes, "with");
              sendRequest(refs, request, (error, response) => {
                if (error !== null) reject(new Error(error));
                else resolve2({
                  errors: replaceDetailsInMessages(response.errors, details),
                  warnings: replaceDetailsInMessages(response.warnings, details),
                  path: response.path,
                  external: response.external,
                  sideEffects: response.sideEffects,
                  namespace: response.namespace,
                  suffix: response.suffix,
                  pluginData: details.load(response.pluginData)
                });
              });
            });
          };
          let promise = setup({
            initialOptions,
            resolve,
            onStart(callback) {
              let registeredText = `This error came from the "onStart" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onStart");
              onStartCallbacks.push({ name, callback, note: registeredNote });
              plugin.onStart = true;
            },
            onEnd(callback) {
              let registeredText = `This error came from the "onEnd" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onEnd");
              onEndCallbacks.push({ name, callback, note: registeredNote });
              plugin.onEnd = true;
            },
            onResolve(options, callback) {
              let registeredText = `This error came from the "onResolve" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onResolve");
              let keys2 = {};
              let filter = getFlag(options, keys2, "filter", mustBeRegExp);
              let namespace = getFlag(options, keys2, "namespace", mustBeString);
              checkForInvalidFlags(options, keys2, `in onResolve() call for plugin ${quote(name)}`);
              if (filter == null) throw new Error(`onResolve() call is missing a filter`);
              let id = nextCallbackID++;
              onResolveCallbacks[id] = { name, callback, note: registeredNote };
              plugin.onResolve.push({ id, filter: jsRegExpToGoRegExp(filter), namespace: namespace || "" });
            },
            onLoad(options, callback) {
              let registeredText = `This error came from the "onLoad" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onLoad");
              let keys2 = {};
              let filter = getFlag(options, keys2, "filter", mustBeRegExp);
              let namespace = getFlag(options, keys2, "namespace", mustBeString);
              checkForInvalidFlags(options, keys2, `in onLoad() call for plugin ${quote(name)}`);
              if (filter == null) throw new Error(`onLoad() call is missing a filter`);
              let id = nextCallbackID++;
              onLoadCallbacks[id] = { name, callback, note: registeredNote };
              plugin.onLoad.push({ id, filter: jsRegExpToGoRegExp(filter), namespace: namespace || "" });
            },
            onDispose(callback) {
              onDisposeCallbacks.push(callback);
            },
            esbuild: streamIn.esbuild
          });
          if (promise) await promise;
          requestPlugins.push(plugin);
        } catch (e) {
          return { ok: false, error: e, pluginName: name };
        }
      }
      requestCallbacks["on-start"] = async (id, request) => {
        details.clear();
        let response = { errors: [], warnings: [] };
        await Promise.all(onStartCallbacks.map(async ({ name, callback, note }) => {
          try {
            let result2 = await callback();
            if (result2 != null) {
              if (typeof result2 !== "object") throw new Error(`Expected onStart() callback in plugin ${quote(name)} to return an object`);
              let keys = {};
              let errors = getFlag(result2, keys, "errors", mustBeArray);
              let warnings = getFlag(result2, keys, "warnings", mustBeArray);
              checkForInvalidFlags(result2, keys, `from onStart() callback in plugin ${quote(name)}`);
              if (errors != null) response.errors.push(...sanitizeMessages(errors, "errors", details, name, void 0));
              if (warnings != null) response.warnings.push(...sanitizeMessages(warnings, "warnings", details, name, void 0));
            }
          } catch (e) {
            response.errors.push(extractErrorMessageV8(e, streamIn, details, note && note(), name));
          }
        }));
        sendResponse(id, response);
      };
      requestCallbacks["on-resolve"] = async (id, request) => {
        let response = {}, name = "", callback, note;
        for (let id2 of request.ids) {
          try {
            ({ name, callback, note } = onResolveCallbacks[id2]);
            let result2 = await callback({
              path: request.path,
              importer: request.importer,
              namespace: request.namespace,
              resolveDir: request.resolveDir,
              kind: request.kind,
              pluginData: details.load(request.pluginData),
              with: request.with
            });
            if (result2 != null) {
              if (typeof result2 !== "object") throw new Error(`Expected onResolve() callback in plugin ${quote(name)} to return an object`);
              let keys = {};
              let pluginName = getFlag(result2, keys, "pluginName", mustBeString);
              let path3 = getFlag(result2, keys, "path", mustBeString);
              let namespace = getFlag(result2, keys, "namespace", mustBeString);
              let suffix = getFlag(result2, keys, "suffix", mustBeString);
              let external = getFlag(result2, keys, "external", mustBeBoolean);
              let sideEffects = getFlag(result2, keys, "sideEffects", mustBeBoolean);
              let pluginData = getFlag(result2, keys, "pluginData", canBeAnything);
              let errors = getFlag(result2, keys, "errors", mustBeArray);
              let warnings = getFlag(result2, keys, "warnings", mustBeArray);
              let watchFiles = getFlag(result2, keys, "watchFiles", mustBeArrayOfStrings);
              let watchDirs = getFlag(result2, keys, "watchDirs", mustBeArrayOfStrings);
              checkForInvalidFlags(result2, keys, `from onResolve() callback in plugin ${quote(name)}`);
              response.id = id2;
              if (pluginName != null) response.pluginName = pluginName;
              if (path3 != null) response.path = path3;
              if (namespace != null) response.namespace = namespace;
              if (suffix != null) response.suffix = suffix;
              if (external != null) response.external = external;
              if (sideEffects != null) response.sideEffects = sideEffects;
              if (pluginData != null) response.pluginData = details.store(pluginData);
              if (errors != null) response.errors = sanitizeMessages(errors, "errors", details, name, void 0);
              if (warnings != null) response.warnings = sanitizeMessages(warnings, "warnings", details, name, void 0);
              if (watchFiles != null) response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
              if (watchDirs != null) response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
              break;
            }
          } catch (e) {
            response = { id: id2, errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name)] };
            break;
          }
        }
        sendResponse(id, response);
      };
      requestCallbacks["on-load"] = async (id, request) => {
        let response = {}, name = "", callback, note;
        for (let id2 of request.ids) {
          try {
            ({ name, callback, note } = onLoadCallbacks[id2]);
            let result2 = await callback({
              path: request.path,
              namespace: request.namespace,
              suffix: request.suffix,
              pluginData: details.load(request.pluginData),
              with: request.with
            });
            if (result2 != null) {
              if (typeof result2 !== "object") throw new Error(`Expected onLoad() callback in plugin ${quote(name)} to return an object`);
              let keys = {};
              let pluginName = getFlag(result2, keys, "pluginName", mustBeString);
              let contents = getFlag(result2, keys, "contents", mustBeStringOrUint8Array);
              let resolveDir = getFlag(result2, keys, "resolveDir", mustBeString);
              let pluginData = getFlag(result2, keys, "pluginData", canBeAnything);
              let loader = getFlag(result2, keys, "loader", mustBeString);
              let errors = getFlag(result2, keys, "errors", mustBeArray);
              let warnings = getFlag(result2, keys, "warnings", mustBeArray);
              let watchFiles = getFlag(result2, keys, "watchFiles", mustBeArrayOfStrings);
              let watchDirs = getFlag(result2, keys, "watchDirs", mustBeArrayOfStrings);
              checkForInvalidFlags(result2, keys, `from onLoad() callback in plugin ${quote(name)}`);
              response.id = id2;
              if (pluginName != null) response.pluginName = pluginName;
              if (contents instanceof Uint8Array) response.contents = contents;
              else if (contents != null) response.contents = encodeUTF8(contents);
              if (resolveDir != null) response.resolveDir = resolveDir;
              if (pluginData != null) response.pluginData = details.store(pluginData);
              if (loader != null) response.loader = loader;
              if (errors != null) response.errors = sanitizeMessages(errors, "errors", details, name, void 0);
              if (warnings != null) response.warnings = sanitizeMessages(warnings, "warnings", details, name, void 0);
              if (watchFiles != null) response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
              if (watchDirs != null) response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
              break;
            }
          } catch (e) {
            response = { id: id2, errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name)] };
            break;
          }
        }
        sendResponse(id, response);
      };
      let runOnEndCallbacks = (result2, done) => done([], []);
      if (onEndCallbacks.length > 0) {
        runOnEndCallbacks = (result2, done) => {
          (async () => {
            const onEndErrors = [];
            const onEndWarnings = [];
            for (const { name, callback, note } of onEndCallbacks) {
              let newErrors;
              let newWarnings;
              try {
                const value = await callback(result2);
                if (value != null) {
                  if (typeof value !== "object") throw new Error(`Expected onEnd() callback in plugin ${quote(name)} to return an object`);
                  let keys = {};
                  let errors = getFlag(value, keys, "errors", mustBeArray);
                  let warnings = getFlag(value, keys, "warnings", mustBeArray);
                  checkForInvalidFlags(value, keys, `from onEnd() callback in plugin ${quote(name)}`);
                  if (errors != null) newErrors = sanitizeMessages(errors, "errors", details, name, void 0);
                  if (warnings != null) newWarnings = sanitizeMessages(warnings, "warnings", details, name, void 0);
                }
              } catch (e) {
                newErrors = [extractErrorMessageV8(e, streamIn, details, note && note(), name)];
              }
              if (newErrors) {
                onEndErrors.push(...newErrors);
                try {
                  result2.errors.push(...newErrors);
                } catch {
                }
              }
              if (newWarnings) {
                onEndWarnings.push(...newWarnings);
                try {
                  result2.warnings.push(...newWarnings);
                } catch {
                }
              }
            }
            done(onEndErrors, onEndWarnings);
          })();
        };
      }
      let scheduleOnDisposeCallbacks = () => {
        for (const cb of onDisposeCallbacks) {
          setTimeout(() => cb(), 0);
        }
      };
      isSetupDone = true;
      return {
        ok: true,
        requestPlugins,
        runOnEndCallbacks,
        scheduleOnDisposeCallbacks
      };
    };
    function createObjectStash() {
      const map = /* @__PURE__ */ new Map();
      let nextID = 0;
      return {
        clear() {
          map.clear();
        },
        load(id) {
          return map.get(id);
        },
        store(value) {
          if (value === void 0) return -1;
          const id = nextID++;
          map.set(id, value);
          return id;
        }
      };
    }
    function extractCallerV8(e, streamIn, ident) {
      let note;
      let tried = false;
      return () => {
        if (tried) return note;
        tried = true;
        try {
          let lines = (e.stack + "").split("\n");
          lines.splice(1, 1);
          let location = parseStackLinesV8(streamIn, lines, ident);
          if (location) {
            note = { text: e.message, location };
            return note;
          }
        } catch {
        }
      };
    }
    function extractErrorMessageV8(e, streamIn, stash, note, pluginName) {
      let text = "Internal error";
      let location = null;
      try {
        text = (e && e.message || e) + "";
      } catch {
      }
      try {
        location = parseStackLinesV8(streamIn, (e.stack + "").split("\n"), "");
      } catch {
      }
      return { id: "", pluginName, text, location, notes: note ? [note] : [], detail: stash ? stash.store(e) : -1 };
    }
    function parseStackLinesV8(streamIn, lines, ident) {
      let at = "    at ";
      if (streamIn.readFileSync && !lines[0].startsWith(at) && lines[1].startsWith(at)) {
        for (let i = 1; i < lines.length; i++) {
          let line = lines[i];
          if (!line.startsWith(at)) continue;
          line = line.slice(at.length);
          while (true) {
            let match = /^(?:new |async )?\S+ \((.*)\)$/.exec(line);
            if (match) {
              line = match[1];
              continue;
            }
            match = /^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(line);
            if (match) {
              line = match[1];
              continue;
            }
            match = /^(\S+):(\d+):(\d+)$/.exec(line);
            if (match) {
              let contents;
              try {
                contents = streamIn.readFileSync(match[1], "utf8");
              } catch {
                break;
              }
              let lineText = contents.split(/\r\n|\r|\n|\u2028|\u2029/)[+match[2] - 1] || "";
              let column = +match[3] - 1;
              let length = lineText.slice(column, column + ident.length) === ident ? ident.length : 0;
              return {
                file: match[1],
                namespace: "file",
                line: +match[2],
                column: encodeUTF8(lineText.slice(0, column)).length,
                length: encodeUTF8(lineText.slice(column, column + length)).length,
                lineText: lineText + "\n" + lines.slice(1).join("\n"),
                suggestion: ""
              };
            }
            break;
          }
        }
      }
      return null;
    }
    function failureErrorWithLog(text, errors, warnings) {
      let limit = 5;
      text += errors.length < 1 ? "" : ` with ${errors.length} error${errors.length < 2 ? "" : "s"}:` + errors.slice(0, limit + 1).map((e, i) => {
        if (i === limit) return "\n...";
        if (!e.location) return `
error: ${e.text}`;
        let { file, line, column } = e.location;
        let pluginText = e.pluginName ? `[plugin: ${e.pluginName}] ` : "";
        return `
${file}:${line}:${column}: ERROR: ${pluginText}${e.text}`;
      }).join("");
      let error = new Error(text);
      for (const [key, value] of [["errors", errors], ["warnings", warnings]]) {
        Object.defineProperty(error, key, {
          configurable: true,
          enumerable: true,
          get: () => value,
          set: (value2) => Object.defineProperty(error, key, {
            configurable: true,
            enumerable: true,
            value: value2
          })
        });
      }
      return error;
    }
    function replaceDetailsInMessages(messages, stash) {
      for (const message of messages) {
        message.detail = stash.load(message.detail);
      }
      return messages;
    }
    function sanitizeLocation(location, where, terminalWidth) {
      if (location == null) return null;
      let keys = {};
      let file = getFlag(location, keys, "file", mustBeString);
      let namespace = getFlag(location, keys, "namespace", mustBeString);
      let line = getFlag(location, keys, "line", mustBeInteger);
      let column = getFlag(location, keys, "column", mustBeInteger);
      let length = getFlag(location, keys, "length", mustBeInteger);
      let lineText = getFlag(location, keys, "lineText", mustBeString);
      let suggestion = getFlag(location, keys, "suggestion", mustBeString);
      checkForInvalidFlags(location, keys, where);
      if (lineText) {
        const relevantASCII = lineText.slice(
          0,
          (column && column > 0 ? column : 0) + (length && length > 0 ? length : 0) + (terminalWidth && terminalWidth > 0 ? terminalWidth : 80)
        );
        if (!/[\x7F-\uFFFF]/.test(relevantASCII) && !/\n/.test(lineText)) {
          lineText = relevantASCII;
        }
      }
      return {
        file: file || "",
        namespace: namespace || "",
        line: line || 0,
        column: column || 0,
        length: length || 0,
        lineText: lineText || "",
        suggestion: suggestion || ""
      };
    }
    function sanitizeMessages(messages, property, stash, fallbackPluginName, terminalWidth) {
      let messagesClone = [];
      let index = 0;
      for (const message of messages) {
        let keys = {};
        let id = getFlag(message, keys, "id", mustBeString);
        let pluginName = getFlag(message, keys, "pluginName", mustBeString);
        let text = getFlag(message, keys, "text", mustBeString);
        let location = getFlag(message, keys, "location", mustBeObjectOrNull);
        let notes = getFlag(message, keys, "notes", mustBeArray);
        let detail = getFlag(message, keys, "detail", canBeAnything);
        let where = `in element ${index} of "${property}"`;
        checkForInvalidFlags(message, keys, where);
        let notesClone = [];
        if (notes) {
          for (const note of notes) {
            let noteKeys = {};
            let noteText = getFlag(note, noteKeys, "text", mustBeString);
            let noteLocation = getFlag(note, noteKeys, "location", mustBeObjectOrNull);
            checkForInvalidFlags(note, noteKeys, where);
            notesClone.push({
              text: noteText || "",
              location: sanitizeLocation(noteLocation, where, terminalWidth)
            });
          }
        }
        messagesClone.push({
          id: id || "",
          pluginName: pluginName || fallbackPluginName,
          text: text || "",
          location: sanitizeLocation(location, where, terminalWidth),
          notes: notesClone,
          detail: stash ? stash.store(detail) : -1
        });
        index++;
      }
      return messagesClone;
    }
    function sanitizeStringArray(values, property) {
      const result2 = [];
      for (const value of values) {
        if (typeof value !== "string") throw new Error(`${quote(property)} must be an array of strings`);
        result2.push(value);
      }
      return result2;
    }
    function sanitizeStringMap(map, property) {
      const result2 = /* @__PURE__ */ Object.create(null);
      for (const key in map) {
        const value = map[key];
        if (typeof value !== "string") throw new Error(`key ${quote(key)} in object ${quote(property)} must be a string`);
        result2[key] = value;
      }
      return result2;
    }
    function convertOutputFiles({ path: path3, contents, hash: hash3 }) {
      let text = null;
      return {
        path: path3,
        contents,
        hash: hash3,
        get text() {
          const binary = this.contents;
          if (text === null || binary !== contents) {
            contents = binary;
            text = decodeUTF8(binary);
          }
          return text;
        }
      };
    }
    function jsRegExpToGoRegExp(regexp) {
      let result2 = regexp.source;
      if (regexp.flags) result2 = `(?${regexp.flags})${result2}`;
      return result2;
    }
    var fs = __require("fs");
    var os = __require("os");
    var path = __require("path");
    var ESBUILD_BINARY_PATH = process.env.ESBUILD_BINARY_PATH || ESBUILD_BINARY_PATH;
    var isValidBinaryPath = (x) => !!x && x !== "/usr/bin/esbuild";
    var packageDarwin_arm64 = "@esbuild/darwin-arm64";
    var packageDarwin_x64 = "@esbuild/darwin-x64";
    var knownWindowsPackages = {
      "win32 arm64 LE": "@esbuild/win32-arm64",
      "win32 ia32 LE": "@esbuild/win32-ia32",
      "win32 x64 LE": "@esbuild/win32-x64"
    };
    var knownUnixlikePackages = {
      "aix ppc64 BE": "@esbuild/aix-ppc64",
      "android arm64 LE": "@esbuild/android-arm64",
      "darwin arm64 LE": "@esbuild/darwin-arm64",
      "darwin x64 LE": "@esbuild/darwin-x64",
      "freebsd arm64 LE": "@esbuild/freebsd-arm64",
      "freebsd x64 LE": "@esbuild/freebsd-x64",
      "linux arm LE": "@esbuild/linux-arm",
      "linux arm64 LE": "@esbuild/linux-arm64",
      "linux ia32 LE": "@esbuild/linux-ia32",
      "linux mips64el LE": "@esbuild/linux-mips64el",
      "linux ppc64 LE": "@esbuild/linux-ppc64",
      "linux riscv64 LE": "@esbuild/linux-riscv64",
      "linux s390x BE": "@esbuild/linux-s390x",
      "linux x64 LE": "@esbuild/linux-x64",
      "linux loong64 LE": "@esbuild/linux-loong64",
      "netbsd arm64 LE": "@esbuild/netbsd-arm64",
      "netbsd x64 LE": "@esbuild/netbsd-x64",
      "openbsd arm64 LE": "@esbuild/openbsd-arm64",
      "openbsd x64 LE": "@esbuild/openbsd-x64",
      "sunos x64 LE": "@esbuild/sunos-x64"
    };
    var knownWebAssemblyFallbackPackages = {
      "android arm LE": "@esbuild/android-arm",
      "android x64 LE": "@esbuild/android-x64",
      "openharmony arm64 LE": "@esbuild/openharmony-arm64"
    };
    function pkgAndSubpathForCurrentPlatform() {
      let pkg;
      let subpath;
      let isWASM = false;
      let platformKey = `${process.platform} ${os.arch()} ${os.endianness()}`;
      if (platformKey in knownWindowsPackages) {
        pkg = knownWindowsPackages[platformKey];
        subpath = "esbuild.exe";
      } else if (platformKey in knownUnixlikePackages) {
        pkg = knownUnixlikePackages[platformKey];
        subpath = "bin/esbuild";
      } else if (platformKey in knownWebAssemblyFallbackPackages) {
        pkg = knownWebAssemblyFallbackPackages[platformKey];
        subpath = "bin/esbuild";
        isWASM = true;
      } else {
        throw new Error(`Unsupported platform: ${platformKey}`);
      }
      return { pkg, subpath, isWASM };
    }
    function pkgForSomeOtherPlatform() {
      const libMainJS = __require.resolve("esbuild");
      const nodeModulesDirectory = path.dirname(path.dirname(path.dirname(libMainJS)));
      if (path.basename(nodeModulesDirectory) === "node_modules") {
        for (const unixKey in knownUnixlikePackages) {
          try {
            const pkg = knownUnixlikePackages[unixKey];
            if (fs.existsSync(path.join(nodeModulesDirectory, pkg))) return pkg;
          } catch {
          }
        }
        for (const windowsKey in knownWindowsPackages) {
          try {
            const pkg = knownWindowsPackages[windowsKey];
            if (fs.existsSync(path.join(nodeModulesDirectory, pkg))) return pkg;
          } catch {
          }
        }
      }
      return null;
    }
    function downloadedBinPath(pkg, subpath) {
      const esbuildLibDir = path.dirname(__require.resolve("esbuild"));
      return path.join(esbuildLibDir, `downloaded-${pkg.replace("/", "-")}-${path.basename(subpath)}`);
    }
    function generateBinPath() {
      if (isValidBinaryPath(ESBUILD_BINARY_PATH)) {
        if (!fs.existsSync(ESBUILD_BINARY_PATH)) {
          console.warn(`[esbuild] Ignoring bad configuration: ESBUILD_BINARY_PATH=${ESBUILD_BINARY_PATH}`);
        } else {
          return { binPath: ESBUILD_BINARY_PATH, isWASM: false };
        }
      }
      const { pkg, subpath, isWASM } = pkgAndSubpathForCurrentPlatform();
      let binPath;
      try {
        binPath = __require.resolve(`${pkg}/${subpath}`);
      } catch (e) {
        binPath = downloadedBinPath(pkg, subpath);
        if (!fs.existsSync(binPath)) {
          try {
            __require.resolve(pkg);
          } catch {
            const otherPkg = pkgForSomeOtherPlatform();
            if (otherPkg) {
              let suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild on Windows or macOS and copying "node_modules"
into a Docker image that runs Linux, or by copying "node_modules" between
Windows and WSL environments.

If you are installing with npm, you can try not copying the "node_modules"
directory when you copy the files over, and running "npm ci" or "npm install"
on the destination platform after the copy. Or you could consider using yarn
instead of npm which has built-in support for installing a package on multiple
platforms simultaneously.

If you are installing with yarn, you can try listing both this platform and the
other platform in your ".yarnrc.yml" file using the "supportedArchitectures"
feature: https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
              if (pkg === packageDarwin_x64 && otherPkg === packageDarwin_arm64 || pkg === packageDarwin_arm64 && otherPkg === packageDarwin_x64) {
                suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild with npm running inside of Rosetta 2 and then
trying to use it with node running outside of Rosetta 2, or vice versa (Rosetta
2 is Apple's on-the-fly x86_64-to-arm64 translation service).

If you are installing with npm, you can try ensuring that both npm and node are
not running under Rosetta 2 and then reinstalling esbuild. This likely involves
changing how you installed npm and/or node. For example, installing node with
the universal installer here should work: https://nodejs.org/en/download/. Or
you could consider using yarn instead of npm which has built-in support for
installing a package on multiple platforms simultaneously.

If you are installing with yarn, you can try listing both "arm64" and "x64"
in your ".yarnrc.yml" file using the "supportedArchitectures" feature:
https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
              }
              throw new Error(`
You installed esbuild for another platform than the one you're currently using.
This won't work because esbuild is written with native code and needs to
install a platform-specific binary executable.
${suggestions}
Another alternative is to use the "esbuild-wasm" package instead, which works
the same way on all platforms. But it comes with a heavy performance cost and
can sometimes be 10x slower than the "esbuild" package, so you may also not
want to do that.
`);
            }
            throw new Error(`The package "${pkg}" could not be found, and is needed by esbuild.

If you are installing esbuild with npm, make sure that you don't specify the
"--no-optional" or "--omit=optional" flags. The "optionalDependencies" feature
of "package.json" is used by esbuild to install the correct binary executable
for your current platform.`);
          }
          throw e;
        }
      }
      if (/\.zip\//.test(binPath)) {
        let pnpapi;
        try {
          pnpapi = __require("pnpapi");
        } catch (e) {
        }
        if (pnpapi) {
          const root = pnpapi.getPackageInformation(pnpapi.topLevel).packageLocation;
          const binTargetPath = path.join(
            root,
            "node_modules",
            ".cache",
            "esbuild",
            `pnpapi-${pkg.replace("/", "-")}-${"0.25.10"}-${path.basename(subpath)}`
          );
          if (!fs.existsSync(binTargetPath)) {
            fs.mkdirSync(path.dirname(binTargetPath), { recursive: true });
            fs.copyFileSync(binPath, binTargetPath);
            fs.chmodSync(binTargetPath, 493);
          }
          return { binPath: binTargetPath, isWASM };
        }
      }
      return { binPath, isWASM };
    }
    var child_process = __require("child_process");
    var crypto = __require("crypto");
    var path2 = __require("path");
    var fs2 = __require("fs");
    var os2 = __require("os");
    var tty = __require("tty");
    var worker_threads;
    if (process.env.ESBUILD_WORKER_THREADS !== "0") {
      try {
        worker_threads = __require("worker_threads");
      } catch {
      }
      let [major, minor] = process.versions.node.split(".");
      if (
        // <v12.17.0 does not work
        +major < 12 || +major === 12 && +minor < 17 || +major === 13 && +minor < 13
      ) {
        worker_threads = void 0;
      }
    }
    var _a5;
    var isInternalWorkerThread = ((_a5 = worker_threads == null ? void 0 : worker_threads.workerData) == null ? void 0 : _a5.esbuildVersion) === "0.25.10";
    var esbuildCommandAndArgs = () => {
      if ((!ESBUILD_BINARY_PATH || false) && (path2.basename(__filename) !== "main.js" || path2.basename(__dirname) !== "lib")) {
        throw new Error(
          `The esbuild JavaScript API cannot be bundled. Please mark the "esbuild" package as external so it's not included in the bundle.

More information: The file containing the code for esbuild's JavaScript API (${__filename}) does not appear to be inside the esbuild package on the file system, which usually means that the esbuild package was bundled into another file. This is problematic because the API needs to run a binary executable inside the esbuild package which is located using a relative path from the API code to the executable. If the esbuild package is bundled, the relative path will be incorrect and the executable won't be found.`
        );
      }
      if (false) {
        return ["node", [path2.join(__dirname, "..", "bin", "esbuild")]];
      } else {
        const { binPath, isWASM } = generateBinPath();
        if (isWASM) {
          return ["node", [binPath]];
        } else {
          return [binPath, []];
        }
      }
    };
    var isTTY = () => tty.isatty(2);
    var fsSync = {
      readFile(tempFile, callback) {
        try {
          let contents = fs2.readFileSync(tempFile, "utf8");
          try {
            fs2.unlinkSync(tempFile);
          } catch {
          }
          callback(null, contents);
        } catch (err) {
          callback(err, null);
        }
      },
      writeFile(contents, callback) {
        try {
          let tempFile = randomFileName();
          fs2.writeFileSync(tempFile, contents);
          callback(tempFile);
        } catch {
          callback(null);
        }
      }
    };
    var fsAsync = {
      readFile(tempFile, callback) {
        try {
          fs2.readFile(tempFile, "utf8", (err, contents) => {
            try {
              fs2.unlink(tempFile, () => callback(err, contents));
            } catch {
              callback(err, contents);
            }
          });
        } catch (err) {
          callback(err, null);
        }
      },
      writeFile(contents, callback) {
        try {
          let tempFile = randomFileName();
          fs2.writeFile(tempFile, contents, (err) => err !== null ? callback(null) : callback(tempFile));
        } catch {
          callback(null);
        }
      }
    };
    var version2 = "0.25.10";
    var build = (options) => ensureServiceIsRunning().build(options);
    var context = (buildOptions) => ensureServiceIsRunning().context(buildOptions);
    var transform = (input, options) => ensureServiceIsRunning().transform(input, options);
    var formatMessages = (messages, options) => ensureServiceIsRunning().formatMessages(messages, options);
    var analyzeMetafile = (messages, options) => ensureServiceIsRunning().analyzeMetafile(messages, options);
    var buildSync = (options) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.buildSync(options);
      }
      let result2;
      runServiceSync((service) => service.buildOrContext({
        callName: "buildSync",
        refs: null,
        options,
        isTTY: isTTY(),
        defaultWD,
        callback: (err, res) => {
          if (err) throw err;
          result2 = res;
        }
      }));
      return result2;
    };
    var transformSync2 = (input, options) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.transformSync(input, options);
      }
      let result2;
      runServiceSync((service) => service.transform({
        callName: "transformSync",
        refs: null,
        input,
        options: options || {},
        isTTY: isTTY(),
        fs: fsSync,
        callback: (err, res) => {
          if (err) throw err;
          result2 = res;
        }
      }));
      return result2;
    };
    var formatMessagesSync = (messages, options) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.formatMessagesSync(messages, options);
      }
      let result2;
      runServiceSync((service) => service.formatMessages({
        callName: "formatMessagesSync",
        refs: null,
        messages,
        options,
        callback: (err, res) => {
          if (err) throw err;
          result2 = res;
        }
      }));
      return result2;
    };
    var analyzeMetafileSync = (metafile, options) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.analyzeMetafileSync(metafile, options);
      }
      let result2;
      runServiceSync((service) => service.analyzeMetafile({
        callName: "analyzeMetafileSync",
        refs: null,
        metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
        options,
        callback: (err, res) => {
          if (err) throw err;
          result2 = res;
        }
      }));
      return result2;
    };
    var stop = () => {
      if (stopService) stopService();
      if (workerThreadService) workerThreadService.stop();
      return Promise.resolve();
    };
    var initializeWasCalled = false;
    var initialize = (options) => {
      options = validateInitializeOptions(options || {});
      if (options.wasmURL) throw new Error(`The "wasmURL" option only works in the browser`);
      if (options.wasmModule) throw new Error(`The "wasmModule" option only works in the browser`);
      if (options.worker) throw new Error(`The "worker" option only works in the browser`);
      if (initializeWasCalled) throw new Error('Cannot call "initialize" more than once');
      ensureServiceIsRunning();
      initializeWasCalled = true;
      return Promise.resolve();
    };
    var defaultWD = process.cwd();
    var longLivedService;
    var stopService;
    var ensureServiceIsRunning = () => {
      if (longLivedService) return longLivedService;
      let [command, args] = esbuildCommandAndArgs();
      let child = child_process.spawn(command, args.concat(`--service=${"0.25.10"}`, "--ping"), {
        windowsHide: true,
        stdio: ["pipe", "pipe", "inherit"],
        cwd: defaultWD
      });
      let { readFromStdout, afterClose, service } = createChannel({
        writeToStdin(bytes) {
          child.stdin.write(bytes, (err) => {
            if (err) afterClose(err);
          });
        },
        readFileSync: fs2.readFileSync,
        isSync: false,
        hasFS: true,
        esbuild: node_exports
      });
      child.stdin.on("error", afterClose);
      child.on("error", afterClose);
      const stdin = child.stdin;
      const stdout = child.stdout;
      stdout.on("data", readFromStdout);
      stdout.on("end", afterClose);
      stopService = () => {
        stdin.destroy();
        stdout.destroy();
        child.kill();
        initializeWasCalled = false;
        longLivedService = void 0;
        stopService = void 0;
      };
      let refCount = 0;
      child.unref();
      if (stdin.unref) {
        stdin.unref();
      }
      if (stdout.unref) {
        stdout.unref();
      }
      const refs = {
        ref() {
          if (++refCount === 1) child.ref();
        },
        unref() {
          if (--refCount === 0) child.unref();
        }
      };
      longLivedService = {
        build: (options) => new Promise((resolve, reject) => {
          service.buildOrContext({
            callName: "build",
            refs,
            options,
            isTTY: isTTY(),
            defaultWD,
            callback: (err, res) => err ? reject(err) : resolve(res)
          });
        }),
        context: (options) => new Promise((resolve, reject) => service.buildOrContext({
          callName: "context",
          refs,
          options,
          isTTY: isTTY(),
          defaultWD,
          callback: (err, res) => err ? reject(err) : resolve(res)
        })),
        transform: (input, options) => new Promise((resolve, reject) => service.transform({
          callName: "transform",
          refs,
          input,
          options: options || {},
          isTTY: isTTY(),
          fs: fsAsync,
          callback: (err, res) => err ? reject(err) : resolve(res)
        })),
        formatMessages: (messages, options) => new Promise((resolve, reject) => service.formatMessages({
          callName: "formatMessages",
          refs,
          messages,
          options,
          callback: (err, res) => err ? reject(err) : resolve(res)
        })),
        analyzeMetafile: (metafile, options) => new Promise((resolve, reject) => service.analyzeMetafile({
          callName: "analyzeMetafile",
          refs,
          metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
          options,
          callback: (err, res) => err ? reject(err) : resolve(res)
        }))
      };
      return longLivedService;
    };
    var runServiceSync = (callback) => {
      let [command, args] = esbuildCommandAndArgs();
      let stdin = new Uint8Array();
      let { readFromStdout, afterClose, service } = createChannel({
        writeToStdin(bytes) {
          if (stdin.length !== 0) throw new Error("Must run at most one command");
          stdin = bytes;
        },
        isSync: true,
        hasFS: true,
        esbuild: node_exports
      });
      callback(service);
      let stdout = child_process.execFileSync(command, args.concat(`--service=${"0.25.10"}`), {
        cwd: defaultWD,
        windowsHide: true,
        input: stdin,
        // We don't know how large the output could be. If it's too large, the
        // command will fail with ENOBUFS. Reserve 16mb for now since that feels
        // like it should be enough. Also allow overriding this with an environment
        // variable.
        maxBuffer: +process.env.ESBUILD_MAX_BUFFER || 16 * 1024 * 1024
      });
      readFromStdout(stdout);
      afterClose(null);
    };
    var randomFileName = () => {
      return path2.join(os2.tmpdir(), `esbuild-${crypto.randomBytes(32).toString("hex")}`);
    };
    var workerThreadService = null;
    var startWorkerThreadService = (worker_threads2) => {
      let { port1: mainPort, port2: workerPort } = new worker_threads2.MessageChannel();
      let worker = new worker_threads2.Worker(__filename, {
        workerData: { workerPort, defaultWD, esbuildVersion: "0.25.10" },
        transferList: [workerPort],
        // From node's documentation: https://nodejs.org/api/worker_threads.html
        //
        //   Take care when launching worker threads from preload scripts (scripts loaded
        //   and run using the `-r` command line flag). Unless the `execArgv` option is
        //   explicitly set, new Worker threads automatically inherit the command line flags
        //   from the running process and will preload the same preload scripts as the main
        //   thread. If the preload script unconditionally launches a worker thread, every
        //   thread spawned will spawn another until the application crashes.
        //
        execArgv: []
      });
      let nextID = 0;
      let fakeBuildError = (text) => {
        let error = new Error(`Build failed with 1 error:
error: ${text}`);
        let errors = [{ id: "", pluginName: "", text, location: null, notes: [], detail: void 0 }];
        error.errors = errors;
        error.warnings = [];
        return error;
      };
      let validateBuildSyncOptions = (options) => {
        if (!options) return;
        let plugins = options.plugins;
        if (plugins && plugins.length > 0) throw fakeBuildError(`Cannot use plugins in synchronous API calls`);
      };
      let applyProperties = (object, properties) => {
        for (let key in properties) {
          object[key] = properties[key];
        }
      };
      let runCallSync = (command, args) => {
        let id = nextID++;
        let sharedBuffer = new SharedArrayBuffer(8);
        let sharedBufferView = new Int32Array(sharedBuffer);
        let msg = { sharedBuffer, id, command, args };
        worker.postMessage(msg);
        let status = Atomics.wait(sharedBufferView, 0, 0);
        if (status !== "ok" && status !== "not-equal") throw new Error("Internal error: Atomics.wait() failed: " + status);
        let { message: { id: id2, resolve, reject, properties } } = worker_threads2.receiveMessageOnPort(mainPort);
        if (id !== id2) throw new Error(`Internal error: Expected id ${id} but got id ${id2}`);
        if (reject) {
          applyProperties(reject, properties);
          throw reject;
        }
        return resolve;
      };
      worker.unref();
      return {
        buildSync(options) {
          validateBuildSyncOptions(options);
          return runCallSync("build", [options]);
        },
        transformSync(input, options) {
          return runCallSync("transform", [input, options]);
        },
        formatMessagesSync(messages, options) {
          return runCallSync("formatMessages", [messages, options]);
        },
        analyzeMetafileSync(metafile, options) {
          return runCallSync("analyzeMetafile", [metafile, options]);
        },
        stop() {
          worker.terminate();
          workerThreadService = null;
        }
      };
    };
    var startSyncServiceWorker = () => {
      let workerPort = worker_threads.workerData.workerPort;
      let parentPort = worker_threads.parentPort;
      let extractProperties = (object) => {
        let properties = {};
        if (object && typeof object === "object") {
          for (let key in object) {
            properties[key] = object[key];
          }
        }
        return properties;
      };
      try {
        let service = ensureServiceIsRunning();
        defaultWD = worker_threads.workerData.defaultWD;
        parentPort.on("message", (msg) => {
          (async () => {
            let { sharedBuffer, id, command, args } = msg;
            let sharedBufferView = new Int32Array(sharedBuffer);
            try {
              switch (command) {
                case "build":
                  workerPort.postMessage({ id, resolve: await service.build(args[0]) });
                  break;
                case "transform":
                  workerPort.postMessage({ id, resolve: await service.transform(args[0], args[1]) });
                  break;
                case "formatMessages":
                  workerPort.postMessage({ id, resolve: await service.formatMessages(args[0], args[1]) });
                  break;
                case "analyzeMetafile":
                  workerPort.postMessage({ id, resolve: await service.analyzeMetafile(args[0], args[1]) });
                  break;
                default:
                  throw new Error(`Invalid command: ${command}`);
              }
            } catch (reject) {
              workerPort.postMessage({ id, reject, properties: extractProperties(reject) });
            }
            Atomics.add(sharedBufferView, 0, 1);
            Atomics.notify(sharedBufferView, 0, Infinity);
          })();
        });
      } catch (reject) {
        parentPort.on("message", (msg) => {
          let { sharedBuffer, id } = msg;
          let sharedBufferView = new Int32Array(sharedBuffer);
          workerPort.postMessage({ id, reject, properties: extractProperties(reject) });
          Atomics.add(sharedBufferView, 0, 1);
          Atomics.notify(sharedBufferView, 0, Infinity);
        });
      }
    };
    if (isInternalWorkerThread) {
      startSyncServiceWorker();
    }
    var node_default = node_exports;
  }
});

// packages/qwik/src/testing/vdom-diff.unit-util.ts
import { Fragment as Fragment2, Slot as Slot2, _getDomContainer, isSignal as isSignal2 } from "../core.mjs";
import { _isJSXNode, _isStringifiable } from "@qwik.dev/core/internal";
import { expect } from "vitest";

// packages/qwik/src/core/client/vnode.ts
import { isDev as isDev10 } from "@qwik.dev/core/build";

// packages/qwik/src/core/shared/utils/qdev.ts
var qDev = globalThis.qDev !== false;
var qInspector = globalThis.qInspector === true;
var qSerialize = globalThis.qSerialize !== false;
var qDynamicPlatform = globalThis.qDynamicPlatform !== false;
var qTest = globalThis.qTest === true;
var qRuntimeQrl = globalThis.qRuntimeQrl === true;
var seal = (obj) => {
  if (qDev) {
    Object.seal(obj);
  }
};

// packages/qwik/src/core/shared/utils/log.ts
var STYLE = qDev ? `background: #564CE0; color: white; padding: 2px 3px; border-radius: 2px; font-size: 0.8em;` : "";
var logError = (message, ...optionalParams) => {
  return createAndLogError(false, message, ...optionalParams);
};
var throwErrorAndStop = (message, ...optionalParams) => {
  const error = createAndLogError(false, message, ...optionalParams);
  debugger;
  throw error;
};
var logErrorAndStop = (message, ...optionalParams) => {
  const err = createAndLogError(qDev, message, ...optionalParams);
  debugger;
  return err;
};
var _printed = /* @__PURE__ */ new Set();
var logOnceWarn = (message, ...optionalParams) => {
  if (qDev) {
    const key = "warn" + String(message);
    if (!_printed.has(key)) {
      _printed.add(key);
      logWarn(message, ...optionalParams);
    }
  }
};
var logWarn = (message, ...optionalParams) => {
  if (qDev) {
    console.warn("%cQWIK WARN", STYLE, message, ...optionalParams);
  }
};
var createAndLogError = (asyncThrow, message, ...optionalParams) => {
  const err = message instanceof Error ? message : new Error(message);
  !qTest && console.error("%cQWIK ERROR", STYLE, err.message, ...optionalParams, err.stack);
  asyncThrow && !qTest && setTimeout(() => {
    throw err;
  }, 0);
  return err;
};

// packages/qwik/src/core/shared/error/assert.ts
var ASSERT_DISCLAIMER = "Internal assert, this is likely caused by a bug in Qwik: ";
function assertDefined(value, text, ...parts) {
  if (qDev) {
    if (value != null) {
      return;
    }
    throwErrorAndStop(ASSERT_DISCLAIMER + text, ...parts);
  }
}
function assertEqual(value1, value2, text, ...parts) {
  if (qDev) {
    if (value1 === value2) {
      return;
    }
    throwErrorAndStop(ASSERT_DISCLAIMER + text, ...parts);
  }
}
function assertTrue(value1, text, ...parts) {
  if (qDev) {
    if (value1 === true) {
      return;
    }
    throwErrorAndStop(ASSERT_DISCLAIMER + text, ...parts);
  }
}
function assertFalse(value1, text, ...parts) {
  if (qDev) {
    if (value1 === false) {
      return;
    }
    throwErrorAndStop(ASSERT_DISCLAIMER + text, ...parts);
  }
}
function assertNumber(value1, text, ...parts) {
  if (qDev) {
    if (typeof value1 === "number") {
      return;
    }
    throwErrorAndStop(ASSERT_DISCLAIMER + text, ...parts);
  }
}

// packages/qwik/src/core/shared/utils/types.ts
var isSerializableObject = (v) => {
  const proto = Object.getPrototypeOf(v);
  return proto === Object.prototype || proto === Array.prototype || proto === null;
};
var isObject = (v) => {
  return typeof v === "object" && v !== null;
};
var isArray = (v) => {
  return Array.isArray(v);
};
var isString = (v) => {
  return typeof v === "string";
};
var isNumber = (v) => {
  return typeof v === "number";
};
var isFunction = (v) => {
  return typeof v === "function";
};
var isPrimitive = (v) => {
  return typeof v !== "object" && typeof v !== "function" && v !== null && v !== void 0;
};

// packages/qwik/src/core/shared/error/error.ts
var codeToText = (code2, ...parts) => {
  if (qDev) {
    const MAP = [
      "Error while serializing class or style attributes",
      // 0
      "Scheduler not found",
      // 1
      "track() received object, without prop to track",
      // 2
      "Only primitive and object literals can be serialized. {{0}}",
      // 3
      "You can render over a existing q:container. Skipping render().",
      // 4
      "QRL is not a function",
      // 5
      "Dynamic import not found",
      // 6
      "Unknown type argument",
      // 7
      `Actual value for useContext({{0}}) can not be found, make sure some ancestor component has set a value using useContextProvider(). In the browser make sure that the context was used during SSR so its state was serialized.`,
      // 8
      "Invoking 'use*()' method outside of invocation context.",
      // 9
      `Calling a 'use*()' method outside 'component$(() => { HERE })' is not allowed. 'use*()' methods provide hooks to the 'component$' state and lifecycle, ie 'use' hooks can only be called synchronously within the 'component$' function or another 'use' method.
See https://qwik.dev/docs/core/tasks/#use-method-rules`,
      // 10
      'The provided Context reference "{{0}}" is not a valid context created by createContextId()',
      // 11
      "SsrError(tag): {{0}}",
      // 12
      "QRLs can not be resolved because it does not have an attached container. This means that the QRL does not know where it belongs inside the DOM, so it cant dynamically import() from a relative path.",
      // 13
      "QRLs can not be dynamically resolved, because it does not have a chunk path",
      // 14
      "{{0}}\nThe JSX ref attribute must be a Signal",
      // 15
      "Serialization Error: Deserialization of data type {{0}} is not implemented",
      // 16
      "Serialization Error: Expected vnode for ref prop, but got {{0}}",
      // 17
      "Serialization Error: Cannot allocate data type {{0}}",
      // 18
      "Serialization Error: Missing root id for {{0}}",
      // 19
      "Serialization Error: Serialization of data type {{0}} is not implemented",
      // 20
      "Serialization Error: Unvisited {{0}}",
      // 21
      "Serialization Error: Missing QRL chunk for {{0}}",
      // 22
      "{{0}}\nThe value of the textarea must be a string found {{1}}",
      // 23
      "Unable to find q:container",
      // 24
      "Element must have 'q:container' attribute.",
      // 25
      "Unknown vnode type {{0}}.",
      // 26
      "Materialize error: missing element: {{0}} {{1}} {{2}}",
      // 27
      "Cannot coerce a Signal, use `.value` instead",
      // 28
      "useComputed$ QRL {{0}} {{1}} cannot return a Promise",
      // 29
      "ComputedSignal is read-only",
      // 30
      "WrappedSignal is read-only",
      // 31
      "Attribute value is unsafe for SSR",
      // 32
      "SerializerSymbol function returned rejected promise",
      // 33
      "Serialization Error: Cannot serialize function: {{0}}"
      // 34
    ];
    let text = MAP[code2] ?? "";
    if (parts.length) {
      text = text.replaceAll(/{{(\d+)}}/g, (_, index) => {
        let v = parts[index];
        if (v && isObject(v) && v.constructor === Object) {
          v = JSON.stringify(v).slice(0, 50);
        }
        return v;
      });
    }
    return `Code(Q${code2}): ${text}`;
  } else {
    return `Code(Q${code2}) https://github.com/QwikDev/qwik/blob/main/packages/qwik/src/core/error/error.ts#L${8 + code2}`;
  }
};
var qError = (code2, errorMessageArgs = []) => {
  const text = codeToText(code2, ...errorMessageArgs);
  return logErrorAndStop(text, ...errorMessageArgs);
};

// packages/qwik/src/core/shared/utils/element.ts
var isNode = (value) => {
  return value && typeof value.nodeType === "number";
};

// packages/qwik/src/core/shared/utils/promises.ts
import { isDev, isServer } from "@qwik.dev/core/build";
var MAX_RETRY_ON_PROMISE_COUNT = 100;
var isPromise = (value) => {
  return !!value && typeof value == "object" && typeof value.then === "function";
};
var safeCall = (call, thenFn, rejectFn) => {
  try {
    const result2 = call();
    if (isPromise(result2)) {
      return result2.then(thenFn, rejectFn);
    } else {
      return thenFn(result2);
    }
  } catch (e) {
    return rejectFn(e);
  }
};
var maybeThen = (valueOrPromise, thenFn) => {
  return isPromise(valueOrPromise) ? valueOrPromise.then(thenFn, shouldNotError) : thenFn(valueOrPromise);
};
var shouldNotError = (reason) => {
  throwErrorAndStop(reason);
};
var delay = (timeout) => {
  return new Promise((resolve) => {
    setTimeout(resolve, timeout);
  });
};
function retryOnPromise(fn, retryCount = 0) {
  const retryOrThrow = (e) => {
    if (isPromise(e) && retryCount < MAX_RETRY_ON_PROMISE_COUNT) {
      return e.then(retryOnPromise.bind(null, fn, retryCount++));
    }
    throw e;
  };
  try {
    const result2 = fn();
    if (isPromise(result2)) {
      return result2.catch((e) => retryOrThrow(e));
    }
    return result2;
  } catch (e) {
    if (isDev && isServer && e instanceof ReferenceError && e.message.includes("window")) {
      e.message = 'It seems like you forgot to add "if (isBrowser) {...}" here:' + e.message;
      throw e;
    }
    return retryOrThrow(e);
  }
}

// packages/qwik/src/core/shared/types.ts
var DEBUG_TYPE = "q:type";
var VirtualTypeName = {
  ["V" /* Virtual */]: (
    /* ********* */
    "Virtual"
  ),
  //
  ["F" /* Fragment */]: (
    /* ******** */
    "Fragment"
  ),
  //
  ["S" /* WrappedSignal */]: (
    /* *** */
    "Signal"
  ),
  //
  ["A" /* Awaited */]: (
    /* ********* */
    "Awaited"
  ),
  //
  ["C" /* Component */]: (
    /* ******* */
    "Component"
  ),
  //
  ["I" /* InlineComponent */]: (
    /* * */
    "InlineComponent"
  ),
  //
  ["P" /* Projection */]: (
    /* ****** */
    "Projection"
  )
  //
};

// packages/qwik/src/core/shared/utils/markers.ts
var OnRenderProp = "q:renderFn";
var ComponentStylesPrefixContent = "\u26A1\uFE0F";
var QSlot = "q:slot";
var QSlotParent = "q:sparent";
var QSlotS = "q:s";
var QStyle = "q:style";
var QStyleSelector = "style[q\\:style]";
var QStyleSSelector = "style[q\\:sstyle]";
var QStylesAllSelector = QStyleSelector + "," + QStyleSSelector;
var QScopedStyle = "q:sstyle";
var QCtxAttr = "q:ctx";
var QBackRefs = "q:brefs";
var QFuncsPrefix = "qFuncs_";
var getQFuncs = (document2, hash3) => {
  return document2[QFuncsPrefix + hash3] || [];
};
var QRenderAttr = "q:render";
var QRuntimeAttr = "q:runtime";
var QVersionAttr = "q:version";
var QBaseAttr = "q:base";
var QLocaleAttr = "q:locale";
var QManifestHashAttr = "q:manifest-hash";
var QInstanceAttr = "q:instance";
var QContainerIsland = "q:container-island";
var QContainerIslandEnd = "/" + QContainerIsland;
var QIgnore = "q:ignore";
var QIgnoreEnd = "/" + QIgnore;
var QContainerAttr = "q:container";
var QContainerAttrEnd = "/" + QContainerAttr;
var QTemplate = "q:template";
var QContainerSelector = "[q\\:container]:not([q\\:container=" + "html" /* HTML */ + "]):not([q\\:container=" + "text" /* TEXT */ + "])";
var HTML_NS = "http://www.w3.org/1999/xhtml";
var SVG_NS = "http://www.w3.org/2000/svg";
var MATH_NS = "http://www.w3.org/1998/Math/MathML";
var XLINK_NS = "http://www.w3.org/1999/xlink";
var XML_NS = "http://www.w3.org/XML/1998/namespace";
var ResourceEvent = "qResource";
var RenderEvent = "qRender";
var TaskEvent = "qTask";
var QDefaultSlot = "";
var ELEMENT_ID = "q:id";
var ELEMENT_KEY = "q:key";
var ELEMENT_PROPS = "q:props";
var ELEMENT_SEQ = "q:seq";
var ELEMENT_SEQ_IDX = "q:seqIdx";
var ELEMENT_BACKPATCH_DATA = "qwik/backpatch";
var Q_PREFIX = "q:";
var NON_SERIALIZABLE_MARKER_PREFIX = ":";
var USE_ON_LOCAL = NON_SERIALIZABLE_MARKER_PREFIX + "on";
var USE_ON_LOCAL_SEQ_IDX = NON_SERIALIZABLE_MARKER_PREFIX + "onIdx";
var USE_ON_LOCAL_FLAGS = NON_SERIALIZABLE_MARKER_PREFIX + "onFlags";
var FLUSH_COMMENT = "qkssr-f";
var STREAM_BLOCK_START_COMMENT = "qkssr-pu";
var STREAM_BLOCK_END_COMMENT = "qkssr-po";
var Q_PROPS_SEPARATOR = ":";
var dangerouslySetInnerHTML = "dangerouslySetInnerHTML";

// packages/qwik/src/core/use/use-locale.ts
import { isServer as isServer2 } from "@qwik.dev/core/build";
var _locale = void 0;
var localAsyncStore;
if (isServer2) {
  import("node:async_hooks").then((module) => {
    localAsyncStore = new module.AsyncLocalStorage();
  }).catch(() => {
  });
}
function setLocale(locale) {
  if (localAsyncStore) {
    localAsyncStore.enterWith(locale);
    return;
  }
  _locale = locale;
}

// packages/qwik/src/core/reactive-primitives/types.ts
var NEEDS_COMPUTATION = Symbol("invalid");
var _EFFECT_BACK_REF = Symbol("backRef");
var STORE_TARGET = Symbol("store.target");
var STORE_HANDLER = Symbol("store.handler");
var STORE_ALL_PROPS = Symbol("store.all");

// packages/qwik/src/core/shared/utils/constants.ts
var _CONST_PROPS = Symbol("CONST");
var _VAR_PROPS = Symbol("VAR");
var _OWNER = Symbol("OWNER");
var _IMMUTABLE = Symbol("IMMUTABLE");
var _UNINITIALIZED = Symbol("UNINITIALIZED");

// packages/qwik/src/core/shared/utils/event-names.ts
var EVENT_SUFFIX = "$";
var isJsxPropertyAnEventName = (name) => {
  return name.endsWith(EVENT_SUFFIX) && (name.startsWith("on" /* on */) || name.startsWith("window:on" /* window */) || name.startsWith("document:on" /* document */));
};
var isHtmlAttributeAnEventName = (name) => {
  return name.startsWith("on:" /* on */) || name.startsWith("on-window:" /* window */) || name.startsWith("on-document:" /* document */);
};
function jsxEventToHtmlAttribute(jsxEvent) {
  if (jsxEvent.endsWith(EVENT_SUFFIX)) {
    const [prefix, idx] = getEventScopeDataFromJsxEvent(jsxEvent);
    if (idx !== -1) {
      const name = jsxEvent.slice(idx, -1);
      return name === "DOMContentLoaded" ? (
        // The only DOM event that is not all lowercase
        prefix + "-d-o-m-content-loaded"
      ) : createEventName(
        name.charAt(0) === "-" ? (
          // marker for case sensitive event name
          name.slice(1)
        ) : name.toLowerCase(),
        prefix
      );
    }
  }
  return null;
}
function createEventName(event, prefix) {
  const eventName = fromCamelToKebabCase(event);
  return prefix + eventName;
}
function getEventScopeDataFromJsxEvent(eventName) {
  let prefix = "on:" /* on */;
  let idx = -1;
  if (eventName.startsWith("on" /* on */)) {
    prefix = "on:" /* on */;
    idx = 2;
  } else if (eventName.startsWith("window:on" /* window */)) {
    prefix = "on-window:" /* window */;
    idx = 9;
  } else if (eventName.startsWith("document:on" /* document */)) {
    prefix = "on-document:" /* document */;
    idx = 11;
  }
  return [prefix, idx];
}
function isPreventDefault(key) {
  return key.startsWith("preventdefault:");
}
var fromCamelToKebabCase = (text) => {
  return text.replace(/([A-Z-])/g, (a) => "-" + a.toLowerCase());
};
var getEventDataFromHtmlAttribute = (htmlKey) => {
  if (htmlKey.startsWith("on:" /* on */)) {
    return ["", htmlKey.substring(3)];
  }
  if (htmlKey.startsWith("on-window:" /* window */)) {
    return ["window", htmlKey.substring(10)];
  }
  return ["document", htmlKey.substring(12)];
};

// packages/qwik/src/core/shared/utils/flyweight.ts
var EMPTY_ARRAY = [];
var EMPTY_OBJ = {};
Object.freeze(EMPTY_ARRAY);
Object.freeze(EMPTY_OBJ);

// packages/qwik/src/core/shared/jsx/props-proxy.ts
function createPropsProxy(owner) {
  return new Proxy({}, new PropsProxyHandler(owner));
}
var PropsProxyHandler = class {
  constructor(owner) {
    this.owner = owner;
  }
  get(_, prop) {
    if (prop === _CONST_PROPS) {
      return this.owner.constProps;
    }
    if (prop === _VAR_PROPS) {
      return this.owner.varProps;
    }
    if (prop === _OWNER) {
      return this.owner;
    }
    let value;
    if (prop === "children") {
      value = this.owner.children;
    } else {
      if (typeof prop === "string" && typeof this.owner.type === "string") {
        const attr = jsxEventToHtmlAttribute(prop);
        if (attr) {
          prop = attr;
        }
      }
      value = directGetPropsProxyProp(this.owner, prop);
    }
    return value instanceof WrappedSignalImpl && value.$flags$ & 4 /* UNWRAP */ ? value.value : value;
  }
  set(_, prop, value) {
    if (prop === _OWNER) {
      this.owner = value;
    } else if (prop === "children") {
      this.owner.children = value;
    } else {
      if (typeof prop === "string" && typeof this.owner.type === "string") {
        const attr = jsxEventToHtmlAttribute(prop);
        if (attr) {
          prop = attr;
        }
      }
      if (this.owner.constProps && prop in this.owner.constProps) {
        this.owner.constProps[prop] = void 0;
        if (!(prop in this.owner.varProps)) {
          this.owner.toSort = true;
        }
        this.owner.varProps[prop] = value;
      } else {
        if (this.owner.varProps === EMPTY_OBJ) {
          this.owner.varProps = {};
        } else {
          if (!(prop in this.owner.varProps)) {
            this.owner.toSort = true;
          }
        }
        this.owner.varProps[prop] = value;
      }
    }
    return true;
  }
  deleteProperty(_, prop) {
    let didDelete = delete this.owner.varProps[prop];
    if (this.owner.constProps) {
      didDelete = delete this.owner.constProps[prop] || didDelete;
    }
    if (this.owner.children != null && prop === "children") {
      this.owner.children = null;
      didDelete = true;
    }
    return didDelete;
  }
  has(_, prop) {
    if (prop === "children") {
      return this.owner.children != null;
    } else if (prop === _CONST_PROPS || prop === _VAR_PROPS) {
      return true;
    }
    if (typeof prop === "string" && typeof this.owner.type === "string") {
      const attr = jsxEventToHtmlAttribute(prop);
      if (attr) {
        prop = attr;
      }
    }
    return prop in this.owner.varProps || (this.owner.constProps ? prop in this.owner.constProps : false);
  }
  getOwnPropertyDescriptor(_, p) {
    const value = p === "children" ? this.owner.children : this.owner.constProps && p in this.owner.constProps ? this.owner.constProps[p] : this.owner.varProps[p];
    return {
      configurable: true,
      enumerable: true,
      value
    };
  }
  ownKeys() {
    const out = Object.keys(this.owner.varProps);
    if (this.owner.children != null) {
      out.push("children");
    }
    if (this.owner.constProps) {
      for (const key in this.owner.constProps) {
        if (out.indexOf(key) === -1) {
          out.push(key);
        }
      }
    }
    return out;
  }
};
var directGetPropsProxyProp = (jsx2, prop) => {
  return jsx2.constProps && prop in jsx2.constProps ? jsx2.constProps[prop] : jsx2.varProps[prop];
};
var isPropsProxy = (obj) => {
  return obj && _VAR_PROPS in obj;
};

// packages/qwik/src/core/reactive-primitives/subscriber.ts
import { isServer as isServer3 } from "@qwik.dev/core/build";
function getSubscriber(effect, prop, data) {
  if (!effect[_EFFECT_BACK_REF]) {
    if (isServer3 && isSsrNode(effect)) {
      effect.setProp(QBackRefs, /* @__PURE__ */ new Map());
    } else {
      effect[_EFFECT_BACK_REF] = /* @__PURE__ */ new Map();
    }
  }
  const subMap = effect[_EFFECT_BACK_REF];
  let sub = subMap.get(prop);
  if (!sub) {
    sub = [effect, prop];
    subMap.set(prop, sub);
  }
  if (data) {
    sub[3 /* DATA */] = data;
  }
  return sub;
}
function isSsrNode(value) {
  return "__brand__" in value && value.__brand__ === "SsrNode";
}

// packages/qwik/src/core/use/utils/tracker.ts
var trackFn = (target, container) => (obj, prop) => {
  const ctx = newInvokeContext();
  ctx.$effectSubscriber$ = getSubscriber(target, ":" /* COMPONENT */);
  ctx.$container$ = container || void 0;
  return invoke(ctx, () => {
    if (isFunction(obj)) {
      return obj();
    }
    if (prop) {
      return obj[prop];
    } else if (isSignal(obj)) {
      return obj.value;
    } else if (isObject(obj) && isStore(obj)) {
      addStoreEffect(
        getStoreTarget(obj),
        STORE_ALL_PROPS,
        getStoreHandler(obj),
        ctx.$effectSubscriber$
      );
      return obj;
    } else {
      throw qError(2 /* trackObjectWithoutProp */);
    }
  });
};
var cleanupFn = (target, handleError) => {
  let cleanupFns = null;
  const cleanup2 = (fn) => {
    if (typeof fn == "function") {
      if (!cleanupFns) {
        cleanupFns = [];
        target.$destroy$ = noSerialize(() => {
          target.$destroy$ = null;
          cleanupFns.forEach((fn2) => {
            try {
              fn2();
            } catch (err) {
              handleError(err);
            }
          });
        });
      }
      cleanupFns.push(fn);
    }
  };
  return [cleanup2, cleanupFns ?? []];
};

// packages/qwik/src/core/reactive-primitives/impl/signal-impl.ts
import { isDev as isDev2 } from "@qwik.dev/core/build";
var DEBUG = false;
var log = (...args) => console.log("SIGNAL", ...args.map(qwikDebugToString));
var SignalImpl = class {
  constructor(container, value) {
    __publicField(this, "$untrackedValue$");
    /** Store a list of effects which are dependent on this signal. */
    __publicField(this, "$effects$", null);
    __publicField(this, "$container$", null);
    __publicField(this, "$wrappedSignal$", null);
    this.$container$ = container;
    this.$untrackedValue$ = value;
    DEBUG && log("new", this);
  }
  /**
   * Use this to force running subscribers, for example when the calculated value has mutated but
   * remained the same object
   */
  force() {
    this.$container$?.$scheduler$(
      7 /* RECOMPUTE_AND_SCHEDULE_EFFECTS */,
      null,
      this,
      this.$effects$
    );
  }
  get untrackedValue() {
    return this.$untrackedValue$;
  }
  // TODO: should we disallow setting the value directly?
  set untrackedValue(value) {
    this.$untrackedValue$ = value;
  }
  get value() {
    return setupSignalValueAccess(
      this,
      () => this.$effects$ || (this.$effects$ = /* @__PURE__ */ new Set()),
      () => this.untrackedValue
    );
  }
  set value(value) {
    if (value !== this.$untrackedValue$) {
      DEBUG && log("Signal.set", this.$untrackedValue$, "->", value, pad("\n" + this.toString(), "  "));
      this.$untrackedValue$ = value;
      this.$container$?.$scheduler$(
        7 /* RECOMPUTE_AND_SCHEDULE_EFFECTS */,
        null,
        this,
        this.$effects$
      );
    }
  }
  // prevent accidental use as value
  valueOf() {
    if (qDev) {
      throw qError(28 /* cannotCoerceSignal */);
    }
  }
  toString() {
    if (isDev2) {
      return `[${this.constructor.name}${this.$flags$ & 1 /* INVALID */ ? " INVALID" : ""} ${String(this.$untrackedValue$)}]` + (Array.from(this.$effects$ || []).map((e) => "\n -> " + pad(qwikDebugToString(e[0]), "    ")).join("\n") || "");
    } else {
      return this.constructor.name;
    }
  }
  toJSON() {
    return { value: this.$untrackedValue$ };
  }
};
var addEffect = (signal, effectSubscriber, effects) => {
  ensureContainsSubscription(effects, effectSubscriber);
  ensureContainsBackRef(effectSubscriber, signal);
  addQrlToSerializationCtx(effectSubscriber, signal.$container$);
};
var setupSignalValueAccess = (target, effectsFn, returnValueFn) => {
  const ctx = tryGetInvokeContext();
  if (ctx) {
    if (target.$container$ === null) {
      if (!ctx.$container$) {
        return returnValueFn();
      }
      target.$container$ = ctx.$container$;
    } else {
      assertTrue(
        !ctx.$container$ || ctx.$container$ === target.$container$,
        "Do not use signals across containers"
      );
    }
    const effectSubscriber = ctx.$effectSubscriber$;
    if (effectSubscriber) {
      addEffect(target, effectSubscriber, effectsFn());
      DEBUG && log("read->sub", pad("\n" + target.toString(), "  "));
    }
  }
  return returnValueFn();
};

// packages/qwik/src/core/reactive-primitives/impl/computed-signal-impl.ts
var DEBUG2 = false;
var log2 = (...args) => console.log("COMPUTED SIGNAL", ...args.map(qwikDebugToString));
var _a, _b;
var ComputedSignalImpl = class extends (_b = SignalImpl, _a = _EFFECT_BACK_REF, _b) {
  constructor(container, fn, flags = 1 /* INVALID */ | 32 /* SERIALIZATION_STRATEGY_ALWAYS */) {
    super(container, NEEDS_COMPUTATION);
    /**
     * The compute function is stored here.
     *
     * The computed functions must be executed synchronously (because of this we need to eagerly
     * resolve the QRL during the mark dirty phase so that any call to it will be synchronous). )
     */
    __publicField(this, "$computeQrl$");
    __publicField(this, "$flags$");
    __publicField(this, _a, null);
    this.$computeQrl$ = fn;
    this.$flags$ = flags;
  }
  invalidate() {
    this.$flags$ |= 1 /* INVALID */;
    this.$container$?.$scheduler$(
      7 /* RECOMPUTE_AND_SCHEDULE_EFFECTS */,
      null,
      this,
      this.$effects$
    );
  }
  /**
   * Use this to force running subscribers, for example when the calculated value has mutated but
   * remained the same object
   */
  force() {
    this.$flags$ |= 2 /* RUN_EFFECTS */;
    super.force();
  }
  get untrackedValue() {
    this.$computeIfNeeded$();
    assertFalse(this.$untrackedValue$ === NEEDS_COMPUTATION, "Invalid state");
    return this.$untrackedValue$;
  }
  $computeIfNeeded$() {
    if (!(this.$flags$ & 1 /* INVALID */)) {
      return;
    }
    const computeQrl = this.$computeQrl$;
    throwIfQRLNotResolved(computeQrl);
    const ctx = tryGetInvokeContext();
    const previousEffectSubscription = ctx?.$effectSubscriber$;
    ctx && (ctx.$effectSubscriber$ = getSubscriber(this, "." /* VNODE */));
    try {
      const untrackedValue = computeQrl.getFn(ctx)();
      if (isPromise(untrackedValue)) {
        throw qError(29 /* computedNotSync */, [
          computeQrl.dev ? computeQrl.dev.file : "",
          computeQrl.$hash$
        ]);
      }
      DEBUG2 && log2("Signal.$compute$", untrackedValue);
      this.$flags$ &= ~1 /* INVALID */;
      const didChange = untrackedValue !== this.$untrackedValue$;
      if (didChange) {
        if (this.$untrackedValue$ !== NEEDS_COMPUTATION) {
          this.$flags$ |= 2 /* RUN_EFFECTS */;
        }
        this.$untrackedValue$ = untrackedValue;
      }
    } finally {
      if (ctx) {
        ctx.$effectSubscriber$ = previousEffectSubscription;
      }
    }
  }
  // Make this signal read-only
  set value(_) {
    throw qError(30 /* computedReadOnly */);
  }
  // Getters don't get inherited when overriding a setter
  get value() {
    return super.value;
  }
};

// packages/qwik/src/core/reactive-primitives/impl/async-computed-signal-impl.ts
var DEBUG3 = false;
var log3 = (...args) => (
  // eslint-disable-next-line no-console
  console.log("ASYNC COMPUTED SIGNAL", ...args.map(qwikDebugToString))
);
var _a2, _b2;
var AsyncComputedSignalImpl = class extends (_b2 = ComputedSignalImpl, _a2 = _EFFECT_BACK_REF, _b2) {
  constructor(container, fn, flags = 1 /* INVALID */) {
    super(container, fn, flags);
    __publicField(this, "$untrackedLoading$", false);
    __publicField(this, "$untrackedError$", null);
    __publicField(this, "$loadingEffects$", null);
    __publicField(this, "$errorEffects$", null);
    __publicField(this, "$destroy$");
    __publicField(this, "$promiseValue$", NEEDS_COMPUTATION);
    __publicField(this, _a2, null);
  }
  /**
   * Loading is true if the signal is still waiting for the promise to resolve, false if the promise
   * has resolved or rejected.
   */
  get loading() {
    return setupSignalValueAccess(
      this,
      () => this.$loadingEffects$ || (this.$loadingEffects$ = /* @__PURE__ */ new Set()),
      () => this.untrackedLoading
    );
  }
  set untrackedLoading(value) {
    if (value !== this.$untrackedLoading$) {
      this.$untrackedLoading$ = value;
      this.$container$?.$scheduler$(
        7 /* RECOMPUTE_AND_SCHEDULE_EFFECTS */,
        null,
        this,
        this.$loadingEffects$
      );
    }
  }
  get untrackedLoading() {
    return this.$untrackedLoading$;
  }
  /** The error that occurred when the signal was resolved. */
  get error() {
    return setupSignalValueAccess(
      this,
      () => this.$errorEffects$ || (this.$errorEffects$ = /* @__PURE__ */ new Set()),
      () => this.untrackedError
    );
  }
  set untrackedError(value) {
    if (value !== this.$untrackedError$) {
      this.$untrackedError$ = value;
      this.$container$?.$scheduler$(
        7 /* RECOMPUTE_AND_SCHEDULE_EFFECTS */,
        null,
        this,
        this.$errorEffects$
      );
    }
  }
  get untrackedError() {
    return this.$untrackedError$;
  }
  invalidate() {
    super.invalidate();
    this.$promiseValue$ = NEEDS_COMPUTATION;
  }
  async resolve() {
    await retryOnPromise(() => this.$computeIfNeeded$());
    return this.$untrackedValue$;
  }
  $computeIfNeeded$() {
    if (!(this.$flags$ & 1 /* INVALID */)) {
      return;
    }
    const [cleanup2] = cleanupFn(this, (err) => this.$container$?.handleError(err, null));
    const untrackedValue = this.$promiseValue$ === NEEDS_COMPUTATION ? this.$computeQrl$.getFn()({
      track: trackFn(this, this.$container$),
      cleanup: cleanup2
    }) : this.$promiseValue$;
    if (isPromise(untrackedValue)) {
      this.untrackedLoading = true;
      this.untrackedError = null;
      throw untrackedValue.then((promiseValue) => {
        this.$promiseValue$ = promiseValue;
        this.untrackedLoading = false;
        this.untrackedError = null;
      }).catch((err) => {
        this.$promiseValue$ = err;
        this.untrackedLoading = false;
        this.untrackedError = err;
      });
    }
    this.$promiseValue$ = NEEDS_COMPUTATION;
    DEBUG3 && log3("Signal.$asyncCompute$", untrackedValue);
    this.$flags$ &= ~1 /* INVALID */;
    const didChange = untrackedValue !== this.$untrackedValue$;
    if (didChange) {
      this.$flags$ |= 2 /* RUN_EFFECTS */;
      this.$untrackedValue$ = untrackedValue;
    }
    return didChange;
  }
};

// packages/qwik/src/core/shared/platform/platform.ts
import { isServer as isServer4 } from "@qwik.dev/core/build";

// packages/qwik/src/core/shared/qrl/qrl-utils.ts
import { isDev as isDev3 } from "@qwik.dev/core/build";
var SYNC_QRL = "<sync>";
var isSyncQrl = (value) => {
  return isQrl(value) && value.$symbol$ == SYNC_QRL;
};
var isQrl = (value) => {
  return typeof value === "function" && typeof value.getSymbol === "function";
};
function assertQrl(qrl) {
  if (isDev3) {
    if (!isQrl(qrl)) {
      throw new Error("Not a QRL");
    }
  }
}
var getSymbolHash = (symbolName) => {
  const index = symbolName.lastIndexOf("_");
  if (index > -1) {
    return symbolName.slice(index + 1);
  }
  return symbolName;
};

// packages/qwik/src/core/shared/platform/platform.ts
var createPlatform = () => {
  return {
    isServer: isServer4,
    importSymbol(containerEl, url, symbolName) {
      if (isServer4) {
        const hash3 = getSymbolHash(symbolName);
        const regSym = globalThis.__qwik_reg_symbols?.get(hash3);
        if (regSym) {
          return regSym;
        }
      }
      if (!url) {
        throw qError(14 /* qrlMissingChunk */, [symbolName]);
      }
      if (!containerEl) {
        throw qError(13 /* qrlMissingContainer */, [url, symbolName]);
      }
      const urlDoc = toUrl(containerEl.ownerDocument, containerEl, url).toString();
      const urlCopy = new URL(urlDoc);
      urlCopy.hash = "";
      const importURL = urlCopy.href;
      return import(
        /* @vite-ignore */
        importURL
      ).then((mod) => {
        return mod[symbolName];
      });
    },
    raf: (fn) => {
      return new Promise((resolve) => {
        requestAnimationFrame(() => {
          resolve(fn());
        });
      });
    },
    chunkForSymbol(symbolName, chunk) {
      return [symbolName, chunk ?? "_"];
    }
  };
};
var toUrl = (doc2, containerEl, url) => {
  const baseURI = doc2.baseURI;
  const base2 = new URL(containerEl.getAttribute(QBaseAttr) ?? baseURI, baseURI);
  return new URL(url, base2);
};
var _platform = /* @__PURE__ */ createPlatform();
var setPlatform = (plt) => _platform = plt;
var getPlatform = () => {
  return _platform;
};
var isServerPlatform = () => {
  if (qDynamicPlatform) {
    return _platform.isServer;
  }
  return false;
};

// packages/qwik/src/core/shared/qrl/qrl-class.ts
import { isBrowser } from "@qwik.dev/core/build";
import { p as preload } from "@qwik.dev/core/preloader";
var resolvedSymbol = Symbol("resolved");
var createQRL = (chunk, symbol, symbolRef, symbolFn, capture, captureRef) => {
  if (qDev && qSerialize) {
    if (captureRef) {
      for (const item of captureRef) {
        verifySerializable(item, "Captured variable in the closure can not be serialized");
      }
    }
  }
  let _containerEl;
  const qrl = async function(...args) {
    const boundedFn = bindFnToContext.call(this, tryGetInvokeContext());
    const result2 = await boundedFn(...args);
    return result2;
  };
  const setContainer = (el) => {
    if (!_containerEl) {
      _containerEl = el;
    }
    return _containerEl;
  };
  function bindFnToContext(currentCtx, beforeFn) {
    const bound = (...args) => {
      if (!qrl.resolved) {
        return qrl.resolve().then((fn) => {
          if (!isFunction(fn)) {
            throw qError(5 /* qrlIsNotFunction */);
          }
          return bound(...args);
        });
      }
      if (beforeFn && beforeFn() === false) {
        return;
      }
      const context = createOrReuseInvocationContext(currentCtx);
      const prevQrl = context.$qrl$;
      const prevEvent = context.$event$;
      context.$qrl$ = qrl;
      context.$event$ || (context.$event$ = this);
      try {
        return invoke.call(this, context, symbolRef, ...args);
      } finally {
        context.$qrl$ = prevQrl;
        context.$event$ = prevEvent;
      }
    };
    return bound;
  }
  const wrapFn = (fn) => {
    if (typeof fn !== "function" || !capture?.length && !captureRef?.length) {
      return fn;
    }
    return function(...args) {
      let context = tryGetInvokeContext();
      if (context) {
        if (context.$qrl$?.$symbol$ === qrl.$symbol$) {
          return fn.apply(this, args);
        }
        const prevQrl = context.$qrl$;
        context.$qrl$ = qrl;
        try {
          return fn.apply(this, args);
        } finally {
          context.$qrl$ = prevQrl;
        }
      }
      context = newInvokeContext();
      context.$qrl$ = qrl;
      context.$event$ = this;
      return invoke.call(this, context, fn, ...args);
    };
  };
  if (symbolFn && resolvedSymbol in symbolFn) {
    symbolRef = symbolFn[resolvedSymbol];
  }
  const resolve = symbolRef ? async () => symbolRef : async (containerEl) => {
    if (symbolRef !== null) {
      return symbolRef;
    }
    if (containerEl) {
      setContainer(containerEl);
    }
    if (chunk === "") {
      assertDefined(_containerEl, "Sync QRL must have container element");
      const hash4 = _containerEl.getAttribute(QInstanceAttr);
      const doc2 = _containerEl.ownerDocument;
      const qFuncs2 = getQFuncs(doc2, hash4);
      return qrl.resolved = symbolRef = qFuncs2[Number(symbol)];
    }
    if (isBrowser && chunk) {
      preload(chunk, 1);
    }
    const start = now();
    const ctx = tryGetInvokeContext();
    if (symbolFn !== null) {
      symbolRef = symbolFn().then((module) => {
        const resolved = wrapFn(symbolRef = module[symbol]);
        symbolFn[resolvedSymbol] = resolved;
        qrl.resolved = resolved;
        return resolved;
      });
    } else {
      const imported = getPlatform().importSymbol(_containerEl, chunk, symbol);
      symbolRef = maybeThen(imported, (ref) => qrl.resolved = wrapFn(symbolRef = ref));
    }
    if (isPromise(symbolRef)) {
      symbolRef.then(
        () => emitUsedSymbol(symbol, ctx?.$element$, start),
        (err) => {
          console.error(`qrl ${symbol} failed to load`, err);
          symbolRef = null;
        }
      );
    }
    return symbolRef;
  };
  const createOrReuseInvocationContext = (invoke2) => {
    if (invoke2 == null) {
      return newInvokeContext();
    } else if (isArray(invoke2)) {
      return newInvokeContextFromTuple(invoke2);
    } else {
      return invoke2;
    }
  };
  const hash3 = getSymbolHash(symbol);
  Object.assign(qrl, {
    getSymbol: () => symbol,
    getHash: () => hash3,
    // captureRef is replaced during deserialization
    getCaptured: () => qrl.$captureRef$,
    resolve,
    $setContainer$: setContainer,
    $chunk$: chunk,
    $symbol$: symbol,
    $hash$: hash3,
    getFn: bindFnToContext,
    $capture$: capture,
    $captureRef$: captureRef,
    dev: null,
    resolved: void 0
  });
  if (symbolRef) {
    symbolRef = maybeThen(symbolRef, (resolved) => qrl.resolved = wrapFn(symbolRef = resolved));
  }
  if (qDev) {
    seal(qrl);
  }
  if (isBrowser && symbol) {
    preload(symbol, 0.8);
  }
  return qrl;
};
var EMITTED = /* @__PURE__ */ new Set();
var emitUsedSymbol = (symbol, element, reqTime) => {
  if (!EMITTED.has(symbol)) {
    EMITTED.add(symbol);
    emitEvent("qsymbol", {
      symbol,
      element,
      reqTime
    });
  }
};
var emitEvent = (eventName, detail) => {
  if (!qTest && !isServerPlatform() && typeof document === "object") {
    document.dispatchEvent(
      new CustomEvent(eventName, {
        bubbles: false,
        detail
      })
    );
  }
};
var now = () => {
  if (qTest || isServerPlatform()) {
    return 0;
  }
  if (typeof performance === "object") {
    return performance.now();
  }
  return 0;
};

// packages/qwik/src/core/shared/qrl/qrl.public.ts
var runtimeSymbolId = 0;
var $ = (expression) => {
  if (!qRuntimeQrl && qDev) {
    throw new Error(
      "Optimizer should replace all usages of $() with some special syntax. If you need to create a QRL manually, use inlinedQrl() instead."
    );
  }
  return createQRL(null, "s" + runtimeSymbolId++, expression, null, null, null);
};
var dollar = $;

// packages/qwik/src/core/shared/qrl/implicit_dollar.ts
var implicit$FirstArg = (fn) => {
  return function(first, ...rest) {
    return fn.call(null, dollar(first), ...rest);
  };
};

// packages/qwik/src/core/reactive-primitives/impl/serializer-signal-impl.ts
var DEBUG4 = false;
var log4 = (...args) => console.log("SERIALIZER SIGNAL", ...args.map(qwikDebugToString));
var SerializerSignalImpl = class extends ComputedSignalImpl {
  constructor(container, argQrl) {
    super(
      container,
      argQrl,
      1 /* INVALID */ | 32 /* SERIALIZATION_STRATEGY_ALWAYS */
    );
    __publicField(this, "$didInitialize$", false);
  }
  $computeIfNeeded$() {
    if (!(this.$flags$ & 1 /* INVALID */)) {
      return;
    }
    throwIfQRLNotResolved(this.$computeQrl$);
    let arg = this.$computeQrl$.resolved;
    if (typeof arg === "function") {
      arg = arg();
    }
    const { deserialize, initial } = arg;
    const update = arg.update;
    const currentValue = this.$untrackedValue$ === NEEDS_COMPUTATION ? initial : this.$untrackedValue$;
    const untrackedValue = trackSignal(
      () => this.$didInitialize$ ? update?.(currentValue) || currentValue : deserialize(currentValue),
      this,
      "." /* VNODE */,
      this.$container$
    );
    DEBUG4 && log4("SerializerSignal.$compute$", untrackedValue);
    const didChange = this.$didInitialize$ && untrackedValue !== "undefined" || untrackedValue !== this.$untrackedValue$;
    this.$flags$ &= ~1 /* INVALID */;
    this.$didInitialize$ = true;
    if (didChange) {
      this.$flags$ |= 2 /* RUN_EFFECTS */;
      this.$untrackedValue$ = untrackedValue;
    }
  }
};

// packages/qwik/src/core/reactive-primitives/signal-api.ts
var createSerializerSignal = (arg) => {
  return new SerializerSignalImpl(null, arg);
};

// packages/qwik/src/core/reactive-primitives/signal.public.ts
var createSerializer$ = implicit$FirstArg(
  createSerializerSignal
);

// packages/qwik/src/core/reactive-primitives/internal-api.ts
var getValueProp = (p0) => p0.value;

// packages/qwik/src/core/reactive-primitives/impl/wrapped-signal-impl.ts
var _a3, _b3;
var WrappedSignalImpl = class extends (_b3 = SignalImpl, _a3 = _EFFECT_BACK_REF, _b3) {
  constructor(container, fn, args, fnStr, flags = 1 /* INVALID */ | 4 /* UNWRAP */) {
    super(container, NEEDS_COMPUTATION);
    __publicField(this, "$args$");
    __publicField(this, "$func$");
    __publicField(this, "$funcStr$");
    __publicField(this, "$flags$");
    __publicField(this, "$hostElement$", null);
    __publicField(this, _a3, null);
    this.$args$ = args;
    this.$func$ = fn;
    this.$funcStr$ = fnStr;
    this.$flags$ = flags;
  }
  invalidate() {
    this.$flags$ |= 1 /* INVALID */;
    try {
      this.$computeIfNeeded$();
    } catch (_) {
      this.$container$?.$scheduler$(
        7 /* RECOMPUTE_AND_SCHEDULE_EFFECTS */,
        this.$hostElement$,
        this,
        this.$effects$
      );
    }
    if (this.$flags$ & 2 /* RUN_EFFECTS */) {
      this.$flags$ &= ~2 /* RUN_EFFECTS */;
      scheduleEffects(this.$container$, this, this.$effects$);
    }
  }
  /**
   * Use this to force running subscribers, for example when the calculated value has mutated but
   * remained the same object.
   */
  force() {
    this.$flags$ |= 2 /* RUN_EFFECTS */;
    this.$container$?.$scheduler$(
      7 /* RECOMPUTE_AND_SCHEDULE_EFFECTS */,
      this.$hostElement$,
      this,
      this.$effects$
    );
  }
  get untrackedValue() {
    this.$computeIfNeeded$();
    assertFalse(this.$untrackedValue$ === NEEDS_COMPUTATION, "Invalid state");
    return this.$untrackedValue$;
  }
  $computeIfNeeded$() {
    if (!(this.$flags$ & 1 /* INVALID */)) {
      return;
    }
    const untrackedValue = trackSignal(
      () => this.$func$(...this.$args$),
      this,
      "." /* VNODE */,
      this.$container$
    );
    this.$flags$ &= ~2 /* RUN_EFFECTS */;
    const didChange = untrackedValue !== this.$untrackedValue$;
    if (didChange) {
      this.$flags$ |= 2 /* RUN_EFFECTS */;
      this.$untrackedValue$ = untrackedValue;
    }
  }
  $unwrapIfSignal$() {
    return this.$func$ === getValueProp && isSignal(this.$args$[0]) ? this.$args$[0] : this;
  }
  // Make this signal read-only
  set value(_) {
    throw qError(31 /* wrappedReadOnly */);
  }
  // Getters don't get inherited when overriding a setter
  get value() {
    return super.value;
  }
};

// packages/qwik/src/core/use/use-core.ts
var _context;
var tryGetInvokeContext = () => {
  if (!_context) {
    const context = typeof document !== "undefined" && document && document.__q_context__;
    if (!context) {
      return void 0;
    }
    if (isArray(context)) {
      return document.__q_context__ = newInvokeContextFromTuple(context);
    }
    return context;
  }
  return _context;
};
var getInvokeContext = () => {
  const ctx = tryGetInvokeContext();
  if (!ctx) {
    throw qError(9 /* useMethodOutsideContext */);
  }
  return ctx;
};
var useInvokeContext = () => {
  const ctx = tryGetInvokeContext();
  if (!ctx || ctx.$event$ !== RenderEvent) {
    throw qError(10 /* useInvokeContext */);
  }
  assertDefined(ctx.$hostElement$, `invoke: $hostElement$ must be defined`, ctx);
  assertDefined(ctx.$effectSubscriber$, `invoke: $effectSubscriber$ must be defined`, ctx);
  return ctx;
};
function invoke(context, fn, ...args) {
  return invokeApply.call(this, context, fn, args);
}
function invokeApply(context, fn, args) {
  const previousContext = _context;
  let returnValue;
  try {
    _context = context;
    returnValue = fn.apply(this, args);
  } finally {
    _context = previousContext;
  }
  return returnValue;
}
var newInvokeContextFromTuple = ([element, event, url]) => {
  const domContainer = getDomContainer(element);
  const hostElement = vnode_locate(domContainer.rootVNode, element);
  const locale = domContainer.$locale$;
  locale && setLocale(locale);
  return newInvokeContext(locale, hostElement, element, event, url);
};
var newInvokeContext = (locale, hostElement, element, event, url) => {
  const $locale$ = locale || (event && isObject(event) && "locale" in event ? event.locale : void 0);
  const ctx = {
    $url$: url,
    $hostElement$: hostElement,
    $element$: element,
    $event$: event,
    $qrl$: void 0,
    $effectSubscriber$: void 0,
    $locale$,
    $container$: void 0
  };
  seal(ctx);
  return ctx;
};
var untrack = (fn) => {
  if (_context) {
    const sub = _context.$effectSubscriber$;
    try {
      _context.$effectSubscriber$ = void 0;
      return fn();
    } finally {
      _context.$effectSubscriber$ = sub;
    }
  } else {
    return fn();
  }
};
var trackInvocation = /* @__PURE__ */ newInvokeContext(
  void 0,
  void 0,
  void 0,
  RenderEvent
);
var trackSignal = (fn, subscriber, property, container, data) => {
  const previousSubscriber = trackInvocation.$effectSubscriber$;
  const previousContainer = trackInvocation.$container$;
  try {
    trackInvocation.$effectSubscriber$ = getSubscriber(subscriber, property, data);
    trackInvocation.$container$ = container;
    return invoke(trackInvocation, fn);
  } finally {
    trackInvocation.$effectSubscriber$ = previousSubscriber;
    trackInvocation.$container$ = previousContainer;
  }
};
var trackSignalAndAssignHost = (value, host, property, container, data) => {
  if (value instanceof WrappedSignalImpl && value.$hostElement$ !== host && host) {
    value.$hostElement$ = host;
  }
  return trackSignal(() => value.value, host, property, container, data);
};

// packages/qwik/src/core/reactive-primitives/impl/store.ts
var DEBUG5 = false;
var log5 = (...args) => console.log("STORE", ...args.map(qwikDebugToString));
var getStoreHandler = (value) => {
  return value[STORE_HANDLER];
};
var getStoreTarget = (value) => {
  return value?.[STORE_TARGET] || null;
};
var forceStoreEffects = (value, prop) => {
  const handler = getStoreHandler(value);
  if (handler) {
    handler.force(prop);
  }
};
var unwrapStore = (value) => {
  return getStoreTarget(value) || value;
};
var isStore = (value) => {
  return STORE_TARGET in value;
};
function createStore(container, obj, flags) {
  return new Proxy(obj, new StoreHandler(flags, container || null));
}
var getOrCreateStore = (obj, flags, container) => {
  if (isSerializableObject(obj) && container) {
    let store = container.$storeProxyMap$.get(obj);
    if (!store) {
      store = createStore(container, obj, flags);
      container.$storeProxyMap$.set(obj, store);
    }
    return store;
  }
  return obj;
};
var StoreHandler = class {
  constructor($flags$, $container$) {
    this.$flags$ = $flags$;
    this.$container$ = $container$;
    __publicField(this, "$effects$", null);
  }
  toString() {
    return "[Store]";
  }
  force(prop) {
    const target = getStoreTarget(this);
    this.$container$?.$scheduler$(
      7 /* RECOMPUTE_AND_SCHEDULE_EFFECTS */,
      null,
      this,
      getEffects(target, prop, this.$effects$)
    );
  }
  get(target, prop) {
    if (typeof prop === "symbol") {
      if (prop === STORE_TARGET) {
        return target;
      }
      if (prop === STORE_HANDLER) {
        return this;
      }
      return target[prop];
    }
    const ctx = tryGetInvokeContext();
    const value = target[prop];
    if (ctx) {
      if (this.$container$ === null) {
        if (!ctx.$container$) {
          return value;
        }
        this.$container$ = ctx.$container$;
      } else {
        assertTrue(
          !ctx.$container$ || ctx.$container$ === this.$container$,
          "Do not use signals across containers"
        );
      }
      const effectSubscriber = ctx.$effectSubscriber$;
      if (effectSubscriber) {
        addStoreEffect(
          target,
          Array.isArray(target) ? STORE_ALL_PROPS : prop,
          this,
          effectSubscriber
        );
      }
    }
    if (prop === "toString" && value === Object.prototype.toString) {
      return this.toString;
    }
    const flags = this.$flags$;
    if (flags & 1 /* RECURSIVE */ && isObject(value) && !Object.isFrozen(value) && !isStore(value) && !Object.isFrozen(target)) {
      return getOrCreateStore(value, this.$flags$, this.$container$);
    }
    return value;
  }
  /** In the case of oldValue and value are the same, the effects are not triggered. */
  set(target, prop, value) {
    if (typeof prop === "symbol") {
      target[prop] = value;
      return true;
    }
    const newValue = this.$flags$ & 1 /* RECURSIVE */ ? unwrapStore(value) : value;
    if (prop in target) {
      const oldValue = target[prop];
      if (newValue !== oldValue) {
        DEBUG5 && log5("Store.set", oldValue, "->", newValue, pad("\n" + this.toString(), "  "));
        setNewValueAndTriggerEffects(prop, newValue, target, this);
      }
    } else {
      DEBUG5 && log5("Store.set", "create property", newValue, pad("\n" + this.toString(), "  "));
      setNewValueAndTriggerEffects(prop, newValue, target, this);
    }
    return true;
  }
  deleteProperty(target, prop) {
    if (typeof prop != "string" || !delete target[prop]) {
      return false;
    }
    if (!Array.isArray(target)) {
      this.$container$?.$scheduler$(
        7 /* RECOMPUTE_AND_SCHEDULE_EFFECTS */,
        null,
        this,
        getEffects(target, prop, this.$effects$)
      );
    }
    return true;
  }
  has(target, prop) {
    if (prop === STORE_TARGET) {
      return true;
    }
    if (typeof prop === "string") {
      const ctx = tryGetInvokeContext();
      if (ctx) {
        const effectSubscriber = ctx.$effectSubscriber$;
        if (effectSubscriber) {
          addStoreEffect(
            target,
            Array.isArray(target) ? STORE_ALL_PROPS : prop,
            this,
            effectSubscriber
          );
        }
      }
    }
    return Object.prototype.hasOwnProperty.call(target, prop);
  }
  ownKeys(target) {
    const ctx = tryGetInvokeContext();
    const effectSubscriber = ctx?.$effectSubscriber$;
    if (effectSubscriber) {
      addStoreEffect(target, STORE_ALL_PROPS, this, effectSubscriber);
    }
    return Reflect.ownKeys(target);
  }
  getOwnPropertyDescriptor(target, prop) {
    const descriptor = Reflect.getOwnPropertyDescriptor(target, prop);
    if (Array.isArray(target) || typeof prop === "symbol") {
      return descriptor;
    }
    if (descriptor && !descriptor.configurable) {
      return descriptor;
    }
    return {
      enumerable: true,
      configurable: true
    };
  }
};
function addStoreEffect(target, prop, store, effectSubscription) {
  const effectsMap = store.$effects$ || (store.$effects$ = /* @__PURE__ */ new Map());
  let effects = effectsMap.get(prop);
  if (!effects) {
    effects = /* @__PURE__ */ new Set();
    effectsMap.set(prop, effects);
  }
  ensureContainsSubscription(effects, effectSubscription);
  ensureContainsBackRef(effectSubscription, target);
  addQrlToSerializationCtx(effectSubscription, store.$container$);
  DEBUG5 && log5("sub", pad("\n" + store.$effects$?.entries.toString(), "  "));
}
function setNewValueAndTriggerEffects(prop, value, target, currentStore) {
  target[prop] = value;
  const effects = getEffects(target, prop, currentStore.$effects$);
  if (effects) {
    currentStore.$container$?.$scheduler$(
      7 /* RECOMPUTE_AND_SCHEDULE_EFFECTS */,
      null,
      currentStore,
      effects
    );
  }
}
function getEffects(target, prop, storeEffects) {
  let effectsToTrigger;
  if (storeEffects) {
    if (Array.isArray(target)) {
      for (const effects of storeEffects.values()) {
        effectsToTrigger || (effectsToTrigger = /* @__PURE__ */ new Set());
        for (const effect of effects) {
          effectsToTrigger.add(effect);
        }
      }
    } else {
      effectsToTrigger = storeEffects.get(prop);
    }
  }
  const storeArrayValue = storeEffects?.get(STORE_ALL_PROPS);
  if (storeArrayValue) {
    effectsToTrigger || (effectsToTrigger = /* @__PURE__ */ new Set());
    for (const effect of storeArrayValue) {
      effectsToTrigger.add(effect);
    }
  }
  return effectsToTrigger || null;
}

// packages/qwik/src/core/reactive-primitives/subscription-data.ts
var SubscriptionData = class {
  constructor(data) {
    __publicField(this, "data");
    this.data = data;
  }
};

// packages/qwik/src/core/reactive-primitives/cleanup.ts
var _a4;
_a4 = _EFFECT_BACK_REF;
var BackRef = class {
  constructor() {
    __publicField(this, _a4, null);
  }
};
function clearAllEffects(container, consumer) {
  if (vnode_isVNode(consumer) && vnode_isElementVNode(consumer)) {
    ensureMaterialized(consumer);
  }
  const effects = consumer[_EFFECT_BACK_REF];
  if (!effects) {
    return;
  }
  for (const [, effect] of effects) {
    clearEffectSubscription(container, effect);
  }
}
function clearEffectSubscription(container, effect) {
  const backRefs = effect[2 /* BACK_REF */];
  if (!backRefs) {
    return;
  }
  for (const producer of backRefs) {
    if (producer instanceof SignalImpl) {
      clearSignal(container, producer, effect);
    } else if (producer instanceof AsyncComputedSignalImpl) {
      clearAsyncComputedSignal(producer, effect);
    } else if (container.$storeProxyMap$.has(producer)) {
      const target = container.$storeProxyMap$.get(producer);
      const storeHandler = getStoreHandler(target);
      clearStore(storeHandler, effect);
    }
  }
}
function clearSignal(container, producer, effect) {
  const effects = producer.$effects$;
  if (effects && effects.has(effect)) {
    effects.delete(effect);
  }
  if (producer instanceof WrappedSignalImpl) {
    producer.$hostElement$ = null;
    clearAllEffects(container, producer);
  }
}
function clearAsyncComputedSignal(producer, effect) {
  const effects = producer.$effects$;
  if (effects && effects.has(effect)) {
    effects.delete(effect);
  }
  const pendingEffects = producer.$loadingEffects$;
  if (pendingEffects && pendingEffects.has(effect)) {
    pendingEffects.delete(effect);
  }
}
function clearStore(producer, effect) {
  const effects = producer?.$effects$;
  if (effects) {
    for (const propEffects of effects.values()) {
      if (propEffects.has(effect)) {
        propEffects.delete(effect);
      }
    }
  }
}

// packages/qwik/src/core/use/use-lexical-scope.public.ts
var useLexicalScope = () => {
  const context = getInvokeContext();
  let qrl = context.$qrl$;
  if (!qrl) {
    const el = context.$element$;
    assertDefined(el, "invoke: element must be defined inside useLexicalScope()", context);
    const containerElement2 = _getQContainerElement(el);
    assertDefined(containerElement2, `invoke: cant find parent q:container of`, el);
    const container = getDomContainer(containerElement2);
    qrl = container.parseQRL(decodeURIComponent(String(context.$url$)));
  } else {
    assertQrl(qrl);
    assertDefined(
      qrl.$captureRef$,
      "invoke: qrl $captureRef$ must be defined inside useLexicalScope()",
      qrl
    );
  }
  return qrl.$captureRef$;
};

// packages/qwik/src/core/use/use-sequential-scope.ts
var useSequentialScope = () => {
  const iCtx = useInvokeContext();
  const hostElement = iCtx.$hostElement$;
  const host = hostElement;
  let seq = iCtx.$container$.getHostProp(host, ELEMENT_SEQ);
  if (seq === null) {
    seq = [];
    iCtx.$container$.setHostProp(host, ELEMENT_SEQ, seq);
  }
  let seqIdx = iCtx.$container$.getHostProp(host, ELEMENT_SEQ_IDX);
  if (seqIdx === null) {
    seqIdx = 0;
  }
  iCtx.$container$.setHostProp(host, ELEMENT_SEQ_IDX, seqIdx + 1);
  while (seq.length <= seqIdx) {
    seq.push(void 0);
  }
  const set = (value) => {
    if (qDev && qSerialize) {
      verifySerializable(value);
    }
    return seq[seqIdx] = value;
  };
  return {
    val: seq[seqIdx],
    set,
    i: seqIdx,
    iCtx
  };
};

// packages/qwik/src/core/use/use-task.ts
var runTask = (task, container, host) => {
  task.$flags$ &= ~8 /* DIRTY */;
  cleanupTask(task);
  const iCtx = newInvokeContext(container.$locale$, host, void 0, TaskEvent);
  iCtx.$container$ = container;
  const taskFn = task.$qrl$.getFn(iCtx, () => clearAllEffects(container, task));
  const track = trackFn(task, container);
  const [cleanup2] = cleanupFn(task, (reason) => container.handleError(reason, host));
  const taskApi = { track, cleanup: cleanup2 };
  return safeCall(
    () => taskFn(taskApi),
    cleanup2,
    (err) => {
      if (isPromise(err)) {
        return err.then(() => runTask(task, container, host));
      } else {
        throw err;
      }
    }
  );
};
var cleanupTask = (task) => {
  const destroy = task.$destroy$;
  if (destroy) {
    task.$destroy$ = null;
    try {
      destroy();
    } catch (err) {
      logError(err);
    }
  }
};
var Task = class extends BackRef {
  constructor($flags$, $index$, $el$, $qrl$, $state$, $destroy$) {
    super();
    this.$flags$ = $flags$;
    this.$index$ = $index$;
    this.$el$ = $el$;
    this.$qrl$ = $qrl$;
    this.$state$ = $state$;
    this.$destroy$ = $destroy$;
  }
};
var isTask = (value) => {
  return value instanceof Task;
};

// packages/qwik/src/core/shared/qrl/qrl.ts
var inlinedQrl = (symbol, symbolName, lexicalScopeCapture = EMPTY_ARRAY) => {
  return createQRL(null, symbolName, symbol, null, null, lexicalScopeCapture);
};

// packages/qwik/src/core/client/vnode-diff.ts
import { isDev as isDev6 } from "@qwik.dev/core/build";

// packages/qwik/src/core/shared/component-execution.ts
import { isDev as isDev4 } from "@qwik.dev/core/build";

// packages/qwik/src/core/shared/jsx/bind-handlers.ts
var _val = (_, element) => {
  const [signal] = useLexicalScope();
  signal.value = element.type === "number" ? element.valueAsNumber : element.value;
};
var _chk = (_, element) => {
  const [signal] = useLexicalScope();
  signal.value = element.checked;
};

// packages/qwik/src/core/shared/jsx/jsx-node.ts
var BIND_VALUE = "bind:value";
var BIND_CHECKED = "bind:checked";
var JSXNodeImpl = class {
  constructor(type, varProps, constProps, children, key, toSort, dev) {
    __publicField(this, "type");
    __publicField(this, "toSort");
    __publicField(this, "key");
    __publicField(this, "varProps");
    __publicField(this, "constProps");
    __publicField(this, "children");
    __publicField(this, "dev");
    __publicField(this, "_proxy", null);
    this.type = type;
    this.toSort = !!toSort;
    this.key = key == null ? null : String(key);
    this.varProps = !varProps || isEmpty(varProps) ? EMPTY_OBJ : varProps;
    this.constProps = !constProps || isEmpty(constProps) ? null : constProps;
    this.children = children;
    if (qDev && dev) {
      this.dev = {
        ...dev,
        stack: new Error().stack?.split("\n").slice(2).join("\n")
      };
    }
    if (typeof type === "string") {
      for (const k in this.constProps) {
        const attr = jsxEventToHtmlAttribute(k);
        if (attr) {
          mergeHandlers(this.constProps, attr, this.constProps[k]);
          delete this.constProps[k];
        }
      }
      for (const k in this.varProps) {
        const attr = jsxEventToHtmlAttribute(k);
        if (attr) {
          if (!constProps || !(k in constProps)) {
            toSort = mergeHandlers(this.varProps, attr, this.varProps[k]) || toSort;
          }
          delete this.varProps[k];
        }
      }
      if (BIND_CHECKED in this.varProps) {
        toSort = handleBindProp(this.varProps, BIND_CHECKED) || toSort;
      } else if (BIND_VALUE in this.varProps) {
        toSort = handleBindProp(this.varProps, BIND_VALUE) || toSort;
      } else if (this.constProps) {
        if (BIND_CHECKED in this.constProps) {
          handleBindProp(this.constProps, BIND_CHECKED);
        } else {
          if (BIND_VALUE in this.constProps) {
            handleBindProp(this.constProps, BIND_VALUE);
          }
        }
      }
      if ("className" in this.varProps) {
        this.varProps.class = this.varProps.className;
        this.varProps.className = void 0;
        toSort = true;
        if (qDev) {
          logOnceWarn(
            `jsx${dev ? ` ${dev.fileName}${dev?.lineNumber ? `:${dev.lineNumber}` : ""}` : ""}: \`className\` is deprecated. Use \`class\` instead.`
          );
        }
      }
      if (this.constProps && "className" in this.constProps) {
        this.constProps.class = this.constProps.className;
        this.constProps.className = void 0;
        if (qDev) {
          logOnceWarn(
            `jsx${dev ? ` ${dev.fileName}${dev?.lineNumber ? `:${dev.lineNumber}` : ""}` : ""}: \`className\` is deprecated. Use \`class\` instead.`
          );
        }
      }
    }
    seal(this);
  }
  get props() {
    return this._proxy || (this._proxy = createPropsProxy(this));
  }
};
var mergeHandlers = (obj, event, handler) => {
  let current = obj[event];
  if (current) {
    if (Array.isArray(current)) {
      current.push(handler);
    } else {
      current = obj[event] = [current, handler];
    }
  } else {
    obj[event] = handler;
    return true;
  }
};
var isJSXNode = (n) => {
  if (qDev) {
    if (n instanceof JSXNodeImpl) {
      return true;
    }
    if (isObject(n) && "key" in n && "props" in n && "type" in n) {
      logWarn(`Duplicate implementations of "JSXNode" found`);
      return true;
    }
    return false;
  } else {
    return n instanceof JSXNodeImpl;
  }
};
var isEmpty = (obj) => {
  for (const prop in obj) {
    if (obj[prop] !== void 0) {
      return false;
    }
  }
  return true;
};
var handleBindProp = (props, prop) => {
  const value = props[prop];
  props[prop] = void 0;
  if (value) {
    if (prop === BIND_CHECKED) {
      props.checked = value;
      props["on:input"] = createQRL(null, "_chk", _chk, null, null, [value]);
    } else {
      props.value = value;
      props["on:input"] = createQRL(null, "_val", _val, null, null, [value]);
    }
    return true;
  }
};

// packages/qwik/src/core/shared/jsx/jsx-internal.ts
var _jsxSorted = (type, varProps, constProps, children, flags, key, dev) => {
  return untrack(() => new JSXNodeImpl(type, varProps, constProps, children, key, false, dev));
};
var _jsxSplit = (type, varProps, constProps, children, flags, key, dev) => {
  return untrack(() => {
    if (varProps) {
      for (const k in varProps) {
        if (k === "children") {
          children || (children = varProps.children);
          varProps.children = void 0;
        } else if (k === "key") {
          key || (key = varProps.key);
          varProps.key = void 0;
        } else if (constProps && k in constProps) {
          varProps[k] = void 0;
        }
      }
    }
    return new JSXNodeImpl(type, varProps, constProps, children, key, true, dev);
  });
};
var Virtual = (props) => props.children;

// packages/qwik/src/core/shared/jsx/jsx-runtime.ts
var Fragment = (props) => props.children;

// packages/qwik/src/core/shared/component-execution.ts
var executeComponent = (container, renderHost, subscriptionHost, componentQRL, props) => {
  const iCtx = newInvokeContext(
    container.$locale$,
    subscriptionHost || void 0,
    void 0,
    RenderEvent
  );
  if (subscriptionHost) {
    iCtx.$effectSubscriber$ = getSubscriber(subscriptionHost, ":" /* COMPONENT */);
    iCtx.$container$ = container;
  }
  let componentFn;
  container.ensureProjectionResolved(renderHost);
  let isInlineComponent = false;
  if (componentQRL === null) {
    componentQRL = container.getHostProp(renderHost, OnRenderProp);
    assertDefined(componentQRL, "No Component found at this location");
  }
  if (isQrl(componentQRL)) {
    props = props || container.getHostProp(renderHost, ELEMENT_PROPS) || EMPTY_OBJ;
    if ("children" in props) {
      delete props.children;
    }
    componentFn = componentQRL.getFn(iCtx);
  } else if (isQwikComponent(componentQRL)) {
    const qComponentFn = componentQRL;
    componentFn = () => invokeApply(iCtx, qComponentFn, [props || EMPTY_OBJ, null, 0]);
  } else {
    isInlineComponent = true;
    const inlineComponent = componentQRL;
    componentFn = () => invokeApply(iCtx, inlineComponent, [props || EMPTY_OBJ]);
  }
  const executeComponentWithPromiseExceptionRetry = (retryCount = 0) => safeCall(
    () => {
      if (!isInlineComponent) {
        container.setHostProp(renderHost, ELEMENT_SEQ_IDX, null);
        container.setHostProp(renderHost, USE_ON_LOCAL_SEQ_IDX, null);
      }
      if (retryCount > 0 && vnode_isVNode(renderHost)) {
        clearAllEffects(container, renderHost);
      }
      return componentFn(props);
    },
    (jsx2) => {
      const useOnEvents = container.getHostProp(renderHost, USE_ON_LOCAL);
      if (useOnEvents) {
        return addUseOnEvents(jsx2, useOnEvents);
      }
      return jsx2;
    },
    (err) => {
      if (isPromise(err) && retryCount < MAX_RETRY_ON_PROMISE_COUNT) {
        return err.then(
          () => executeComponentWithPromiseExceptionRetry(++retryCount)
        );
      } else {
        if (retryCount >= MAX_RETRY_ON_PROMISE_COUNT) {
          throw new Error(`Max retry count of component execution reached`);
        }
        throw err;
      }
    }
  );
  return executeComponentWithPromiseExceptionRetry();
};
function addUseOnEvents(jsx2, useOnEvents) {
  const jsxElement = findFirstElementNode(jsx2);
  let jsxResult = jsx2;
  const qVisibleEvent = "on:qvisible";
  return maybeThen(jsxElement, (jsxElement2) => {
    const isHeadless = !jsxElement2;
    let placeholderElement = null;
    for (const key in useOnEvents) {
      if (Object.prototype.hasOwnProperty.call(useOnEvents, key)) {
        let targetElement = jsxElement2;
        let eventKey = key;
        if (isHeadless) {
          if (key === qVisibleEvent || key.startsWith("on-document:" /* document */) || key.startsWith("on-window:" /* window */)) {
            if (!placeholderElement) {
              const [createdElement, newJsx] = injectPlaceholderElement(jsxResult);
              jsxResult = newJsx;
              placeholderElement = createdElement;
            }
            targetElement = placeholderElement;
          } else {
            if (isDev4) {
              logWarn(
                'You are trying to add an event "' + key + '" using `useOn` hook, but a node to which you can add an event is not found. Please make sure that the component has a valid element node. '
              );
            }
            continue;
          }
        }
        if (targetElement) {
          if (targetElement.type === "script" && key === qVisibleEvent) {
            eventKey = "on-document:qinit";
            if (isDev4) {
              logWarn(
                'You are trying to add an event "' + key + '" using the `useVisibleTask$` hook with the "intersection-observer" strategy, but a node to which you can add an event is not found. Using "document-ready" or "document-idle" instead.'
              );
            }
          }
          addUseOnEvent(targetElement, eventKey, useOnEvents[key]);
        }
      }
    }
    return jsxResult;
  });
}
function addUseOnEvent(jsxElement, key, value) {
  const props = jsxElement.constProps || (jsxElement.constProps = {});
  const propValue = props[key];
  if (propValue == null) {
    props[key] = value;
  } else if (Array.isArray(propValue)) {
    propValue.push(...value);
  } else {
    props[key] = [propValue, ...value];
  }
  const varProp = jsxElement.varProps[key];
  if (varProp) {
    if (Array.isArray(propValue)) {
      propValue.push(...props[key]);
    } else {
      jsxElement.varProps[key] = [propValue, ...value];
    }
    props[key] = void 0;
  }
}
function findFirstElementNode(jsx2) {
  const queue2 = [jsx2];
  while (queue2.length) {
    const jsx3 = queue2.shift();
    if (isJSXNode(jsx3)) {
      if (typeof jsx3.type === "string") {
        return jsx3;
      }
      queue2.push(jsx3.children);
    } else if (isArray(jsx3)) {
      queue2.push(...jsx3);
    } else if (isPromise(jsx3)) {
      return maybeThen(
        jsx3,
        (jsx4) => findFirstElementNode(jsx4)
      );
    } else if (isSignal(jsx3)) {
      return findFirstElementNode(untrack(() => jsx3.value));
    }
  }
  return null;
}
function injectPlaceholderElement(jsx2) {
  if (isJSXNode(jsx2)) {
    const placeholder = createPlaceholderScriptNode();
    if (jsx2.type !== Fragment && !isQwikComponent(jsx2.type)) {
      return [placeholder, _jsxSorted(Fragment, null, null, [jsx2, placeholder], 0, null)];
    }
    if (jsx2.children == null) {
      jsx2.children = placeholder;
    } else if (isArray(jsx2.children)) {
      jsx2.children.push(placeholder);
    } else {
      jsx2.children = [jsx2.children, placeholder];
    }
    return [placeholder, jsx2];
  }
  if (isPrimitive(jsx2)) {
    const placeholder = createPlaceholderScriptNode();
    return [placeholder, _jsxSorted(Fragment, null, null, [jsx2, placeholder], 0, null)];
  }
  if (isArray(jsx2) && jsx2.length > 0) {
    const [createdElement, _] = injectPlaceholderElement(jsx2[0]);
    return [createdElement, jsx2];
  }
  return [null, jsx2];
}
function createPlaceholderScriptNode() {
  return new JSXNodeImpl("script", null, { hidden: "" });
}

// packages/qwik/src/core/shared/jsx/slot.public.ts
var Slot = (props) => {
  return _jsxSorted(Virtual, null, { [QSlotS]: "" }, props.children, 0, props.name ?? "");
};

// packages/qwik/src/core/shared/jsx/utils.public.ts
var SkipRender = Symbol("skip render");
var SSRRaw = () => null;
var SSRComment = () => null;

// packages/qwik/src/core/shared/utils/character-escaping.ts
function escapeHTML(html) {
  let escapedHTML = "";
  const length = html.length;
  let idx = 0;
  let lastIdx = idx;
  for (; idx < length; idx++) {
    const ch = html.charCodeAt(idx);
    if (ch === 60) {
      escapedHTML += html.substring(lastIdx, idx) + "&lt;";
    } else if (ch === 62) {
      escapedHTML += html.substring(lastIdx, idx) + "&gt;";
    } else if (ch === 38) {
      escapedHTML += html.substring(lastIdx, idx) + "&amp;";
    } else if (ch === 34) {
      escapedHTML += html.substring(lastIdx, idx) + "&quot;";
    } else if (ch === 39) {
      escapedHTML += html.substring(lastIdx, idx) + "&#39;";
    } else {
      continue;
    }
    lastIdx = idx + 1;
  }
  if (lastIdx === 0) {
    return html;
  } else {
    return escapedHTML + html.substring(lastIdx);
  }
}

// packages/qwik/src/core/shared/utils/jsx-filename.ts
function getFileLocationFromJsx(jsxDev) {
  if (!jsxDev) {
    return null;
  }
  const sanitizedFileName = jsxDev.fileName?.replace(/\\/g, "/");
  if (sanitizedFileName) {
    return `${sanitizedFileName}:${jsxDev.lineNumber}:${jsxDev.columnNumber}`;
  }
  return null;
}

// packages/qwik/src/core/shared/utils/prop.ts
function isSlotProp(prop) {
  return !prop.startsWith("q:") && !prop.startsWith(NON_SERIALIZABLE_MARKER_PREFIX);
}

// packages/qwik/src/core/shared/utils/scoped-styles.ts
var styleContent = (styleId) => {
  return ComponentStylesPrefixContent + styleId;
};
function hasClassAttr(props) {
  return "class" in props || "className" in props;
}
function isClassAttr(key) {
  return key === "class" || key === "className";
}
function convertScopedStyleIdsToArray(scopedStyleIds) {
  return scopedStyleIds?.split(" ") ?? null;
}
function convertStyleIdsToString(scopedStyleIds) {
  return Array.from(scopedStyleIds).join(" ");
}
var addComponentStylePrefix = (styleId) => {
  if (styleId) {
    let idx = 0;
    do {
      styleId = styleId.substring(0, idx) + styleContent(styleId.substring(idx));
    } while ((idx = styleId.indexOf(" ", idx) + 1) !== 0);
  }
  return styleId || null;
};

// packages/qwik/src/core/shared/utils/unitless_number.ts
var unitlessNumbers = /* @__PURE__ */ new Set([
  "animationIterationCount",
  "aspectRatio",
  "borderImageOutset",
  "borderImageSlice",
  "borderImageWidth",
  "boxFlex",
  "boxFlexGroup",
  "boxOrdinalGroup",
  "columnCount",
  "columns",
  "flex",
  "flexGrow",
  "flexShrink",
  "gridArea",
  "gridRow",
  "gridRowEnd",
  "gridRowStart",
  "gridColumn",
  "gridColumnEnd",
  "gridColumnStart",
  "fontWeight",
  "lineClamp",
  "lineHeight",
  "opacity",
  "order",
  "orphans",
  "scale",
  "tabSize",
  "widows",
  "zIndex",
  "zoom",
  "MozAnimationIterationCount",
  // Known Prefixed Properties
  "MozBoxFlex",
  // TODO: Remove these since they shouldn't be used in modern code
  "msFlex",
  "msFlexPositive",
  "WebkitAnimationIterationCount",
  "WebkitBoxFlex",
  "WebkitBoxOrdinalGroup",
  "WebkitColumnCount",
  "WebkitColumns",
  "WebkitFlex",
  "WebkitFlexGrow",
  "WebkitFlexShrink",
  "WebkitLineClamp"
]);
var isUnitlessNumber = (name) => {
  return unitlessNumbers.has(name);
};

// packages/qwik/src/core/shared/utils/styles.ts
var serializeClass = (obj) => {
  if (!obj) {
    return "";
  }
  if (isString(obj)) {
    return obj.trim();
  }
  const classes = [];
  if (isArray(obj)) {
    for (const o of obj) {
      const classList = serializeClass(o);
      if (classList) {
        classes.push(classList);
      }
    }
  } else {
    for (const [key, value] of Object.entries(obj)) {
      if (value) {
        classes.push(key.trim());
      }
    }
  }
  return classes.join(" ");
};
var fromCamelToKebabCaseWithDash = (text) => {
  return text.replace(/([A-Z])/g, "-$1").toLowerCase();
};
var stringifyStyle = (obj) => {
  if (obj == null) {
    return "";
  }
  if (typeof obj == "object") {
    if (isArray(obj)) {
      throw qError(0 /* stringifyClassOrStyle */, [obj, "style"]);
    } else {
      const chunks = [];
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          const value = obj[key];
          if (value != null && typeof value !== "function") {
            if (key.startsWith("--")) {
              chunks.push(key + ":" + value);
            } else {
              chunks.push(fromCamelToKebabCaseWithDash(key) + ":" + setValueForStyle(key, value));
            }
          }
        }
      }
      return chunks.join(";");
    }
  }
  return String(obj);
};
var serializeBooleanOrNumberAttribute = (value) => {
  return value != null ? String(value) : null;
};
function serializeAttribute(key, value, styleScopedId) {
  if (isClassAttr(key)) {
    const serializedClass = serializeClass(value);
    value = styleScopedId ? styleScopedId + (serializedClass.length ? " " + serializedClass : serializedClass) : serializedClass;
  } else if (key === "style") {
    value = stringifyStyle(value);
  } else if (isEnumeratedBooleanAttribute(key) || typeof value === "number") {
    value = serializeBooleanOrNumberAttribute(value);
  } else if (value === false || value == null) {
    value = null;
  } else if (value === true && isPreventDefault(key)) {
    value = "";
  }
  return value;
}
function isEnumeratedBooleanAttribute(key) {
  return isAriaAttribute(key) || ["spellcheck", "draggable", "contenteditable"].includes(key);
}
var setValueForStyle = (styleName, value) => {
  if (typeof value === "number" && value !== 0 && !isUnitlessNumber(styleName)) {
    return value + "px";
  }
  return value;
};
function isAriaAttribute(prop) {
  return prop.startsWith("aria-");
}

// packages/qwik/src/core/client/util-mapArray.ts
var mapApp_findIndx = (array, key, start) => {
  assertTrue(start % 2 === 0, "Expecting even number.");
  let bottom = start >> 1;
  let top = array.length - 2 >> 1;
  while (bottom <= top) {
    const mid = bottom + (top - bottom >> 1);
    const midKey = array[mid << 1];
    if (midKey === key) {
      return mid << 1;
    }
    if (midKey < key) {
      bottom = mid + 1;
    } else {
      top = mid - 1;
    }
  }
  return bottom << 1 ^ -1;
};
var mapArray_set = (array, key, value, start, allowNullValue = false) => {
  const indx = mapApp_findIndx(array, key, start);
  if (indx >= 0) {
    if (value == null && !allowNullValue) {
      array.splice(indx, 2);
    } else {
      array[indx + 1] = value;
    }
  } else if (value != null || allowNullValue) {
    array.splice(indx ^ -1, 0, key, value);
  }
};
var mapApp_remove = (array, key, start) => {
  const indx = mapApp_findIndx(array, key, start);
  let value = null;
  if (indx >= 0) {
    value = array[indx + 1];
    array.splice(indx, 2);
    return value;
  }
  return value;
};
var mapArray_get = (array, key, start) => {
  const indx = mapApp_findIndx(array, key, start);
  if (indx >= 0) {
    return array[indx + 1];
  } else {
    return null;
  }
};
var mapArray_has = (array, key, start) => {
  return mapApp_findIndx(array, key, start) >= 0;
};

// packages/qwik/src/core/client/vnode-namespace.ts
import { isDev as isDev5 } from "@qwik.dev/core/build";
var isForeignObjectElement = (elementName) => {
  return isDev5 ? elementName.toLowerCase() === "foreignobject" : elementName === "foreignObject";
};
var isSvgElement = (elementName) => elementName === "svg" || isForeignObjectElement(elementName);
var isMathElement = (elementName) => elementName === "math";
var vnode_isDefaultNamespace = (vnode) => {
  const flags = vnode.flags;
  return (flags & 192 /* NAMESPACE_MASK */) === 0;
};
var vnode_getElementNamespaceFlags = (element) => {
  const namespace = fastNamespaceURI(element);
  switch (namespace) {
    case SVG_NS:
      return 64 /* NS_svg */;
    case MATH_NS:
      return 128 /* NS_math */;
    default:
      return 0 /* NS_html */;
  }
};
function vnode_getDomChildrenWithCorrectNamespacesToInsert(journal, domParentVNode, newChild) {
  const { elementNamespace, elementNamespaceFlag } = getNewElementNamespaceData(
    domParentVNode,
    newChild
  );
  let domChildren = [];
  if (elementNamespace === HTML_NS) {
    domChildren = vnode_getDOMChildNodes(journal, newChild);
  } else {
    const children = vnode_getDOMChildNodes(journal, newChild, true);
    for (let i = 0; i < children.length; i++) {
      const childVNode = children[i];
      if (vnode_isTextVNode(childVNode)) {
        domChildren.push(childVNode.textNode);
        continue;
      }
      if ((childVNode.flags & 192 /* NAMESPACE_MASK */) === (domParentVNode.flags & 192 /* NAMESPACE_MASK */)) {
        domChildren.push(childVNode.element);
        continue;
      }
      const newChildElement = vnode_cloneElementWithNamespace(
        childVNode,
        domParentVNode,
        elementNamespace,
        elementNamespaceFlag
      );
      if (newChildElement) {
        domChildren.push(newChildElement);
      }
    }
  }
  return domChildren;
}
function cloneDomTreeWithNamespace(element, elementName, namespace, deep = false) {
  const newElement = element.ownerDocument.createElementNS(namespace, elementName);
  for (const attr of element.attributes) {
    if (attr.name !== Q_PROPS_SEPARATOR) {
      newElement.setAttribute(attr.name, attr.value);
    }
  }
  if (deep) {
    for (const child of element.childNodes) {
      const nodeType = child.nodeType;
      if (nodeType === 3) {
        newElement.appendChild(child.cloneNode());
      } else if (nodeType === 1) {
        newElement.appendChild(
          cloneDomTreeWithNamespace(child, child.localName, namespace, deep)
        );
      }
    }
  }
  return newElement;
}
function vnode_cloneElementWithNamespace(elementVNode, parentVNode, namespace, namespaceFlag) {
  ensureElementVNode(elementVNode);
  let vCursor = elementVNode;
  let vParent = null;
  let rootElement = null;
  let parentElement = null;
  while (vCursor) {
    let childElement = null;
    let newChildElement = null;
    if (vnode_isElementVNode(vCursor)) {
      childElement = vCursor.element;
      const childElementTag = vnode_getElementName(vCursor);
      const vCursorParent = vCursor.parent;
      const vCursorDomParent = rootElement == null ? parentVNode : vCursorParent && vnode_getDomParentVNode(vCursorParent);
      if (vCursorDomParent) {
        const namespaceData = getNewElementNamespaceData(
          vCursorDomParent,
          vnode_getElementName(vCursor)
        );
        namespace = namespaceData.elementNamespace;
        namespaceFlag = namespaceData.elementNamespaceFlag;
      }
      const vFirstChild = vnode_getFirstChild(vCursor);
      newChildElement = cloneDomTreeWithNamespace(
        childElement,
        childElementTag,
        namespace,
        // deep if there is no vnode children, children are probably inserted via innerHTML
        !vFirstChild
      );
      childElement.remove();
      if (rootElement == null) {
        rootElement = newChildElement;
      }
      if (parentElement) {
        parentElement.appendChild(newChildElement);
      }
      vCursor.element = newChildElement;
      vCursor.flags &= -193 /* NEGATED_NAMESPACE_MASK */;
      vCursor.flags |= namespaceFlag;
      if (vFirstChild) {
        vCursor = vFirstChild;
        parentElement = newChildElement;
        continue;
      } else if (shouldIgnoreChildren(childElement)) {
        const container = getDomContainerFromQContainerElement(childElement);
        if (container) {
          const innerContainerFirstVNode = vnode_getFirstChild(container.rootVNode);
          if (innerContainerFirstVNode) {
            vCursor = innerContainerFirstVNode;
            parentElement = newChildElement;
            continue;
          }
        }
      }
    }
    if (vCursor === elementVNode) {
      return rootElement;
    }
    const vNextSibling = vCursor.nextSibling;
    if (vNextSibling) {
      vCursor = vNextSibling;
      continue;
    }
    vParent = vCursor.parent;
    while (vParent) {
      if (vParent === elementVNode) {
        return rootElement;
      }
      const vNextParentSibling = vParent.nextSibling;
      if (vNextParentSibling) {
        vCursor = vNextParentSibling;
        return rootElement;
      }
      vParent = vParent.parent;
    }
    if (vParent == null) {
      return rootElement;
    }
  }
  return rootElement;
}
function isSvg(tagOrVNode) {
  return typeof tagOrVNode === "string" ? isSvgElement(tagOrVNode) : (tagOrVNode.flags & 64 /* NS_svg */) !== 0;
}
function isMath(tagOrVNode) {
  return typeof tagOrVNode === "string" ? isMathElement(tagOrVNode) : (tagOrVNode.flags & 128 /* NS_math */) !== 0;
}
function getNewElementNamespaceData(domParentVNode, tagOrVNode) {
  const parentIsDefaultNamespace = domParentVNode ? !!vnode_getElementName(domParentVNode) && vnode_isDefaultNamespace(domParentVNode) : true;
  const parentIsForeignObject = !parentIsDefaultNamespace ? isForeignObjectElement(vnode_getElementName(domParentVNode)) : false;
  let elementNamespace = HTML_NS;
  let elementNamespaceFlag = 0 /* NS_html */;
  const isElementVNodeOrString = typeof tagOrVNode === "string" || vnode_isElementVNode(tagOrVNode);
  if (isElementVNodeOrString && isSvg(tagOrVNode)) {
    elementNamespace = SVG_NS;
    elementNamespaceFlag = 64 /* NS_svg */;
  } else if (isElementVNodeOrString && isMath(tagOrVNode)) {
    elementNamespace = MATH_NS;
    elementNamespaceFlag = 128 /* NS_math */;
  } else if (domParentVNode && !parentIsForeignObject && !parentIsDefaultNamespace) {
    const isParentSvg = (domParentVNode.flags & 64 /* NS_svg */) !== 0;
    const isParentMath = (domParentVNode.flags & 128 /* NS_math */) !== 0;
    elementNamespace = isParentSvg ? SVG_NS : isParentMath ? MATH_NS : HTML_NS;
    elementNamespaceFlag = domParentVNode.flags & 192 /* NAMESPACE_MASK */;
  }
  return {
    elementNamespace,
    elementNamespaceFlag
  };
}
function getAttributeNamespace(attributeName) {
  switch (attributeName) {
    case "xlink:href":
    case "xlink:actuate":
    case "xlink:arcrole":
    case "xlink:role":
    case "xlink:show":
    case "xlink:title":
    case "xlink:type":
      return XLINK_NS;
    case "xml:base":
    case "xml:lang":
    case "xml:space":
      return XML_NS;
    default:
      return null;
  }
}

// packages/qwik/src/core/client/vnode-diff.ts
var vnode_diff = (container, jsxNode, vStartNode, scopedStyleIdPrefix) => {
  let journal = container.$journal$;
  const stack2 = [];
  const asyncQueue = [];
  let vParent = null;
  let vCurrent = null;
  let vNewNode = null;
  let vSiblings = null;
  let vSiblingsArray = null;
  let vSideBuffer = null;
  let jsxChildren = null;
  let jsxValue = null;
  let jsxIdx = 0;
  let jsxCount = 0;
  let shouldAdvance = true;
  const CONST_SUBSCRIPTION_DATA = new SubscriptionData({
    $scopedStyleIdPrefix$: scopedStyleIdPrefix,
    $isConst$: true
  });
  const NON_CONST_SUBSCRIPTION_DATA = new SubscriptionData({
    $scopedStyleIdPrefix$: scopedStyleIdPrefix,
    $isConst$: false
  });
  diff(jsxNode, vStartNode);
  return drainAsyncQueue();
  function diff(jsxNode2, vStartNode2) {
    assertFalse(vnode_isVNode(jsxNode2), "JSXNode should not be a VNode");
    assertTrue(vnode_isVNode(vStartNode2), "vStartNode should be a VNode");
    vParent = vStartNode2;
    vNewNode = null;
    vCurrent = vnode_getFirstChild(vStartNode2);
    stackPush(jsxNode2, true);
    if (vParent.flags & 32 /* Deleted */) {
      return;
    }
    while (stack2.length) {
      while (jsxIdx < jsxCount) {
        assertFalse(vParent === vCurrent, "Parent and current can't be the same");
        if (typeof jsxValue === "string") {
          expectText(jsxValue);
        } else if (typeof jsxValue === "number") {
          expectText(String(jsxValue));
        } else if (jsxValue && typeof jsxValue === "object") {
          if (Array.isArray(jsxValue)) {
            descend(jsxValue, false);
          } else if (isSignal(jsxValue)) {
            expectVirtual("S" /* WrappedSignal */, null);
            const unwrappedSignal = jsxValue instanceof WrappedSignalImpl ? jsxValue.$unwrapIfSignal$() : jsxValue;
            const currentSignal = vCurrent?.[_EFFECT_BACK_REF]?.get("." /* VNODE */)?.[0 /* CONSUMER */];
            if (currentSignal !== unwrappedSignal) {
              const vHost = vNewNode || vCurrent;
              descend(
                resolveSignalAndDescend(
                  () => trackSignalAndAssignHost(unwrappedSignal, vHost, "." /* VNODE */, container)
                ),
                true
              );
            }
          } else if (isPromise(jsxValue)) {
            expectVirtual("A" /* Awaited */, null);
            asyncQueue.push(jsxValue, vNewNode || vCurrent);
          } else if (isJSXNode(jsxValue)) {
            const type = jsxValue.type;
            if (typeof type === "string") {
              expectNoMoreTextNodes();
              expectElement(jsxValue, type);
              descend(jsxValue.children, true);
            } else if (typeof type === "function") {
              if (type === Fragment) {
                expectNoMoreTextNodes();
                expectVirtual("F" /* Fragment */, jsxValue.key);
                descend(jsxValue.children, true);
              } else if (type === Slot) {
                expectNoMoreTextNodes();
                if (!expectSlot()) {
                  descend(jsxValue.children, true);
                }
              } else if (type === Projection) {
                expectProjection();
                descend(
                  jsxValue.children,
                  true,
                  // special case for projection, we don't want to expect no children
                  // because the projection's children are not removed
                  false
                );
              } else if (type === SSRComment) {
                expectNoMore();
              } else if (type === SSRRaw) {
                expectNoMore();
              } else {
                expectNoMoreTextNodes();
                expectComponent(type);
              }
            }
          }
        } else if (jsxValue === SkipRender) {
          journal = [];
        } else {
          expectText("");
        }
        advance();
      }
      expectNoMore();
      cleanupSideBuffer();
      ascend();
    }
  }
  function resolveSignalAndDescend(fn) {
    try {
      return fn();
    } catch (e) {
      if (isPromise(e)) {
        const retryPromise = e.then(() => retryOnPromise(fn));
        asyncQueue.push(retryPromise, vNewNode || vCurrent);
        return null;
      }
      throw e;
    }
  }
  function advance() {
    if (!shouldAdvance) {
      shouldAdvance = true;
      return;
    }
    jsxIdx++;
    if (jsxIdx < jsxCount) {
      jsxValue = jsxChildren[jsxIdx];
    } else if (stack2[stack2.length - 1] === false) {
      return ascend();
    }
    if (vNewNode !== null) {
      vNewNode = null;
    } else {
      advanceToNextSibling();
    }
  }
  function peekNextSibling() {
    return vCurrent ? vCurrent.nextSibling : null;
  }
  function advanceToNextSibling() {
    vCurrent = peekNextSibling();
  }
  function descend(children, descendVNode, shouldExpectNoChildren = true) {
    if (shouldExpectNoChildren && (children == null || descendVNode && isArray(children) && children.length === 0)) {
      expectNoChildren();
      return;
    }
    stackPush(children, descendVNode);
    if (descendVNode) {
      assertDefined(vCurrent || vNewNode, "Expecting vCurrent to be defined.");
      vSideBuffer = null;
      vSiblings = null;
      vSiblingsArray = null;
      vParent = vNewNode || vCurrent;
      vCurrent = vnode_getFirstChild(vParent);
      vNewNode = null;
    }
    shouldAdvance = false;
  }
  function ascend() {
    const descendVNode = stack2.pop();
    if (descendVNode) {
      vSideBuffer = stack2.pop();
      vSiblings = stack2.pop();
      vSiblingsArray = stack2.pop();
      vNewNode = stack2.pop();
      vCurrent = stack2.pop();
      vParent = stack2.pop();
    }
    jsxValue = stack2.pop();
    jsxCount = stack2.pop();
    jsxIdx = stack2.pop();
    jsxChildren = stack2.pop();
    advance();
  }
  function stackPush(children, descendVNode) {
    stack2.push(jsxChildren, jsxIdx, jsxCount, jsxValue);
    if (descendVNode) {
      stack2.push(vParent, vCurrent, vNewNode, vSiblingsArray, vSiblings, vSideBuffer);
    }
    stack2.push(descendVNode);
    if (Array.isArray(children)) {
      jsxIdx = 0;
      jsxCount = children.length;
      jsxChildren = children;
      jsxValue = jsxCount > 0 ? children[0] : null;
    } else if (children === void 0) {
      jsxIdx = 0;
      jsxValue = null;
      jsxChildren = null;
      jsxCount = 0;
    } else {
      jsxIdx = 0;
      jsxValue = children;
      jsxChildren = null;
      jsxCount = 1;
    }
  }
  function getInsertBefore() {
    if (vNewNode) {
      return vCurrent;
    } else {
      return peekNextSibling();
    }
  }
  function descendContentToProject(children, host) {
    const projectionChildren = Array.isArray(children) ? children : [children];
    const createProjectionJSXNode = (slotName) => {
      return new JSXNodeImpl(Projection, null, null, [], slotName);
    };
    const projections = [];
    if (host) {
      const props = vnode_getProps(host);
      for (let i = 0; i < props.length; i = i + 2) {
        const prop = props[i];
        if (isSlotProp(prop)) {
          const slotName = prop;
          projections.push(slotName);
          projections.push(createProjectionJSXNode(slotName));
        }
      }
    }
    if (projections.length === 0 && children == null) {
      return;
    }
    for (let i = 0; i < projectionChildren.length; i++) {
      const child = projectionChildren[i];
      const slotName = String(
        isJSXNode(child) && directGetPropsProxyProp(child, QSlot) || QDefaultSlot
      );
      const idx = mapApp_findIndx(projections, slotName, 0);
      let jsxBucket;
      if (idx >= 0) {
        jsxBucket = projections[idx + 1];
      } else {
        projections.splice(~idx, 0, slotName, jsxBucket = createProjectionJSXNode(slotName));
      }
      const removeProjection = child === false;
      if (!removeProjection) {
        jsxBucket.children.push(child);
      }
    }
    for (let i = projections.length - 2; i >= 0; i = i - 2) {
      projections.splice(i, 1);
    }
    descend(projections, true);
  }
  function expectProjection() {
    const jsxNode2 = jsxValue;
    const slotName = jsxNode2.key;
    vCurrent = vParent.getProp(
      slotName,
      (id) => vnode_locate(container.rootVNode, id)
    );
    vCurrent = vCurrent && vCurrent.flags & 32 /* Deleted */ ? null : vCurrent;
    if (vCurrent == null) {
      vNewNode = vnode_newVirtual();
      isDev6 && vNewNode.setProp(DEBUG_TYPE, "P" /* Projection */);
      isDev6 && vNewNode.setProp("q:code", "expectProjection");
      vNewNode.setProp(QSlot, slotName);
      vNewNode.slotParent = vParent;
      vParent.setProp(slotName, vNewNode);
    }
  }
  function expectSlot() {
    const vHost = vnode_getProjectionParentComponent(vParent);
    const slotNameKey = getSlotNameKey(vHost);
    const vProjectedNode = vHost ? vHost.getProp(
      slotNameKey,
      // for slots this id is vnode ref id
      null
      // Projections should have been resolved through container.ensureProjectionResolved
      //(id) => vnode_locate(container.rootVNode, id)
    ) : null;
    if (vProjectedNode == null) {
      vnode_insertBefore(
        journal,
        vParent,
        vNewNode = vnode_newVirtual(),
        vCurrent && getInsertBefore()
      );
      vNewNode.setProp(QSlot, slotNameKey);
      vHost && vHost.setProp(slotNameKey, vNewNode);
      isDev6 && vNewNode.setProp(DEBUG_TYPE, "P" /* Projection */);
      isDev6 && vNewNode.setProp("q:code", "expectSlot" + count++);
      return false;
    } else if (vProjectedNode === vCurrent) {
    } else {
      vnode_insertBefore(
        journal,
        vParent,
        vNewNode = vProjectedNode,
        vCurrent && getInsertBefore()
      );
      vNewNode.setProp(QSlot, slotNameKey);
      vHost && vHost.setProp(slotNameKey, vNewNode);
      isDev6 && vNewNode.setProp(DEBUG_TYPE, "P" /* Projection */);
      isDev6 && vNewNode.setProp("q:code", "expectSlot" + count++);
    }
    return true;
  }
  function getSlotNameKey(vHost) {
    const jsxNode2 = jsxValue;
    const constProps = jsxNode2.constProps;
    if (constProps && typeof constProps == "object" && "name" in constProps) {
      const constValue = constProps.name;
      if (vHost && constValue instanceof WrappedSignalImpl) {
        return trackSignalAndAssignHost(constValue, vHost, ":" /* COMPONENT */, container);
      }
    }
    return directGetPropsProxyProp(jsxNode2, "name") || QDefaultSlot;
  }
  function cleanupSideBuffer() {
    if (vSideBuffer) {
      for (const vNode of vSideBuffer.values()) {
        if (vNode.flags & 32 /* Deleted */) {
          continue;
        }
        cleanup(container, vNode);
        vnode_remove(journal, vParent, vNode, true);
      }
      vSideBuffer.clear();
      vSideBuffer = null;
    }
    vCurrent = null;
  }
  function drainAsyncQueue() {
    while (asyncQueue.length) {
      const jsxNode2 = asyncQueue.shift();
      const vHostNode = asyncQueue.shift();
      if (isPromise(jsxNode2)) {
        return jsxNode2.then((jsxNode3) => {
          diff(jsxNode3, vHostNode);
          return drainAsyncQueue();
        }).catch((e) => {
          container.handleError(e, vHostNode);
          return drainAsyncQueue();
        });
      } else {
        diff(jsxNode2, vHostNode);
      }
    }
  }
  function expectNoChildren() {
    const vFirstChild = vCurrent && vnode_getFirstChild(vCurrent);
    if (vFirstChild !== null) {
      let vChild = vFirstChild;
      while (vChild) {
        cleanup(container, vChild);
        vChild = vChild.nextSibling;
      }
      vnode_truncate(journal, vCurrent, vFirstChild);
    }
  }
  function expectNoMore() {
    assertFalse(vParent === vCurrent, "Parent and current can't be the same");
    if (vCurrent !== null) {
      while (vCurrent) {
        const toRemove = vCurrent;
        advanceToNextSibling();
        if (vParent === toRemove.parent) {
          cleanup(container, toRemove);
          vnode_remove(journal, vParent, toRemove, true);
        }
      }
    }
  }
  function expectNoMoreTextNodes() {
    while (vCurrent !== null && vnode_isTextVNode(vCurrent)) {
      cleanup(container, vCurrent);
      const toRemove = vCurrent;
      advanceToNextSibling();
      vnode_remove(journal, vParent, toRemove, true);
    }
  }
  function createNewElement(jsx2, elementName, currentFile) {
    const element = createElementWithNamespace(elementName);
    function setAttribute(key2, value, vHost) {
      value = serializeAttribute(key2, value, scopedStyleIdPrefix);
      if (value != null) {
        if (vHost.flags & 64 /* NS_svg */) {
          const namespace = getAttributeNamespace(key2);
          if (namespace) {
            element.setAttributeNS(namespace, key2, String(value));
            return;
          }
        }
        element.setAttribute(key2, String(value));
      }
    }
    const { constProps } = jsx2;
    let needsQDispatchEventPatch = false;
    if (constProps) {
      for (const key2 in constProps) {
        let value = constProps[key2];
        if (isHtmlAttributeAnEventName(key2)) {
          const data = getEventDataFromHtmlAttribute(key2);
          if (data) {
            const scope = data[0];
            const eventName = data[1];
            if (eventName) {
              vNewNode.setProp(HANDLER_PREFIX + ":" + scope + ":" + eventName, value);
              if (scope) {
                vNewNode.setAttr(key2, "", journal);
              }
              registerQwikLoaderEvent(eventName);
            }
          }
          needsQDispatchEventPatch = true;
          continue;
        }
        if (key2 === "ref") {
          if (isSignal(value)) {
            value.value = element;
            continue;
          } else if (typeof value === "function") {
            value(element);
            continue;
          } else if (value == null) {
            continue;
          } else {
            throw qError(15 /* invalidRefValue */, [currentFile]);
          }
        }
        if (isSignal(value)) {
          const vHost = vNewNode;
          const signal = value;
          value = retryOnPromise(
            () => trackSignalAndAssignHost(signal, vHost, key2, container, CONST_SUBSCRIPTION_DATA)
          );
        }
        if (isPromise(value)) {
          const vHost = vNewNode;
          value.then((resolvedValue) => setAttribute(key2, resolvedValue, vHost));
          continue;
        }
        if (key2 === dangerouslySetInnerHTML) {
          if (value) {
            element.innerHTML = String(value);
            element.setAttribute(QContainerAttr, "html" /* HTML */);
          }
          continue;
        }
        if (elementName === "textarea" && key2 === "value") {
          if (value && typeof value !== "string") {
            if (isDev6) {
              throw qError(23 /* wrongTextareaValue */, [currentFile, value]);
            }
            continue;
          }
          element.value = escapeHTML(value || "");
          continue;
        }
        setAttribute(key2, value, vNewNode);
      }
    }
    const key = jsx2.key;
    if (key) {
      vNewNode.setProp(ELEMENT_KEY, key);
    }
    if (scopedStyleIdPrefix) {
      const classAttributeExists = hasClassAttr(jsx2.varProps) || jsx2.constProps && hasClassAttr(jsx2.constProps);
      if (!classAttributeExists) {
        element.setAttribute("class", scopedStyleIdPrefix);
      }
    }
    vnode_insertBefore(journal, vParent, vNewNode, vCurrent);
    return needsQDispatchEventPatch;
  }
  function createElementWithNamespace(elementName) {
    const domParentVNode = vnode_getDomParentVNode(vParent);
    const { elementNamespace, elementNamespaceFlag } = getNewElementNamespaceData(
      domParentVNode,
      elementName
    );
    const element = container.document.createElementNS(elementNamespace, elementName);
    vNewNode = vnode_newElement(element, elementName);
    vNewNode.flags |= elementNamespaceFlag;
    return element;
  }
  function expectElement(jsx2, elementName) {
    const isSameElementName = vCurrent && vnode_isElementVNode(vCurrent) && elementName === vnode_getElementName(vCurrent);
    const jsxKey = jsx2.key;
    let needsQDispatchEventPatch = false;
    const currentKey = getKey(vCurrent);
    if (!isSameElementName || jsxKey !== currentKey) {
      const sideBufferKey = getSideBufferKey(elementName, jsxKey);
      const createNew = () => needsQDispatchEventPatch = createNewElement(jsx2, elementName);
      moveOrCreateKeyedNode(elementName, jsxKey, sideBufferKey, vParent, createNew);
    } else {
      deleteFromSideBuffer(elementName, jsxKey);
    }
    const jsxAttrs = [];
    const props = jsx2.varProps;
    if (jsx2.toSort) {
      const keys = Object.keys(props).sort();
      for (const key of keys) {
        const value = props[key];
        if (value != null) {
          jsxAttrs.push(key, value);
        }
      }
    } else {
      for (const key in props) {
        const value = props[key];
        if (value != null) {
          jsxAttrs.push(key, value);
        }
      }
    }
    if (jsxKey !== null) {
      mapArray_set(jsxAttrs, ELEMENT_KEY, jsxKey, 0);
    }
    const vNode = vNewNode || vCurrent;
    const element = vNode.element;
    if (!element.vNode) {
      element.vNode = vNode;
    }
    needsQDispatchEventPatch = setBulkProps(vNode, jsxAttrs, isDev6 && getFileLocationFromJsx(jsx2.dev) || null) || needsQDispatchEventPatch;
    if (needsQDispatchEventPatch) {
      if (!element.qDispatchEvent) {
        element.qDispatchEvent = (event, scope) => {
          const eventName = fromCamelToKebabCase(event.type);
          const eventProp = ":" + scope.substring(1) + ":" + eventName;
          const qrls = [
            vNode.getProp(eventProp, null),
            vNode.getProp(HANDLER_PREFIX + eventProp, null)
          ];
          let returnValue = false;
          qrls.flat(2).forEach((qrl) => {
            if (qrl) {
              if (isSyncQrl(qrl)) {
                qrl(event, element);
              } else {
                const value = container.$scheduler$(
                  2 /* RUN_QRL */,
                  vNode,
                  qrl,
                  [event, element]
                );
                returnValue = returnValue || value === true;
              }
            }
          });
          return returnValue;
        };
      }
    }
  }
  function setBulkProps(vnode, srcAttrs, currentFile) {
    vnode_ensureElementInflated(vnode);
    const dstAttrs = vnode_getProps(vnode);
    let srcIdx = 0;
    let dstIdx = 0;
    let patchEventDispatch = false;
    const setAttribute = (key, value, vHost) => {
      vHost.setAttr(
        key,
        value !== null ? serializeAttribute(key, value, scopedStyleIdPrefix) : null,
        journal
      );
    };
    const record = (key, value) => {
      if (key.startsWith(":")) {
        vnode.setProp(key, value);
        return;
      }
      if (key === "ref") {
        const element = vnode.element;
        if (isSignal(value)) {
          value.value = element;
          return;
        } else if (typeof value === "function") {
          value(element);
          return;
        } else {
          throw qError(15 /* invalidRefValue */, [currentFile]);
        }
      }
      const currentEffect = vnode[_EFFECT_BACK_REF]?.get(key);
      if (isSignal(value)) {
        const unwrappedSignal = value instanceof WrappedSignalImpl ? value.$unwrapIfSignal$() : value;
        const currentSignal = currentEffect?.[0 /* CONSUMER */];
        if (currentSignal === unwrappedSignal) {
          return;
        }
        if (currentEffect) {
          clearEffectSubscription(container, currentEffect);
        }
        const vHost = vnode;
        value = retryOnPromise(
          () => trackSignalAndAssignHost(
            unwrappedSignal,
            vHost,
            key,
            container,
            NON_CONST_SUBSCRIPTION_DATA
          )
        );
      } else {
        if (currentEffect) {
          clearEffectSubscription(container, currentEffect);
        }
      }
      if (isPromise(value)) {
        const vHost = vnode;
        value.then((resolvedValue) => setAttribute(key, resolvedValue, vHost));
        return;
      }
      setAttribute(key, value, vnode);
    };
    const recordJsxEvent = (key, value) => {
      const data = getEventDataFromHtmlAttribute(key);
      if (data) {
        const [scope, eventName] = data;
        record(":" + scope + ":" + eventName, value);
        registerQwikLoaderEvent(eventName);
        patchEventDispatch = true;
      }
    };
    while (srcIdx < srcAttrs.length || dstIdx < dstAttrs.length) {
      const srcKey = srcIdx < srcAttrs.length ? srcAttrs[srcIdx] : void 0;
      const dstKey = dstIdx < dstAttrs.length ? dstAttrs[dstIdx] : void 0;
      if (dstKey?.startsWith(HANDLER_PREFIX) || dstKey?.startsWith(Q_PREFIX)) {
        dstIdx += 2;
        continue;
      }
      if (srcKey === void 0) {
        if (isHtmlAttributeAnEventName(dstKey)) {
          dstIdx += 2;
        } else {
          record(dstKey, null);
        }
      } else if (dstKey === void 0) {
        const srcValue = srcAttrs[srcIdx + 1];
        if (isHtmlAttributeAnEventName(srcKey)) {
          recordJsxEvent(srcKey, srcValue);
        } else {
          record(srcKey, srcValue);
        }
        srcIdx += 2;
        dstIdx += 2;
      } else if (srcKey === dstKey) {
        const srcValue = srcAttrs[srcIdx + 1];
        const dstValue = dstAttrs[dstIdx + 1];
        const isEventHandler = isHtmlAttributeAnEventName(srcKey);
        if (srcValue !== dstValue) {
          if (isEventHandler) {
            recordJsxEvent(srcKey, srcValue);
          } else {
            record(srcKey, srcValue);
          }
        } else if (isEventHandler && !vnode.element.qDispatchEvent) {
          recordJsxEvent(srcKey, srcValue);
        }
        srcIdx += 2;
        dstIdx += 2;
      } else if (srcKey < dstKey) {
        const srcValue = srcAttrs[srcIdx + 1];
        if (isHtmlAttributeAnEventName(srcKey)) {
          recordJsxEvent(srcKey, srcValue);
        } else {
          record(srcKey, srcValue);
        }
        srcIdx += 2;
        dstIdx += 2;
      } else {
        if (isHtmlAttributeAnEventName(dstKey)) {
          dstIdx += 2;
        } else {
          record(dstKey, null);
        }
      }
    }
    return patchEventDispatch;
  }
  function registerQwikLoaderEvent(eventName) {
    const window2 = container.document.defaultView;
    if (window2) {
      (window2.qwikevents || (window2.qwikevents = [])).push(eventName);
    }
  }
  function retrieveChildWithKey(nodeName, key) {
    let vNodeWithKey = null;
    if (vSiblings === null) {
      vSiblings = /* @__PURE__ */ new Map();
      vSiblingsArray = [];
      let vNode = vCurrent;
      while (vNode) {
        const name = vnode_isElementVNode(vNode) ? vnode_getElementName(vNode) : null;
        const vKey = getKey(vNode) || getComponentHash(vNode, container.$getObjectById$);
        if (vNodeWithKey === null && vKey == key && name == nodeName) {
          vNodeWithKey = vNode;
        } else {
          if (vKey === null) {
            vSiblingsArray.push(name, vNode);
          } else {
            vSiblings.set(getSideBufferKey(name, vKey), vNode);
          }
        }
        vNode = vNode.nextSibling;
      }
    } else {
      if (key === null) {
        for (let i = 0; i < vSiblingsArray.length; i += 2) {
          if (vSiblingsArray[i] === nodeName) {
            vNodeWithKey = vSiblingsArray[i + 1];
            vSiblingsArray.splice(i, 2);
            break;
          }
        }
      } else {
        const siblingsKey = getSideBufferKey(nodeName, key);
        if (vSiblings.has(siblingsKey)) {
          vNodeWithKey = vSiblings.get(siblingsKey);
          vSiblings.delete(siblingsKey);
        }
      }
    }
    collectSideBufferSiblings(vNodeWithKey);
    return vNodeWithKey;
  }
  function collectSideBufferSiblings(targetNode) {
    if (!targetNode) {
      if (vCurrent) {
        const name = vnode_isElementVNode(vCurrent) ? vnode_getElementName(vCurrent) : null;
        const vKey = getKey(vCurrent) || getComponentHash(vCurrent, container.$getObjectById$);
        if (vKey != null) {
          const sideBufferKey = getSideBufferKey(name, vKey);
          vSideBuffer || (vSideBuffer = /* @__PURE__ */ new Map());
          vSideBuffer.set(sideBufferKey, vCurrent);
          vSiblings?.delete(sideBufferKey);
        }
      }
      return;
    }
    let vNode = vCurrent;
    while (vNode && vNode !== targetNode) {
      const name = vnode_isElementVNode(vNode) ? vnode_getElementName(vNode) : null;
      const vKey = getKey(vNode) || getComponentHash(vNode, container.$getObjectById$);
      if (vKey != null) {
        const sideBufferKey = getSideBufferKey(name, vKey);
        vSideBuffer || (vSideBuffer = /* @__PURE__ */ new Map());
        vSideBuffer.set(sideBufferKey, vNode);
        vSiblings?.delete(sideBufferKey);
      }
      vNode = vNode.nextSibling;
    }
  }
  function getSideBufferKey(nodeName, key) {
    if (key == null) {
      return null;
    }
    return nodeName ? nodeName + ":" + key : key;
  }
  function deleteFromSideBuffer(nodeName, key) {
    const sbKey = getSideBufferKey(nodeName, key);
    if (sbKey && vSideBuffer?.has(sbKey)) {
      vSideBuffer.delete(sbKey);
      return true;
    }
    return false;
  }
  function moveOrCreateKeyedNode(nodeName, lookupKey, sideBufferKey, parentForInsert, createNew, addCurrentToSideBufferOnSideInsert) {
    vNewNode = retrieveChildWithKey(nodeName, lookupKey);
    if (vNewNode) {
      vCurrent = vNewNode;
      vNewNode = null;
      return;
    }
    if (sideBufferKey != null) {
      const buffered = vSideBuffer?.get(sideBufferKey) || null;
      if (buffered) {
        vSideBuffer.delete(sideBufferKey);
        if (addCurrentToSideBufferOnSideInsert && vCurrent) {
          const currentKey = getKey(vCurrent) || getComponentHash(vCurrent, container.$getObjectById$);
          if (currentKey != null) {
            const currentName = vnode_isElementVNode(vCurrent) ? vnode_getElementName(vCurrent) : null;
            const currentSideKey = getSideBufferKey(currentName, currentKey);
            if (currentSideKey != null) {
              vSideBuffer || (vSideBuffer = /* @__PURE__ */ new Map());
              vSideBuffer.set(currentSideKey, vCurrent);
            }
          }
        }
        vnode_insertBefore(journal, parentForInsert, buffered, vCurrent);
        vCurrent = buffered;
        vNewNode = null;
        return;
      }
    }
    return createNew();
  }
  function expectVirtual(type, jsxKey) {
    const checkKey = type === "F" /* Fragment */;
    const currentKey = getKey(vCurrent);
    const currentIsVirtual = vCurrent && vnode_isVirtualVNode(vCurrent);
    const isSameNode = currentIsVirtual && currentKey === jsxKey && (checkKey ? !!jsxKey : true);
    if (isSameNode) {
      deleteFromSideBuffer(null, currentKey);
      return;
    }
    const createNew = () => {
      vnode_insertBefore(
        journal,
        vParent,
        vNewNode = vnode_newVirtual(),
        vCurrent && getInsertBefore()
      );
      vNewNode.setProp(ELEMENT_KEY, jsxKey);
      isDev6 && vNewNode.setProp(DEBUG_TYPE, type);
    };
    if (jsxKey === null) {
      createNew();
      return;
    }
    moveOrCreateKeyedNode(
      null,
      jsxKey,
      getSideBufferKey(null, jsxKey),
      vParent,
      createNew,
      true
    );
  }
  function expectComponent(component) {
    const componentMeta = component[SERIALIZABLE_STATE];
    let host = vNewNode || vCurrent;
    const jsxNode2 = jsxValue;
    if (componentMeta) {
      const jsxProps = jsxNode2.props;
      let shouldRender = false;
      const [componentQRL] = componentMeta;
      const componentHash = componentQRL.$hash$;
      const vNodeComponentHash = getComponentHash(host, container.$getObjectById$);
      const lookupKey = jsxNode2.key || componentHash;
      const vNodeLookupKey = getKey(host) || vNodeComponentHash;
      const lookupKeysAreEqual = lookupKey === vNodeLookupKey;
      const hashesAreEqual = componentHash === vNodeComponentHash;
      if (!lookupKeysAreEqual) {
        const createNew = () => {
          insertNewComponent(host, componentQRL, jsxProps);
          shouldRender = true;
        };
        moveOrCreateKeyedNode(null, lookupKey, lookupKey, vParent, createNew);
        host = vNewNode || vCurrent;
      } else if (!hashesAreEqual || !jsxNode2.key) {
        insertNewComponent(host, componentQRL, jsxProps);
        host = vNewNode;
        shouldRender = true;
      } else {
        deleteFromSideBuffer(null, lookupKey);
      }
      if (host) {
        let vNodeProps = host.getProp(
          ELEMENT_PROPS,
          container.$getObjectById$
        );
        let propsAreDifferent = false;
        if (!shouldRender) {
          propsAreDifferent = propsDiffer(
            jsxProps[_CONST_PROPS],
            vNodeProps?.[_CONST_PROPS]
          ) || propsDiffer(
            jsxProps[_VAR_PROPS],
            vNodeProps?.[_VAR_PROPS]
          );
          shouldRender = shouldRender || propsAreDifferent;
        }
        if (shouldRender) {
          if (propsAreDifferent) {
            if (vNodeProps) {
              vNodeProps[_CONST_PROPS] = jsxProps[_CONST_PROPS];
              vNodeProps[_VAR_PROPS] = jsxProps[_VAR_PROPS];
              vNodeProps[_OWNER] = jsxProps[_OWNER];
            } else if (jsxProps) {
              host.setProp(ELEMENT_PROPS, jsxProps);
              vNodeProps = jsxProps;
            }
          }
          host.setProp(OnRenderProp, componentQRL);
          host.flags &= ~32 /* Deleted */;
          container.$scheduler$(6 /* COMPONENT */, host, componentQRL, vNodeProps);
        }
      }
      descendContentToProject(jsxNode2.children, host);
    } else {
      const lookupKey = jsxNode2.key;
      const vNodeLookupKey = getKey(host);
      const lookupKeysAreEqual = lookupKey === vNodeLookupKey;
      const vNodeComponentHash = getComponentHash(host, container.$getObjectById$);
      const isInlineComponent = vNodeComponentHash == null;
      if (host && !isInlineComponent || lookupKey == null) {
        insertNewInlineComponent();
        host = vNewNode;
      } else if (!lookupKeysAreEqual) {
        const createNew = () => {
          insertNewInlineComponent();
        };
        moveOrCreateKeyedNode(null, lookupKey, lookupKey, vParent, createNew);
        host = vNewNode || vCurrent;
      } else {
        deleteFromSideBuffer(null, lookupKey);
      }
      if (host) {
        let componentHost = host;
        while (componentHost && (vnode_isVirtualVNode(componentHost) ? componentHost.getProp(
          OnRenderProp,
          null
        ) === null : true)) {
          componentHost = componentHost.parent;
        }
        const jsxOutput = executeComponent(
          container,
          host,
          componentHost || container.rootVNode,
          component,
          jsxNode2.props
        );
        asyncQueue.push(jsxOutput, host);
      }
    }
  }
  function insertNewComponent(host, componentQRL, jsxProps) {
    if (host) {
      clearAllEffects(container, host);
    }
    vnode_insertBefore(
      journal,
      vParent,
      vNewNode = vnode_newVirtual(),
      vCurrent && getInsertBefore()
    );
    const jsxNode2 = jsxValue;
    isDev6 && vNewNode.setProp(DEBUG_TYPE, "C" /* Component */);
    container.setHostProp(vNewNode, OnRenderProp, componentQRL);
    container.setHostProp(vNewNode, ELEMENT_PROPS, jsxProps);
    container.setHostProp(vNewNode, ELEMENT_KEY, jsxNode2.key);
  }
  function insertNewInlineComponent() {
    vnode_insertBefore(
      journal,
      vParent,
      vNewNode = vnode_newVirtual(),
      vCurrent && getInsertBefore()
    );
    const jsxNode2 = jsxValue;
    isDev6 && vNewNode.setProp(DEBUG_TYPE, "I" /* InlineComponent */);
    vNewNode.setProp(ELEMENT_PROPS, jsxNode2.props);
    if (jsxNode2.key) {
      vNewNode.setProp(ELEMENT_KEY, jsxNode2.key);
    }
  }
  function expectText(text) {
    if (vCurrent !== null) {
      const type = vnode_getType(vCurrent);
      if (type === 3) {
        if (text !== vnode_getText(vCurrent)) {
          vnode_setText(journal, vCurrent, text);
          return;
        }
        return;
      }
    }
    vnode_insertBefore(
      journal,
      vParent,
      vNewNode = vnode_newText(container.document.createTextNode(text), text),
      vCurrent
    );
  }
};
function getKey(vNode) {
  if (vNode == null) {
    return null;
  }
  return vNode.getProp(ELEMENT_KEY, null);
}
function getComponentHash(vNode, getObject) {
  if (vNode == null) {
    return null;
  }
  const qrl = vNode.getProp(OnRenderProp, getObject);
  return qrl ? qrl.$hash$ : null;
}
function Projection() {
}
function propsDiffer(src, dst) {
  const srcEmpty = isPropsEmpty(src);
  const dstEmpty = isPropsEmpty(dst);
  if (srcEmpty && dstEmpty) {
    return false;
  }
  if (srcEmpty || dstEmpty) {
    return true;
  }
  const srcKeys = Object.keys(src);
  const dstKeys = Object.keys(dst);
  let srcLen = srcKeys.length;
  let dstLen = dstKeys.length;
  if ("children" in src) {
    srcLen--;
  }
  if (QBackRefs in src) {
    srcLen--;
  }
  if ("children" in dst) {
    dstLen--;
  }
  if (QBackRefs in dst) {
    dstLen--;
  }
  if (srcLen !== dstLen) {
    return true;
  }
  for (const key of srcKeys) {
    if (key === "children" || key === QBackRefs) {
      continue;
    }
    if (!Object.prototype.hasOwnProperty.call(dst, key) || src[key] !== dst[key]) {
      return true;
    }
  }
  return false;
}
function isPropsEmpty(props) {
  if (!props) {
    return true;
  }
  return Object.keys(props).length === 0;
}
function cleanup(container, vNode) {
  let vCursor = vNode;
  if (vnode_isTextVNode(vNode)) {
    markVNodeAsDeleted(vCursor);
    return;
  }
  let vParent = null;
  do {
    const type = vCursor.flags;
    if (type & 3 /* ELEMENT_OR_VIRTUAL_MASK */) {
      clearAllEffects(container, vCursor);
      markVNodeAsDeleted(vCursor);
      if (type & 2 /* Virtual */) {
        const seq = container.getHostProp(vCursor, ELEMENT_SEQ);
        if (seq) {
          for (let i = 0; i < seq.length; i++) {
            const obj = seq[i];
            if (isTask(obj)) {
              const task = obj;
              clearAllEffects(container, task);
              if (task.$flags$ & 1 /* VISIBLE_TASK */) {
                container.$scheduler$(32 /* CLEANUP_VISIBLE */, task);
              } else {
                cleanupTask(task);
              }
            }
          }
        }
      }
      const isComponent = type & 2 /* Virtual */ && vCursor.getProp(OnRenderProp, null) !== null;
      if (isComponent) {
        const attrs = vnode_getProps(vCursor);
        for (let i = 0; i < attrs.length; i = i + 2) {
          const key = attrs[i];
          if (isSlotProp(key)) {
            const value = attrs[i + 1];
            if (value) {
              attrs[i + 1] = null;
              const projection = typeof value === "string" ? vnode_locate(container.rootVNode, value) : value;
              let projectionChild = vnode_getFirstChild(projection);
              while (projectionChild) {
                cleanup(container, projectionChild);
                projectionChild = projectionChild.nextSibling;
              }
              cleanupStaleUnclaimedProjection(container.$journal$, projection);
            }
          }
        }
      }
      const isProjection = vnode_isProjection(vCursor);
      if (!isProjection) {
        const vFirstChild = vnode_getFirstChild(vCursor);
        if (vFirstChild) {
          vCursor = vFirstChild;
          continue;
        }
      } else if (vCursor === vNode) {
        const vFirstChild = vnode_getFirstChild(vCursor);
        if (vFirstChild) {
          vnode_walkVNode(vFirstChild, (vNode2) => {
            if (vNode2.flags & 2 /* Virtual */) {
              vNode2.slotParent;
            }
          });
          return;
        }
      }
    } else if (type & 4 /* Text */) {
      markVNodeAsDeleted(vCursor);
    }
    if (vCursor === vNode) {
      return;
    }
    const vNextSibling = vCursor.nextSibling;
    if (vNextSibling) {
      vCursor = vNextSibling;
      continue;
    }
    vParent = vCursor.parent;
    while (vParent) {
      if (vParent === vNode) {
        return;
      }
      const vNextParentSibling = vParent.nextSibling;
      if (vNextParentSibling) {
        vCursor = vNextParentSibling;
        break;
      }
      vParent = vParent.parent;
    }
    if (vParent == null) {
      return;
    }
  } while (true);
}
function cleanupStaleUnclaimedProjection(journal, projection) {
  const projectionParent = projection.parent;
  if (projectionParent) {
    const projectionParentType = projectionParent.flags;
    if (projectionParentType & 1 /* Element */ && vnode_getElementName(projectionParent) === QTemplate) {
      vnode_remove(journal, projectionParent, projection, true);
    }
  }
}
function markVNodeAsDeleted(vCursor) {
  vCursor.flags |= 32 /* Deleted */;
}
var HANDLER_PREFIX = ":";
var count = 0;

// packages/qwik/src/core/use/use-resource.ts
var _createResourceReturn = (opts) => {
  const resource = {
    __brand: "resource",
    value: void 0,
    loading: !isServerPlatform(),
    _resolved: void 0,
    _error: void 0,
    _state: "pending",
    _timeout: opts?.timeout ?? -1,
    _cache: 0
  };
  return resource;
};
var createResourceReturn = (container, opts, initialPromise) => {
  const result2 = _createResourceReturn(opts);
  result2.value = initialPromise;
  return createStore(container, result2, 1 /* RECURSIVE */);
};
var runResource = (task, container, host) => {
  task.$flags$ &= ~8 /* DIRTY */;
  cleanupTask(task);
  const iCtx = newInvokeContext(container.$locale$, host, void 0, ResourceEvent);
  iCtx.$container$ = container;
  const taskFn = task.$qrl$.getFn(iCtx, () => clearAllEffects(container, task));
  const resource = task.$state$;
  assertDefined(
    resource,
    'useResource: when running a resource, "task.resource" must be a defined.',
    task
  );
  const track = trackFn(task, container);
  const [cleanup2, cleanups] = cleanupFn(
    task,
    (reason) => container.handleError(reason, host)
  );
  const resourceTarget = unwrapStore(resource);
  const opts = {
    track,
    cleanup: cleanup2,
    cache(policy) {
      let milliseconds = 0;
      if (policy === "immutable") {
        milliseconds = Infinity;
      } else {
        milliseconds = policy;
      }
      resource._cache = milliseconds;
    },
    previous: resourceTarget._resolved
  };
  let resolve;
  let reject;
  let done = false;
  const setState = (resolved, value) => {
    if (!done) {
      done = true;
      if (resolved) {
        done = true;
        resourceTarget.loading = false;
        resourceTarget._state = "resolved";
        resourceTarget._resolved = value;
        resourceTarget._error = void 0;
        resolve(value);
      } else {
        done = true;
        resourceTarget.loading = false;
        resourceTarget._state = "rejected";
        resourceTarget._error = value;
        reject(value);
      }
      if (!isServerPlatform()) {
        forceStoreEffects(resource, "_state");
      }
      return true;
    }
    return false;
  };
  cleanups.push(() => {
    if (untrack(() => resource.loading) === true) {
      const value = untrack(() => resource._resolved);
      setState(true, value);
    }
  });
  invoke(iCtx, () => {
    resource._state = "pending";
    resource.loading = !isServerPlatform();
    resource.value = new Promise((r, re) => {
      resolve = r;
      reject = re;
    });
  });
  const promise = safeCall(
    () => taskFn(opts),
    (value) => {
      setState(true, value);
    },
    (err) => {
      if (isPromise(err)) {
        return err.then(() => runResource(task, container, host));
      } else {
        setState(false, err);
      }
    }
  );
  const timeout = resourceTarget._timeout;
  if (timeout > 0) {
    return Promise.race([
      promise,
      delay(timeout).then(() => {
        if (setState(false, new Error("timeout"))) {
          cleanupTask(task);
        }
      })
    ]);
  }
  return promise;
};

// packages/qwik/src/core/shared/scheduler-rules.ts
var VISIBLE_BLOCKING_RULES = [
  // NODE_DIFF blocks VISIBLE on same host,
  // if the blocked chore is a child of the blocking chore
  // or the blocked chore is a sibling of the blocking chore
  {
    blockedType: 16 /* VISIBLE */,
    blockingType: 4 /* NODE_DIFF */,
    match: (blocked, blocking) => isDescendant(blocked, blocking) || isDescendant(blocking, blocked)
  },
  // COMPONENT blocks VISIBLE on same host
  // if the blocked chore is a child of the blocking chore
  // or the blocked chore is a sibling of the blocking chore
  {
    blockedType: 16 /* VISIBLE */,
    blockingType: 6 /* COMPONENT */,
    match: (blocked, blocking) => isDescendant(blocked, blocking) || isDescendant(blocking, blocked)
  }
];
var BLOCKING_RULES = [
  // QRL_RESOLVE blocks RUN_QRL, TASK, VISIBLE on same host
  {
    blockedType: 2 /* RUN_QRL */,
    blockingType: 1 /* QRL_RESOLVE */,
    match: (blocked, blocking) => {
      const blockedQrl = blocked.$target$;
      const blockingQrl = blocking.$target$;
      return isSameHost(blocked, blocking) && isSameQrl(blockedQrl, blockingQrl);
    }
  },
  {
    blockedType: 3 /* TASK */,
    blockingType: 1 /* QRL_RESOLVE */,
    match: (blocked, blocking) => {
      const blockedTask = blocked.$payload$;
      const blockingQrl = blocking.$target$;
      return isSameHost(blocked, blocking) && isSameQrl(blockedTask.$qrl$, blockingQrl);
    }
  },
  {
    blockedType: 16 /* VISIBLE */,
    blockingType: 1 /* QRL_RESOLVE */,
    match: (blocked, blocking) => {
      const blockedTask = blocked.$payload$;
      const blockingQrl = blocking.$target$;
      return isSameHost(blocked, blocking) && isSameQrl(blockedTask.$qrl$, blockingQrl);
    }
  },
  // COMPONENT blocks NODE_DIFF, NODE_PROP on same host
  {
    blockedType: 4 /* NODE_DIFF */,
    blockingType: 6 /* COMPONENT */,
    match: (blocked, blocking) => blocked.$host$ === blocking.$host$
  },
  {
    blockedType: 5 /* NODE_PROP */,
    blockingType: 6 /* COMPONENT */,
    match: (blocked, blocking) => blocked.$host$ === blocking.$host$
  },
  ...VISIBLE_BLOCKING_RULES,
  // TASK blocks subsequent TASKs in the same component
  {
    blockedType: 3 /* TASK */,
    blockingType: 3 /* TASK */,
    match: (blocked, blocking, container) => {
      if (blocked.$host$ !== blocking.$host$) {
        return false;
      }
      const blockedIdx = blocked.$idx$;
      if (!isNumber(blockedIdx) || blockedIdx <= 0) {
        return false;
      }
      const previousTask = findPreviousTaskInComponent(blocked.$host$, blockedIdx, container);
      return previousTask === blocking.$payload$;
    }
  }
];
function isDescendant(descendantChore, ancestorChore) {
  const descendantHost = descendantChore.$host$;
  const ancestorHost = ancestorChore.$host$;
  if (!vnode_isVNode(descendantHost) || !vnode_isVNode(ancestorHost)) {
    return false;
  }
  return vnode_isDescendantOf(descendantHost, ancestorHost);
}
function isSameHost(a, b) {
  return a.$host$ === b.$host$;
}
function isSameQrl(a, b) {
  return a.$symbol$ === b.$symbol$;
}
function findAncestorBlockingChore(chore, type) {
  const host = chore.$host$;
  if (!vnode_isVNode(host)) {
    return null;
  }
  const isNormalQueue = type === 0 /* CHORES */;
  let current = host;
  current = vnode_getProjectionParentOrParent(current);
  while (current) {
    const blockingChores = isNormalQueue ? current.chores : current.blockedChores;
    if (blockingChores) {
      for (const blockingChore of blockingChores) {
        if (blockingChore.$type$ < 16 /* VISIBLE */ && blockingChore.$type$ !== 3 /* TASK */ && blockingChore.$type$ !== 1 /* QRL_RESOLVE */ && blockingChore.$type$ !== 2 /* RUN_QRL */) {
          return blockingChore;
        }
      }
    }
    current = vnode_getProjectionParentOrParent(current);
  }
  return null;
}
function findBlockingChore(chore, choreQueue, blockedChores, runningChores, container) {
  const blockingChoreInChoreQueue = findAncestorBlockingChore(chore, 0 /* CHORES */);
  if (blockingChoreInChoreQueue) {
    return blockingChoreInChoreQueue;
  }
  const blockingChoreInBlockedChores = findAncestorBlockingChore(
    chore,
    1 /* BLOCKED_CHORES */
  );
  if (blockingChoreInBlockedChores) {
    return blockingChoreInBlockedChores;
  }
  for (const rule of BLOCKING_RULES) {
    if (chore.$type$ !== rule.blockedType) {
      continue;
    }
    for (const candidate of choreQueue) {
      if (candidate.$type$ === rule.blockingType && rule.match(chore, candidate, container)) {
        return candidate;
      }
    }
    for (const candidate of blockedChores) {
      if (candidate.$type$ === rule.blockingType && rule.match(chore, candidate, container)) {
        return candidate;
      }
    }
    for (const candidate of runningChores) {
      if (candidate.$type$ === rule.blockingType && rule.match(chore, candidate, container)) {
        return candidate;
      }
    }
  }
  return null;
}
function findPreviousTaskInComponent(host, currentTaskIdx, container) {
  const elementSeq = container.getHostProp(host, ELEMENT_SEQ);
  if (!elementSeq || elementSeq.length <= currentTaskIdx) {
    return null;
  }
  for (let i = currentTaskIdx - 1; i >= 0; i--) {
    const candidate = elementSeq[i];
    if (candidate instanceof Task && candidate.$flags$ & 2 /* TASK */) {
      return candidate;
    }
  }
  return null;
}
function findBlockingChoreForVisible(chore, runningChores, container) {
  for (const rule of VISIBLE_BLOCKING_RULES) {
    if (chore.$type$ !== rule.blockedType) {
      continue;
    }
    for (const candidate of runningChores) {
      if (candidate.$type$ === rule.blockingType && rule.match(chore, candidate, container)) {
        return candidate;
      }
    }
  }
  return null;
}

// packages/qwik/src/core/shared/platform/next-tick.ts
var createNextTick = (fn) => {
  let nextTick;
  if (typeof setImmediate === "function") {
    nextTick = () => {
      setImmediate(fn);
    };
  } else if (typeof MessageChannel !== "undefined") {
    const channel = new MessageChannel();
    channel.port1.onmessage = () => {
      fn();
    };
    nextTick = () => {
      channel.port2.postMessage(null);
    };
  } else {
    nextTick = () => {
      setTimeout(fn);
    };
  }
  return nextTick;
};

// packages/qwik/src/core/shared/scheduler-document-position.ts
var aVNodePath = [];
var bVNodePath = [];
var vnode_documentPosition = (a, b) => {
  if (a === b) {
    return 0;
  }
  let aDepth = -1;
  let bDepth = -1;
  while (a) {
    const vNode = aVNodePath[++aDepth] = a;
    a = vNode.parent || a.slotParent;
  }
  while (b) {
    const vNode = bVNodePath[++bDepth] = b;
    b = vNode.parent || b.slotParent;
  }
  while (aDepth >= 0 && bDepth >= 0) {
    a = aVNodePath[aDepth];
    b = bVNodePath[bDepth];
    if (a === b) {
      aDepth--;
      bDepth--;
    } else {
      let cursor = b;
      do {
        cursor = cursor.nextSibling;
        if (cursor === a) {
          return 1;
        }
      } while (cursor);
      cursor = b;
      do {
        cursor = cursor.previousSibling;
        if (cursor === a) {
          return -1;
        }
      } while (cursor);
      if (b.slotParent) {
        return -1;
      }
      return 1;
    }
  }
  return aDepth < bDepth ? -1 : 1;
};
var aSsrNodePath = [];
var bSsrNodePath = [];
var ssrNodeDocumentPosition = (a, b) => {
  if (a === b) {
    return 0;
  }
  let aDepth = -1;
  let bDepth = -1;
  while (a) {
    const ssrNode = aSsrNodePath[++aDepth] = a;
    a = ssrNode.parentComponent;
  }
  while (b) {
    const ssrNode = bSsrNodePath[++bDepth] = b;
    b = ssrNode.parentComponent;
  }
  while (aDepth >= 0 && bDepth >= 0) {
    a = aSsrNodePath[aDepth];
    b = bSsrNodePath[bDepth];
    if (a === b) {
      aDepth--;
      bDepth--;
    } else {
      return 1;
    }
  }
  return aDepth < bDepth ? -1 : 1;
};

// packages/qwik/src/core/client/chore-array.ts
var ChoreArray = class extends Array {
  add(value) {
    const idx = sortedFindIndex(this, value);
    if (idx < 0) {
      this.splice(~idx, 0, value);
      return idx;
    }
    const existing = this[idx];
    if (existing.$payload$ !== value.$payload$) {
      existing.$payload$ = value.$payload$;
    }
    return idx;
  }
  delete(value) {
    const idx = this.indexOf(value);
    if (idx >= 0) {
      this.splice(idx, 1);
    }
    return idx;
  }
};
function sortedFindIndex(sortedArray, value) {
  let bottom = 0;
  let top = sortedArray.length;
  while (bottom < top) {
    const middle = bottom + (top - bottom >> 1);
    const midChore = sortedArray[middle];
    const comp = choreComparator(value, midChore);
    if (comp < 0) {
      top = middle;
    } else if (comp > 0) {
      bottom = middle + 1;
    } else {
      return middle;
    }
  }
  return ~bottom;
}
function choreComparator(a, b) {
  const macroTypeDiff = (a.$type$ & 240 /* MACRO */) - (b.$type$ & 240 /* MACRO */);
  if (macroTypeDiff !== 0) {
    return macroTypeDiff;
  }
  const aHost = a.$host$;
  const bHost = b.$host$;
  if (aHost !== bHost && aHost !== null && bHost !== null) {
    if (vnode_isVNode(aHost) && vnode_isVNode(bHost)) {
      const hostDiff = vnode_documentPosition(aHost, bHost);
      if (hostDiff !== 0) {
        return hostDiff;
      }
    } else {
      assertFalse(vnode_isVNode(aHost), "expected aHost to be SSRNode but it is a VNode");
      assertFalse(vnode_isVNode(bHost), "expected bHost to be SSRNode but it is a VNode");
      const hostDiff = ssrNodeDocumentPosition(aHost, bHost);
      if (hostDiff !== 0) {
        return hostDiff;
      }
    }
  }
  const microTypeDiff = (a.$type$ & 15 /* MICRO */) - (b.$type$ & 15 /* MICRO */);
  if (microTypeDiff !== 0) {
    return microTypeDiff;
  }
  const idxDiff = toNumber(a.$idx$) - toNumber(b.$idx$);
  if (idxDiff !== 0) {
    return idxDiff;
  }
  if (a.$target$ !== b.$target$) {
    if (isQrl(a.$target$) && isQrl(b.$target$) && a.$target$.$hash$ === b.$target$.$hash$) {
      return 0;
    }
    return 1;
  }
  if (a.$type$ === 7 /* RECOMPUTE_AND_SCHEDULE_EFFECTS */ && b.$type$ === 7 /* RECOMPUTE_AND_SCHEDULE_EFFECTS */ && (a.$target$ instanceof StoreHandler && b.$target$ instanceof StoreHandler || a.$target$ instanceof AsyncComputedSignalImpl && b.$target$ instanceof AsyncComputedSignalImpl) && a.$payload$ !== b.$payload$) {
    return 1;
  }
  return 0;
}
function toNumber(value) {
  return typeof value === "number" ? value : -1;
}

// packages/qwik/src/core/shared/scheduler.ts
var DEBUG6 = false;
var ChoreState = /* @__PURE__ */ ((ChoreState2) => {
  ChoreState2[ChoreState2["NONE"] = 0] = "NONE";
  ChoreState2[ChoreState2["RUNNING"] = 1] = "RUNNING";
  ChoreState2[ChoreState2["FAILED"] = 2] = "FAILED";
  ChoreState2[ChoreState2["DONE"] = 3] = "DONE";
  return ChoreState2;
})(ChoreState || {});
var getChorePromise = (chore) => chore.$state$ === 0 /* NONE */ ? chore.$returnValue$ || (chore.$returnValue$ = new Promise((resolve, reject) => {
  chore.$resolve$ = resolve;
  chore.$reject$ = reject;
})) : chore.$returnValue$;
var createScheduler = (container, journalFlush, choreQueue, blockedChores, runningChores) => {
  let drainChore = null;
  let drainScheduled = false;
  let isDraining = false;
  let isJournalFlushRunning = false;
  let flushBudgetStart = 0;
  let currentTime = performance.now();
  const nextTick = createNextTick(drainChoreQueue);
  let flushTimerId = null;
  function drainInNextTick() {
    if (!drainScheduled) {
      drainScheduled = true;
      nextTick();
    }
  }
  const FREQUENCY_MS = Math.floor(1e3 / 60);
  return schedule;
  function schedule(type, hostOrTask = null, targetOrQrl = null, payload = null) {
    if (type === 255 /* WAIT_FOR_QUEUE */ && drainChore) {
      return drainChore;
    }
    const isTask2 = type === 3 /* TASK */ || type === 16 /* VISIBLE */ || type === 32 /* CLEANUP_VISIBLE */;
    if (isTask2) {
      hostOrTask.$flags$ |= 8 /* DIRTY */;
    }
    const chore = {
      $type$: type,
      $idx$: isTask2 ? hostOrTask.$index$ : typeof targetOrQrl === "string" ? targetOrQrl : 0,
      $host$: isTask2 ? hostOrTask.$el$ : hostOrTask,
      $target$: targetOrQrl,
      $payload$: isTask2 ? hostOrTask : payload,
      $state$: 0 /* NONE */,
      $blockedChores$: null,
      $startTime$: void 0,
      $endTime$: void 0,
      $resolve$: void 0,
      $reject$: void 0,
      $returnValue$: null
    };
    if (type === 255 /* WAIT_FOR_QUEUE */) {
      getChorePromise(chore);
      drainChore = chore;
      drainInNextTick();
      return chore;
    }
    const isServer6 = isServerPlatform();
    const isClientOnly = type === 4 /* NODE_DIFF */ || type === 1 /* QRL_RESOLVE */;
    if (isServer6 && isClientOnly) {
      DEBUG6 && debugTrace(
        `skip client chore ${debugChoreTypeToString(type)}`,
        chore,
        choreQueue,
        blockedChores
      );
      finishChore(chore, void 0);
      return chore;
    }
    if (isServer6 && chore.$host$ && isSsrNode(chore.$host$)) {
      const isUpdatable = !!(chore.$host$.flags & 1 /* Updatable */);
      if (!isUpdatable) {
        if (
          // backpatching exceptions:
          // - node prop is allowed because it is used to update the node property
          // - recompute and schedule effects because it triggers effects (so node prop too)
          chore.$type$ !== 5 /* NODE_PROP */ && chore.$type$ !== 7 /* RECOMPUTE_AND_SCHEDULE_EFFECTS */
        ) {
          const warningMessage = `A '${choreTypeToName(
            chore.$type$
          )}' chore was scheduled on a host element that has already been streamed to the client.
This can lead to inconsistencies between Server-Side Rendering (SSR) and Client-Side Rendering (CSR).

Problematic chore:
  - Type: ${choreTypeToName(chore.$type$)}
  - Host: ${chore.$host$.toString()}
  - Nearest element location: ${chore.$host$.currentFile}

This is often caused by modifying a signal in an already rendered component during SSR.`;
          logWarn(warningMessage);
          DEBUG6 && debugTrace("schedule.SKIPPED host is not updatable", chore, choreQueue, blockedChores);
          return chore;
        }
      }
    }
    const shouldBlock = chore.$type$ !== 1 /* QRL_RESOLVE */ && chore.$type$ !== 2 /* RUN_QRL */;
    if (shouldBlock) {
      const blockingChore = findBlockingChore(
        chore,
        choreQueue,
        blockedChores,
        runningChores,
        container
      );
      if (blockingChore) {
        addBlockedChore(chore, blockingChore, blockedChores);
        return chore;
      }
      const runningChore = getRunningChore(chore);
      if (runningChore) {
        addBlockedChore(chore, runningChore, blockedChores);
        return chore;
      }
    }
    addChore(chore, choreQueue);
    DEBUG6 && debugTrace("schedule", chore, choreQueue, blockedChores);
    const runImmediately = isServer6 && type === 6 /* COMPONENT */ || type === 2 /* RUN_QRL */;
    if (runImmediately && !isDraining) {
      immediateDrain();
    } else {
      drainInNextTick();
    }
    return chore;
  }
  function immediateDrain() {
    drainScheduled = true;
    drainChoreQueue();
  }
  function cancelFlushTimer() {
    if (flushTimerId != null) {
      clearTimeout(flushTimerId);
      flushTimerId = null;
    }
  }
  function scheduleFlushTimer() {
    const isServer6 = isServerPlatform();
    if (isServer6) {
      return;
    }
    if (flushTimerId != null) {
      return;
    }
    const now2 = performance.now();
    const elapsed = now2 - flushBudgetStart;
    const delay2 = Math.max(0, FREQUENCY_MS - elapsed);
    if (delay2 === 0) {
      if (!isDraining) {
        applyJournalFlush();
      }
      return;
    }
    flushTimerId = setTimeout(() => {
      flushTimerId = null;
      applyJournalFlush();
    }, delay2);
  }
  function applyJournalFlush() {
    if (!isJournalFlushRunning) {
      isJournalFlushRunning = true;
      journalFlush();
      isJournalFlushRunning = false;
      flushBudgetStart = performance.now();
      cancelFlushTimer();
      DEBUG6 && debugTrace("journalFlush.DONE", null, choreQueue, blockedChores);
    }
  }
  function shouldApplyJournalFlush(isServer6) {
    return !isServer6 && currentTime - flushBudgetStart >= FREQUENCY_MS;
  }
  function drainChoreQueue() {
    const isServer6 = isServerPlatform();
    drainScheduled = false;
    if (isDraining) {
      return;
    }
    if (!choreQueue.length) {
      applyJournalFlush();
      if (drainChore && !runningChores.size) {
        drainChore.$resolve$(null);
        drainChore = null;
      }
      return;
    }
    isDraining = true;
    flushBudgetStart = performance.now();
    cancelFlushTimer();
    const maybeFinishDrain = () => {
      if (choreQueue.length) {
        drainInNextTick();
        return false;
      }
      if (drainChore && runningChores.size) {
        if (shouldApplyJournalFlush(isServer6)) {
          applyJournalFlush();
        }
        return false;
      }
      currentChore = null;
      applyJournalFlush();
      drainChore?.$resolve$(null);
      drainChore = null;
      DEBUG6 && debugTrace("drain.DONE", drainChore, choreQueue, blockedChores);
      return true;
    };
    const scheduleBlockedChoresAndDrainIfNeeded = (chore) => {
      let blockedChoresScheduled = false;
      if (chore.$blockedChores$) {
        for (const blockedChore of chore.$blockedChores$) {
          const blockingChore = findBlockingChore(
            blockedChore,
            choreQueue,
            blockedChores,
            runningChores,
            container
          );
          if (blockingChore) {
            (blockingChore.$blockedChores$ || (blockingChore.$blockedChores$ = new ChoreArray())).add(blockedChore);
          } else {
            blockedChores.delete(blockedChore);
            if (vnode_isVNode(blockedChore.$host$)) {
              blockedChore.$host$.blockedChores?.delete(blockedChore);
            }
            addChore(blockedChore, choreQueue);
            DEBUG6 && debugTrace("schedule.UNBLOCKED", blockedChore, choreQueue, blockedChores);
            blockedChoresScheduled = true;
          }
        }
        chore.$blockedChores$ = null;
      }
      if (blockedChoresScheduled && !isDraining) {
        drainInNextTick();
      }
    };
    let currentChore = null;
    try {
      while (choreQueue.length) {
        currentTime = performance.now();
        const chore = currentChore = choreQueue.shift();
        if (chore.$state$ !== 0 /* NONE */) {
          continue;
        }
        if (vNodeAlreadyDeleted(chore) && // we need to process cleanup tasks for deleted nodes
        chore.$type$ !== 32 /* CLEANUP_VISIBLE */) {
          DEBUG6 && debugTrace("skip chore", chore, choreQueue, blockedChores);
          if (vnode_isVNode(chore.$host$)) {
            chore.$host$.chores?.delete(chore);
          }
          continue;
        }
        if (chore.$type$ === 16 /* VISIBLE */) {
          applyJournalFlush();
          const blockingChore = findBlockingChoreForVisible(chore, runningChores, container);
          if (blockingChore && blockingChore.$state$ === 1 /* RUNNING */) {
            addBlockedChore(chore, blockingChore, blockedChores);
            continue;
          }
        }
        chore.$startTime$ = performance.now();
        const result2 = executeChore(chore, isServer6);
        chore.$returnValue$ = result2;
        if (isPromise(result2)) {
          runningChores.add(chore);
          chore.$state$ = 1 /* RUNNING */;
          result2.then((value) => {
            finishChore(chore, value);
          }).catch((e) => {
            if (chore.$state$ !== 1 /* RUNNING */) {
              console.error(e);
              return;
            }
            handleError(chore, e);
          }).finally(() => {
            runningChores.delete(chore);
            scheduleBlockedChoresAndDrainIfNeeded(chore);
            let finished = false;
            if (drainChore && !runningChores.size) {
              finished = maybeFinishDrain();
            }
            if (!finished && !isDraining) {
              scheduleFlushTimer();
            }
          });
        } else {
          finishChore(chore, result2);
          scheduleBlockedChoresAndDrainIfNeeded(chore);
        }
        if (shouldApplyJournalFlush(isServer6)) {
          applyJournalFlush();
          drainInNextTick();
          return;
        }
      }
    } catch (e) {
      handleError(currentChore, e);
      scheduleBlockedChoresAndDrainIfNeeded(currentChore);
    } finally {
      isDraining = false;
      maybeFinishDrain();
    }
  }
  function finishChore(chore, value) {
    chore.$endTime$ = performance.now();
    chore.$state$ = 3 /* DONE */;
    chore.$returnValue$ = value;
    chore.$resolve$?.(value);
    if (vnode_isVNode(chore.$host$)) {
      chore.$host$.chores?.delete(chore);
    }
    DEBUG6 && debugTrace("execute.DONE", chore, choreQueue, blockedChores);
  }
  function handleError(chore, e) {
    chore.$endTime$ = performance.now();
    chore.$state$ = 2 /* FAILED */;
    DEBUG6 && debugTrace("execute.ERROR", chore, choreQueue, blockedChores);
    chore.$reject$?.(e);
    container.handleError(e, chore.$host$);
  }
  function executeChore(chore, isServer6) {
    const host = chore.$host$;
    DEBUG6 && debugTrace("execute", chore, choreQueue, blockedChores);
    let returnValue;
    switch (chore.$type$) {
      case 6 /* COMPONENT */:
        {
          returnValue = safeCall(
            () => executeComponent(
              container,
              host,
              host,
              chore.$target$,
              chore.$payload$
            ),
            (jsx2) => {
              if (isServer6) {
                return jsx2;
              } else {
                const styleScopedId = container.getHostProp(host, QScopedStyle);
                return retryOnPromise(
                  () => vnode_diff(
                    container,
                    jsx2,
                    host,
                    addComponentStylePrefix(styleScopedId)
                  )
                );
              }
            },
            (err) => {
              handleError(chore, err);
            }
          );
        }
        break;
      case 2 /* RUN_QRL */:
        {
          const fn = chore.$target$.getFn();
          returnValue = retryOnPromise(
            () => fn(...chore.$payload$)
          );
        }
        break;
      case 3 /* TASK */:
      case 16 /* VISIBLE */:
        {
          const payload = chore.$payload$;
          if (payload.$flags$ & 4 /* RESOURCE */) {
            returnValue = runResource(
              payload,
              container,
              host
            );
          } else {
            returnValue = runTask(
              payload,
              container,
              host
            );
          }
        }
        break;
      case 32 /* CLEANUP_VISIBLE */:
        {
          const task = chore.$payload$;
          cleanupTask(task);
        }
        break;
      case 4 /* NODE_DIFF */:
        {
          const parentVirtualNode = chore.$target$;
          let jsx2 = chore.$payload$;
          if (isSignal(jsx2)) {
            jsx2 = jsx2.value;
          }
          returnValue = retryOnPromise(
            () => vnode_diff(container, jsx2, parentVirtualNode, null)
          );
        }
        break;
      case 5 /* NODE_PROP */:
        {
          const virtualNode = chore.$host$;
          const payload = chore.$payload$;
          let value = payload.$value$;
          if (isSignal(value)) {
            value = value.value;
          }
          const isConst = payload.$isConst$;
          const journal = container.$journal$;
          const property = chore.$idx$;
          const serializedValue = serializeAttribute(
            property,
            value,
            payload.$scopedStyleIdPrefix$
          );
          if (isServer6) {
            container.addBackpatchEntry(
              chore.$host$.id,
              property,
              serializedValue
            );
            returnValue = null;
          } else {
            if (isConst) {
              const element = virtualNode.element;
              journal.push(2 /* SetAttribute */, element, property, serializedValue);
            } else {
              virtualNode.setAttr(property, serializedValue, journal);
            }
            returnValue = void 0;
          }
        }
        break;
      case 1 /* QRL_RESOLVE */: {
        {
          const target = chore.$target$;
          returnValue = !target.resolved ? target.resolve() : null;
        }
        break;
      }
      case 7 /* RECOMPUTE_AND_SCHEDULE_EFFECTS */: {
        {
          const target = chore.$target$;
          const effects = chore.$payload$;
          if (!effects?.size) {
            break;
          }
          let shouldCompute = target instanceof ComputedSignalImpl || target instanceof WrappedSignalImpl;
          if (target instanceof AsyncComputedSignalImpl && effects !== target.$effects$) {
            shouldCompute = false;
          }
          if (shouldCompute) {
            const ctx = newInvokeContext();
            ctx.$container$ = container;
            returnValue = maybeThen(
              retryOnPromise(
                () => invoke.call(target, ctx, target.$computeIfNeeded$)
              ),
              () => {
                if (target.$flags$ & 2 /* RUN_EFFECTS */) {
                  target.$flags$ &= ~2 /* RUN_EFFECTS */;
                  return retryOnPromise(() => scheduleEffects(container, target, effects));
                }
              }
            );
          } else {
            returnValue = retryOnPromise(() => {
              scheduleEffects(container, target, effects);
            });
          }
        }
        break;
      }
    }
    return returnValue;
  }
  function getRunningChore(chore) {
    if (runningChores.size) {
      for (const runningChore of runningChores) {
        const comp = choreComparator(chore, runningChore);
        if (comp === 0) {
          return runningChore;
        }
      }
    }
    return null;
  }
};
function vNodeAlreadyDeleted(chore) {
  return !!(chore.$host$ && vnode_isVNode(chore.$host$) && chore.$host$.flags & 32 /* Deleted */);
}
function addBlockedChore(blockedChore, blockingChore, blockedChores) {
  var _a5;
  DEBUG6 && debugTrace(
    `blocked chore by ${debugChoreToString(blockingChore)}`,
    blockedChore,
    void 0,
    blockedChores
  );
  (blockingChore.$blockedChores$ || (blockingChore.$blockedChores$ = new ChoreArray())).add(blockedChore);
  blockedChores.add(blockedChore);
  if (vnode_isVNode(blockedChore.$host$)) {
    ((_a5 = blockedChore.$host$).blockedChores || (_a5.blockedChores = new ChoreArray())).add(blockedChore);
  }
}
function addChore(chore, choreArray) {
  var _a5;
  const idx = choreArray.add(chore);
  if (idx < 0 && vnode_isVNode(chore.$host$)) {
    ((_a5 = chore.$host$).chores || (_a5.chores = new ChoreArray())).add(chore);
  }
}
function choreTypeToName(type) {
  return {
    [1 /* QRL_RESOLVE */]: "Resolve QRL",
    [2 /* RUN_QRL */]: "Run QRL",
    [3 /* TASK */]: "Task",
    [4 /* NODE_DIFF */]: "Changes diffing",
    [5 /* NODE_PROP */]: "Updating node property",
    [6 /* COMPONENT */]: "Component",
    [7 /* RECOMPUTE_AND_SCHEDULE_EFFECTS */]: "Signal recompute",
    [16 /* VISIBLE */]: "Visible",
    [32 /* CLEANUP_VISIBLE */]: "Cleanup visible",
    [255 /* WAIT_FOR_QUEUE */]: "Wait for queue"
  }[type] || "Unknown: " + type;
}
function debugChoreTypeToString(type) {
  return {
    [1 /* QRL_RESOLVE */]: "QRL_RESOLVE",
    [2 /* RUN_QRL */]: "RUN_QRL",
    [3 /* TASK */]: "TASK",
    [4 /* NODE_DIFF */]: "NODE_DIFF",
    [5 /* NODE_PROP */]: "NODE_PROP",
    [6 /* COMPONENT */]: "COMPONENT",
    [7 /* RECOMPUTE_AND_SCHEDULE_EFFECTS */]: "RECOMPUTE_SIGNAL",
    [16 /* VISIBLE */]: "VISIBLE",
    [32 /* CLEANUP_VISIBLE */]: "CLEANUP_VISIBLE",
    [255 /* WAIT_FOR_QUEUE */]: "WAIT_FOR_QUEUE"
  }[type] || "UNKNOWN: " + type;
}
function debugChoreToString(chore) {
  const type = debugChoreTypeToString(chore.$type$);
  const state = chore.$state$ ? `[${ChoreState[chore.$state$]}] ` : "";
  const host = String(chore.$host$).replaceAll(/\n.*/gim, "");
  const qrlTarget = chore.$target$?.$symbol$;
  return `${state}Chore(${type} ${chore.$type$ === 1 /* QRL_RESOLVE */ || chore.$type$ === 2 /* RUN_QRL */ ? qrlTarget : host} ${chore.$idx$})`;
}
function debugTrace(action, arg, queue2, blockedChores) {
  const lines = [];
  lines.push(`Scheduler: ${action}`);
  if (arg) {
    lines.push("");
    if (arg && "$type$" in arg) {
      const chore = arg;
      const type = debugChoreTypeToString(chore.$type$);
      const host = String(chore.$host$).replaceAll(/\n.*/gim, "");
      const qrlTarget = chore.$target$?.$symbol$;
      const targetOrHost = chore.$type$ === 1 /* QRL_RESOLVE */ || chore.$type$ === 2 /* RUN_QRL */ ? qrlTarget : host;
      lines.push(`\u{1F3AF} Current Chore:`);
      lines.push(`  Type: ${type}`);
      lines.push(`  Host: ${targetOrHost}`);
      if (chore.$startTime$ && chore.$endTime$) {
        const executionTime = chore.$endTime$ - chore.$startTime$;
        lines.push(`  Time: ${executionTime.toFixed(2)}ms`);
      } else if (chore.$startTime$) {
        const elapsedTime = performance.now() - chore.$startTime$;
        lines.push(`  Time: ${elapsedTime.toFixed(2)}ms (running)`);
      }
      if (chore.$blockedChores$ && chore.$blockedChores$.length > 0) {
        lines.push(`  \u26D4 Blocked Chores:`);
        chore.$blockedChores$.forEach((blockedChore, index) => {
          const blockedType = debugChoreTypeToString(blockedChore.$type$);
          const blockedTarget = String(blockedChore.$host$).replaceAll(/\n.*/gim, "");
          lines.push(`    ${index + 1}. ${blockedType} ${blockedTarget} ${blockedChore.$idx$}`);
        });
      }
    } else {
      lines.push(`\u{1F4DD} Argument: ${String(arg).replaceAll(/\n.*/gim, "")}`);
    }
  }
  if (queue2 && queue2.length > 0) {
    lines.push("");
    lines.push(`\u{1F4CB} Queue (${queue2.length} items):`);
    for (let i = 0; i < queue2.length; i++) {
      const chore = queue2[i];
      const isActive = chore === arg;
      const activeMarker = isActive ? `\u25B6 ` : "  ";
      const type = debugChoreTypeToString(chore.$type$);
      const state = chore.$state$ ? `[${ChoreState[chore.$state$]}]` : "";
      const host = String(chore.$host$).replaceAll(/\n.*/gim, "");
      const qrlTarget = chore.$target$?.$symbol$;
      const target = chore.$type$ === 1 /* QRL_RESOLVE */ || chore.$type$ === 2 /* RUN_QRL */ ? qrlTarget : host;
      const line = `${activeMarker}${state} ${type} ${target} ${chore.$idx$}`;
      lines.push(line);
    }
  }
  if (blockedChores && blockedChores.size > 0) {
    lines.push("");
    lines.push(`\u{1F6AB} Blocked Chores (${blockedChores.size} items):`);
    Array.from(blockedChores).forEach((chore, index) => {
      const type = debugChoreTypeToString(chore.$type$);
      const host = String(chore.$host$).replaceAll(/\n.*/gim, "");
      const qrlTarget = chore.$target$?.$symbol$;
      const target = chore.$type$ === 1 /* QRL_RESOLVE */ || chore.$type$ === 2 /* RUN_QRL */ ? qrlTarget : host;
      lines.push(`  ${index + 1}. ${type} ${target} ${chore.$idx$}`);
    });
  }
  lines.push("");
  lines.push("\u2500".repeat(60));
  console.log(lines.join("\n") + "\n");
}

// packages/qwik/src/core/version.ts
var version = globalThis.QWIK_VERSION;

// packages/qwik/src/core/shared/serdes/serialize.ts
import { isDev as isDev8 } from "@qwik.dev/core/build";

// packages/qwik/src/core/shared/serdes/constants.ts
var _constants = [
  void 0,
  null,
  true,
  false,
  "",
  EMPTY_ARRAY,
  EMPTY_OBJ,
  NEEDS_COMPUTATION,
  STORE_ALL_PROPS,
  _UNINITIALIZED,
  Slot,
  Fragment,
  NaN,
  Infinity,
  -Infinity,
  Number.MAX_SAFE_INTEGER,
  Number.MAX_SAFE_INTEGER - 1,
  Number.MIN_SAFE_INTEGER
];
var _constantNames = [
  "undefined",
  "null",
  "true",
  "false",
  "''",
  "EMPTY_ARRAY",
  "EMPTY_OBJ",
  "NEEDS_COMPUTATION",
  "STORE_ALL_PROPS",
  "_UNINITIALIZED",
  "Slot",
  "Fragment",
  "NaN",
  "Infinity",
  "-Infinity",
  "MAX_SAFE_INTEGER",
  "MAX_SAFE_INTEGER-1",
  "MIN_SAFE_INTEGER"
];
var _typeIdNames = [
  "Plain",
  "RootRef",
  "ForwardRef",
  "Constant",
  "Array",
  "Object",
  "URL",
  "Date",
  "Regex",
  "VNode",
  "RefVNode",
  "BigInt",
  "URLSearchParams",
  "ForwardRefs",
  "Error",
  "Promise",
  "Set",
  "Map",
  "Uint8Array",
  "QRL",
  "PreloadQRL",
  "Task",
  "Resource",
  "Component",
  "Signal",
  "WrappedSignal",
  "ComputedSignal",
  "AsyncComputedSignal",
  "SerializerSignal",
  "Store",
  "FormData",
  "JSXNode",
  "PropsProxy",
  "SubscriptionData"
];

// packages/qwik/src/core/shared/serdes/qrl-to-string.ts
import { isDev as isDev7 } from "@qwik.dev/core/build";
function qrlToString(serializationContext, value, raw) {
  let symbol = value.$symbol$;
  let chunk = value.$chunk$;
  const platform = getPlatform();
  if (platform) {
    const result2 = platform.chunkForSymbol(symbol, chunk, value.dev?.file);
    if (result2) {
      chunk = result2[1];
      symbol = result2[0];
    }
  }
  const isSync = isSyncQrl(value);
  if (!isSync) {
    if (!chunk) {
      chunk = serializationContext.$symbolToChunkResolver$(value.$hash$);
    }
    if (isDev7) {
      const backChannel = globalThis.__qrl_back_channel__ || (globalThis.__qrl_back_channel__ = /* @__PURE__ */ new Map());
      backChannel.set(value.$symbol$, value.resolved);
      if (!chunk) {
        chunk = QRL_RUNTIME_CHUNK;
      }
    }
    if (!chunk) {
      throw qError(14 /* qrlMissingChunk */, [value.$symbol$]);
    }
    if (chunk.startsWith("./")) {
      chunk = chunk.slice(2);
    }
  } else {
    const fn = value.resolved;
    chunk = "";
    symbol = String(serializationContext.$addSyncFn$(null, 0, fn));
  }
  if (!value.$capture$ && Array.isArray(value.$captureRef$) && value.$captureRef$.length > 0) {
    value.$capture$ = value.$captureRef$.map((ref) => `${serializationContext.$addRoot$(ref)}`);
  }
  if (raw) {
    return [chunk, symbol, value.$capture$];
  }
  let qrlStringInline = `${chunk}#${symbol}`;
  if (value.$capture$ && value.$capture$.length > 0) {
    qrlStringInline += `[${value.$capture$.join(" ")}]`;
  }
  return qrlStringInline;
}
function createQRLWithBackChannel(chunk, symbol, captureIds) {
  let qrlRef = null;
  if (isDev7 && chunk === QRL_RUNTIME_CHUNK) {
    const backChannel = globalThis.__qrl_back_channel__;
    assertDefined(backChannel, "Missing QRL_RUNTIME_CHUNK");
    qrlRef = backChannel.get(symbol);
  }
  return createQRL(chunk, symbol, qrlRef, null, captureIds, null);
}
function parseQRL(qrl) {
  const hashIdx = qrl.indexOf("#");
  const captureStart = qrl.indexOf("[", hashIdx);
  const captureEnd = qrl.indexOf("]", captureStart);
  const chunk = hashIdx > -1 ? qrl.slice(0, hashIdx) : qrl.slice(0, captureStart);
  const symbol = captureStart > -1 ? qrl.slice(hashIdx + 1, captureStart) : qrl.slice(hashIdx + 1);
  const captureIds = captureStart > -1 && captureEnd > -1 ? qrl.slice(captureStart + 1, captureEnd).split(" ").filter((v) => v.length).map((s) => parseInt(s, 10)) : null;
  return createQRLWithBackChannel(chunk, symbol, captureIds);
}
var QRL_RUNTIME_CHUNK = "mock-chunk";

// packages/qwik/src/core/shared/serdes/serialize.ts
async function serialize(serializationContext) {
  const {
    $writer$,
    $isSsrNode$,
    $isDomRef$,
    $storeProxyMap$,
    $addRoot$,
    $promoteToRoot$,
    getSeenRef,
    $markSeen$
  } = serializationContext;
  let rootIdx = 0;
  const forwardRefs = [];
  let forwardRefsId = 0;
  const promises = /* @__PURE__ */ new Set();
  const preloadQrls = /* @__PURE__ */ new Set();
  const s11nWeakRefs = /* @__PURE__ */ new Map();
  let parent;
  const qrlMap = /* @__PURE__ */ new Map();
  const outputArray = (value, keepNulls, writeFn) => {
    $writer$.write("[");
    let separator = false;
    let length;
    if (keepNulls) {
      length = value.length;
    } else {
      length = value.length - 1;
      while (length >= 0 && value[length] === null) {
        length--;
      }
      length++;
    }
    for (let i = 0; i < length; i++) {
      if (separator) {
        $writer$.write(",");
      } else {
        separator = true;
      }
      writeFn(value[i], i);
    }
    $writer$.write("]");
  };
  const output = (type, value, keepNulls) => {
    $writer$.write(`${type},`);
    if (typeof value === "number") {
      $writer$.write(value.toString());
    } else if (typeof value === "string") {
      const s = JSON.stringify(value);
      let angleBracketIdx = -1;
      let lastIdx = 0;
      while ((angleBracketIdx = s.indexOf("</", lastIdx)) !== -1) {
        $writer$.write(s.slice(lastIdx, angleBracketIdx));
        $writer$.write("<\\/");
        lastIdx = angleBracketIdx + 2;
      }
      $writer$.write(lastIdx === 0 ? s : s.slice(lastIdx));
    } else {
      outputArray(value, keepNulls, (valueItem, idx) => {
        writeValue(valueItem, idx);
      });
    }
  };
  const addPreloadQrl = (qrl) => {
    if (!isSyncQrl(qrl)) {
      preloadQrls.add(qrl);
      serializationContext.$addRoot$(qrl);
    }
  };
  const getSeenRefOrOutput = (value, index, keepWeak) => {
    let seen = getSeenRef(value);
    const forwardRefIdx = !keepWeak && s11nWeakRefs.get(value);
    if (!seen) {
      if (keepWeak) {
        return true;
      }
      if (typeof forwardRefIdx === "number") {
        seen = $addRoot$(value, true);
      } else {
        return $markSeen$(value, parent, index);
      }
    }
    if (seen.$parent$) {
      if (!parent) {
        $promoteToRoot$(seen, index);
        value = serializationContext.$roots$[index];
      } else {
        $promoteToRoot$(seen);
      }
    }
    if (typeof forwardRefIdx === "number") {
      forwardRefs[forwardRefIdx] = seen.$index$;
      s11nWeakRefs.delete(value);
    }
    const rootIdx2 = value instanceof BackRef2 ? value.$path$ : seen.$index$;
    if (!parent && rootIdx2 === index) {
      return seen;
    }
    output(1 /* RootRef */, rootIdx2);
  };
  const writeValue = (value, index) => {
    if (fastSkipSerialize(value)) {
      output(3 /* Constant */, 0 /* Undefined */);
    } else {
      switch (typeof value) {
        case "undefined":
          output(3 /* Constant */, 0 /* Undefined */);
          break;
        case "boolean":
          output(3 /* Constant */, value ? 2 /* True */ : 3 /* False */);
          break;
        case "number":
          if (Number.isNaN(value)) {
            output(3 /* Constant */, 12 /* NaN */);
          } else if (!Number.isFinite(value)) {
            output(
              3 /* Constant */,
              value < 0 ? 14 /* NegativeInfinity */ : 13 /* PositiveInfinity */
            );
          } else if (value === Number.MAX_SAFE_INTEGER) {
            output(3 /* Constant */, 15 /* MaxSafeInt */);
          } else if (value === Number.MAX_SAFE_INTEGER - 1) {
            output(3 /* Constant */, 16 /* AlmostMaxSafeInt */);
          } else if (value === Number.MIN_SAFE_INTEGER) {
            output(3 /* Constant */, 17 /* MinSafeInt */);
          } else {
            output(0 /* Plain */, value);
          }
          break;
        case "string":
          if (value.length === 0) {
            output(3 /* Constant */, 4 /* EmptyString */);
          } else {
            if (value.length < 4 || getSeenRefOrOutput(value, index)) {
              output(0 /* Plain */, value);
            }
          }
          break;
        case "bigint":
          if (value < 1e4 && value > -1e3 || getSeenRefOrOutput(value, index)) {
            output(11 /* BigInt */, value.toString());
          }
          break;
        case "symbol":
          if (value === NEEDS_COMPUTATION) {
            output(3 /* Constant */, 7 /* NEEDS_COMPUTATION */);
          } else if (value === STORE_ALL_PROPS) {
            output(3 /* Constant */, 8 /* STORE_ALL_PROPS */);
          } else if (value === _UNINITIALIZED) {
            output(3 /* Constant */, 9 /* UNINITIALIZED */);
          }
          break;
        case "function":
          if (value === Slot) {
            output(3 /* Constant */, 10 /* Slot */);
          } else if (value === Fragment) {
            output(3 /* Constant */, 11 /* Fragment */);
          } else if (isQrl(value)) {
            if (getSeenRefOrOutput(value, index)) {
              const [chunk, symbol, captureIds] = qrlToString(serializationContext, value, true);
              let data;
              let type;
              if (chunk !== "") {
                data = `${$addRoot$(chunk)} ${$addRoot$(symbol)}${captureIds ? " " + captureIds.join(" ") : ""}`;
                const existing = qrlMap.get(data);
                if (existing) {
                  const ref = $addRoot$(existing);
                  output(1 /* RootRef */, ref);
                  return;
                } else {
                  qrlMap.set(data, value);
                }
                type = preloadQrls.has(value) ? 20 /* PreloadQRL */ : 19 /* QRL */;
              } else {
                data = Number(symbol);
                type = 19 /* QRL */;
              }
              output(type, data);
            }
          } else if (isQwikComponent(value)) {
            const [qrl] = value[SERIALIZABLE_STATE];
            serializationContext.$renderSymbols$.add(qrl.$symbol$);
            output(23 /* Component */, [qrl]);
          } else {
            throw qError(34 /* serializeErrorCannotSerializeFunction */, [value.toString()]);
          }
          break;
        case "object":
          if (value === EMPTY_ARRAY) {
            output(3 /* Constant */, 5 /* EMPTY_ARRAY */);
          } else if (value === EMPTY_OBJ) {
            output(3 /* Constant */, 6 /* EMPTY_OBJ */);
          } else if (value === null) {
            output(3 /* Constant */, 1 /* Null */);
          } else if (value instanceof BackRef2) {
            output(1 /* RootRef */, value.$path$);
          } else {
            const newSeenRef = getSeenRefOrOutput(value, index);
            if (newSeenRef) {
              const oldParent = parent;
              parent = newSeenRef;
              writeObjectValue(value);
              parent = oldParent;
            }
          }
          break;
        default:
          throw qError(20 /* serializeErrorUnknownType */, [typeof value]);
      }
    }
  };
  const writeObjectValue = (value) => {
    if (isPropsProxy(value)) {
      const owner = value[_OWNER];
      output(32 /* PropsProxy */, [_serializationWeakRef(owner), owner.varProps, owner.constProps]);
    } else if (value instanceof SubscriptionData) {
      output(33 /* SubscriptionData */, [value.data.$scopedStyleIdPrefix$, value.data.$isConst$]);
    } else if (isStore(value)) {
      if (isResource(value)) {
        serializationContext.$resources$.add(value);
        const forwardRefId = resolvePromise(value.value, $addRoot$, (resolved, resolvedValue) => {
          return new PromiseResult(
            22 /* Resource */,
            resolved,
            resolvedValue,
            getStoreHandler(value).$effects$
          );
        });
        output(2 /* ForwardRef */, forwardRefId);
      } else {
        const storeHandler = getStoreHandler(value);
        const storeTarget = getStoreTarget(value);
        const flags = storeHandler.$flags$;
        const effects = storeHandler.$effects$;
        const innerStores = [];
        for (const prop in storeTarget) {
          const propValue = storeTarget[prop];
          const innerStore = $storeProxyMap$.get(propValue);
          if (innerStore) {
            innerStores.push(innerStore);
          }
        }
        const out = [storeTarget, flags, effects, ...innerStores];
        while (out[out.length - 1] == null) {
          out.pop();
        }
        output(29 /* Store */, out);
      }
    } else if (isSerializerObj(value)) {
      const result2 = value[SerializerSymbol](value);
      if (isPromise(result2)) {
        const forwardRef = resolvePromise(result2, $addRoot$, (resolved, resolvedValue) => {
          return new PromiseResult(28 /* SerializerSignal */, resolved, resolvedValue, null, null);
        });
        output(2 /* ForwardRef */, forwardRef);
      } else {
        const index = parent.$index$;
        parent = parent.$parent$;
        writeValue(result2, index);
      }
    } else if (isObjectLiteral(value)) {
      if (Array.isArray(value)) {
        output(4 /* Array */, value);
      } else {
        const out = [];
        for (const key in value) {
          if (Object.prototype.hasOwnProperty.call(value, key)) {
            const subVal = value[key];
            if (!fastSkipSerialize(subVal)) {
              out.push(key, subVal);
            }
          }
        }
        output(5 /* Object */, out.length ? out : 0);
      }
    } else if ($isDomRef$(value)) {
      value.$ssrNode$.vnodeData[0] |= 16 /* SERIALIZE */;
      output(10 /* RefVNode */, value.$ssrNode$.id);
    } else if (value instanceof SignalImpl) {
      if (value instanceof SerializerSignalImpl) {
        addPreloadQrl(value.$computeQrl$);
        const forwardRefId = resolvePromise(
          getCustomSerializerPromise(value, value.$untrackedValue$),
          $addRoot$,
          (resolved, resolvedValue) => {
            return new PromiseResult(
              28 /* SerializerSignal */,
              resolved,
              resolvedValue,
              value.$effects$,
              value.$computeQrl$
            );
          }
        );
        output(2 /* ForwardRef */, forwardRefId);
        return;
      }
      if (value instanceof WrappedSignalImpl) {
        output(25 /* WrappedSignal */, [
          ...serializeWrappingFn(serializationContext, value),
          filterEffectBackRefs(value[_EFFECT_BACK_REF]),
          value.$flags$,
          value.$hostElement$,
          ...value.$effects$ || []
        ]);
      } else if (value instanceof ComputedSignalImpl) {
        let v = value.$untrackedValue$;
        const shouldAlwaysSerialize = value.$flags$ & 32 /* SERIALIZATION_STRATEGY_ALWAYS */;
        const shouldNeverSerialize = value.$flags$ & 16 /* SERIALIZATION_STRATEGY_NEVER */;
        const isInvalid = value.$flags$ & 1 /* INVALID */;
        const isSkippable = fastSkipSerialize(value.$untrackedValue$);
        if (shouldAlwaysSerialize) {
          v = value.$untrackedValue$;
        } else if (shouldNeverSerialize) {
          v = NEEDS_COMPUTATION;
        } else if (isInvalid || isSkippable) {
          v = NEEDS_COMPUTATION;
        }
        addPreloadQrl(value.$computeQrl$);
        const out = [value.$computeQrl$, value.$effects$];
        const isAsync = value instanceof AsyncComputedSignalImpl;
        if (isAsync) {
          out.push(
            value.$loadingEffects$,
            value.$errorEffects$,
            value.$untrackedLoading$,
            value.$untrackedError$
          );
        }
        if (v !== NEEDS_COMPUTATION) {
          out.push(v);
        }
        output(isAsync ? 27 /* AsyncComputedSignal */ : 26 /* ComputedSignal */, out);
      } else {
        output(24 /* Signal */, [value.$untrackedValue$, ...value.$effects$ || []]);
      }
    } else if (value instanceof URL) {
      output(6 /* URL */, value.href);
    } else if (value instanceof Date) {
      output(7 /* Date */, Number.isNaN(value.valueOf()) ? "" : value.valueOf());
    } else if (value instanceof RegExp) {
      output(8 /* Regex */, value.toString());
    } else if (value instanceof Error) {
      const out = [value.message];
      out.push(...Object.entries(value).flat());
      if (isDev8) {
        out.push("stack", value.stack);
      }
      output(14 /* Error */, out);
    } else if ($isSsrNode$(value)) {
      const rootIndex = $addRoot$(value);
      serializationContext.$setProp$(value, ELEMENT_ID, String(rootIndex));
      output(9 /* VNode */, value.id);
      const vNodeData = value.vnodeData;
      if (vNodeData) {
        discoverValuesForVNodeData(vNodeData, (vNodeDataValue) => $addRoot$(vNodeDataValue));
        vNodeData[0] |= 16 /* SERIALIZE */;
      }
      if (value.children) {
        for (const child of value.children) {
          const childVNodeData = child.vnodeData;
          if (childVNodeData) {
            for (const value2 of childVNodeData) {
              if (isSsrAttrs(value2)) {
                const backRefKeyIndex = value2.findIndex((v) => v === QBackRefs);
                if (backRefKeyIndex !== -1) {
                  $addRoot$(value2[backRefKeyIndex + 1]);
                }
              }
            }
            childVNodeData[0] |= 16 /* SERIALIZE */;
          }
        }
      }
    } else if (typeof FormData !== "undefined" && value instanceof FormData) {
      const array = [];
      value.forEach((value2, key) => {
        if (typeof value2 === "string") {
          array.push(key, value2);
        } else {
          array.push(key, value2.name);
        }
      });
      output(30 /* FormData */, array);
    } else if (value instanceof URLSearchParams) {
      output(12 /* URLSearchParams */, value.toString());
    } else if (value instanceof Set) {
      output(16 /* Set */, [...value.values()]);
    } else if (value instanceof Map) {
      const combined = [];
      for (const [k, v] of value.entries()) {
        combined.push(k, v);
      }
      output(17 /* Map */, combined);
    } else if (isJSXNode(value)) {
      const out = [
        value.type,
        value.key,
        value.varProps,
        value.constProps,
        value.children,
        value.toSort || null
      ];
      while (out[out.length - 1] == null) {
        out.pop();
      }
      output(31 /* JSXNode */, out);
    } else if (value instanceof Task) {
      const out = [
        value.$qrl$,
        value.$flags$,
        value.$index$,
        value.$el$,
        value[_EFFECT_BACK_REF],
        value.$state$
      ];
      while (out[out.length - 1] == null) {
        out.pop();
      }
      output(21 /* Task */, out);
    } else if (isPromise(value)) {
      const forwardRefId = resolvePromise(value, $addRoot$, (resolved, resolvedValue) => {
        return new PromiseResult(15 /* Promise */, resolved, resolvedValue);
      });
      output(2 /* ForwardRef */, forwardRefId);
    } else if (value instanceof PromiseResult) {
      if (value.$type$ === 22 /* Resource */) {
        output(22 /* Resource */, [value.$resolved$, value.$value$, value.$effects$]);
      } else if (value.$type$ === 28 /* SerializerSignal */) {
        if (value.$qrl$) {
          output(28 /* SerializerSignal */, [value.$qrl$, value.$effects$, value.$value$]);
        } else if (value.$resolved$) {
          const index = parent.$index$;
          parent = parent.$parent$;
          writeValue(value.$value$, index);
        } else {
          console.error(value.$value$);
          throw qError(33 /* serializerSymbolRejectedPromise */);
        }
      } else {
        output(15 /* Promise */, [value.$resolved$, value.$value$]);
      }
    } else if (value instanceof Uint8Array) {
      let buf = "";
      for (const c of value) {
        buf += String.fromCharCode(c);
      }
      const out = btoa(buf).replace(/=+$/, "");
      output(18 /* Uint8Array */, out);
    } else if (value instanceof SerializationWeakRef) {
      const obj = value.$obj$;
      if (getSeenRefOrOutput(obj, parent.$index$, true)) {
        let forwardRefId = s11nWeakRefs.get(obj);
        if (forwardRefId === void 0) {
          forwardRefId = forwardRefsId++;
          s11nWeakRefs.set(obj, forwardRefId);
          forwardRefs[forwardRefId] = -1;
        }
        output(2 /* ForwardRef */, forwardRefId);
      }
    } else if (vnode_isVNode(value)) {
      output(3 /* Constant */, 0 /* Undefined */);
    } else {
      throw qError(20 /* serializeErrorUnknownType */, [typeof value]);
    }
  };
  function resolvePromise(promise, $addRoot$2, classCreator) {
    const forwardRefId = forwardRefsId++;
    promise.then((resolvedValue) => {
      promises.delete(promise);
      forwardRefs[forwardRefId] = $addRoot$2(classCreator(true, resolvedValue));
    }).catch((err) => {
      promises.delete(promise);
      forwardRefs[forwardRefId] = $addRoot$2(classCreator(false, err));
    });
    promises.add(promise);
    return forwardRefId;
  }
  const outputRoots = async () => {
    $writer$.write("[");
    const { $roots$ } = serializationContext;
    while (rootIdx < $roots$.length || promises.size) {
      if (rootIdx !== 0) {
        $writer$.write(",");
      }
      let separator = false;
      for (; rootIdx < $roots$.length; rootIdx++) {
        if (separator) {
          $writer$.write(",");
        } else {
          separator = true;
        }
        writeValue($roots$[rootIdx], rootIdx);
      }
      if (promises.size) {
        try {
          await Promise.race(promises);
        } catch {
        }
      }
    }
    if (forwardRefs.length) {
      let lastIdx = forwardRefs.length - 1;
      while (lastIdx >= 0 && forwardRefs[lastIdx] === -1) {
        lastIdx--;
      }
      if (lastIdx >= 0) {
        $writer$.write(",");
        $writer$.write(13 /* ForwardRefs */ + ",");
        const out = lastIdx === forwardRefs.length - 1 ? forwardRefs : forwardRefs.slice(0, lastIdx + 1);
        outputArray(out, true, (value) => {
          $writer$.write(String(value));
        });
      }
    }
    $writer$.write("]");
  };
  await outputRoots();
}
var PromiseResult = class {
  constructor($type$, $resolved$, $value$, $effects$ = null, $qrl$ = null) {
    this.$type$ = $type$;
    this.$resolved$ = $resolved$;
    this.$value$ = $value$;
    this.$effects$ = $effects$;
    this.$qrl$ = $qrl$;
  }
};
function getCustomSerializerPromise(signal, value) {
  return new Promise((resolve) => {
    signal.$computeQrl$.resolve().then((arg) => {
      let data;
      if (arg.serialize) {
        data = arg.serialize(value);
      } else if (SerializerSymbol in value) {
        data = value[SerializerSymbol](value);
      }
      if (data === void 0) {
        data = NEEDS_COMPUTATION;
      }
      resolve(data);
    });
  });
}
var discoverValuesForVNodeData = (vnodeData, callback) => {
  for (const value of vnodeData) {
    if (isSsrAttrs(value)) {
      for (let i = 1; i < value.length; i += 2) {
        const keyValue = value[i - 1];
        const attrValue = value[i];
        if (attrValue == null || typeof attrValue === "string" || // skip empty props
        keyValue === ELEMENT_PROPS && Object.keys(attrValue).length === 0) {
          continue;
        }
        callback(attrValue);
      }
    }
  }
};
var isSsrAttrs = (value) => Array.isArray(value) && value.length > 0;
function isObjectLiteral(obj) {
  const prototype = Object.getPrototypeOf(obj);
  return prototype == null || prototype === Object.prototype || prototype === Array.prototype;
}
function isResource(value) {
  return "__brand" in value && value.__brand === "resource";
}
function serializeWrappingFn(serializationContext, value) {
  if (value.$funcStr$ && value.$funcStr$[0] === "{") {
    value.$funcStr$ = `(${value.$funcStr$})`;
  }
  const syncFnId = serializationContext.$addSyncFn$(
    value.$funcStr$,
    value.$args$.length,
    value.$func$
  );
  return [syncFnId, value.$args$];
}
function filterEffectBackRefs(effectBackRef) {
  let effectBackRefToSerialize = null;
  if (effectBackRef) {
    for (const [effectProp, effect] of effectBackRef) {
      if (effect[2 /* BACK_REF */]) {
        effectBackRefToSerialize || (effectBackRefToSerialize = /* @__PURE__ */ new Map());
        effectBackRefToSerialize.set(effectProp, effect);
      }
    }
  }
  return effectBackRefToSerialize;
}
var SerializationWeakRef = class {
  constructor($obj$) {
    this.$obj$ = $obj$;
  }
};
var _serializationWeakRef = (obj) => new SerializationWeakRef(obj);

// packages/qwik/src/core/shared/serdes/serialization-context.ts
var isDomRef = (obj) => false;
var BackRef2 = class {
  constructor($path$) {
    this.$path$ = $path$;
  }
};
var createSerializationContext = (NodeConstructor, DomRefConstructor, symbolToChunkResolver, getProp, setProp, storeProxyMap, writer) => {
  if (!writer) {
    const buffer = [];
    writer = {
      write: (text) => buffer.push(text),
      toString: () => buffer.join("")
    };
  }
  const seenObjsMap = /* @__PURE__ */ new Map();
  const syncFnMap = /* @__PURE__ */ new Map();
  const syncFns = [];
  const roots = [];
  const getSeenRef = (obj) => seenObjsMap.get(obj);
  const $markSeen$ = (obj, parent, index) => {
    const ref = { $index$: index, $parent$: parent };
    seenObjsMap.set(obj, ref);
    return ref;
  };
  const $getObjectPath$ = (ref) => {
    const path = [];
    while (ref.$parent$) {
      path.unshift(ref.$index$);
      ref = ref.$parent$;
    }
    path.unshift(ref.$index$);
    return path.join(" ");
  };
  const $promoteToRoot$ = (ref, index) => {
    const path = $getObjectPath$(ref);
    if (index === void 0) {
      index = roots.length;
    }
    roots[index] = new BackRef2(path);
    ref.$parent$ = null;
    ref.$index$ = index;
  };
  const $addRoot$ = ((obj, returnRef) => {
    let seen = seenObjsMap.get(obj);
    let index;
    if (!seen) {
      index = roots.length;
      seen = {
        $index$: index
        // TODO benchmark with and without $parent$
        // $parent$: undefined
      };
      seenObjsMap.set(obj, seen);
      roots.push(obj);
    } else {
      if (seen.$parent$) {
        $promoteToRoot$(seen);
      }
      index = seen.$index$;
    }
    return returnRef ? seen : index;
  });
  const isSsrNode2 = NodeConstructor ? (obj) => obj instanceof NodeConstructor : (() => false);
  isDomRef = DomRefConstructor ? (obj) => obj instanceof DomRefConstructor : (() => false);
  return {
    async $serialize$() {
      return await serialize(this);
    },
    $isSsrNode$: isSsrNode2,
    $isDomRef$: isDomRef,
    $symbolToChunkResolver$: symbolToChunkResolver,
    getSeenRef,
    $roots$: roots,
    $markSeen$,
    $hasRootId$: (obj) => {
      const id = seenObjsMap.get(obj);
      return id && (id.$parent$ ? void 0 : id.$index$);
    },
    $promoteToRoot$,
    $addRoot$,
    $syncFns$: syncFns,
    $addSyncFn$: (funcStr, argCount, fn) => {
      const isFullFn = funcStr == null;
      if (isFullFn) {
        funcStr = fn.serialized || fn.toString();
      }
      let id = syncFnMap.get(funcStr);
      if (id === void 0) {
        id = syncFns.length;
        syncFnMap.set(funcStr, id);
        if (isFullFn) {
          syncFns.push(funcStr);
        } else {
          let code2 = "(";
          for (let i = 0; i < argCount; i++) {
            code2 += (i == 0 ? "p" : ",p") + i;
          }
          syncFns.push(code2 += ")=>" + funcStr);
        }
      }
      return id;
    },
    $writer$: writer,
    $eventQrls$: /* @__PURE__ */ new Set(),
    $eventNames$: /* @__PURE__ */ new Set(),
    $resources$: /* @__PURE__ */ new Set(),
    $renderSymbols$: /* @__PURE__ */ new Set(),
    $storeProxyMap$: storeProxyMap,
    $getProp$: getProp,
    $setProp$: setProp
  };
};

// packages/qwik/src/core/shared/shared-container.ts
var _SharedContainer = class {
  constructor(journalFlush, serverData, locale) {
    __publicField(this, "$version$");
    __publicField(this, "$scheduler$");
    __publicField(this, "$storeProxyMap$");
    /// Current language locale
    __publicField(this, "$locale$");
    /// Retrieve Object from paused serialized state.
    __publicField(this, "$getObjectById$");
    __publicField(this, "$serverData$");
    __publicField(this, "$currentUniqueId$", 0);
    __publicField(this, "$instanceHash$", null);
    __publicField(this, "$buildBase$", null);
    __publicField(this, "$flushEpoch$", 0);
    this.$serverData$ = serverData;
    this.$locale$ = locale;
    this.$version$ = version;
    this.$storeProxyMap$ = /* @__PURE__ */ new WeakMap();
    this.$getObjectById$ = (_id) => {
      throw Error("Not implemented");
    };
    const choreQueue = new ChoreArray();
    const blockedChores = /* @__PURE__ */ new Set();
    const runningChores = /* @__PURE__ */ new Set();
    this.$scheduler$ = createScheduler(
      this,
      journalFlush,
      choreQueue,
      blockedChores,
      runningChores
    );
  }
  trackSignalValue(signal, subscriber, property, data) {
    return trackSignalAndAssignHost(signal, subscriber, property, this, data);
  }
  serializationCtxFactory(NodeConstructor, DomRefConstructor, symbolToChunkResolver, writer) {
    return createSerializationContext(
      NodeConstructor,
      DomRefConstructor,
      symbolToChunkResolver,
      this.getHostProp.bind(this),
      this.setHostProp.bind(this),
      this.$storeProxyMap$,
      writer
    );
  }
};

// packages/qwik/src/core/shared/component.public.ts
var componentQrl = (componentQrl3) => {
  function QwikComponent(props, key, flags = 0) {
    assertQrl(componentQrl3);
    assertNumber(flags, "The Qwik Component was not invoked correctly");
    const hash3 = qTest ? "sX" : componentQrl3.$hash$.slice(0, 4);
    const finalKey = hash3 + ":" + (key ? key : "");
    const InnerCmp = () => {
    };
    InnerCmp[SERIALIZABLE_STATE] = [componentQrl3];
    return _jsxSplit(InnerCmp, props, null, props.children, flags, finalKey);
  }
  QwikComponent[SERIALIZABLE_STATE] = [componentQrl3];
  return QwikComponent;
};
var SERIALIZABLE_STATE = Symbol("serializable-data");
var isQwikComponent = (component) => {
  return typeof component == "function" && component[SERIALIZABLE_STATE] !== void 0;
};

// packages/qwik/src/core/shared/serdes/can-serialize.ts
var canSerialize = (value, seen = /* @__PURE__ */ new WeakSet()) => {
  if (value == null || typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "bigint") {
    return true;
  } else if (typeof value === "object") {
    if (seen.has(value)) {
      return true;
    }
    seen.add(value);
    const proto = Object.getPrototypeOf(value);
    if (isStore(value)) {
      value = getStoreTarget(value);
    }
    if (proto == Object.prototype) {
      for (const key in value) {
        if (!canSerialize(
          untrack(() => value[key]),
          seen
        )) {
          return false;
        }
      }
      return true;
    } else if (proto == Array.prototype) {
      for (let i = 0; i < value.length; i++) {
        if (!canSerialize(value[i], seen)) {
          return false;
        }
      }
      return true;
    } else if (isTask(value)) {
      return true;
    } else if (isPropsProxy(value)) {
      return true;
    } else if (isPromise(value)) {
      return true;
    } else if (isJSXNode(value)) {
      return true;
    } else if (value instanceof Error) {
      return true;
    } else if (value instanceof URL) {
      return true;
    } else if (value instanceof Date) {
      return true;
    } else if (value instanceof RegExp) {
      return true;
    } else if (value instanceof URLSearchParams) {
      return true;
    } else if (value instanceof FormData) {
      return true;
    } else if (value instanceof Set) {
      return true;
    } else if (value instanceof Map) {
      return true;
    } else if (value instanceof Uint8Array) {
      return true;
    } else if (value instanceof SubscriptionData) {
      return true;
    } else if (isDomRef?.(value)) {
      return true;
    }
  } else if (typeof value === "function") {
    if (isQrl(value) || isQwikComponent(value) || value === Slot || value === Fragment) {
      return true;
    }
  } else if (value === _UNINITIALIZED || value === NEEDS_COMPUTATION || value === STORE_ALL_PROPS) {
    return true;
  }
  return false;
};

// packages/qwik/src/core/shared/serdes/dump-state.ts
var circularProofJson = (obj, indent) => {
  const seen = /* @__PURE__ */ new WeakSet();
  return JSON.stringify(
    obj,
    (_, value) => {
      if (isObject(value)) {
        if (seen.has(value)) {
          return `[Circular ${value.constructor.name}]`;
        }
        seen.add(value);
      }
      return value;
    },
    indent
  );
};
var printRaw = (value, prefix) => {
  let result2 = vnode_isVNode(value) ? vnode_toString.call(value, 1, "", true).replaceAll(/\n.*/gm, "") : typeof value === "function" ? String(value) : circularProofJson(value, 2);
  if (result2.length > 500) {
    result2 = result2.slice(0, 500) + '"...';
  }
  result2 = result2.replace(/\n/g, "\n" + prefix);
  return result2.includes("\n") ? result2 = `
${prefix}${result2}` : result2;
};
var hasRaw = false;
var _dumpState = (state, color = false, prefix = "", limit = 20) => {
  const RED = color ? "\x1B[31m" : "";
  const RESET = color ? "\x1B[0m" : "";
  const isRoot = prefix === "";
  const out = [];
  for (let i = 0; i < state.length; i++) {
    if (limit && i > 2 * limit) {
      out.push("...");
      break;
    }
    const key = state[i];
    let value = state[++i];
    if (key === 0 /* Plain */) {
      const isRaw = typeof value !== "number" && typeof value !== "string";
      if (isRaw) {
        hasRaw = true;
      }
      const type = `{${isObject(value) ? value.constructor.name : typeof value}}`;
      out.push(`${RED}${type}${RESET} ${printRaw(value, `${prefix}  `)}`);
    } else {
      if (key === 3 /* Constant */) {
        value = constantToName(value);
      } else if (typeof value === "string") {
        value = JSON.stringify(value);
        if (value.length > 120) {
          value = value.slice(0, 120) + '"...';
        }
      } else if (key === 13 /* ForwardRefs */) {
        value = `[
${prefix}  ${value.join(`
${prefix}  `)}
${prefix}]`;
      } else if (Array.isArray(value)) {
        value = value.length ? `[
${_dumpState(value, color, `${prefix}  `)}
${prefix}]` : "[]";
      }
      out.push(`${RED}${typeIdToName(key)}${RESET} ${value}`);
    }
  }
  const result2 = out.map((v, i) => `${prefix}${isRoot ? `${i} ` : ""}${v}`).join("\n");
  if (isRoot) {
    const count2 = hasRaw ? "" : `(${JSON.stringify(state).length} chars)`;
    hasRaw = false;
    return `
${result2}
${count2}`;
  }
  return result2;
};
var typeIdToName = (code2) => {
  return _typeIdNames[code2] || `Unknown(${code2})`;
};
var constantToName = (code2) => {
  return _constantNames[code2] || `Unknown(${code2})`;
};

// packages/qwik/src/core/shared/serdes/deser-proxy.ts
var needsInflation = (typeId) => typeId >= 14 /* Error */ || typeId === 4 /* Array */ || typeId === 5 /* Object */;
var deserializedProxyMap = /* @__PURE__ */ new WeakMap();
var isDeserializerProxy = (value) => {
  return isObject(value) && SERIALIZER_PROXY_UNWRAP in value;
};
var SERIALIZER_PROXY_UNWRAP = Symbol("UNWRAP");
var wrapDeserializerProxy = (container, data) => {
  if (!Array.isArray(data) || // must be an array
  vnode_isVNode(data) || // and not a VNode or Slot
  isDeserializerProxy(data)) {
    return data;
  }
  let proxy = deserializedProxyMap.get(data);
  if (!proxy) {
    const target = Array(data.length / 2).fill(void 0);
    proxy = new Proxy(target, new DeserializationHandler(container, data));
    deserializedProxyMap.set(data, proxy);
  }
  return proxy;
};
var DeserializationHandler = class {
  constructor($container$, $data$) {
    this.$container$ = $container$;
    this.$data$ = $data$;
    __publicField(this, "$length$");
    this.$length$ = this.$data$.length / 2;
  }
  get(target, property, receiver) {
    if (property === SERIALIZER_PROXY_UNWRAP) {
      return target;
    }
    const i = typeof property === "number" ? property : typeof property === "string" ? parseInt(property, 10) : NaN;
    if (Number.isNaN(i) || i < 0 || i >= this.$length$) {
      return Reflect.get(target, property, receiver);
    }
    const idx = i * 2;
    const typeId = this.$data$[idx];
    const value = this.$data$[idx + 1];
    if (typeId === 0 /* Plain */) {
      return value;
    }
    const container = this.$container$;
    const propValue = allocate(container, typeId, value);
    Reflect.set(target, property, propValue);
    this.$data$[idx] = 0 /* Plain */;
    this.$data$[idx + 1] = propValue;
    if (needsInflation(typeId)) {
      inflate(container, propValue, typeId, value);
    }
    return propValue;
  }
  has(target, property) {
    if (property === SERIALIZER_PROXY_UNWRAP) {
      return true;
    }
    return Object.prototype.hasOwnProperty.call(target, property);
  }
  set(target, property, value, receiver) {
    if (property === SERIALIZER_PROXY_UNWRAP) {
      return false;
    }
    const out = Reflect.set(target, property, value, receiver);
    const i = typeof property === "number" ? property : parseInt(property, 10);
    if (Number.isNaN(i) || i < 0 || i >= this.$data$.length / 2) {
      return out;
    }
    const idx = i * 2;
    this.$data$[idx] = 0 /* Plain */;
    this.$data$[idx + 1] = value;
    return true;
  }
};

// packages/qwik/src/core/shared/serdes/allocate.ts
var resolvers = /* @__PURE__ */ new WeakMap();
var pendingStoreTargets = /* @__PURE__ */ new Map();
var allocate = (container, typeId, value) => {
  switch (typeId) {
    case 0 /* Plain */:
      return value;
    case 1 /* RootRef */:
      return container.$getObjectById$(value);
    case 2 /* ForwardRef */:
      if (!container.$forwardRefs$) {
        return _UNINITIALIZED;
      }
      const rootRef = container.$forwardRefs$[value];
      if (rootRef === -1 || rootRef === void 0) {
        return _UNINITIALIZED;
      } else {
        return container.$getObjectById$(rootRef);
      }
    case 13 /* ForwardRefs */:
      return value;
    case 3 /* Constant */:
      return _constants[value];
    case 4 /* Array */:
      return Array(value.length / 2);
    case 5 /* Object */:
      return {};
    case 19 /* QRL */:
    case 20 /* PreloadQRL */: {
      if (typeof value === "string") {
        const data = value.split(" ").map(Number);
        const chunk = container.$getObjectById$(data[0]);
        const symbol = container.$getObjectById$(data[1]);
        const captureIds = data.length > 2 ? data.slice(2) : null;
        return createQRLWithBackChannel(chunk, symbol, captureIds);
      } else {
        return createQRLWithBackChannel("", String(value));
      }
    }
    case 21 /* Task */:
      return new Task(-1, -1, null, null, null, null);
    case 22 /* Resource */: {
      const res = createResourceReturn(
        container,
        // we don't care about the timeout value
        void 0,
        void 0
      );
      res.loading = false;
      return res;
    }
    case 6 /* URL */:
      return new URL(value);
    case 7 /* Date */:
      return new Date(value);
    case 8 /* Regex */:
      const idx = value.lastIndexOf("/");
      return new RegExp(value.slice(1, idx), value.slice(idx + 1));
    case 14 /* Error */:
      return new Error();
    case 23 /* Component */:
      return componentQrl(null);
    case 24 /* Signal */:
      return new SignalImpl(container, 0);
    case 25 /* WrappedSignal */:
      return new WrappedSignalImpl(container, null, null, null);
    case 26 /* ComputedSignal */:
      return new ComputedSignalImpl(container, null);
    case 27 /* AsyncComputedSignal */:
      return new AsyncComputedSignalImpl(container, null);
    case 28 /* SerializerSignal */:
      return new SerializerSignalImpl(container, null);
    case 29 /* Store */: {
      const data = value;
      const t = data[0];
      const v = data[1];
      const storeValue = allocate(container, t, v);
      const store = getOrCreateStore(storeValue, 0 /* NONE */, container);
      if (needsInflation(t)) {
        pendingStoreTargets.set(storeValue, { t, v });
      }
      data[0] = 0 /* Plain */;
      data[1] = storeValue;
      return store;
    }
    case 12 /* URLSearchParams */:
      return new URLSearchParams(value);
    case 30 /* FormData */:
      return new FormData();
    case 31 /* JSXNode */:
      return new JSXNodeImpl(null);
    case 11 /* BigInt */:
      return BigInt(value);
    case 16 /* Set */:
      return /* @__PURE__ */ new Set();
    case 17 /* Map */:
      return /* @__PURE__ */ new Map();
    case 15 /* Promise */:
      let resolve;
      let reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      resolvers.set(promise, [resolve, reject]);
      promise.catch(() => {
      });
      return promise;
    case 18 /* Uint8Array */:
      const encodedLength = value.length;
      const blocks = encodedLength >>> 2;
      const rest = encodedLength & 3;
      const decodedLength = blocks * 3 + (rest ? rest - 1 : 0);
      return new Uint8Array(decodedLength);
    case 32 /* PropsProxy */:
      return createPropsProxy(null);
    case 9 /* VNode */:
      return retrieveVNodeOrDocument(container, value);
    case 10 /* RefVNode */:
      const vNode = retrieveVNodeOrDocument(container, value);
      if (vnode_isVNode(vNode)) {
        ensureMaterialized(vNode);
        return vnode_getNode(vNode);
      } else {
        throw qError(17 /* serializeErrorExpectedVNode */, [typeof vNode]);
      }
    case 33 /* SubscriptionData */:
      return new SubscriptionData({});
    default:
      throw qError(18 /* serializeErrorCannotAllocate */, [typeId]);
  }
};
function retrieveVNodeOrDocument(container, value) {
  return value ? container.rootVNode ? vnode_locate(container.rootVNode, value) : void 0 : container.element?.ownerDocument;
}

// packages/qwik/src/core/shared/serdes/inflate.ts
var inflate = (container, target, typeId, data) => {
  if (typeId === 0 /* Plain */) {
    return;
  }
  if (typeId !== 4 /* Array */ && Array.isArray(data)) {
    data = _eagerDeserializeArray(container, data);
  }
  switch (typeId) {
    case 4 /* Array */:
      _eagerDeserializeArray(container, data, target);
      break;
    case 5 /* Object */:
      if (data === 0) {
        break;
      }
      for (let i2 = 0; i2 < data.length; i2 += 2) {
        const key = data[i2];
        const value = data[i2 + 1];
        target[key] = value;
      }
      break;
    case 19 /* QRL */:
    case 20 /* PreloadQRL */:
      _inflateQRL(container, target);
      if (typeId === 20 /* PreloadQRL */) {
        target.resolve();
      }
      break;
    case 21 /* Task */:
      const task = target;
      const v = data;
      task.$qrl$ = v[0];
      task.$flags$ = v[1];
      task.$index$ = v[2];
      task.$el$ = v[3];
      task[_EFFECT_BACK_REF] = v[4];
      task.$state$ = v[5];
      break;
    case 22 /* Resource */:
      const [resolved, result2, effects] = data;
      const resource = target;
      if (resolved) {
        resource.value = Promise.resolve(result2);
        resource._resolved = result2;
        resource._state = "resolved";
      } else {
        resource.value = Promise.reject(result2);
        resource._error = result2;
        resource._state = "rejected";
      }
      getStoreHandler(target).$effects$ = effects;
      break;
    case 23 /* Component */:
      target[SERIALIZABLE_STATE][0] = data[0];
      break;
    case 29 /* Store */: {
      const store = unwrapStore(target);
      const storeTarget = pendingStoreTargets.get(store);
      if (storeTarget) {
        pendingStoreTargets.delete(store);
        inflate(container, store, storeTarget.t, storeTarget.v);
      }
      const [, flags, effects2] = data;
      const storeHandler = getStoreHandler(target);
      storeHandler.$flags$ = flags;
      storeHandler.$effects$ = effects2;
      break;
    }
    case 24 /* Signal */: {
      const signal = target;
      const d2 = data;
      signal.$untrackedValue$ = d2[0];
      signal.$effects$ = new Set(d2.slice(1));
      break;
    }
    case 25 /* WrappedSignal */: {
      const signal = target;
      const d2 = data;
      signal.$func$ = container.getSyncFn(d2[0]);
      signal.$args$ = d2[1];
      signal[_EFFECT_BACK_REF] = d2[2];
      signal.$untrackedValue$ = NEEDS_COMPUTATION;
      signal.$flags$ = d2[3];
      signal.$flags$ |= 1 /* INVALID */;
      signal.$hostElement$ = d2[4];
      signal.$effects$ = new Set(d2.slice(5));
      inflateWrappedSignalValue(signal);
      break;
    }
    case 27 /* AsyncComputedSignal */: {
      const asyncComputed = target;
      const d2 = data;
      asyncComputed.$computeQrl$ = d2[0];
      asyncComputed.$effects$ = new Set(d2[1]);
      asyncComputed.$loadingEffects$ = new Set(d2[2]);
      asyncComputed.$errorEffects$ = new Set(d2[3]);
      asyncComputed.$untrackedLoading$ = d2[4];
      asyncComputed.$untrackedError$ = d2[5] || null;
      const hasValue = d2.length > 6;
      if (hasValue) {
        asyncComputed.$untrackedValue$ = d2[6];
      }
      asyncComputed.$flags$ |= 1 /* INVALID */;
      break;
    }
    // Inflating a SerializerSignal is the same as inflating a ComputedSignal
    case 28 /* SerializerSignal */:
    case 26 /* ComputedSignal */: {
      const computed = target;
      const d2 = data;
      computed.$computeQrl$ = d2[0];
      computed.$effects$ = new Set(d2[1]);
      const hasValue = d2.length > 2;
      if (hasValue) {
        computed.$untrackedValue$ = d2[2];
        if (typeId === 28 /* SerializerSignal */) {
          computed.$flags$ |= 1 /* INVALID */;
        }
      } else {
        computed.$flags$ |= 1 /* INVALID */;
        computed.$computeQrl$.resolve();
        container.$scheduler$(1 /* QRL_RESOLVE */, null, computed.$computeQrl$);
      }
      break;
    }
    case 14 /* Error */: {
      const d2 = data;
      target.message = d2[0];
      for (let i2 = 1; i2 < d2.length; i2 += 2) {
        target[d2[i2]] = d2[i2 + 1];
      }
      break;
    }
    case 30 /* FormData */: {
      const formData = target;
      const d2 = data;
      for (let i2 = 0; i2 < d2.length; i2++) {
        formData.append(d2[i2++], d2[i2]);
      }
      break;
    }
    case 31 /* JSXNode */: {
      const jsx2 = target;
      const [type, key, varProps, constProps, children, toSort] = data;
      jsx2.type = type;
      jsx2.key = key;
      jsx2.varProps = varProps;
      jsx2.constProps = constProps || null;
      jsx2.children = children;
      jsx2.toSort = !!toSort;
      break;
    }
    case 16 /* Set */: {
      const set = target;
      const d2 = data;
      for (let i2 = 0; i2 < d2.length; i2++) {
        set.add(d2[i2]);
      }
      break;
    }
    case 17 /* Map */: {
      const map = target;
      const d2 = data;
      for (let i2 = 0; i2 < d2.length; i2++) {
        map.set(d2[i2++], d2[i2]);
      }
      break;
    }
    case 15 /* Promise */: {
      const promise = target;
      const [resolved2, result3] = data;
      const [resolve, reject] = resolvers.get(promise);
      if (resolved2) {
        resolve(result3);
      } else {
        reject(result3);
      }
      break;
    }
    case 18 /* Uint8Array */:
      const bytes = target;
      const buf = atob(data);
      let i = 0;
      for (const s of buf) {
        bytes[i++] = s.charCodeAt(0);
      }
      break;
    case 32 /* PropsProxy */:
      const propsProxy = target;
      const d = data;
      let owner = d[0];
      if (owner === _UNINITIALIZED) {
        owner = new JSXNodeImpl(Fragment, d[1], d[2]);
        owner._proxy = propsProxy;
      }
      propsProxy[_OWNER] = owner;
      break;
    case 33 /* SubscriptionData */: {
      const effectData = target;
      effectData.data.$scopedStyleIdPrefix$ = data[0];
      effectData.data.$isConst$ = data[1];
      break;
    }
    default:
      throw qError(16 /* serializeErrorNotImplemented */, [typeId]);
  }
};
var _eagerDeserializeArray = (container, data, output = Array(data.length / 2)) => {
  for (let i = 0; i < data.length; i += 2) {
    output[i / 2] = deserializeData(container, data[i], data[i + 1]);
  }
  return output;
};
function _inflateQRL(container, qrl) {
  if (qrl.$captureRef$) {
    return qrl;
  }
  const captureIds = qrl.$capture$;
  qrl.$captureRef$ = captureIds ? captureIds.map((id) => container.$getObjectById$(id)) : null;
  qrl.$capture$ = null;
  if (container.element) {
    qrl.$setContainer$(container.element);
  }
  return qrl;
}
function deserializeData(container, typeId, value) {
  if (typeId === 0 /* Plain */) {
    return value;
  }
  const propValue = allocate(container, typeId, value);
  if (needsInflation(typeId)) {
    inflate(container, propValue, typeId, value);
  }
  return propValue;
}
function inflateWrappedSignalValue(signal) {
  if (signal.$hostElement$ !== null && vnode_isVNode(signal.$hostElement$)) {
    const hostVNode = signal.$hostElement$;
    const effects = signal.$effects$;
    let hasAttrValue = false;
    if (effects) {
      for (const [_, key] of effects) {
        if (isString(key)) {
          const attrValue = hostVNode.getAttr(key);
          if (attrValue !== null) {
            signal.$untrackedValue$ = attrValue;
            hasAttrValue = true;
            break;
          }
        }
      }
    }
    if (!hasAttrValue) {
      const firstChild = vnode_getFirstChild(hostVNode);
      if (firstChild && hostVNode.firstChild === hostVNode.lastChild && vnode_isTextVNode(firstChild)) {
        signal.$untrackedValue$ = vnode_getText(firstChild);
      }
    }
  }
}

// packages/qwik/src/core/shared/serdes/preprocess-state.ts
import { isServer as isServer5 } from "@qwik.dev/core/build";
import { p as preload2 } from "@qwik.dev/core/preloader";
function preprocessState(data, container) {
  const isRootDeepRef = (type, value) => {
    return type === 1 /* RootRef */ && typeof value === "string";
  };
  const isForwardRefsMap = (type) => {
    return type === 13 /* ForwardRefs */;
  };
  const isPreloadQrlType = (type) => {
    return type === 20 /* PreloadQRL */;
  };
  const processRootRef = (index) => {
    const rootRefPath = data[index + 1].split(" ");
    let object = data;
    let objectType = 1 /* RootRef */;
    let typeIndex = 0;
    let valueIndex = 0;
    let parent = null;
    for (let i = 0; i < rootRefPath.length; i++) {
      parent = object;
      typeIndex = parseInt(rootRefPath[i], 10) * 2;
      valueIndex = typeIndex + 1;
      objectType = object[typeIndex];
      object = object[valueIndex];
      if (objectType === 1 /* RootRef */) {
        const rootRef = object;
        const rootRefTypeIndex = rootRef * 2;
        objectType = data[rootRefTypeIndex];
        object = data[rootRefTypeIndex + 1];
      }
    }
    if (parent) {
      parent[typeIndex] = 1 /* RootRef */;
      parent[valueIndex] = index / 2;
    }
    data[index] = objectType;
    data[index + 1] = object;
  };
  const toPreload = isServer5 ? void 0 : [];
  for (let i = 0; i < data.length; i += 2) {
    if (isRootDeepRef(data[i], data[i + 1])) {
      processRootRef(i);
    } else if (isForwardRefsMap(data[i])) {
      container.$forwardRefs$ = data[i + 1];
    } else if (!isServer5 && isPreloadQrlType(data[i])) {
      const qrl = data[i + 1];
      const chunkIdx = Number(qrl.split(" ")[0]);
      toPreload.push(chunkIdx);
    }
  }
  if (!isServer5) {
    for (const idx of toPreload) {
      const chunkType = data[idx * 2];
      let chunk;
      if (chunkType === 0 /* Plain */) {
        chunk = data[idx * 2 + 1];
      } else if (chunkType === 1 /* RootRef */) {
        const refIdx = data[idx * 2 + 1];
        chunk = data[refIdx * 2 + 1];
      } else {
        continue;
      }
      preload2(chunk, 0.3);
    }
  }
}

// packages/qwik/src/core/shared/serdes/serdes.public.ts
function getObjectById(id, stateData) {
  if (typeof id === "string") {
    id = parseInt(id, 10);
  }
  assertTrue(id < stateData.length, `Invalid reference ${id} >= ${stateData.length}`);
  return stateData[id];
}

// packages/qwik/src/core/shared/serdes/verify.ts
var verifySerializable = (value, preMessage) => {
  const seen = /* @__PURE__ */ new WeakSet();
  return untrack(() => _verifySerializable(value, seen, "_", preMessage));
};
var _verifySerializable = (value, seen, ctx, preMessage) => {
  const unwrapped = unwrapStore(value);
  if (unwrapped == null) {
    return value;
  }
  if (shouldSerialize(unwrapped)) {
    if (typeof unwrapped === "object") {
      if (seen.has(unwrapped)) {
        return value;
      }
      seen.add(unwrapped);
    }
    if (isSignal(unwrapped)) {
      return value;
    }
    if (canSerialize(unwrapped)) {
      return value;
    }
    const typeObj = typeof unwrapped;
    switch (typeObj) {
      case "object":
        if (isPromise(unwrapped)) {
          return value;
        }
        if (isNode(unwrapped)) {
          return value;
        }
        if (isArray(unwrapped)) {
          let expectIndex = 0;
          unwrapped.forEach((v, i) => {
            if (i !== expectIndex) {
              throw qError(3 /* verifySerializable */, [unwrapped]);
            }
            _verifySerializable(v, seen, ctx + "[" + i + "]");
            expectIndex = i + 1;
          });
          return value;
        }
        if (isSerializableObject(unwrapped)) {
          for (const [key, item] of Object.entries(unwrapped)) {
            _verifySerializable(item, seen, ctx + "." + key);
          }
          return value;
        }
        break;
    }
    let message;
    if (preMessage) {
      message = preMessage;
    } else {
      message = "Value cannot be serialized";
    }
    if (ctx !== "_") {
      message += ` in ${ctx},`;
    }
    if (typeObj === "object") {
      message += ` because it's an instance of "${value?.constructor.name}". You might need to use 'noSerialize()' or use an object literal instead. Check out https://qwik.dev/docs/advanced/dollar/`;
    } else if (typeObj === "function") {
      const fnName = value.name;
      message += ` because it's a function named "${fnName}". You might need to convert it to a QRL using $(fn):

const ${fnName} = $(${String(
        value
      )});

Please check out https://qwik.dev/docs/advanced/qrl/ for more information.`;
    }
    throw qError(3 /* verifySerializable */, [message]);
  }
  return value;
};
var noSerializeSet = /* @__PURE__ */ new WeakSet();
var shouldSerialize = (obj) => {
  if (isObject(obj) || isFunction(obj)) {
    return !noSerializeSet.has(obj) && !(NoSerializeSymbol in obj);
  }
  return true;
};
var fastSkipSerialize = (obj) => {
  return !!obj && (isObject(obj) || typeof obj === "function") && (NoSerializeSymbol in obj || noSerializeSet.has(obj));
};
var noSerialize = (input) => {
  if (isObject(input) && input !== null || typeof input === "function") {
    noSerializeSet.add(input);
  }
  return input;
};
var NoSerializeSymbol = Symbol("noSerialize");
var SerializerSymbol = Symbol("serialize");

// packages/qwik/src/core/use/use-context.ts
var createContextId = (name) => {
  assertTrue(/^[\w/.-]+$/.test(name), "Context name must only contain A-Z,a-z,0-9,_,.,-", name);
  return /* @__PURE__ */ Object.freeze({
    id: fromCamelToKebabCase(name)
  });
};
var useContextProvider = (context, newValue) => {
  const { val, set, iCtx } = useSequentialScope();
  if (val !== void 0) {
    return;
  }
  if (qDev) {
    validateContext(context);
  }
  if (qDev && qSerialize) {
    verifySerializable(newValue);
  }
  iCtx.$container$.setContext(iCtx.$hostElement$, context, newValue);
  set(1);
};
var validateContext = (context) => {
  if (!isObject(context) || typeof context.id !== "string" || context.id.length === 0) {
    throw qError(11 /* invalidContext */, [context]);
  }
};

// packages/qwik/src/core/shared/error/error-handling.ts
var ERROR_CONTEXT = /* @__PURE__ */ createContextId("qk-error");
var isRecoverable = (err) => {
  if (err && err instanceof Error) {
    if ("plugin" in err) {
      return false;
    }
  }
  return true;
};

// packages/qwik/src/core/shared/vnode-data-types.ts
var VNodeDataSeparator = {
  REFERENCE_CH: (
    /* ***** */
    `~`
  ),
  // `~` is a reference to the node. Save it.
  REFERENCE: (
    /* ******** */
    126
  ),
  // `~` is a reference to the node. Save it.
  ADVANCE_1_CH: (
    /* ***** */
    `!`
  ),
  // `!` is vNodeData separator skipping 0. (ie next vNode)
  ADVANCE_1: (
    /* ********* */
    33
  ),
  // `!` is vNodeData separator skipping 0. (ie next vNode)
  ADVANCE_2_CH: (
    /* ***** */
    `"`
  ),
  // `"` is vNodeData separator skipping 1.
  ADVANCE_2: (
    /* ********* */
    34
  ),
  // `"` is vNodeData separator skipping 1.
  ADVANCE_4_CH: (
    /* ***** */
    `#`
  ),
  // `#` is vNodeData separator skipping 2.
  ADVANCE_4: (
    /* ********* */
    35
  ),
  // `#` is vNodeData separator skipping 2.
  ADVANCE_8_CH: (
    /* ***** */
    `$`
  ),
  // `$` is vNodeData separator skipping 4.
  ADVANCE_8: (
    /* ********* */
    36
  ),
  // `$` is vNodeData separator skipping 4.
  ADVANCE_16_CH: (
    /* **** */
    `%`
  ),
  // `%` is vNodeData separator skipping 8.
  ADVANCE_16: (
    /* ******** */
    37
  ),
  // `%` is vNodeData separator skipping 8.
  ADVANCE_32_CH: (
    /* **** */
    `&`
  ),
  // `&` is vNodeData separator skipping 16.
  ADVANCE_32: (
    /* ******** */
    38
  ),
  // `&` is vNodeData separator skipping 16.
  ADVANCE_64_CH: (
    /* **** */
    `'`
  ),
  // `'` is vNodeData separator skipping 32.
  ADVANCE_64: (
    /* ******** */
    39
  ),
  // `'` is vNodeData separator skipping 32.
  ADVANCE_128_CH: (
    /* *** */
    `(`
  ),
  // `(` is vNodeData separator skipping 64.
  ADVANCE_128: (
    /* ******* */
    40
  ),
  // `(` is vNodeData separator skipping 64.
  ADVANCE_256_CH: (
    /* *** */
    `)`
  ),
  // `)` is vNodeData separator skipping 128.
  ADVANCE_256: (
    /* ******* */
    41
  ),
  // `)` is vNodeData separator skipping 128.
  ADVANCE_512_CH: (
    /* *** */
    `*`
  ),
  // `*` is vNodeData separator skipping 256.
  ADVANCE_512: (
    /* ******* */
    42
  ),
  // `*` is vNodeData separator skipping 256.
  ADVANCE_1024_CH: (
    /* ** */
    `+`
  ),
  // `+` is vNodeData separator skipping 512.
  ADVANCE_1024: (
    /* ****** */
    43
  ),
  // `+` is vNodeData separator skipping 512.
  ADVANCE_2048_CH: (
    /* *  */
    ","
  ),
  // ',' is vNodeData separator skipping 1024.
  ADVANCE_2048: (
    /* ****** */
    44
  ),
  // ',' is vNodeData separator skipping 1024.
  ADVANCE_4096_CH: (
    /* *  */
    `-`
  ),
  // `-` is vNodeData separator skipping 2048.
  ADVANCE_4096: (
    /* ****** */
    45
  ),
  // `-` is vNodeData separator skipping 2048.
  ADVANCE_8192_CH: (
    /* *  */
    `.`
  ),
  // `.` is vNodeData separator skipping 4096.
  ADVANCE_8192: (
    /* ****** */
    46
  )
  // `.` is vNodeData separator skipping 4096.
};
var VNodeDataChar = {
  OPEN: (
    /* ************** */
    123
  ),
  // `{` is the start of the VNodeData for a virtual element.
  OPEN_CHAR: (
    /* ****** */
    "{"
  ),
  CLOSE: (
    /* ************* */
    125
  ),
  // `}` is the end of the VNodeData for a virtual element.
  CLOSE_CHAR: (
    /* ***** */
    "}"
  ),
  SCOPED_STYLE: (
    /* ******* */
    59
  ),
  // `;` - `q:sstyle` - Style attribute.
  SCOPED_STYLE_CHAR: (
    /* */
    ";"
  ),
  RENDER_FN: (
    /* ********** */
    60
  ),
  // `<` - `q:renderFn' - Component QRL render function (body)
  RENDER_FN_CHAR: (
    /* ** */
    "<"
  ),
  ID: (
    /* ***************** */
    61
  ),
  // `=` - `q:id` - ID of the element.
  ID_CHAR: (
    /* ********* */
    "="
  ),
  PROPS: (
    /* ************** */
    62
  ),
  // `>` - `q:props' - Component Props
  PROPS_CHAR: (
    /* ****** */
    ">"
  ),
  SLOT_PARENT: (
    /* ******** */
    63
  ),
  // `?` - `q:sparent` - Slot parent.
  SLOT_PARENT_CHAR: (
    /*  */
    "?"
  ),
  KEY: (
    /* **************** */
    64
  ),
  // `@` - `q:key` - Element key.
  KEY_CHAR: (
    /* ******** */
    "@"
  ),
  SEQ: (
    /* **************** */
    91
  ),
  // `[` - `q:seq' - Seq value from `useSequentialScope()`
  SEQ_CHAR: (
    /* ******** */
    "["
  ),
  DON_T_USE: (
    /* ********** */
    92
  ),
  // `\` - SKIP because `\` is used as escaping
  DON_T_USE_CHAR: "\\",
  CONTEXT: (
    /* ************ */
    93
  ),
  // `]` - `q:ctx' - Component context/props
  CONTEXT_CHAR: (
    /* **** */
    "]"
  ),
  SEQ_IDX: (
    /* ************ */
    94
  ),
  // `^` - `q:seqIdx' - Sequential scope id
  SEQ_IDX_CHAR: (
    /* **** */
    "^"
  ),
  BACK_REFS: (
    /* ********** */
    96
  ),
  // '`' - `q:brefs' - Effect dependencies/subscriptions
  BACK_REFS_CHAR: (
    /* ** */
    "`"
  ),
  SEPARATOR: (
    /* ********* */
    124
  ),
  // `|` - Separator char to encode any key/value pairs.
  SEPARATOR_CHAR: (
    /* ** */
    "|"
  ),
  SLOT: (
    /* ************** */
    126
  ),
  // `~` - `q:slot' - Slot name
  SLOT_CHAR: (
    /* ******* */
    "~"
  )
};

// packages/qwik/src/core/client/process-vnode-data.ts
function processVNodeData(document2) {
  const Q_CONTAINER = "q:container";
  const Q_CONTAINER_END = "/" + Q_CONTAINER;
  const Q_PROPS_SEPARATOR2 = ":";
  const Q_SHADOW_ROOT = "q:shadowroot";
  const Q_IGNORE = "q:ignore";
  const Q_IGNORE_END = "/" + Q_IGNORE;
  const Q_CONTAINER_ISLAND = "q:container-island";
  const Q_CONTAINER_ISLAND_END = "/" + Q_CONTAINER_ISLAND;
  const qDocument = document2;
  const vNodeDataMap = qDocument.qVNodeData || (qDocument.qVNodeData = /* @__PURE__ */ new WeakMap());
  const prototype = document2.body;
  const getter = (prototype2, name) => {
    let getter2;
    while (prototype2 && !(getter2 = Object.getOwnPropertyDescriptor(prototype2, name)?.get)) {
      prototype2 = Object.getPrototypeOf(prototype2);
    }
    return getter2 || function() {
      return this[name];
    };
  };
  const getAttribute = prototype.getAttribute;
  const hasAttribute = prototype.hasAttribute;
  const getNodeType = getter(prototype, "nodeType");
  const attachVnodeDataAndRefs = (element) => {
    Array.from(element.querySelectorAll('script[type="qwik/vnode"]')).forEach((script2) => {
      script2.setAttribute("type", "x-qwik/vnode");
      const qContainerElement = script2.closest("[q\\:container]");
      qContainerElement.qVnodeData = script2.textContent;
      qContainerElement.qVNodeRefs = /* @__PURE__ */ new Map();
    });
    element.querySelectorAll("[q\\:shadowroot]").forEach((parent) => {
      const shadowRoot = parent.shadowRoot;
      shadowRoot && attachVnodeDataAndRefs(shadowRoot);
    });
  };
  attachVnodeDataAndRefs(document2);
  let NodeType;
  ((NodeType2) => {
    NodeType2[NodeType2["CONTAINER_MASK"] = 1] = "CONTAINER_MASK";
    NodeType2[NodeType2["ELEMENT"] = 2] = "ELEMENT";
    NodeType2[NodeType2["ELEMENT_CONTAINER"] = 3] = "ELEMENT_CONTAINER";
    NodeType2[NodeType2["ELEMENT_SHADOW_ROOT_WRAPPER"] = 6] = "ELEMENT_SHADOW_ROOT_WRAPPER";
    NodeType2[NodeType2["COMMENT_SKIP_START"] = 9] = "COMMENT_SKIP_START";
    NodeType2[NodeType2["COMMENT_SKIP_END"] = 8] = "COMMENT_SKIP_END";
    NodeType2[NodeType2["COMMENT_IGNORE_START"] = 16] = "COMMENT_IGNORE_START";
    NodeType2[NodeType2["COMMENT_IGNORE_END"] = 32] = "COMMENT_IGNORE_END";
    NodeType2[NodeType2["COMMENT_ISLAND_START"] = 65] = "COMMENT_ISLAND_START";
    NodeType2[NodeType2["COMMENT_ISLAND_END"] = 64] = "COMMENT_ISLAND_END";
    NodeType2[NodeType2["OTHER"] = 0] = "OTHER";
  })(NodeType || (NodeType = {}));
  const getFastNodeType = (node) => {
    const nodeType = getNodeType.call(node);
    if (nodeType === 1) {
      const qContainer = getAttribute.call(node, Q_CONTAINER);
      if (qContainer === null) {
        if (hasAttribute.call(node, Q_SHADOW_ROOT)) {
          return 6 /* ELEMENT_SHADOW_ROOT_WRAPPER */;
        }
        const isQElement = hasAttribute.call(node, Q_PROPS_SEPARATOR2);
        return isQElement ? 2 /* ELEMENT */ : 0 /* OTHER */;
      } else {
        return 3 /* ELEMENT_CONTAINER */;
      }
    } else if (nodeType === 8) {
      const nodeValue = node.nodeValue || "";
      if (nodeValue.startsWith(Q_CONTAINER_ISLAND)) {
        return 65 /* COMMENT_ISLAND_START */;
      } else if (nodeValue.startsWith(Q_IGNORE)) {
        return 16 /* COMMENT_IGNORE_START */;
      } else if (nodeValue.startsWith(Q_CONTAINER)) {
        return 9 /* COMMENT_SKIP_START */;
      } else if (nodeValue.startsWith(Q_CONTAINER_ISLAND_END)) {
        return 64 /* COMMENT_ISLAND_END */;
      } else if (nodeValue.startsWith(Q_IGNORE_END)) {
        return 32 /* COMMENT_IGNORE_END */;
      } else if (nodeValue.startsWith(Q_CONTAINER_END)) {
        return 8 /* COMMENT_SKIP_END */;
      }
    }
    return 0 /* OTHER */;
  };
  const isSeparator = (ch) => (
    /* `!` */
    VNodeDataSeparator.ADVANCE_1 <= ch && ch <= VNodeDataSeparator.ADVANCE_8192
  );
  const findVDataSectionEnd = (vData, start, end) => {
    let depth = 0;
    while (true) {
      if (start < end) {
        const ch = vData.charCodeAt(start);
        if (depth === 0 && isSeparator(ch)) {
          break;
        } else {
          if (ch === VNodeDataChar.OPEN) {
            depth++;
          } else if (ch === VNodeDataChar.CLOSE) {
            depth--;
          }
          start++;
        }
      } else {
        break;
      }
    }
    return start;
  };
  const nextSibling = (node) => {
    while (node && (node = node.nextSibling) && getFastNodeType(node) === 0 /* OTHER */) {
    }
    return node;
  };
  const walkContainer = (walker2, containerNode, node, exitNode, vData, qVNodeRefs, prefix) => {
    const vData_length = vData.length;
    let elementIdx = 0;
    let vNodeElementIndex = -1;
    let vData_start = 0;
    let vData_end = 0;
    let ch = 0;
    let needsToStoreRef = -1;
    let nextNode = null;
    const howManyElementsToSkip = () => {
      let elementsToSkip = 0;
      while (isSeparator(ch = vData.charCodeAt(vData_start))) {
        elementsToSkip += 1 << ch - VNodeDataSeparator.ADVANCE_1;
        vData_start++;
        if (vData_start >= vData_length) {
          break;
        }
      }
      return elementsToSkip;
    };
    do {
      if (node === exitNode) {
        return;
      }
      nextNode = null;
      const nodeType = node == containerNode ? 2 /* ELEMENT */ : getFastNodeType(node);
      if (nodeType === 3 /* ELEMENT_CONTAINER */) {
        const container = node;
        let cursor = node;
        while (cursor && !(nextNode = nextSibling(cursor))) {
          cursor = cursor.parentNode;
        }
        walkContainer(
          walker2,
          container,
          node,
          nextNode,
          container.qVnodeData || "",
          container.qVNodeRefs,
          prefix + "  "
        );
      } else if (nodeType === 16 /* COMMENT_IGNORE_START */) {
        let islandNode = node;
        do {
          islandNode = walker2.nextNode();
          if (!islandNode) {
            throw new Error(`Island inside <!--${node?.nodeValue}--> not found!`);
          }
        } while (getFastNodeType(islandNode) !== 65 /* COMMENT_ISLAND_START */);
        nextNode = null;
      } else if (nodeType === 64 /* COMMENT_ISLAND_END */) {
        nextNode = node;
        do {
          nextNode = walker2.nextNode();
          if (!nextNode) {
            throw new Error(`Ignore block not closed!`);
          }
        } while (getFastNodeType(nextNode) !== 32 /* COMMENT_IGNORE_END */);
        nextNode = null;
      } else if (nodeType === 9 /* COMMENT_SKIP_START */) {
        nextNode = node;
        do {
          nextNode = nextSibling(nextNode);
          if (!nextNode) {
            throw new Error(`<!--${node?.nodeValue}--> not closed!`);
          }
        } while (getFastNodeType(nextNode) !== 8 /* COMMENT_SKIP_END */);
        walkContainer(walker2, node, node, nextNode, "", null, prefix + "  ");
      } else if (nodeType === 6 /* ELEMENT_SHADOW_ROOT_WRAPPER */) {
        nextNode = nextSibling(node);
        const shadowRootContainer = node;
        const shadowRoot = shadowRootContainer?.shadowRoot;
        if (shadowRoot) {
          walkContainer(
            // we need to create a new walker for the shadow root
            document2.createTreeWalker(
              shadowRoot,
              1 | 128
              /*  NodeFilter.SHOW_COMMENT */
            ),
            null,
            shadowRoot,
            null,
            "",
            null,
            prefix + "  "
          );
        }
      }
      if ((nodeType & 2 /* ELEMENT */) === 2 /* ELEMENT */) {
        if (vNodeElementIndex < elementIdx) {
          if (vNodeElementIndex === -1) {
            vNodeElementIndex = 0;
          }
          vData_start = vData_end;
          if (vData_start < vData_length) {
            vNodeElementIndex += howManyElementsToSkip();
            const shouldStoreRef = ch === VNodeDataSeparator.REFERENCE;
            if (shouldStoreRef) {
              needsToStoreRef = vNodeElementIndex;
              vData_start++;
              if (vData_start < vData_length) {
                ch = vData.charCodeAt(vData_end);
              } else {
                ch = VNodeDataSeparator.ADVANCE_1;
              }
            }
            vData_end = findVDataSectionEnd(vData, vData_start, vData_length);
          } else {
            vNodeElementIndex = Number.MAX_SAFE_INTEGER;
          }
        }
        if (elementIdx === vNodeElementIndex) {
          if (needsToStoreRef === elementIdx) {
            qVNodeRefs.set(elementIdx, node);
          }
          const instructions = vData.substring(vData_start, vData_end);
          vNodeDataMap.set(node, instructions);
        }
        elementIdx++;
      }
    } while (node = nextNode || walker2.nextNode());
  };
  const walker = document2.createTreeWalker(
    document2,
    1 | 128
    /*  NodeFilter.SHOW_COMMENT */
  );
  walkContainer(walker, null, walker.firstChild(), null, "", null, "");
}

// packages/qwik/src/core/client/dom-container.ts
function getDomContainer(element) {
  const qContainerElement = _getQContainerElement(element);
  if (!qContainerElement) {
    throw qError(24 /* containerNotFound */);
  }
  return getDomContainerFromQContainerElement(qContainerElement);
}
function getDomContainerFromQContainerElement(qContainerElement) {
  const qElement = qContainerElement;
  let container = qElement.qContainer;
  if (!container) {
    container = new DomContainer(qElement);
  }
  return container;
}
function _getQContainerElement(element) {
  const qContainerElement = vnode_isVNode(element) ? vnode_getDomParent(element, true) : element;
  return qContainerElement.closest(QContainerSelector);
}
var isDomContainer = (container) => {
  return container instanceof DomContainer;
};
var DomContainer = class extends _SharedContainer {
  constructor(element) {
    super(
      () => {
        this.$flushEpoch$++;
        vnode_applyJournal(this.$journal$);
      },
      {},
      element.getAttribute(QLocaleAttr)
    );
    __publicField(this, "element");
    __publicField(this, "qContainer");
    __publicField(this, "qManifestHash");
    __publicField(this, "rootVNode");
    __publicField(this, "document");
    __publicField(this, "$journal$");
    __publicField(this, "$rawStateData$");
    __publicField(this, "$storeProxyMap$", /* @__PURE__ */ new WeakMap());
    __publicField(this, "$qFuncs$");
    __publicField(this, "$instanceHash$");
    __publicField(this, "$forwardRefs$", null);
    __publicField(this, "vNodeLocate", (id) => vnode_locate(this.rootVNode, id));
    __publicField(this, "$stateData$");
    __publicField(this, "$styleIds$", null);
    __publicField(this, "$getObjectById$", (id) => {
      return getObjectById(id, this.$stateData$);
    });
    this.qContainer = element.getAttribute(QContainerAttr);
    if (!this.qContainer) {
      throw qError(25 /* elementWithoutContainer */);
    }
    this.$journal$ = [
      // The first time we render we need to hoist the styles.
      // (Meaning we need to move all styles from component inline to <head>)
      // We bulk move all of the styles, because the expensive part is
      // for the browser to recompute the styles, (not the actual DOM manipulation.)
      // By moving all of them at once we can minimize the reflow.
      3 /* HoistStyles */,
      element.ownerDocument
    ];
    this.document = element.ownerDocument;
    this.element = element;
    this.$buildBase$ = element.getAttribute(QBaseAttr);
    this.$instanceHash$ = element.getAttribute(QInstanceAttr);
    this.qManifestHash = element.getAttribute(QManifestHashAttr);
    this.rootVNode = vnode_newUnMaterializedElement(this.element);
    this.$rawStateData$ = [];
    this.$stateData$ = [];
    const document2 = this.element.ownerDocument;
    if (!document2.qVNodeData) {
      processVNodeData(document2);
    }
    this.$qFuncs$ = getQFuncs(document2, this.$instanceHash$) || EMPTY_ARRAY;
    this.$setServerData$();
    element.setAttribute(QContainerAttr, "resumed" /* RESUMED */);
    element.qContainer = this;
    const qwikStates = element.querySelectorAll('script[type="qwik/state"]');
    if (qwikStates.length !== 0) {
      const lastState = qwikStates[qwikStates.length - 1];
      this.$rawStateData$ = JSON.parse(lastState.textContent);
      preprocessState(this.$rawStateData$, this);
      this.$stateData$ = wrapDeserializerProxy(this, this.$rawStateData$);
    }
  }
  $setRawState$(id, vParent) {
    this.$stateData$[id] = vParent;
  }
  parseQRL(qrl) {
    return _inflateQRL(this, parseQRL(qrl));
  }
  handleError(err, host) {
    if (qDev && host) {
      if (typeof document !== "undefined") {
        const vHost = host;
        const journal = [];
        const vHostParent = vHost.parent;
        const vHostNextSibling = vHost.nextSibling;
        const vErrorDiv = vnode_createErrorDiv(document, vHost, err, journal);
        const insertHost = vnode_isElementVNode(vHost) ? vHostParent || vHost : vHost;
        const insertBefore = insertHost === vHost ? null : vHostNextSibling;
        vnode_insertBefore(journal, insertHost, vErrorDiv, insertBefore);
        vnode_applyJournal(journal);
      }
      if (err && err instanceof Error) {
        if (!("hostElement" in err)) {
          err["hostElement"] = String(host);
        }
      }
      if (!isRecoverable(err)) {
        throw err;
      }
    }
    const errorStore = host && this.resolveContext(host, ERROR_CONTEXT);
    if (!errorStore) {
      throw err;
    }
    errorStore.error = err;
  }
  setContext(host, context, value) {
    let ctx = this.getHostProp(host, QCtxAttr);
    if (ctx == null) {
      this.setHostProp(host, QCtxAttr, ctx = []);
    }
    mapArray_set(ctx, context.id, value, 0, true);
  }
  resolveContext(host, contextId) {
    while (host) {
      const ctx = this.getHostProp(host, QCtxAttr);
      if (ctx != null && mapArray_has(ctx, contextId.id, 0)) {
        return mapArray_get(ctx, contextId.id, 0);
      }
      host = this.getParentHost(host);
    }
    return void 0;
  }
  getParentHost(host) {
    let vNode = host.parent;
    while (vNode) {
      if (vnode_isVirtualVNode(vNode)) {
        if (vNode.getProp(OnRenderProp, null) !== null) {
          return vNode;
        }
        vNode = vNode.parent || // If virtual node, than it could be a slot so we need to read its parent.
        vNode.slotParent;
      } else {
        vNode = vNode.parent;
      }
    }
    return null;
  }
  setHostProp(host, name, value) {
    const vNode = host;
    vNode.setProp(name, value);
  }
  getHostProp(host, name) {
    const vNode = host;
    let getObjectById2 = null;
    switch (name) {
      case ELEMENT_SEQ:
      case ELEMENT_PROPS:
      case OnRenderProp:
      case QCtxAttr:
      case QBackRefs:
        getObjectById2 = this.$getObjectById$;
        break;
      case ELEMENT_SEQ_IDX:
      case USE_ON_LOCAL_SEQ_IDX:
        getObjectById2 = parseInt;
        break;
    }
    return vNode.getProp(name, getObjectById2);
  }
  ensureProjectionResolved(vNode) {
    if ((vNode.flags & 16 /* Resolved */) === 0) {
      vNode.flags |= 16 /* Resolved */;
      const props = vnode_getProps(vNode);
      for (let i = 0; i < props.length; i = i + 2) {
        const prop = props[i];
        if (isSlotProp(prop)) {
          const value = props[i + 1];
          if (typeof value == "string") {
            const projection = this.vNodeLocate(value);
            props[i + 1] = projection;
          }
        }
      }
    }
  }
  getSyncFn(id) {
    const fn = this.$qFuncs$[id];
    assertTrue(typeof fn === "function", "Invalid reference: " + id);
    return fn;
  }
  $appendStyle$(content, styleId, host, scoped) {
    if (scoped) {
      const scopedStyleIdsString = this.getHostProp(host, QScopedStyle);
      const scopedStyleIds = new Set(convertScopedStyleIdsToArray(scopedStyleIdsString));
      scopedStyleIds.add(styleId);
      this.setHostProp(host, QScopedStyle, convertStyleIdsToString(scopedStyleIds));
    }
    if (this.$styleIds$ == null) {
      this.$styleIds$ = /* @__PURE__ */ new Set();
      this.element.querySelectorAll(QStyleSelector).forEach((style) => {
        this.$styleIds$.add(style.getAttribute(QStyle));
      });
    }
    if (!this.$styleIds$.has(styleId)) {
      this.$styleIds$.add(styleId);
      const styleElement = this.document.createElement("style");
      styleElement.setAttribute(QStyle, styleId);
      styleElement.textContent = content;
      this.$journal$.push(6 /* Insert */, this.document.head, null, styleElement);
    }
  }
  // TODO: should be moved to the Qwik Router?
  /** Set the server data for the Qwik Router. */
  $setServerData$() {
    const containerAttributes = {};
    const attrs = this.element.attributes;
    if (attrs) {
      for (let index = 0; index < attrs.length; index++) {
        const attr = attrs[index];
        if (attr.name === Q_PROPS_SEPARATOR) {
          continue;
        }
        containerAttributes[attr.name] = attr.value;
      }
    }
    this.$serverData$ = { containerAttributes };
  }
};

// packages/qwik/src/core/reactive-primitives/utils.ts
var DEBUG7 = false;
var log6 = (...args) => console.log("SIGNAL", ...args.map(qwikDebugToString));
var throwIfQRLNotResolved = (qrl) => {
  const resolved = qrl.resolved;
  if (!resolved) {
    throw qrl.resolve();
  }
};
var isSignal = (value) => {
  return value instanceof SignalImpl;
};
var ensureContainsSubscription = (array, effectSubscription) => {
  !array.has(effectSubscription) && array.add(effectSubscription);
};
var ensureContainsBackRef = (array, value) => {
  var _a5;
  array[_a5 = 2 /* BACK_REF */] || (array[_a5] = /* @__PURE__ */ new Set());
  !array[2 /* BACK_REF */].has(value) && array[2 /* BACK_REF */].add(value);
};
var addQrlToSerializationCtx = (effectSubscriber, container) => {
  if (!!container && !isDomContainer(container)) {
    const effect = effectSubscriber[0 /* CONSUMER */];
    const property = effectSubscriber[1 /* PROPERTY */];
    let qrl = null;
    if (isTask(effect)) {
      qrl = effect.$qrl$;
    } else if (effect instanceof ComputedSignalImpl) {
      qrl = effect.$computeQrl$;
    } else if (property === ":" /* COMPONENT */) {
      qrl = container.getHostProp(effect, OnRenderProp);
    }
    if (qrl) {
      container.serializationCtx.$eventQrls$.add(qrl);
    }
  }
};
var scheduleEffects = (container, signal, effects) => {
  const isBrowser4 = !isServerPlatform();
  if (effects) {
    const scheduleEffect = (effectSubscription) => {
      const consumer = effectSubscription[0 /* CONSUMER */];
      const property = effectSubscription[1 /* PROPERTY */];
      assertDefined(container, "Container must be defined.");
      if (isTask(consumer)) {
        consumer.$flags$ |= 8 /* DIRTY */;
        DEBUG7 && log6("schedule.consumer.task", pad("\n" + String(consumer), "  "));
        let choreType = 3 /* TASK */;
        if (consumer.$flags$ & 1 /* VISIBLE_TASK */) {
          choreType = 16 /* VISIBLE */;
        }
        container.$scheduler$(choreType, consumer);
      } else if (consumer instanceof SignalImpl) {
        if (consumer instanceof ComputedSignalImpl) {
          if (!consumer.$computeQrl$.resolved) {
            container.$scheduler$(1 /* QRL_RESOLVE */, null, consumer.$computeQrl$);
          }
        }
        consumer.invalidate();
      } else if (property === ":" /* COMPONENT */) {
        const host = consumer;
        const qrl = container.getHostProp(host, OnRenderProp);
        assertDefined(qrl, "Component must have QRL");
        const props = container.getHostProp(host, ELEMENT_PROPS);
        container.$scheduler$(6 /* COMPONENT */, host, qrl, props);
      } else if (property === "." /* VNODE */) {
        if (isBrowser4) {
          const host = consumer;
          container.$scheduler$(4 /* NODE_DIFF */, host, host, signal);
        }
      } else {
        const host = consumer;
        const effectData = effectSubscription[3 /* DATA */];
        if (effectData instanceof SubscriptionData) {
          const data = effectData.data;
          const payload = {
            ...data,
            $value$: signal
          };
          container.$scheduler$(5 /* NODE_PROP */, host, property, payload);
        }
      }
    };
    for (const effect of effects) {
      scheduleEffect(effect);
    }
  }
  DEBUG7 && log6("done scheduling");
};
var isSerializerObj = (obj) => {
  return isObject(obj) && typeof obj[SerializerSymbol] === "function";
};

// packages/qwik/src/core/debug.ts
var stringifyPath = [];
function qwikDebugToString(value) {
  if (value === null) {
    return "null";
  } else if (value === void 0) {
    return "undefined";
  } else if (typeof value === "string") {
    return '"' + value + '"';
  } else if (typeof value === "number" || typeof value === "boolean") {
    return String(value);
  } else if (isTask(value)) {
    return `Task(${qwikDebugToString(value.$qrl$)})`;
  } else if (isQrl(value)) {
    return `Qrl(${value.$symbol$})`;
  } else if (typeof value === "object" || typeof value === "function") {
    if (stringifyPath.includes(value)) {
      return "*";
    }
    if (stringifyPath.length > 10) {
    }
    try {
      stringifyPath.push(value);
      if (Array.isArray(value)) {
        if (vnode_isVNode(value)) {
          return "(" + value.getProp(DEBUG_TYPE, null) + ")";
        } else {
          return value.map(qwikDebugToString);
        }
      } else if (isSignal(value)) {
        if (value instanceof WrappedSignalImpl) {
          return "WrappedSignal";
        } else if (value instanceof ComputedSignalImpl) {
          return "ComputedSignal";
        } else {
          return "Signal";
        }
      } else if (isStore(value)) {
        return "Store";
      } else if (isJSXNode(value)) {
        return jsxToString(value);
      } else if (vnode_isVNode(value)) {
        return "(" + value.getProp(DEBUG_TYPE, null) + ")";
      }
    } finally {
      stringifyPath.pop();
    }
  }
  return value;
}
var pad = (text, prefix) => {
  return String(text).split("\n").map((line, idx) => (idx ? prefix : "") + line).join("\n");
};
var jsxToString = (value) => {
  if (isJSXNode(value)) {
    let str = "<" + value.type;
    if (value.props) {
      for (const [key, val] of Object.entries(value.props)) {
        str += " " + key + "=" + qwikDebugToString(val);
      }
      const children = value.children;
      if (children != null) {
        str += ">";
        if (Array.isArray(children)) {
          children.forEach((child) => {
            str += jsxToString(child);
          });
        } else {
          str += jsxToString(children);
        }
        str += "</" + value.type + ">";
      } else {
        str += "/>";
      }
    }
    return str;
  } else {
    return String(value);
  }
};

// packages/qwik/src/core/shared/utils/maps.ts
var mergeMaps = (map1, map2) => {
  for (const [k, v] of map2) {
    map1.set(k, v);
  }
  return map1;
};

// packages/qwik/src/core/client/vnode-impl.ts
import { isDev as isDev9 } from "@qwik.dev/core/build";
var VNode = class extends BackRef {
  constructor(flags, parent, previousSibling, nextSibling) {
    super();
    this.flags = flags;
    this.parent = parent;
    this.previousSibling = previousSibling;
    this.nextSibling = nextSibling;
    __publicField(this, "props", null);
    __publicField(this, "slotParent", null);
    // scheduled chores for this vnode
    __publicField(this, "chores", null);
    // blocked chores for this vnode
    __publicField(this, "blockedChores", null);
  }
  getProp(key, getObject) {
    const type = this.flags;
    if ((type & 3 /* ELEMENT_OR_VIRTUAL_MASK */) !== 0) {
      type & 1 /* Element */ && vnode_ensureElementInflated(this);
      this.props || (this.props = []);
      const idx = mapApp_findIndx(this.props, key, 0);
      if (idx >= 0) {
        let value = this.props[idx + 1];
        if (typeof value === "string" && getObject) {
          this.props[idx + 1] = value = getObject(value);
        }
        return value;
      }
    }
    return null;
  }
  setProp(key, value) {
    this.props || (this.props = []);
    const idx = mapApp_findIndx(this.props, key, 0);
    if (idx >= 0) {
      this.props[idx + 1] = value;
    } else if (value != null) {
      this.props.splice(idx ^ -1, 0, key, value);
    }
  }
  getAttr(key) {
    if ((this.flags & 3 /* ELEMENT_OR_VIRTUAL_MASK */) !== 0) {
      vnode_ensureElementInflated(this);
      this.props || (this.props = []);
      return mapArray_get(this.props, key, 0);
    }
    return null;
  }
  setAttr(key, value, journal) {
    const type = this.flags;
    if ((type & 3 /* ELEMENT_OR_VIRTUAL_MASK */) !== 0) {
      vnode_ensureElementInflated(this);
      this.props || (this.props = []);
      const idx = mapApp_findIndx(this.props, key, 0);
      if (idx >= 0) {
        if (this.props[idx + 1] != value && this instanceof ElementVNode) {
          journal && journal.push(2 /* SetAttribute */, this.element, key, value);
        }
        if (value == null) {
          this.props.splice(idx, 2);
        } else {
          this.props[idx + 1] = value;
        }
      } else if (value != null) {
        this.props.splice(idx ^ -1, 0, key, value);
        if (this instanceof ElementVNode) {
          journal && journal.push(2 /* SetAttribute */, this.element, key, value);
        }
      }
    }
  }
  toString() {
    if (isDev9) {
      return vnode_toString.call(this);
    }
    return String(this);
  }
};
var TextVNode = class extends VNode {
  constructor(flags, parent, previousSibling, nextSibling, textNode, text) {
    super(flags, parent, previousSibling, nextSibling);
    this.textNode = textNode;
    this.text = text;
  }
};
var VirtualVNode = class extends VNode {
  constructor(flags, parent, previousSibling, nextSibling, firstChild, lastChild) {
    super(flags, parent, previousSibling, nextSibling);
    this.firstChild = firstChild;
    this.lastChild = lastChild;
  }
};
var ElementVNode = class extends VNode {
  constructor(flags, parent, previousSibling, nextSibling, firstChild, lastChild, element, elementName) {
    super(flags, parent, previousSibling, nextSibling);
    this.firstChild = firstChild;
    this.lastChild = lastChild;
    this.element = element;
    this.elementName = elementName;
  }
};

// packages/qwik/src/core/client/vnode.ts
var vnode_newElement = (element, elementName) => {
  assertEqual(fastNodeType(element), 1, "Expecting element node.");
  const vnode = new ElementVNode(
    1 /* Element */ | 8 /* Inflated */ | -1 << 8 /* shift */,
    // Flag
    null,
    null,
    null,
    null,
    null,
    element,
    elementName
  );
  assertTrue(vnode_isElementVNode(vnode), "Incorrect format of ElementVNode.");
  assertFalse(vnode_isTextVNode(vnode), "Incorrect format of ElementVNode.");
  assertFalse(vnode_isVirtualVNode(vnode), "Incorrect format of ElementVNode.");
  element.vNode = vnode;
  return vnode;
};
var vnode_newUnMaterializedElement = (element) => {
  assertEqual(fastNodeType(element), 1, "Expecting element node.");
  const vnode = new ElementVNode(
    1 /* Element */ | -1 << 8 /* shift */,
    // Flag
    null,
    null,
    null,
    void 0,
    void 0,
    element,
    void 0
  );
  assertTrue(vnode_isElementVNode(vnode), "Incorrect format of ElementVNode.");
  assertFalse(vnode_isTextVNode(vnode), "Incorrect format of ElementVNode.");
  assertFalse(vnode_isVirtualVNode(vnode), "Incorrect format of ElementVNode.");
  element.vNode = vnode;
  return vnode;
};
var vnode_newSharedText = (previousTextNode, sharedTextNode, textContent) => {
  sharedTextNode && assertEqual(fastNodeType(sharedTextNode), 3, "Expecting element node.");
  const vnode = new TextVNode(
    4 /* Text */ | -1 << 8 /* shift */,
    // Flag
    null,
    // Parent
    previousTextNode,
    // Previous TextNode (usually first child)
    null,
    // Next sibling
    sharedTextNode,
    // SharedTextNode
    textContent
    // Text Content
  );
  assertFalse(vnode_isElementVNode(vnode), "Incorrect format of TextVNode.");
  assertTrue(vnode_isTextVNode(vnode), "Incorrect format of TextVNode.");
  assertFalse(vnode_isVirtualVNode(vnode), "Incorrect format of TextVNode.");
  return vnode;
};
var vnode_newText = (textNode, textContent) => {
  const vnode = new TextVNode(
    4 /* Text */ | 8 /* Inflated */ | -1 << 8 /* shift */,
    // Flags
    null,
    // Parent
    null,
    // No previous sibling
    null,
    // We may have a next sibling.
    textNode,
    // TextNode
    textContent
    // Text Content
  );
  assertEqual(fastNodeType(textNode), 3, "Expecting element node.");
  assertFalse(vnode_isElementVNode(vnode), "Incorrect format of TextVNode.");
  assertTrue(vnode_isTextVNode(vnode), "Incorrect format of TextVNode.");
  assertFalse(vnode_isVirtualVNode(vnode), "Incorrect format of TextVNode.");
  return vnode;
};
var vnode_newVirtual = () => {
  const vnode = new VirtualVNode(
    2 /* Virtual */ | -1 << 8 /* shift */,
    // Flags
    null,
    null,
    null,
    null,
    null
  );
  assertFalse(vnode_isElementVNode(vnode), "Incorrect format of TextVNode.");
  assertFalse(vnode_isTextVNode(vnode), "Incorrect format of TextVNode.");
  assertTrue(vnode_isVirtualVNode(vnode), "Incorrect format of TextVNode.");
  return vnode;
};
var vnode_isVNode = (vNode) => {
  return vNode instanceof VNode;
};
var vnode_isElementVNode = (vNode) => {
  assertDefined(vNode, "Missing vNode");
  const flag = vNode.flags;
  return (flag & 1 /* Element */) === 1 /* Element */;
};
var vnode_isElementOrTextVNode = (vNode) => {
  assertDefined(vNode, "Missing vNode");
  const flag = vNode.flags;
  return (flag & 5 /* ELEMENT_OR_TEXT_MASK */) !== 0;
};
var vnode_isMaterialized = (vNode) => {
  assertDefined(vNode, "Missing vNode");
  const flag = vNode.flags;
  return (flag & 1 /* Element */) === 1 /* Element */ && vNode.firstChild !== void 0 && vNode.lastChild !== void 0;
};
var vnode_isTextVNode = (vNode) => {
  assertDefined(vNode, "Missing vNode");
  const flag = vNode.flags;
  return (flag & 4 /* Text */) === 4 /* Text */;
};
var vnode_isVirtualVNode = (vNode) => {
  assertDefined(vNode, "Missing vNode");
  const flag = vNode.flags;
  return (flag & 2 /* Virtual */) === 2 /* Virtual */;
};
var vnode_isProjection = (vNode) => {
  assertDefined(vNode, "Missing vNode");
  const flag = vNode.flags;
  return (flag & 2 /* Virtual */) === 2 /* Virtual */ && vNode.getProp(QSlot, null) !== null;
};
var ensureTextVNode = (vNode) => {
  assertTrue(vnode_isTextVNode(vNode), "Expecting TextVNode was: " + vnode_getNodeTypeName(vNode));
  return vNode;
};
var ensureElementOrVirtualVNode = (vNode) => {
  assertDefined(vNode, "Missing vNode");
  assertTrue(
    (vNode.flags & 3 /* ELEMENT_OR_VIRTUAL_MASK */) !== 0,
    "Expecting ElementVNode or VirtualVNode was: " + vnode_getNodeTypeName(vNode)
  );
};
var ensureElementVNode = (vNode) => {
  assertTrue(
    vnode_isElementVNode(vNode),
    "Expecting ElementVNode was: " + vnode_getNodeTypeName(vNode)
  );
  return vNode;
};
var vnode_getNodeTypeName = (vNode) => {
  if (vNode) {
    const flags = vNode.flags;
    switch (flags & 7 /* TYPE_MASK */) {
      case 1 /* Element */:
        return "Element";
      case 2 /* Virtual */:
        return "Virtual";
      case 4 /* Text */:
        return "Text";
    }
  }
  return "<unknown>";
};
var vnode_ensureElementInflated = (vnode) => {
  const flags = vnode.flags;
  if ((flags & 15 /* INFLATED_TYPE_MASK */) === 1 /* Element */) {
    const elementVNode = vnode;
    elementVNode.flags ^= 8 /* Inflated */;
    const element = elementVNode.element;
    const attributes = element.attributes;
    for (let idx = 0; idx < attributes.length; idx++) {
      const attr = attributes[idx];
      const key = attr.name;
      if (key === Q_PROPS_SEPARATOR || !key) {
        break;
      } else if (key.startsWith(QContainerAttr)) {
        const props = vnode_getProps(elementVNode);
        if (attr.value === "html" /* HTML */) {
          mapArray_set(props, dangerouslySetInnerHTML, element.innerHTML, 0);
        } else if (attr.value === "text" /* TEXT */ && "value" in element) {
          mapArray_set(props, "value", element.value, 0);
        }
      } else if (!key.startsWith("on:" /* on */)) {
        const value = attr.value;
        const props = vnode_getProps(elementVNode);
        mapArray_set(props, key, value, 0);
      }
    }
  }
};
function vnode_walkVNode(vNode, callback) {
  let vCursor = vNode;
  if (vnode_isTextVNode(vNode)) {
    return;
  }
  let vParent = null;
  do {
    if (callback?.(vCursor, vParent)) {
      return;
    }
    const vFirstChild = vnode_getFirstChild(vCursor);
    if (vFirstChild) {
      vCursor = vFirstChild;
      continue;
    }
    if (vCursor === vNode) {
      return;
    }
    const vNextSibling = vCursor.nextSibling;
    if (vNextSibling) {
      vCursor = vNextSibling;
      continue;
    }
    vParent = vCursor.parent;
    while (vParent) {
      if (vParent === vNode) {
        return;
      }
      const vNextParentSibling = vParent.nextSibling;
      if (vNextParentSibling) {
        vCursor = vNextParentSibling;
        break;
      }
      vParent = vParent.parent;
    }
    if (vParent == null) {
      return;
    }
  } while (true);
}
function vnode_getDOMChildNodes(journal, root, isVNode = false, childNodes = []) {
  if (vnode_isElementOrTextVNode(root)) {
    if (vnode_isTextVNode(root)) {
      vnode_ensureTextInflated(journal, root);
    }
    childNodes.push(isVNode ? root : vnode_getNode(root));
    return childNodes;
  }
  let vNode = vnode_getFirstChild(root);
  while (vNode) {
    if (vnode_isElementVNode(vNode)) {
      childNodes.push(isVNode ? vNode : vnode_getNode(vNode));
    } else if (vnode_isTextVNode(vNode)) {
      vnode_ensureTextInflated(journal, vNode);
      childNodes.push(isVNode ? vNode : vnode_getNode(vNode));
    } else {
      isVNode ? vnode_getDOMChildNodes(journal, vNode, true, childNodes) : vnode_getDOMChildNodes(journal, vNode, false, childNodes);
    }
    vNode = vNode.nextSibling;
  }
  return childNodes;
}
var vnode_getDomSibling = (vNode, nextDirection, descend) => {
  const childProp = nextDirection ? "firstChild" : "lastChild";
  const siblingProp = nextDirection ? "nextSibling" : "previousSibling";
  let cursor = vNode;
  while (descend && cursor && vnode_isVirtualVNode(cursor)) {
    const child = cursor[childProp];
    if (!child) {
      break;
    }
    if (child.flags & 5 /* ELEMENT_OR_TEXT_MASK */) {
      return child;
    }
    cursor = child;
  }
  while (cursor) {
    let sibling = cursor[siblingProp];
    if (sibling && sibling.flags & 5 /* ELEMENT_OR_TEXT_MASK */) {
      return sibling;
    } else if (!sibling) {
      let virtual = cursor.parent;
      if (virtual && !vnode_isVirtualVNode(virtual)) {
        return null;
      }
      while (virtual && !(sibling = virtual[siblingProp])) {
        virtual = virtual.parent;
        if (virtual && !vnode_isVirtualVNode(virtual)) {
          return null;
        }
      }
      if (!sibling) {
        return null;
      }
      if (vnode_isTextVNode(sibling) && virtual && vnode_isElementVNode(virtual)) {
        return null;
      }
    }
    while (sibling) {
      cursor = sibling;
      if (cursor.flags & 5 /* ELEMENT_OR_TEXT_MASK */ && vnode_getNode(cursor)) {
        return cursor;
      }
      sibling = cursor[childProp];
    }
  }
  return null;
};
var vnode_ensureInflatedIfText = (journal, vNode) => {
  if (vnode_isTextVNode(vNode)) {
    vnode_ensureTextInflated(journal, vNode);
  }
};
var vnode_ensureTextInflated = (journal, vnode) => {
  const textVNode = ensureTextVNode(vnode);
  const flags = textVNode.flags;
  if ((flags & 8 /* Inflated */) === 0) {
    const parentNode = vnode_getDomParent(vnode);
    assertDefined(parentNode, "Missing parent node.");
    const sharedTextNode = textVNode.textNode;
    const doc2 = parentNode.ownerDocument;
    let cursor = vnode_getDomSibling(vnode, false, true);
    const node = vnode_getDomSibling(vnode, true, true);
    const insertBeforeNode = sharedTextNode || ((node instanceof ElementVNode ? node.element : node?.textNode) || null);
    let lastPreviousTextNode = insertBeforeNode;
    while (cursor && vnode_isTextVNode(cursor)) {
      if ((cursor.flags & 8 /* Inflated */) === 0) {
        const textNode = doc2.createTextNode(cursor.text);
        journal.push(6 /* Insert */, parentNode, lastPreviousTextNode, textNode);
        lastPreviousTextNode = textNode;
        cursor.textNode = textNode;
        cursor.flags |= 8 /* Inflated */;
      }
      cursor = vnode_getDomSibling(cursor, false, true);
    }
    cursor = vnode;
    while (cursor && vnode_isTextVNode(cursor)) {
      const next = vnode_getDomSibling(cursor, true, true);
      const isLastNode = next ? !vnode_isTextVNode(next) : true;
      if ((cursor.flags & 8 /* Inflated */) === 0) {
        if (isLastNode && sharedTextNode) {
          journal.push(1 /* SetText */, sharedTextNode, cursor.text);
        } else {
          const textNode = doc2.createTextNode(cursor.text);
          journal.push(6 /* Insert */, parentNode, insertBeforeNode, textNode);
          cursor.textNode = textNode;
        }
        cursor.flags |= 8 /* Inflated */;
      }
      cursor = next;
    }
  }
};
var vnode_locate = (rootVNode, id) => {
  ensureElementVNode(rootVNode);
  let vNode = rootVNode;
  const containerElement2 = rootVNode.element;
  const { qVNodeRefs } = containerElement2;
  let elementOffset = -1;
  let refElement;
  if (typeof id === "string") {
    assertDefined(qVNodeRefs, "Missing qVNodeRefs.");
    elementOffset = parseInt(id);
    refElement = qVNodeRefs.get(elementOffset);
  } else {
    refElement = id;
    const vNode2 = refElement.vNode;
    if (vNode2) {
      return vNode2;
    }
  }
  assertDefined(refElement, "Missing refElement.");
  if (!vnode_isVNode(refElement)) {
    assertTrue(
      containerElement2.contains(refElement),
      `Couldn't find the element inside the container while locating the VNode.`
    );
    let parent = refElement;
    const elementPath = [refElement];
    while (parent && parent !== containerElement2 && !parent.vNode) {
      parent = parent.parentElement;
      elementPath.push(parent);
    }
    if (parent.vNode) {
      vNode = parent.vNode;
    }
    for (let i = elementPath.length - 2; i >= 0; i--) {
      vNode = vnode_getVNodeForChildNode(vNode, elementPath[i]);
    }
    if (elementOffset != -1) {
      refElement.vNode = vNode;
      qVNodeRefs.set(elementOffset, vNode);
    }
  } else {
    vNode = refElement;
  }
  if (typeof id === "string") {
    const idLength = id.length;
    let idx = indexOfAlphanumeric(id, idLength);
    let childIdx = 0;
    while (idx < idLength) {
      const ch = id.charCodeAt(idx);
      childIdx *= 26;
      if (ch >= 97) {
        childIdx += ch - 97;
      } else {
        childIdx += ch - 65;
        vNode = vnode_getChildWithIdx(vNode, childIdx);
        childIdx = 0;
      }
      idx++;
    }
  }
  return vNode;
};
var vnode_getChildWithIdx = (vNode, childIdx) => {
  let child = vnode_getFirstChild(vNode);
  assertDefined(child, "Missing child.");
  while (child.flags >>> 8 /* shift */ !== childIdx) {
    child = child.nextSibling;
    assertDefined(child, "Missing child.");
  }
  return child;
};
var vNodeStack = [];
var vnode_getVNodeForChildNode = (vNode, childElement) => {
  ensureElementVNode(vNode);
  let child = vnode_getFirstChild(vNode);
  assertDefined(child, "Missing child.");
  while (child && (child instanceof ElementVNode ? child.element !== childElement : true)) {
    if (vnode_isVirtualVNode(child)) {
      const next = child.nextSibling;
      const firstChild = vnode_getFirstChild(child);
      if (firstChild) {
        next && vNodeStack.push(next);
        child = firstChild;
      } else {
        child = next || (vNodeStack.length ? vNodeStack.pop() : null);
      }
    } else {
      const next = child.nextSibling;
      if (next) {
        child = next;
      } else {
        child = next || vNodeStack.pop();
      }
    }
    assertDefined(child, "Missing child.");
  }
  while (vNodeStack.length) {
    vNodeStack.pop();
  }
  ensureElementVNode(child);
  assertEqual(child.element, childElement, "Child not found.");
  return child;
};
var indexOfAlphanumeric = (id, length) => {
  let idx = 0;
  while (idx < length) {
    if (id.charCodeAt(idx) <= 57) {
      idx++;
    } else {
      return idx;
    }
  }
  return length;
};
var vnode_createErrorDiv = (document2, host, err, journal) => {
  const errorDiv = document2.createElement("errored-host");
  if (err && err instanceof Error) {
    errorDiv.props = { error: err };
  }
  errorDiv.setAttribute("q:key", "_error_");
  const vErrorDiv = vnode_newElement(errorDiv, "errored-host");
  vnode_getDOMChildNodes(journal, host, true).forEach((child) => {
    vnode_insertBefore(journal, vErrorDiv, child, null);
  });
  return vErrorDiv;
};
var parseBoolean = (value) => {
  if (value === "false") {
    return false;
  }
  return Boolean(value);
};
var isBooleanAttr = (element, key) => {
  const isBoolean = key == "allowfullscreen" || key == "async" || key == "autofocus" || key == "autoplay" || key == "checked" || key == "controls" || key == "default" || key == "defer" || key == "disabled" || key == "formnovalidate" || key == "inert" || key == "ismap" || key == "itemscope" || key == "loop" || key == "multiple" || key == "muted" || key == "nomodule" || key == "novalidate" || key == "open" || key == "playsinline" || key == "readonly" || key == "required" || key == "reversed" || key == "selected";
  return isBoolean && key in element;
};
var vnode_applyJournal = (journal) => {
  let idx = 0;
  const length = journal.length;
  while (idx < length) {
    const op = journal[idx++];
    switch (op) {
      case 1 /* SetText */:
        const text = journal[idx++];
        text.nodeValue = journal[idx++];
        break;
      case 2 /* SetAttribute */:
        const element = journal[idx++];
        let key = journal[idx++];
        if (key === "className") {
          key = "class";
        }
        const value = journal[idx++];
        if (isBooleanAttr(element, key)) {
          element[key] = parseBoolean(value);
        } else if (key === "value" && key in element) {
          element.value = String(value);
        } else if (key === dangerouslySetInnerHTML) {
          element.innerHTML = value;
          element.setAttribute(QContainerAttr, "html" /* HTML */);
        } else {
          if (value == null || value === false) {
            element.removeAttribute(key);
          } else {
            element.setAttribute(key, String(value));
          }
        }
        break;
      case 3 /* HoistStyles */:
        const document2 = journal[idx++];
        const head = document2.head;
        const styles = document2.querySelectorAll(QStylesAllSelector);
        for (let i = 0; i < styles.length; i++) {
          head.appendChild(styles[i]);
        }
        break;
      case 4 /* Remove */:
        const removeParent = journal[idx++];
        let nodeToRemove;
        while (idx < length && typeof (nodeToRemove = journal[idx]) !== "number") {
          removeParent.removeChild(nodeToRemove);
          idx++;
        }
        break;
      case 5 /* RemoveAll */:
        const removeAllParent = journal[idx++];
        if (removeAllParent.replaceChildren) {
          removeAllParent.replaceChildren();
        } else {
          removeAllParent.textContent = "";
        }
        break;
      case 6 /* Insert */:
        const insertParent = journal[idx++];
        const insertBefore = journal[idx++];
        let newChild;
        while (idx < length && typeof (newChild = journal[idx]) !== "number") {
          insertParent.insertBefore(newChild, insertBefore);
          idx++;
        }
        break;
    }
  }
  journal.length = 0;
};
var vnode_insertBefore = (journal, parent, newChild, insertBefore) => {
  ensureElementOrVirtualVNode(parent);
  if (vnode_isElementVNode(parent)) {
    ensureMaterialized(parent);
  }
  const newChildCurrentParent = newChild.parent;
  if (newChild === insertBefore) {
    if (newChildCurrentParent) {
      return;
    } else {
      insertBefore = null;
    }
  }
  const domParentVNode = vnode_getDomParentVNode(parent, false);
  const parentNode = domParentVNode && domParentVNode.element;
  let domChildren = null;
  if (domParentVNode) {
    domChildren = vnode_getDomChildrenWithCorrectNamespacesToInsert(
      journal,
      domParentVNode,
      newChild
    );
  }
  if (newChildCurrentParent && (newChild.previousSibling || newChild.nextSibling || newChildCurrentParent !== parent)) {
    vnode_remove(journal, newChildCurrentParent, newChild, false);
  }
  const parentIsDeleted = parent.flags & 32 /* Deleted */;
  if (!parentIsDeleted) {
    let adjustedInsertBefore = null;
    if (insertBefore == null) {
      if (vnode_isVirtualVNode(parent)) {
        adjustedInsertBefore = vnode_getDomSibling(parent, true, false);
      }
    } else if (vnode_isVirtualVNode(insertBefore)) {
      adjustedInsertBefore = vnode_getDomSibling(insertBefore, true, true);
    } else {
      adjustedInsertBefore = insertBefore;
    }
    adjustedInsertBefore && vnode_ensureInflatedIfText(journal, adjustedInsertBefore);
    if (domChildren && domChildren.length) {
      journal.push(
        6 /* Insert */,
        parentNode,
        vnode_getNode(adjustedInsertBefore),
        ...domChildren
      );
    }
  }
  const vNext = insertBefore;
  const vPrevious = vNext ? vNext.previousSibling : parent.lastChild;
  if (vNext) {
    vNext.previousSibling = newChild;
  } else {
    parent.lastChild = newChild;
  }
  if (vPrevious) {
    vPrevious.nextSibling = newChild;
  } else {
    parent.firstChild = newChild;
  }
  newChild.previousSibling = vPrevious;
  newChild.nextSibling = vNext;
  newChild.parent = parent;
  if (parentIsDeleted) {
    newChild.flags |= 32 /* Deleted */;
  }
};
var vnode_getDomParent = (vnode, includeProjection = true) => {
  vnode = vnode_getDomParentVNode(vnode, includeProjection);
  return vnode && vnode.element;
};
var vnode_getDomParentVNode = (vnode, includeProjection = true) => {
  while (vnode && !vnode_isElementVNode(vnode)) {
    vnode = vnode.parent || (includeProjection ? vnode.slotParent : null);
  }
  return vnode;
};
var vnode_remove = (journal, vParent, vToRemove, removeDOM) => {
  assertEqual(vParent, vToRemove.parent, "Parent mismatch.");
  if (vnode_isTextVNode(vToRemove)) {
    vnode_ensureTextInflated(journal, vToRemove);
  }
  if (removeDOM) {
    const domParent = vnode_getDomParent(vParent, false);
    const isInnerHTMLParent = vParent.getAttr(dangerouslySetInnerHTML);
    if (isInnerHTMLParent) {
      return;
    }
    const children = vnode_getDOMChildNodes(journal, vToRemove);
    domParent && children.length && journal.push(4 /* Remove */, domParent, ...children);
  }
  const vPrevious = vToRemove.previousSibling;
  const vNext = vToRemove.nextSibling;
  if (vPrevious) {
    vPrevious.nextSibling = vNext;
  } else {
    vParent.firstChild = vNext;
  }
  if (vNext) {
    vNext.previousSibling = vPrevious;
  } else {
    vParent.lastChild = vPrevious;
  }
  vToRemove.previousSibling = null;
  vToRemove.nextSibling = null;
};
var vnode_truncate = (journal, vParent, vDelete) => {
  assertDefined(vDelete, "Missing vDelete.");
  const parent = vnode_getDomParent(vParent);
  if (parent) {
    if (vnode_isElementVNode(vParent)) {
      journal.push(5 /* RemoveAll */, parent);
    } else {
      const children = vnode_getDOMChildNodes(journal, vParent);
      children.length && journal.push(4 /* Remove */, parent, ...children);
    }
  }
  const vPrevious = vDelete.previousSibling;
  if (vPrevious) {
    vPrevious.nextSibling = null;
  } else {
    vParent.firstChild = null;
  }
  vParent.lastChild = vPrevious;
};
var vnode_getElementName = (vnode) => {
  const elementVNode = ensureElementVNode(vnode);
  let elementName = elementVNode.elementName;
  if (elementName === void 0) {
    const element = elementVNode.element;
    const nodeName = fastNodeName(element).toLowerCase();
    elementName = elementVNode.elementName = nodeName;
    elementVNode.flags |= vnode_getElementNamespaceFlags(element);
  }
  return elementName;
};
var vnode_getText = (textVNode) => {
  let text = textVNode.text;
  if (text === void 0) {
    text = textVNode.text = textVNode.textNode.nodeValue;
  }
  return text;
};
var vnode_setText = (journal, textVNode, text) => {
  vnode_ensureTextInflated(journal, textVNode);
  const textNode = textVNode.textNode;
  journal.push(1 /* SetText */, textNode, textVNode.text = text);
};
var vnode_getFirstChild = (vnode) => {
  if (vnode_isTextVNode(vnode)) {
    return null;
  }
  let vFirstChild = vnode.firstChild;
  if (vFirstChild === void 0) {
    vFirstChild = ensureMaterialized(vnode);
  }
  return vFirstChild;
};
var vnode_materialize = (vNode) => {
  const element = vNode.element;
  const firstChild = fastFirstChild(element);
  const vNodeData = element.ownerDocument?.qVNodeData?.get(element);
  const vFirstChild = materialize(vNode, element, firstChild, vNodeData);
  return vFirstChild;
};
var materialize = (vNode, element, firstChild, vNodeData) => {
  if (vNodeData) {
    if (vNodeData.charCodeAt(0) === VNodeDataChar.SEPARATOR) {
      const elementVNodeDataStartIdx = 1;
      let elementVNodeDataEndIdx = 1;
      while (vNodeData.charCodeAt(elementVNodeDataEndIdx) !== VNodeDataChar.SEPARATOR) {
        elementVNodeDataEndIdx++;
      }
      const elementVNodeData = vNodeData.substring(
        elementVNodeDataStartIdx,
        elementVNodeDataEndIdx
      );
      vNodeData = vNodeData.substring(elementVNodeDataEndIdx + 1);
      const vFirstChild = materializeFromDOM(vNode, firstChild, elementVNodeData);
      if (!vNodeData) {
        return vFirstChild;
      }
    }
    return materializeFromVNodeData(vNode, vNodeData, element, firstChild);
  } else {
    return materializeFromDOM(vNode, firstChild);
  }
};
var ensureMaterialized = (vnode) => {
  const vParent = ensureElementVNode(vnode);
  let vFirstChild = vParent.firstChild;
  if (vFirstChild === void 0) {
    const element = vParent.element;
    if (vParent.parent && shouldIgnoreChildren(element)) {
      vFirstChild = vParent.firstChild = vParent.lastChild = null;
    } else {
      vFirstChild = vnode_materialize(vParent);
    }
  }
  assertTrue(vParent.firstChild !== void 0, "Did not materialize.");
  assertTrue(vParent.lastChild !== void 0, "Did not materialize.");
  return vFirstChild;
};
var _fastHasAttribute = null;
var shouldIgnoreChildren = (node) => {
  if (!_fastHasAttribute) {
    _fastHasAttribute = node.hasAttribute;
  }
  return _fastHasAttribute.call(node, QContainerAttr);
};
var _fastNodeType = null;
var fastNodeType = (node) => {
  if (!_fastNodeType) {
    _fastNodeType = fastGetter(node, "nodeType");
  }
  return _fastNodeType.call(node);
};
var fastIsTextOrElement = (node) => {
  const type = fastNodeType(node);
  return type === /* Node.TEXT_NODE */
  3 || type === /* Node.ELEMENT_NODE */
  1;
};
var _fastNextSibling = null;
var fastNextSibling = (node) => {
  if (!_fastNextSibling) {
    _fastNextSibling = fastGetter(node, "nextSibling");
  }
  if (!_fastFirstChild) {
    _fastFirstChild = fastGetter(node, "firstChild");
  }
  while (node) {
    node = _fastNextSibling.call(node);
    if (node !== null) {
      const type = fastNodeType(node);
      if (type === /* Node.TEXT_NODE */
      3 || type === /* Node.ELEMENT_NODE */
      1) {
        break;
      } else if (type === /* Node.COMMENT_NODE */
      8) {
        const nodeValue = node.nodeValue;
        if (nodeValue?.startsWith(QIgnore)) {
          return getNodeAfterCommentNode(node, QContainerIsland, _fastNextSibling, _fastFirstChild);
        } else if (node.nodeValue?.startsWith(QContainerIslandEnd)) {
          return getNodeAfterCommentNode(node, QIgnoreEnd, _fastNextSibling, _fastFirstChild);
        } else if (nodeValue?.startsWith(QContainerAttr)) {
          while (node && (node = _fastNextSibling.call(node))) {
            if (fastNodeType(node) === /* Node.COMMENT_NODE */
            8 && node.nodeValue?.startsWith(QContainerAttrEnd)) {
              break;
            }
          }
        }
      }
    }
  }
  return node;
};
function getNodeAfterCommentNode(node, commentValue, nextSibling, firstChild) {
  while (node) {
    if (node.nodeValue?.startsWith(commentValue)) {
      node = nextSibling.call(node) || null;
      return node;
    }
    let nextNode = firstChild.call(node);
    if (!nextNode) {
      nextNode = nextSibling.call(node);
    }
    if (!nextNode) {
      nextNode = fastParentNode(node);
      if (nextNode) {
        nextNode = nextSibling.call(nextNode);
      }
    }
    node = nextNode;
  }
  return null;
}
var _fastParentNode = null;
var fastParentNode = (node) => {
  if (!_fastParentNode) {
    _fastParentNode = fastGetter(node, "parentNode");
  }
  return _fastParentNode.call(node);
};
var _fastFirstChild = null;
var fastFirstChild = (node) => {
  if (!_fastFirstChild) {
    _fastFirstChild = fastGetter(node, "firstChild");
  }
  node = node && _fastFirstChild.call(node);
  while (node && !fastIsTextOrElement(node)) {
    node = fastNextSibling(node);
  }
  return node;
};
var _fastNamespaceURI = null;
var fastNamespaceURI = (element) => {
  if (!_fastNamespaceURI) {
    _fastNamespaceURI = fastGetter(element, "namespaceURI");
  }
  return _fastNamespaceURI.call(element);
};
var _fastNodeName = null;
var fastNodeName = (element) => {
  if (!_fastNodeName) {
    _fastNodeName = fastGetter(element, "nodeName");
  }
  return _fastNodeName.call(element);
};
var fastGetter = (prototype, name) => {
  let getter;
  while (prototype && !(getter = Object.getOwnPropertyDescriptor(prototype, name)?.get)) {
    prototype = Object.getPrototypeOf(prototype);
  }
  return getter || function() {
    return this[name];
  };
};
var hasQStyleAttribute = (element) => {
  return element.nodeName === "STYLE" && (element.hasAttribute(QScopedStyle) || element.hasAttribute(QStyle));
};
var hasPropsSeparator = (element) => {
  return element.hasAttribute(Q_PROPS_SEPARATOR);
};
var materializeFromDOM = (vParent, firstChild, vData) => {
  let vFirstChild = null;
  const skipElements = () => {
    while (isElement(child) && shouldSkipElement(child)) {
      child = fastNextSibling(child);
    }
  };
  let child = firstChild;
  skipElements();
  let vChild = null;
  while (child) {
    const nodeType = fastNodeType(child);
    let vNextChild = null;
    if (nodeType === /* Node.TEXT_NODE */
    3) {
      vNextChild = vnode_newText(child, child.textContent ?? void 0);
    } else if (nodeType === /* Node.ELEMENT_NODE */
    1) {
      vNextChild = vnode_newUnMaterializedElement(child);
    }
    if (vNextChild) {
      vNextChild.parent = vParent;
      vChild && (vChild.nextSibling = vNextChild);
      vNextChild.previousSibling = vChild;
      vChild = vNextChild;
    }
    if (!vFirstChild) {
      vParent.firstChild = vFirstChild = vChild;
    }
    child = fastNextSibling(child);
    skipElements();
  }
  vParent.lastChild = vChild || null;
  vParent.firstChild = vFirstChild;
  if (vData) {
    let container = null;
    processVNodeData2(vData, (peek, consumeValue) => {
      if (peek() === VNodeDataChar.ID) {
        if (!container) {
          container = getDomContainer(vParent.element);
        }
        const id = consumeValue();
        container.$setRawState$(parseInt(id), vParent);
        isDev10 && vParent.setAttr(ELEMENT_ID, id, null);
      } else if (peek() === VNodeDataChar.BACK_REFS) {
        if (!container) {
          container = getDomContainer(vParent.element);
        }
        setEffectBackRefFromVNodeData(vParent, consumeValue(), container);
      } else {
        consumeValue();
      }
    });
  }
  return vFirstChild;
};
function setEffectBackRefFromVNodeData(vParent, value, container) {
  if (!vParent[_EFFECT_BACK_REF]) {
    Object.defineProperty(vParent, _EFFECT_BACK_REF, {
      get() {
        const subMap = container.$getObjectById$(value);
        vParent[_EFFECT_BACK_REF] = subMap;
        return subMap;
      },
      set(value2) {
        Object.defineProperty(vParent, _EFFECT_BACK_REF, {
          value: value2,
          writable: true,
          enumerable: true,
          configurable: true
        });
      },
      enumerable: true,
      configurable: true
    });
  } else {
    const subMap = vParent[_EFFECT_BACK_REF];
    mergeMaps(subMap, container.$getObjectById$(value));
  }
}
var processVNodeData2 = (vData, callback) => {
  let nextToConsumeIdx = 0;
  let ch = 0;
  let peekCh = 0;
  const getChar = (idx) => {
    return idx < vData.length ? vData.charCodeAt(idx) : 0;
  };
  const peek = () => {
    if (peekCh !== 0) {
      return peekCh;
    } else {
      return peekCh = getChar(nextToConsumeIdx);
    }
  };
  const consume = () => {
    ch = peek();
    peekCh = 0;
    nextToConsumeIdx++;
    return ch;
  };
  const consumeValue = () => {
    consume();
    const start = nextToConsumeIdx;
    while (peek() <= 58 && peekCh !== 0 || peekCh === 95 || peekCh >= 65 && peekCh <= 90 || peekCh >= 97 && peekCh <= 122) {
      consume();
    }
    return vData.substring(start, nextToConsumeIdx);
  };
  while (peek() !== 0) {
    callback(peek, consumeValue, consume, getChar, nextToConsumeIdx);
  }
};
var vnode_getAttrKeys = (vnode) => {
  const type = vnode.flags;
  if ((type & 3 /* ELEMENT_OR_VIRTUAL_MASK */) !== 0) {
    vnode_ensureElementInflated(vnode);
    const keys = [];
    const props = vnode_getProps(vnode);
    for (let i = 0; i < props.length; i = i + 2) {
      const key = props[i];
      if (!key.startsWith(Q_PROPS_SEPARATOR)) {
        keys.push(key);
      }
    }
    return keys;
  }
  return [];
};
var vnode_getProps = (vnode) => {
  vnode.props || (vnode.props = []);
  return vnode.props;
};
var vnode_isDescendantOf = (vnode, ancestor) => {
  let parent = vnode_getProjectionParentOrParent(vnode);
  while (parent) {
    if (parent === ancestor) {
      return true;
    }
    parent = vnode_getProjectionParentOrParent(parent);
  }
  return false;
};
var vnode_getProjectionParentOrParent = (vnode) => {
  return vnode.parent || vnode.slotParent;
};
var vnode_getNode = (vnode) => {
  if (vnode === null || vnode_isVirtualVNode(vnode)) {
    return null;
  }
  if (vnode_isElementVNode(vnode)) {
    return vnode.element;
  }
  assertTrue(vnode_isTextVNode(vnode), "Expecting Text Node.");
  return vnode.textNode;
};
function vnode_toString(depth = 20, offset = "", materialize2 = false, siblings = false, colorize = true) {
  let vnode = this;
  if (depth === 0) {
    return "...";
  }
  if (vnode === null) {
    return "null";
  }
  if (vnode === void 0) {
    return "undefined";
  }
  const strings = [];
  const NAME_COL_PREFIX = "\x1B[34m";
  const NAME_COL_SUFFIX = "\x1B[0m";
  do {
    if (vnode_isTextVNode(vnode)) {
      strings.push(qwikDebugToString(vnode_getText(vnode)));
    } else if (vnode_isVirtualVNode(vnode)) {
      const idx = vnode.flags >>> 8 /* shift */;
      const attrs = ["[" + String(idx) + "]"];
      vnode_getAttrKeys(vnode).forEach((key) => {
        if (key !== DEBUG_TYPE) {
          const value = vnode.getAttr(key);
          attrs.push(" " + key + "=" + qwikDebugToString(value));
        }
      });
      const name = (colorize ? NAME_COL_PREFIX : "") + (VirtualTypeName[vnode.getAttr(DEBUG_TYPE) || "V" /* Virtual */] || VirtualTypeName["V" /* Virtual */]) + (colorize ? NAME_COL_SUFFIX : "");
      strings.push("<" + name + attrs.join("") + ">");
      const child = vnode_getFirstChild(vnode);
      child && strings.push(
        "  " + vnode_toString.call(child, depth - 1, offset + "  ", true, true, colorize)
      );
      strings.push("</" + name + ">");
    } else if (vnode_isElementVNode(vnode)) {
      const tag = vnode_getElementName(vnode);
      const attrs = [];
      const keys = vnode_getAttrKeys(vnode);
      keys.forEach((key) => {
        const value = vnode.getAttr(key);
        attrs.push(" " + key + "=" + qwikDebugToString(value));
      });
      const node = vnode_getNode(vnode);
      if (node) {
        const vnodeData = node.ownerDocument.qVNodeData?.get(node);
        if (vnodeData) {
          attrs.push(" q:vnodeData=" + qwikDebugToString(vnodeData));
        }
      }
      const domAttrs = node.attributes;
      for (let i = 0; i < domAttrs.length; i++) {
        const attr = domAttrs[i];
        if (keys.indexOf(attr.name) === -1) {
          attrs.push(" " + attr.name + (attr.value ? "=" + qwikDebugToString(attr.value) : ""));
        }
      }
      strings.push("<" + tag + attrs.join("") + ">");
      if (vnode_isMaterialized(vnode) || materialize2) {
        const child = vnode_getFirstChild(vnode);
        child && strings.push(
          "  " + vnode_toString.call(child, depth - 1, offset + "  ", true, true, colorize)
        );
      } else {
        strings.push("  <!-- not materialized --!>");
      }
      strings.push("</" + tag + ">");
    }
    vnode = siblings && vnode.nextSibling || null;
  } while (vnode);
  return strings.join("\n" + offset);
}
var isNumber2 = (ch) => (
  /* `0` */
  48 <= ch && ch <= 57
);
var isLowercase = (ch) => (
  /* `a` */
  97 <= ch && ch <= 122
);
function shouldSkipElement(element) {
  return (
    // Skip over elements that don't have a props separator. They are not rendered by Qwik.
    !hasPropsSeparator(element) || // We pretend that style element's don't exist as they can get moved out.
    // skip over style elements, as those need to be moved to the head
    // and are not included in the counts.
    hasQStyleAttribute(element)
  );
}
var stack = [];
function materializeFromVNodeData(vParent, vData, element, child) {
  let idx = 0;
  let vFirst = null;
  let vLast = null;
  let previousTextNode = null;
  const addVNode = (node) => {
    node.flags = node.flags & 255 /* mask */ | idx << 8 /* shift */;
    idx++;
    vLast && (vLast.nextSibling = node);
    node.previousSibling = vLast;
    node.parent = vParent;
    if (!vFirst) {
      vParent.firstChild = vFirst = node;
    }
    vLast = node;
  };
  let textIdx = 0;
  let combinedText = null;
  let container = null;
  const shouldSkipNode = (node) => {
    const nodeIsElement = isElement(node);
    return !nodeIsElement || nodeIsElement && shouldSkipElement(node);
  };
  processVNodeData2(vData, (peek, consumeValue, consume, getChar, nextToConsumeIdx) => {
    if (isNumber2(peek())) {
      while (shouldSkipNode(child)) {
        child = fastNextSibling(child);
        if (!child) {
          throw qError(27 /* materializeVNodeDataError */, [vData, peek(), nextToConsumeIdx]);
        }
      }
      combinedText = null;
      previousTextNode = null;
      let value = 0;
      while (isNumber2(peek())) {
        value *= 10;
        value += consume() - 48;
      }
      while (value--) {
        addVNode(vnode_newUnMaterializedElement(child));
        child = fastNextSibling(child);
      }
    } else if (peek() === VNodeDataChar.SCOPED_STYLE) {
      vParent.setAttr(QScopedStyle, consumeValue(), null);
    } else if (peek() === VNodeDataChar.RENDER_FN) {
      vParent.setAttr(OnRenderProp, consumeValue(), null);
    } else if (peek() === VNodeDataChar.ID) {
      if (!container) {
        container = getDomContainer(element);
      }
      const id = consumeValue();
      container.$setRawState$(parseInt(id), vParent);
      isDev10 && vParent.setAttr(ELEMENT_ID, id, null);
    } else if (peek() === VNodeDataChar.PROPS) {
      vParent.setAttr(ELEMENT_PROPS, consumeValue(), null);
    } else if (peek() === VNodeDataChar.KEY) {
      const isEscapedValue = getChar(nextToConsumeIdx + 1) === VNodeDataChar.SEPARATOR;
      let value;
      if (isEscapedValue) {
        consume();
        value = decodeURI(consumeValue());
        consume();
      } else {
        value = consumeValue();
      }
      vParent.setAttr(ELEMENT_KEY, value, null);
    } else if (peek() === VNodeDataChar.SEQ) {
      vParent.setAttr(ELEMENT_SEQ, consumeValue(), null);
    } else if (peek() === VNodeDataChar.SEQ_IDX) {
      vParent.setAttr(ELEMENT_SEQ_IDX, consumeValue(), null);
    } else if (peek() === VNodeDataChar.BACK_REFS) {
      if (!container) {
        container = getDomContainer(element);
      }
      setEffectBackRefFromVNodeData(vParent, consumeValue(), container);
    } else if (peek() === VNodeDataChar.SLOT_PARENT) {
      if (!container) {
        container = getDomContainer(element);
      }
      vParent.slotParent = vnode_locate(container.rootVNode, consumeValue());
    } else if (peek() === VNodeDataChar.CONTEXT) {
      vParent.setAttr(QCtxAttr, consumeValue(), null);
    } else if (peek() === VNodeDataChar.OPEN) {
      consume();
      addVNode(vnode_newVirtual());
      stack.push(vParent, vFirst, vLast, previousTextNode, idx);
      idx = 0;
      vParent = vLast;
      vFirst = vLast = null;
    } else if (peek() === VNodeDataChar.SEPARATOR) {
      const key = consumeValue();
      const value = consumeValue();
      vParent.setAttr(key, value, null);
    } else if (peek() === VNodeDataChar.CLOSE) {
      consume();
      vParent.lastChild = vLast;
      idx = stack.pop();
      previousTextNode = stack.pop();
      vLast = stack.pop();
      vFirst = stack.pop();
      vParent = stack.pop();
    } else if (peek() === VNodeDataChar.SLOT) {
      vParent.setAttr(QSlot, consumeValue(), null);
    } else {
      while (isElement(child) && shouldSkipElement(child)) {
        child = fastNextSibling(child);
      }
      const textNode = child && fastNodeType(child) === /* Node.TEXT_NODE */
      3 ? child : null;
      if (combinedText === null) {
        combinedText = textNode ? textNode.nodeValue : null;
        textIdx = 0;
      }
      let length = 0;
      while (isLowercase(peek())) {
        length += consume() - 97;
        length *= 26;
      }
      length += consume() - 65;
      const text = combinedText === null ? "" : combinedText.substring(textIdx, textIdx + length);
      addVNode(
        previousTextNode = vnode_newSharedText(previousTextNode, textNode, text)
      );
      textIdx += length;
    }
  });
  vParent.lastChild = vLast;
  return vFirst;
}
var vnode_getType = (vnode) => {
  const type = vnode.flags;
  if (type & 1 /* Element */) {
    return 1;
  } else if (type & 2 /* Virtual */) {
    return 11;
  } else if (type & 4 /* Text */) {
    return 3;
  }
  throw qError(26 /* invalidVNodeType */, [type]);
};
var isElement = (node) => node && typeof node == "object" && fastNodeType(node) === /** Node.ELEMENT_NODE* */
1;
var vnode_getProjectionParentComponent = (vHost) => {
  let projectionDepth = 1;
  while (projectionDepth--) {
    while (vHost && (vnode_isVirtualVNode(vHost) ? vHost.getProp(OnRenderProp, null) === null : true)) {
      const qSlotParent = vHost.slotParent;
      const vProjectionParent = vnode_isVirtualVNode(vHost) && qSlotParent;
      if (vProjectionParent) {
        projectionDepth++;
      }
      vHost = vProjectionParent || vHost.parent;
    }
    if (projectionDepth > 0) {
      vHost = vHost.parent;
    }
  }
  return vHost;
};

// packages/qwik/src/testing/vdom-diff.unit-util.ts
import { format } from "prettier";

// packages/qwik/src/testing/document.ts
var import_domino = __toESM(require_lib(), 1);

// packages/qwik/src/testing/util.ts
function normalizeUrl(url) {
  if (url != null) {
    if (typeof url === "string") {
      return new URL(url || "/", BASE_URI);
    }
    if (typeof url.href === "string") {
      return new URL(url.href || "/", BASE_URI);
    }
  }
  return new URL(BASE_URI);
}
var BASE_URI = `http://document.qwik.dev/`;
var __self = typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && self;
async function waitForDrain(container) {
  await container.$scheduler$(255 /* WAIT_FOR_QUEUE */).$returnValue$;
}

// packages/qwik/src/testing/document.ts
function createDocument(opts) {
  const doc2 = import_domino.default.createDocument(opts?.html);
  ensureGlobals(doc2, opts);
  return doc2;
}
function createWindow(opts = {}) {
  return createDocument(opts).defaultView;
}
function ensureGlobals(doc2, opts) {
  if (doc2 && doc2[QWIK_DOC]) {
    return doc2.defaultView;
  }
  if (!doc2 || doc2.nodeType !== 9) {
    throw new Error(`Invalid document`);
  }
  doc2[QWIK_DOC] = true;
  const loc = normalizeUrl(opts?.url);
  Object.defineProperty(doc2, "baseURI", {
    get: () => loc.href,
    set: (url) => loc.href = normalizeUrl(url).href
  });
  doc2.defaultView = {
    get document() {
      return doc2;
    },
    get location() {
      return loc;
    },
    get origin() {
      return loc.origin;
    },
    addEventListener: noop,
    removeEventListener: noop,
    history: {
      pushState: noop,
      replaceState: noop,
      go: noop,
      back: noop,
      forward: noop
    },
    CustomEvent: class CustomEvent {
      constructor(type, details) {
        __publicField(this, "type");
        Object.assign(this, details);
        this.type = type;
      }
    }
  };
  return doc2.defaultView;
}
var noop = () => {
};
var QWIK_DOC = Symbol();
var MockShadowRoot = class extends import_domino.default.impl.DocumentFragment {
  constructor(host) {
    super();
    __publicField(this, "nodeType", 11);
    // DOCUMENT_FRAGMENT_NODE
    __publicField(this, "host");
    this.host = host;
    this.ownerDocument = host.ownerDocument;
  }
  append(...nodes) {
    for (const node of nodes) {
      if (node.nodeType === 11) {
        for (const child of Array.from(node.childNodes)) {
          this.appendChild(child);
        }
      } else {
        this.appendChild(node);
      }
    }
  }
};

// packages/qwik/src/server/tag-nesting.ts
var allowedContent = (state) => {
  switch (state) {
    case 2 /* TEXT */:
      return ["text content", null];
    case 0 /* NOT_ALLOWED */:
      return ["no content", null];
    case 32 /* HTML */:
      return ["html content", "<head>, <body>"];
    case 64 /* HEAD */:
      return [
        "head content",
        "<title>, <script>, <noscript>, <style>, <meta>, <link>, <base>, <template>"
      ];
    case 130 /* BODY */:
      return ["body content", "all tags allowed here"];
    case 4 /* EMPTY */:
      return ["no-content element", null];
    case 10 /* ANYTHING */:
      return ["any content", null];
    case 4096 /* TABLE */:
      return ["table", "<caption>, <colgroup>, <tbody>, <thead>, <tfoot>"];
    case 8192 /* TABLE_BODY */:
      return ["table body", "<tr>"];
    case 16384 /* TABLE_ROW */:
      return ["table row", "<td>, <th>"];
    case 32768 /* TABLE_COLGROUP */:
      return ["table column group", "<col>"];
    case 258 /* PHRASING_ANY */:
    case 514 /* PHRASING_INSIDE_INPUT */:
    case 1026 /* PHRASING_CONTAINER */:
      return ["phrasing content", "<a>, <b>, <img>, <input> ... (no <div>, <p> ...)"];
    case 2050 /* PICTURE */:
      return ["picture content", "<source>, <img>"];
    case 4098 /* BUTTON */:
      return ["button content", "phrasing content except interactive elements"];
    case 1 /* DOCUMENT */:
      return ["document", "<html>"];
  }
};
var initialTag = (tag) => {
  switch (tag) {
    case "html":
      return 32 /* HTML */;
    case "head":
      return 64 /* HEAD */;
    case "body":
      return 130 /* BODY */;
    default:
      return isTagAllowed(10 /* ANYTHING */, tag);
  }
};
function isTagAllowed(state, tag) {
  switch (state) {
    case 2 /* TEXT */:
    case 0 /* NOT_ALLOWED */:
      return 0 /* NOT_ALLOWED */;
    case 32 /* HTML */:
      return isInHtml(tag);
    case 64 /* HEAD */:
      return isInHead(tag);
    case 130 /* BODY */:
    case 10 /* ANYTHING */:
    case 1026 /* PHRASING_CONTAINER */:
      return isInAnything(tag);
    case 4096 /* TABLE */:
      return isInTable(tag);
    case 8192 /* TABLE_BODY */:
      return isInTableBody(tag);
    case 16384 /* TABLE_ROW */:
      return isInTableRow(tag);
    case 32768 /* TABLE_COLGROUP */:
      return isInTableColGroup(tag);
    case 258 /* PHRASING_ANY */:
      return isInPhrasing(tag, true);
    case 514 /* PHRASING_INSIDE_INPUT */:
      return isInPhrasing(tag, false);
    case 2050 /* PICTURE */:
      return isInPicture(tag);
    case 4098 /* BUTTON */:
      return isInButton(tag);
    case 1 /* DOCUMENT */:
      if (tag === "html") {
        return 32 /* HTML */;
      }
  }
  return 0 /* NOT_ALLOWED */;
}
function isInHtml(text) {
  switch (text) {
    case "head":
      return 64 /* HEAD */;
    case "body":
      return 130 /* BODY */;
    default:
      return 0 /* NOT_ALLOWED */;
  }
}
function isInHead(text) {
  switch (text) {
    case "title":
    case "script":
    case "noscript":
    case "style":
      return 2 /* TEXT */;
    case "meta":
    case "link":
    case "base":
      return 4 /* EMPTY */;
    case "template":
      return 10 /* ANYTHING */;
    default:
      return 0 /* NOT_ALLOWED */;
  }
}
function isSelfClosingTag(text) {
  switch (text) {
    case "area":
    case "base":
    case "basefont":
    case "bgsound":
    case "br":
    case "col":
    case "embed":
    case "frame":
    case "hr":
    case "img":
    case "input":
    case "keygen":
    case "link":
    case "meta":
    case "param":
    case "source":
    case "track":
    case "wbr":
      return true;
    default:
      return false;
  }
}
function isInAnything(text) {
  if (isSelfClosingTag(text)) {
    return 4 /* EMPTY */;
  }
  switch (text) {
    case "script":
    case "style":
    case "noscript":
    case "noframes":
      return 2 /* TEXT */;
    case "p":
    case "pre":
      return 258 /* PHRASING_ANY */;
    case "table":
      return 4096 /* TABLE */;
    case "html":
    case "head":
    case "body":
      return 0 /* NOT_ALLOWED */;
    case "button":
      return 4098 /* BUTTON */;
    case "input":
    case "textarea":
      return 514 /* PHRASING_INSIDE_INPUT */;
    case "picture":
      return 2050 /* PICTURE */;
    default:
      return 10 /* ANYTHING */;
  }
}
function isInTable(text) {
  switch (text) {
    case "caption":
      return 10 /* ANYTHING */;
    case "colgroup":
      return 32768 /* TABLE_COLGROUP */;
    case "thead":
    case "tbody":
    case "tfoot":
      return 8192 /* TABLE_BODY */;
    case "script":
      return 2 /* TEXT */;
    default:
      return 0 /* NOT_ALLOWED */;
  }
}
function isInTableBody(text) {
  switch (text) {
    case "tr":
      return 16384 /* TABLE_ROW */;
    case "script":
      return 2 /* TEXT */;
    default:
      return 0 /* NOT_ALLOWED */;
  }
}
function isInTableRow(text) {
  switch (text) {
    case "td":
    case "th":
      return 10 /* ANYTHING */;
    case "script":
      return 2 /* TEXT */;
    default:
      return 0 /* NOT_ALLOWED */;
  }
}
function isInTableColGroup(text) {
  switch (text) {
    case "col":
      return 4 /* EMPTY */;
    case "script":
      return 2 /* TEXT */;
    default:
      return 0 /* NOT_ALLOWED */;
  }
}
function isInPicture(text) {
  switch (text) {
    case "source":
      return 4 /* EMPTY */;
    case "img":
      return 4 /* EMPTY */;
    case "script":
      return 2 /* TEXT */;
    default:
      return 0 /* NOT_ALLOWED */;
  }
}
function isInButton(text) {
  switch (text) {
    case "button":
    case "input":
    case "textarea":
    case "select":
    case "a":
      return 0 /* NOT_ALLOWED */;
    case "picture":
      return 2050 /* PICTURE */;
    default:
      return isInPhrasing(text, false);
  }
}
function isInPhrasing(text, allowInput) {
  switch (text) {
    case "svg":
    case "math":
      return 1026 /* PHRASING_CONTAINER */;
    case "input":
    case "textarea":
      return allowInput ? 514 /* PHRASING_INSIDE_INPUT */ : 0 /* NOT_ALLOWED */;
    case "a":
    case "abbr":
    case "area":
    case "audio":
    case "b":
    case "bdi":
    case "bdo":
    case "br":
    case "button":
    case "canvas":
    case "cite":
    case "code":
    case "command":
    case "data":
    case "datalist":
    case "del":
    case "dfn":
    case "em":
    case "embed":
    case "i":
    case "iframe":
    case "img":
    case "ins":
    case "itemprop":
    case "kbd":
    case "keygen":
    case "label":
    case "link":
    case "map":
    case "mark":
    case "meta":
    case "meter":
    case "noscript":
    case "object":
    case "option":
    case "output":
    case "progress":
    case "q":
    case "ruby":
    case "s":
    case "samp":
    case "select":
    case "slot":
    case "small":
    case "span":
    case "strong":
    case "sub":
    case "sup":
    case "template":
    case "time":
    case "u":
    case "var":
    case "video":
    case "wbr":
      return allowInput ? 258 /* PHRASING_ANY */ : 514 /* PHRASING_INSIDE_INPUT */;
    case "script":
    case "style":
      return 2 /* TEXT */;
    case "picture":
      return 2050 /* PICTURE */;
    default:
      return 0 /* NOT_ALLOWED */;
  }
}

// packages/qwik/src/testing/jsx.ts
function prettyJSX(element, prefix = "") {
  if (!isJSXNode(element)) {
    return prefix + element;
  }
  const lines = [];
  lines.push(prefix, "<", element.type);
  const attrs = Object.entries(element.props).map(([name, value]) => {
    const serializedAttr = serializeAttribute(name, value);
    return {
      name,
      value: serializedAttr === true ? "" : serializedAttr
    };
  }).filter(
    (attr) => [Q_PROPS_SEPARATOR, ELEMENT_KEY, "children"].indexOf(attr.name) == -1 && !attr.name.startsWith("on")
  ).sort((a, b) => a.name.localeCompare(b.name));
  for (let i = 0; i < attrs.length; i++) {
    const attr = attrs[i];
    lines.push("\n", prefix, "   ", attr.name, '="', attr.value, '"');
  }
  if (typeof element.type === "string" && isSelfClosingTag(element.type)) {
    lines.push(" />");
    return lines.join("");
  }
  lines.push(">");
  const children = element.children;
  if (children) {
    if (isJSXNode(children)) {
      lines.push("\n", prettyJSX(children, prefix + "  "));
    } else if (Array.isArray(children)) {
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isJSXNode(child)) {
          lines.push("\n", prettyJSX(child, prefix + "  "));
        } else {
          lines.push("\n", prefix, child);
        }
      }
    } else {
      lines.push("\n", prefix, children);
    }
  }
  lines.push("\n", prefix, "</", element.type, ">");
  return lines.join("");
}

// packages/qwik/src/testing/html.ts
function isTemplate(node) {
  const tagName = node && node.tagName || "";
  return tagName.toUpperCase() == "TEMPLATE";
}
function prettyHtml(element, prefix = "") {
  const lines = [];
  lines.push(prefix, "<", element.localName);
  const attrs = Array.from(element.attributes).map((attr) => ({ name: attr.name, value: attr.value })).filter(
    (attr) => [Q_PROPS_SEPARATOR, ELEMENT_KEY].indexOf(attr.name) == -1 && !attr.name.startsWith("on")
  ).sort((a, b) => a.name.localeCompare(b.name));
  for (let i = 0; i < attrs.length; i++) {
    const attr = attrs[i];
    lines.push("\n", prefix, "   ", attr.name, '="', attr.value, '"');
  }
  if (isSelfClosingTag(element.localName)) {
    lines.push(" />");
    return lines.join("");
  }
  lines.push(">");
  let child = isTemplate(element) ? element.content.firstChild : element.firstChild;
  let text = "";
  while (child) {
    if (child.nodeType === 3) {
      text += child.textContent;
      child = child.nextSibling;
      continue;
    } else if (text) {
      lines.push("\n", prefix, text);
      text = "";
    }
    if (isElement2(child)) {
      lines.push("\n", prettyHtml(child, prefix + "  "));
    } else {
      lines.push("\n", prefix, child.textContent);
    }
    child = child.nextSibling;
  }
  if (text) {
    lines.push("\n", prefix, text);
    text = "";
  }
  lines.push("\n", prefix, "</", element.localName, ">");
  return lines.join("");
}
function isElement2(value) {
  return isNode2(value) && value.nodeType === 1;
}
function isNode2(value) {
  return value && typeof value.nodeType === "number";
}

// packages/qwik/src/testing/vdom-diff.unit-util.ts
expect.extend({
  toMatchVDOM(received, expected, isCsr) {
    const { isNot } = this;
    const container = getContainerElement(received);
    const isSsr = typeof isCsr === "boolean" ? !isCsr : isSsrRenderer(container);
    const diffs = diffJsxVNode(received, expected, [], container, isSsr);
    return {
      pass: isNot ? diffs.length !== 0 : diffs.length === 0,
      message: () => diffs.join("\n")
    };
  },
  async toMatchDOM(received, expected) {
    const { isNot } = this;
    if (!received) {
      return {
        pass: false,
        message: () => "Missing element"
      };
    }
    if (!isElement2(received)) {
      return {
        pass: false,
        message: () => "Received is not an element"
      };
    }
    const receivedHTML = await format(prettyHtml(received), formatOptions);
    const expectedHTML = await format(prettyJSX(expected), formatOptions);
    return {
      pass: isNot ? receivedHTML !== expectedHTML : receivedHTML === expectedHTML,
      message: () => "Expected HTML is not matching received HTML",
      actual: receivedHTML,
      expected: expectedHTML
    };
  }
});
var ignoredAttributes = [QBackRefs, ELEMENT_ID, "", Q_PROPS_SEPARATOR];
function getContainerElement(vNode) {
  let maybeParent;
  do {
    maybeParent = vNode.parent;
    if (maybeParent) {
      vNode = maybeParent;
    }
  } while (maybeParent);
  return vnode_getNode(vNode);
}
function isSsrRenderer(container) {
  return container.hasAttribute(QRenderAttr);
}
function isSkippableNode(node) {
  return node.type === Fragment2 && !node.constProps?.["ssr-required"];
}
function diffJsxVNode(received, expected, path = [], container, isSsr) {
  if (!received) {
    return [path.join(" > ") + " missing"];
  }
  const diffs = [];
  if (typeof expected === "string") {
    const receivedText = vnode_isTextVNode(received) ? vnode_getText(received) : null;
    if (expected !== receivedText) {
      diffs.push(path.join(" > "));
      diffs.push("EXPECTED", JSON.stringify(expected));
      diffs.push("RECEIVED:", JSON.stringify(receivedText));
    }
  } else if (isSsr && expected.type !== Fragment2 && vnode_getNodeTypeName(received) === "Virtual" && getVNodeChildren(container, received).length === 1) {
    return diffJsxVNode(vnode_getFirstChild(received), expected, path, container, false);
  } else if (!isSsr || isSsr && !isSkippableNode(expected)) {
    const receivedTag = vnode_isElementVNode(received) ? vnode_getElementName(received) : vnode_isVirtualVNode(received) ? Fragment2 : "...";
    const isTagSame = String(expected.type).toLowerCase() == String(receivedTag).toLowerCase();
    if (!isTagSame) {
      diffs.push(
        path.join(" > ") + " expecting=" + tagToString(expected.type) + " received=" + tagToString(receivedTag)
      );
    }
    const allProps = [];
    expected.varProps && propsAdd(allProps, Object.keys(expected.varProps));
    expected.constProps && propsAdd(allProps, Object.keys(expected.constProps));
    const receivedElement = vnode_isElementVNode(received) ? vnode_getNode(received) : null;
    propsAdd(
      allProps,
      vnode_isElementVNode(received) ? vnode_getAttrKeys(received).filter((key) => !ignoredAttributes.includes(key)).sort() : []
    );
    receivedElement && propsAdd(allProps, constPropsFromElement(receivedElement));
    path.push(tagToString(expected.type));
    allProps.sort();
    allProps.forEach((prop) => {
      if (isJsxPropertyAnEventName(prop) || isHtmlAttributeAnEventName(prop)) {
        return;
      }
      const propLowerCased = prop.toLowerCase();
      let receivedValue = received.getAttr(prop) || received.getAttr(propLowerCased) || receivedElement?.getAttribute(prop) || receivedElement?.getAttribute(propLowerCased);
      let expectedValue = prop === "key" || prop === ELEMENT_KEY ? receivedValue : expected.props[prop];
      if (typeof receivedValue === "boolean" || typeof receivedValue === "number") {
        receivedValue = serializeBooleanOrNumberAttribute(receivedValue);
      }
      if (typeof expectedValue === "number") {
        expectedValue = serializeBooleanOrNumberAttribute(expectedValue);
      }
      if (!attrsEqual(expectedValue, receivedValue)) {
        diffs.push(`${path.join(" > ")}: [${prop}]`);
        diffs.push("  EXPECTED: " + JSON.stringify(expectedValue));
        diffs.push("  RECEIVED: " + JSON.stringify(receivedValue));
      }
    });
    diffJsxVNodeChildren(received, expected, path, container, isSsr, diffs);
  } else if (isSsr && isSkippableNode(expected)) {
    diffJsxVNodeChildren(received, expected, path, container, isSsr, diffs);
  }
  return diffs;
}
function getJSXChildren(jsx2) {
  const children = jsx2.children;
  if (Array.isArray(children)) {
    return children;
  } else if (children != null) {
    return [children];
  }
  return [];
}
function diffJsxVNodeChildren(received, expected, path, container, isSsr, diffs) {
  const allExpectedChildren = getJSXChildren(expected);
  const expectedChildren = getFilteredJSXChildren(allExpectedChildren, isSsr, {
    mergedText: void 0
  });
  if (_isJSXNode(expected)) {
    expected.children = expectedChildren;
  }
  const receivedChildren = getVNodeChildren(container, received);
  if (receivedChildren.length === expectedChildren.length) {
    for (let i = 0; i < receivedChildren.length; i++) {
      const receivedChild = receivedChildren[i];
      const expectedChild = expectedChildren[i];
      diffs.push(
        ...diffJsxVNode(receivedChild, expectedChild, path, container, isSsr)
      );
    }
  } else {
    diffs.push(
      `${path.join(" > ")} expecting ${expectedChildren.length} children but was ${receivedChildren.length}`
    );
    diffs.push("EXPECTED", jsxToHTML(expected, "  "));
    diffs.push("RECEIVED", received.toString());
  }
  path.pop();
}
function getFilteredJSXChildren(children, isSsr, data) {
  const filteredChildren = [];
  const pushMergedTextIfNeeded = () => {
    if (data.mergedText !== void 0) {
      filteredChildren.push(data.mergedText);
      data.mergedText = void 0;
    }
  };
  function processChildren(children2) {
    for (const child of children2) {
      if (typeof child === "string" || typeof child === "number") {
        if (child !== "") {
          data.mergedText = typeof data.mergedText === "string" ? data.mergedText + child : String(child);
        }
        continue;
      }
      if (isSsr && _isJSXNode(child) && isSkippableNode(child)) {
        const skippedNodeChildren = getJSXChildren(child);
        processChildren(skippedNodeChildren);
      } else {
        pushMergedTextIfNeeded();
        filteredChildren.push(child);
      }
    }
  }
  processChildren(children);
  pushMergedTextIfNeeded();
  return filteredChildren;
}
function getVNodeChildren(container, vNode) {
  const children = [];
  let mergedText;
  const pushMergedTextIfNeeded = () => {
    if (mergedText !== void 0) {
      const mergedTextVNode = vnode_newText(
        container.ownerDocument.createTextNode(mergedText),
        mergedText
      );
      children.push(mergedTextVNode);
      mergedText = void 0;
    }
  };
  let child = vnode_getFirstChild(vNode);
  while (child) {
    if (!shouldSkip(child)) {
      if (vnode_isTextVNode(child)) {
        const vnodeText = vnode_getText(child);
        if (vnodeText !== "") {
          if (mergedText === void 0) {
            mergedText = vnodeText;
          } else {
            mergedText += vnodeText;
          }
        }
        child = child.nextSibling;
        continue;
      }
      pushMergedTextIfNeeded();
      children.push(child);
    }
    child = child.nextSibling;
  }
  pushMergedTextIfNeeded();
  return children;
}
function jsxToHTML(jsx2, pad2 = "") {
  const html = [];
  if (jsx2.type) {
    html.push(pad2, "<", tagToString(jsx2.type), ">\n");
    getJSXChildren(jsx2).forEach((jsx3) => {
      html.push(jsxToHTML(jsx3, pad2 + "  "));
    });
    html.push(pad2, "</", tagToString(jsx2.type), ">\n");
  } else {
    html.push(pad2, JSON.stringify(jsx2), "\n");
  }
  return html.join("");
}
function tagToString(tag) {
  if (tag === Fragment2) {
    return "Fragment";
  }
  if (tag === Slot2) {
    return "Slot";
  }
  return String(tag);
}
function shouldSkip(vNode) {
  if (vNode && vnode_isElementVNode(vNode)) {
    const tag = vnode_getElementName(vNode);
    if (tag === "script" && (vNode.getAttr("type") === "qwik/vnode" || vNode.getAttr("type") === "x-qwik/vnode" || vNode.getAttr("type") === "qwik/state")) {
      return true;
    }
  }
  return false;
}
function walkJSX(jsx2, apply) {
  if (_isJSXNode(jsx2)) {
    apply.enter(jsx2);
    if (Array.isArray(jsx2.children)) {
      for (const child of jsx2.children) {
        processChild(child);
      }
    } else if (jsx2.children) {
      processChild(jsx2.children);
    }
    apply.leave(jsx2);
  } else if (typeof jsx2 === "string") {
    apply.text(jsx2);
  } else if (typeof jsx2 === "number") {
    apply.text(String(jsx2));
  } else {
    throw new Error("unsupported: " + jsx2);
  }
  function processChild(child) {
    if (isSignal2(child)) {
      child = child.value;
    }
    if (_isStringifiable(child)) {
      apply.text(child);
    } else if (_isJSXNode(child)) {
      walkJSX(child, apply);
    } else {
      throw new Error("Unknown type: " + child);
    }
  }
}
function vnode_fromJSX(jsx2) {
  const doc2 = createDocument();
  doc2.documentElement.setAttribute(QContainerAttr, "resumed" /* RESUMED */);
  doc2.qVNodeData = /* @__PURE__ */ new WeakMap();
  const container = _getDomContainer(doc2.body);
  const vBody = vnode_newUnMaterializedElement(doc2.body);
  let vParent = vBody;
  const journal = container.$journal$;
  walkJSX(jsx2, {
    enter: (jsx3) => {
      const type = jsx3.type;
      let child;
      if (typeof type === "string") {
        child = vnode_newUnMaterializedElement(doc2.createElement(type));
      } else if (typeof type === "function") {
        if (type === Fragment2) {
          child = vnode_newVirtual();
        } else {
          throw new Error("Unknown type:" + type);
        }
      } else {
        throw new Error("Unknown type:" + type);
      }
      vnode_insertBefore(journal, vParent, child, null);
      const props = jsx3.varProps;
      for (const key in props) {
        if (Object.prototype.hasOwnProperty.call(props, key)) {
          if (isJsxPropertyAnEventName(key)) {
            continue;
          }
          if (key.startsWith(HANDLER_PREFIX) || isHtmlAttributeAnEventName(key)) {
            child.setProp(key, props[key]);
          } else {
            child.setAttr(key, String(props[key]), journal);
          }
        }
      }
      if (jsx3.key != null) {
        child.setAttr(ELEMENT_KEY, String(jsx3.key), journal);
      }
      vParent = child;
    },
    leave: (_jsx) => {
      vParent = vParent.parent;
    },
    text: (value) => {
      vnode_insertBefore(
        journal,
        vParent,
        vnode_newText(doc2.createTextNode(String(value)), String(value)),
        null
      );
    }
  });
  vnode_applyJournal(journal);
  return { vParent, vNode: vnode_getFirstChild(vParent), document: doc2, container };
}
function constPropsFromElement(element) {
  const props = [];
  for (let i = 0; i < element.attributes.length; i++) {
    const attr = element.attributes[i];
    if (!ignoredAttributes.includes(attr.name)) {
      props.push(attr.name);
    }
  }
  props.sort();
  return props;
}
function propsAdd(existing, incoming) {
  for (const prop of incoming) {
    if (prop !== "children") {
      let found = false;
      for (let i = 0; i < existing.length; i++) {
        if (existing[i].toLowerCase() === prop.toLowerCase()) {
          found = true;
          break;
        }
      }
      if (!found) {
        existing.push(prop);
      }
    }
  }
}
var formatOptions = { parser: "html", htmlWhitespaceSensitivity: "ignore" };
function attrsEqual(expectedValue, receivedValue) {
  const isEqual = typeof expectedValue == "boolean" ? expectedValue ? receivedValue !== null : receivedValue === null || receivedValue === "false" : expectedValue == receivedValue;
  return isEqual;
}

// packages/qwik/src/testing/element-fixture.ts
import { getDomContainer as getDomContainer2 } from "../core.mjs";

// packages/qwik/src/testing/platform.ts
import { existsSync } from "node:fs";
import { fileURLToPath } from "node:url";
function createPlatform2() {
  const moduleCache = /* @__PURE__ */ new Map();
  const testPlatform2 = {
    isServer: false,
    importSymbol(containerEl, url, symbolName) {
      const hash3 = getSymbolHash(symbolName);
      const regSym = globalThis.__qwik_reg_symbols?.get(hash3);
      if (regSym) {
        return regSym;
      }
      if (!url) {
        console.error("Q-ERROR: importSymbol missing url for", symbolName);
        throw new Error("Missing URL");
      }
      if (!containerEl) {
        throw new Error("Missing Container");
      }
      const urlDoc = toUrl2(containerEl.ownerDocument, containerEl, url);
      const importPath = toPath(urlDoc);
      const mod = moduleCache.get(importPath);
      if (mod) {
        if (!mod || !(symbolName in mod)) {
          throw new Error(`Q-ERROR: missing symbol '${symbolName}' in module '${url}'.`);
        }
        return mod[symbolName];
      }
      return import(importPath).then((mod2) => {
        moduleCache.set(importPath, mod2);
        if (!mod2 || !(symbolName in mod2)) {
          throw new Error(`Q-ERROR: missing symbol '${symbolName}' in module '${url}'.`);
        }
        return mod2[symbolName];
      });
    },
    raf: (fn) => {
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve(fn());
        });
      });
    },
    flush: async () => {
      await Promise.resolve();
    },
    chunkForSymbol() {
      return void 0;
    }
  };
  return testPlatform2;
}
function setTestPlatform(_setPlatform) {
  _setPlatform(testPlatform);
}
function toUrl2(doc2, containerEl, url) {
  const base2 = new URL(containerEl?.getAttribute("q:base") ?? doc2.baseURI, doc2.baseURI);
  return new URL(url, base2);
}
function toPath(url) {
  const normalizedUrl = new URL(String(url));
  normalizedUrl.hash = "";
  normalizedUrl.search = "";
  const path = fileURLToPath(String(normalizedUrl));
  const importPaths = [path, ...testExts.map((ext) => path + ext)];
  for (const importPath of importPaths) {
    if (existsSync(importPath)) {
      return importPath;
    }
  }
  throw new Error(`Unable to find path for import "${url}"`);
}
var testPlatform = createPlatform2();
function getTestPlatform() {
  return testPlatform;
}
var testExts = [".ts", ".tsx", ".js", ".cjs", ".mjs", ".jsx"];

// packages/qwik/src/testing/element-fixture.ts
var ElementFixture = class {
  constructor(options = {}) {
    __publicField(this, "window");
    __publicField(this, "document");
    __publicField(this, "superParent");
    __publicField(this, "parent");
    __publicField(this, "host");
    __publicField(this, "child");
    this.window = createWindow();
    this.document = this.window.document;
    this.superParent = this.document.createElement("super-parent");
    this.document.body.appendChild(this.superParent);
    this.parent = this.document.createElement("parent");
    this.superParent.appendChild(this.parent);
    if (options.html) {
      this.parent.innerHTML = options.html;
      this.host = this.parent.firstElementChild;
      assertDefined(this.host, "host element must be defined");
      this.host.querySelectorAll('script[q\\:func="qwik/json"]').forEach((script2) => {
        const code2 = script2.textContent;
        if (code2?.match(Q_FUNCS_PREFIX)) {
          const equal = code2.indexOf("=");
          const qFuncs2 = (0, eval)(code2.substring(equal + 1));
          const container = this.host.closest(QContainerSelector2);
          const hash3 = container.getAttribute(QInstanceAttr);
          document[QFuncsPrefix + hash3] = qFuncs2;
        }
      });
      this.child = null;
    } else {
      this.host = this.document.createElement(options.tagName || "host");
      this.child = this.document.createElement("child");
      this.parent.appendChild(this.host);
      this.host.appendChild(this.child);
    }
  }
};
function isDocumentOrWindowEvent(scope) {
  return scope === "-document" || scope === "-window";
}
async function trigger(root, queryOrElement, eventName, eventPayload = {}, options) {
  const waitForIdle = options?.waitForIdle ?? true;
  let scope = "";
  if (eventName.startsWith(":")) {
    const colonIndex = eventName.substring(1).indexOf(":");
    scope = "-" + eventName.substring(1, colonIndex + 1);
    eventName = eventName.substring(colonIndex + 2);
    if (scope === "-document") {
      queryOrElement = `[on-document\\:${fromCamelToKebabCase(eventName)}]`;
    } else {
      queryOrElement = `[on-window\\:${fromCamelToKebabCase(eventName)}]`;
    }
  }
  const elements = typeof queryOrElement === "string" ? Array.from(root.querySelectorAll(queryOrElement)) : [queryOrElement];
  let container = null;
  for (const element of elements) {
    if (!element) {
      continue;
    }
    if (!container) {
      container = getDomContainer2(element);
    }
    const event = new Event(eventName, {
      bubbles: true,
      cancelable: true
    });
    Object.assign(event, eventPayload);
    const prefix = scope ? scope === "-document" ? "on-document:" /* document */ : "on-window:" /* window */ : "on:" /* on */;
    const attrName = prefix + fromCamelToKebabCase(eventName);
    await dispatch(element, attrName, event, scope);
  }
  const waitForQueueChore = container?.$scheduler$(255 /* WAIT_FOR_QUEUE */);
  if (waitForIdle && waitForQueueChore) {
    await waitForQueueChore.$returnValue$;
  }
}
var PREVENT_DEFAULT = "preventdefault:";
var STOP_PROPAGATION = "stoppropagation:";
var Q_FUNCS_PREFIX = /document.qdata\["qFuncs_(.+)"\]=/;
var QContainerSelector2 = "[q\\:container]";
var dispatch = async (element, attrName, event, scope) => {
  const isDocumentOrWindow = isDocumentOrWindowEvent(scope);
  const preventAttributeName = PREVENT_DEFAULT + (isDocumentOrWindow ? event.type.substring(1) : event.type);
  const stopPropagationName = STOP_PROPAGATION + event.type;
  while (element) {
    const preventDefault = element.hasAttribute(preventAttributeName);
    const stopPropagation = element.hasAttribute(stopPropagationName);
    if (preventDefault) {
      event.preventDefault();
    }
    if (stopPropagation) {
      event.stopPropagation();
    }
    if ("qDispatchEvent" in element) {
      element.qDispatchEvent(event, scope);
      await delay(0);
      return;
    } else if (element.hasAttribute(attrName)) {
      const container = getDomContainer2(element);
      const qrl = element.getAttribute(attrName);
      const ctx = newInvokeContextFromTuple([element, event]);
      try {
        await Promise.all(
          qrl.split("\n").map((qrl2) => container.parseQRL(qrl2.trim())).map((qrl2) => {
            return invokeApply(ctx, qrl2, [event, element]);
          })
        );
      } catch (error) {
        console.error("!!! qrl error", qrl, error);
        throw error;
      }
      return;
    }
    element = element.parentElement;
  }
};

// packages/qwik/src/testing/library.ts
var createDOM = async function({ html } = {}) {
  const qwik = await getQwik();
  setTestPlatform(qwik.setPlatform);
  const host = new ElementFixture({ html }).host;
  return {
    render: function(jsxElement) {
      return qwik.render(host, jsxElement);
    },
    screen: host,
    userEvent: async function(queryOrElement, eventNameCamel, eventPayload = {}) {
      return trigger(host, queryOrElement, eventNameCamel, eventPayload);
    }
  };
};
var getQwik = async () => {
  if (false) {
    return await null;
  } else {
    return await import("../core.mjs");
  }
};

// packages/qwik/src/testing/expect-dom.tsx
import { assert } from "vitest";
import { format as format2 } from "prettier";
async function expectDOM(actual, expected) {
  const options = { parser: "html", htmlWhitespaceSensitivity: "ignore" };
  assert.equal(await format2(actual.outerHTML, options), await format2(expected, options));
}

// packages/qwik/src/testing/rendering.unit-util.tsx
var import_esbuild = __toESM(require_main(), 1);
import { Slot as Slot3, componentQrl as componentQrl2, render } from "../core.mjs";
import { _getDomContainer as _getDomContainer2 } from "@qwik.dev/core/internal";
import { readFileSync } from "fs";
import { join } from "path";
import { fileURLToPath as fileURLToPath2 } from "url";
import { expect as expect2 } from "vitest";

// packages/qwik/src/core/preloader/queue.ts
import { isBrowser as isBrowser3 } from "@qwik.dev/core/build";

// packages/qwik/src/core/preloader/constants.ts
import { isBrowser as isBrowser2 } from "@qwik.dev/core/build";
var doc = isBrowser2 ? document : void 0;
var config = {
  $DEBUG$: false,
  $maxIdlePreloads$: 25,
  $invPreloadProbability$: 0.65
};
var rel = isBrowser2 && doc.createElement("link").relList.supports("modulepreload") ? "modulePreload" : "preload";
var loadStart = Date.now();
var isJSRegex = /\.[mc]?js$/;

// packages/qwik/src/core/preloader/types.ts
var BundleImportState_None = 0;
var BundleImportState_Queued = 1;
var BundleImportState_Preload = 2;
var BundleImportState_Alias = 3;
var BundleImportState_Loaded = 4;

// packages/qwik/src/core/preloader/bundle-graph.ts
var base;
var graph;
var makeBundle = (name, deps) => {
  return {
    $name$: name,
    $state$: isJSRegex.test(name) ? BundleImportState_None : BundleImportState_Alias,
    $deps$: shouldResetFactor ? deps?.map((d) => ({ ...d, $factor$: 1 })) : deps,
    $inverseProbability$: 1,
    $createdTs$: Date.now(),
    $waitedMs$: 0,
    $loadedMs$: 0
  };
};
var parseBundleGraph = (serialized) => {
  const graph2 = /* @__PURE__ */ new Map();
  let i = 0;
  while (i < serialized.length) {
    const name = serialized[i++];
    const deps = [];
    let idx;
    let probability = 1;
    while (idx = serialized[i], typeof idx === "number") {
      if (idx < 0) {
        probability = -idx / 10;
      } else {
        deps.push({
          $name$: serialized[idx],
          $importProbability$: probability,
          $factor$: 1
        });
      }
      i++;
    }
    graph2.set(name, deps);
  }
  return graph2;
};
var getBundle = (name) => {
  let bundle = bundles.get(name);
  if (!bundle) {
    let deps;
    if (graph) {
      deps = graph.get(name);
      if (!deps) {
        return;
      }
      if (!deps.length) {
        deps = void 0;
      }
    }
    bundle = makeBundle(name, deps);
    bundles.set(name, bundle);
  }
  return bundle;
};
var initPreloader = (serializedBundleGraph, opts) => {
  if (opts) {
    if ("debug" in opts) {
      config.$DEBUG$ = !!opts.debug;
    }
    if (typeof opts.preloadProbability === "number") {
      config.$invPreloadProbability$ = 1 - opts.preloadProbability;
    }
  }
  if (base != null || !serializedBundleGraph) {
    return;
  }
  base = "";
  graph = parseBundleGraph(serializedBundleGraph);
};

// packages/qwik/src/core/preloader/queue.ts
var bundles = /* @__PURE__ */ new Map();
var shouldResetFactor;
var queueDirty;
var preloadCount = 0;
var queue = [];
var log7 = (...args) => {
  console.log(
    `Preloader ${Date.now() - loadStart}ms ${preloadCount}/${queue.length} queued>`,
    ...args
  );
};
var resetQueue = () => {
  bundles.clear();
  queueDirty = false;
  shouldResetFactor = true;
  preloadCount = 0;
  queue.length = 0;
};
var sortQueue = () => {
  if (queueDirty) {
    queue.sort((a, b) => a.$inverseProbability$ - b.$inverseProbability$);
    queueDirty = false;
  }
};
var getQueue = () => {
  sortQueue();
  let probability = 0.4;
  const result2 = [];
  for (const b of queue) {
    const nextProbability = Math.round((1 - b.$inverseProbability$) * 10);
    if (nextProbability !== probability) {
      probability = nextProbability;
      result2.push(probability);
    }
    result2.push(b.$name$);
  }
  return result2;
};
var trigger2 = () => {
  if (!queue.length) {
    return;
  }
  sortQueue();
  while (queue.length) {
    const bundle = queue[0];
    const inverseProbability = bundle.$inverseProbability$;
    const probability = 1 - inverseProbability;
    const allowedPreloads = graph ? config.$maxIdlePreloads$ : (
      // While the graph is not available, we limit to 5 preloads
      5
    );
    if (probability >= 0.99 || preloadCount < allowedPreloads) {
      queue.shift();
      preloadOne(bundle);
    } else {
      break;
    }
  }
  if (config.$DEBUG$ && !queue.length) {
    const loaded = [...bundles.values()].filter((b) => b.$state$ > BundleImportState_None);
    const waitTime = loaded.reduce((acc, b) => acc + b.$waitedMs$, 0);
    const loadTime = loaded.reduce((acc, b) => acc + b.$loadedMs$, 0);
    log7(
      `>>>> done ${loaded.length}/${bundles.size} total: ${waitTime}ms waited, ${loadTime}ms loaded`
    );
  }
};
var preloadOne = (bundle) => {
  if (bundle.$state$ >= BundleImportState_Preload) {
    return;
  }
  preloadCount++;
  const start = Date.now();
  bundle.$waitedMs$ = start - bundle.$createdTs$;
  bundle.$state$ = BundleImportState_Preload;
  config.$DEBUG$ && log7(
    `<< load ${Math.round((1 - bundle.$inverseProbability$) * 100)}% after ${`${bundle.$waitedMs$}ms`}`,
    bundle.$name$
  );
  const link = doc.createElement("link");
  link.href = new URL(`${base}${bundle.$name$}`, doc.baseURI).toString();
  link.rel = rel;
  link.as = "script";
  link.onload = link.onerror = () => {
    preloadCount--;
    const end = Date.now();
    bundle.$loadedMs$ = end - start;
    bundle.$state$ = BundleImportState_Loaded;
    config.$DEBUG$ && log7(`>> done after ${bundle.$loadedMs$}ms`, bundle.$name$);
    link.remove();
    trigger2();
  };
  doc.head.appendChild(link);
};
var adjustProbabilities = (bundle, newInverseProbability, seen) => {
  if (seen?.has(bundle)) {
    return;
  }
  const previousInverseProbability = bundle.$inverseProbability$;
  bundle.$inverseProbability$ = newInverseProbability;
  if (previousInverseProbability - bundle.$inverseProbability$ < 0.01) {
    return;
  }
  if (
    // don't queue until we have initialized the preloader
    base != null && bundle.$state$ < BundleImportState_Preload
  ) {
    if (bundle.$state$ === BundleImportState_None) {
      bundle.$state$ = BundleImportState_Queued;
      queue.push(bundle);
      config.$DEBUG$ && log7(`queued ${Math.round((1 - bundle.$inverseProbability$) * 100)}%`, bundle.$name$);
    }
    queueDirty = true;
  }
  if (bundle.$deps$) {
    seen || (seen = /* @__PURE__ */ new Set());
    seen.add(bundle);
    const probability = 1 - bundle.$inverseProbability$;
    for (const dep of bundle.$deps$) {
      const depBundle = getBundle(dep.$name$);
      if (depBundle.$inverseProbability$ === 0) {
        continue;
      }
      let newInverseProbability2;
      if (probability === 1 || probability >= 0.99 && depsCount < 100) {
        depsCount++;
        newInverseProbability2 = Math.min(0.01, 1 - dep.$importProbability$);
      } else {
        const newInverseImportProbability = 1 - dep.$importProbability$ * probability;
        const prevAdjust = dep.$factor$;
        const factor = newInverseImportProbability / prevAdjust;
        newInverseProbability2 = Math.max(0.02, depBundle.$inverseProbability$ * factor);
        dep.$factor$ = factor;
      }
      adjustProbabilities(depBundle, newInverseProbability2, seen);
    }
  }
};
var handleBundle = (name, inverseProbability) => {
  const bundle = getBundle(name);
  if (bundle && bundle.$inverseProbability$ > inverseProbability) {
    adjustProbabilities(bundle, inverseProbability);
  }
};
var depsCount;
var preload3 = (name, probability) => {
  if (!name?.length) {
    return;
  }
  depsCount = 0;
  let inverseProbability = probability ? 1 - probability : 0.4;
  if (Array.isArray(name)) {
    for (let i = name.length - 1; i >= 0; i--) {
      const item = name[i];
      if (typeof item === "number") {
        inverseProbability = 1 - item / 10;
      } else {
        handleBundle(item, inverseProbability);
      }
    }
  } else {
    handleBundle(name, inverseProbability);
  }
  if (isBrowser3) {
    trigger2();
  }
};
if (isBrowser3) {
  document.addEventListener("qsymbol", (ev) => {
    const { symbol, href } = ev.detail;
    if (href) {
      const hash3 = symbol.slice(symbol.lastIndexOf("_") + 1);
      preload3(hash3, 1);
    }
  });
}

// packages/qwik/src/server/platform.ts
import { setPlatform as setPlatform2 } from "../core.mjs";
import { isDev as isDev11 } from "@qwik.dev/core/build";
var getDevSegmentPath = (mapper, hash3, symbolName, parent) => {
  const existing = mapper?.[hash3];
  if (existing) {
    return existing;
  }
  if (symbolName === SYNC_QRL) {
    return [symbolName, ""];
  }
  if (!parent) {
    if (symbolName.startsWith("_") && symbolName.length < 6) {
      return [symbolName, `${import.meta.env.BASE_URL}@qwik-handlers`];
    }
    console.error("qwik symbolMapper: unknown qrl requested without parent:", symbolName);
    return [symbolName, `${import.meta.env.BASE_URL}${symbolName}.js`];
  }
  const qrlFile = `${import.meta.env.BASE_URL}${parent.startsWith("/") ? parent.slice(1) : parent}_${symbolName}.js`;
  return [symbolName, qrlFile];
};
function createPlatform3(opts, resolvedManifest) {
  const mapper = resolvedManifest?.mapper;
  const mapperFn = opts.symbolMapper ? opts.symbolMapper : (symbolName, _chunk, parent) => {
    if (mapper || isDev11 && import.meta.env.MODE !== "test") {
      const hash3 = getSymbolHash2(symbolName);
      const result2 = !isDev11 ? mapper[hash3] : getDevSegmentPath(mapper, hash3, symbolName, parent);
      if (!result2) {
        if (hash3 === SYNC_QRL) {
          return [hash3, ""];
        }
        const isRegistered = globalThis.__qwik_reg_symbols?.has(hash3);
        if (isRegistered) {
          return [symbolName, "_"];
        }
        console.error("Cannot resolve symbol", symbolName, "in", mapper, parent);
      }
      return result2;
    }
  };
  const serverPlatform = {
    isServer: true,
    async importSymbol(_containerEl, url, symbolName) {
      const hash3 = getSymbolHash2(symbolName);
      const regSym = globalThis.__qwik_reg_symbols?.get(hash3);
      if (regSym) {
        return regSym;
      }
      let modulePath = String(url);
      if (!modulePath.endsWith(".js")) {
        modulePath += ".js";
      }
      const module = __require(modulePath);
      if (!(symbolName in module)) {
        throw new Error(`Q-ERROR: missing symbol '${symbolName}' in module '${modulePath}'.`);
      }
      return module[symbolName];
    },
    raf: () => {
      console.error("server can not rerender");
      return Promise.resolve();
    },
    chunkForSymbol(symbolName, _chunk, parent) {
      return mapperFn(symbolName, mapper, parent);
    }
  };
  return serverPlatform;
}
async function setServerPlatform(opts, manifest) {
  const platform = createPlatform3(opts, manifest);
  setPlatform2(platform);
}
var getSymbolHash2 = (symbolName) => {
  const index = symbolName.lastIndexOf("_");
  if (index > -1) {
    return symbolName.slice(index + 1);
  }
  return symbolName;
};

// packages/qwik/src/server/utils.ts
function createTimer() {
  if (typeof performance === "undefined") {
    return () => 0;
  }
  const start = performance.now();
  return () => {
    const end = performance.now();
    const delta = end - start;
    return delta / 1e6;
  };
}
function getBuildBase(opts) {
  let base2 = opts.base;
  if (typeof opts.base === "function") {
    base2 = opts.base(opts);
  }
  if (typeof base2 === "string") {
    if (!base2.endsWith("/")) {
      base2 += "/";
    }
    return base2;
  }
  return `${import.meta.env.BASE_URL || "/"}build/`;
}
var versions = {
  qwik: globalThis.QWIK_VERSION,
  qwikDom: globalThis.QWIK_DOM_VERSION
};

// packages/qwik/src/server/ssr-container.ts
import { isDev as isDev13 } from "@qwik.dev/core/build";
import {
  _SubscriptionData as SubscriptionData2,
  _SharedContainer as _SharedContainer2,
  _jsxSorted as _jsxSorted2,
  _jsxSplit as _jsxSplit2,
  _walkJSX,
  isSignal as isSignal3
} from "@qwik.dev/core/internal";

// packages/qwik/src/server/preload-strategy.ts
import { getPlatform as getPlatform2 } from "../core.mjs";

// packages/qwik/src/server/preload-utils.ts
function flattenPrefetchResources(prefetchResources) {
  const urls = [];
  const addPrefetchResource = (prefetchResources2) => {
    if (prefetchResources2) {
      for (const prefetchResource of prefetchResources2) {
        if (!urls.includes(prefetchResource.url)) {
          urls.push(prefetchResource.url);
          if (prefetchResource.imports) {
            addPrefetchResource(prefetchResource.imports);
          }
        }
      }
    }
  };
  addPrefetchResource(prefetchResources);
  return urls;
}

// packages/qwik/src/server/preload-strategy.ts
var getBundles = (qrls) => {
  const platform = getPlatform2();
  return qrls?.map((qrl) => {
    const symbol = qrl.$symbol$;
    const chunk = qrl.$chunk$;
    const result2 = platform.chunkForSymbol(symbol, chunk, qrl.dev?.file);
    if (result2) {
      return result2[1];
    }
    return chunk;
  }).filter(Boolean);
};
function getPreloadPaths(qrls, opts, resolvedManifest) {
  const prefetchStrategy = opts.prefetchStrategy;
  if (prefetchStrategy === null) {
    return [];
  }
  if (!resolvedManifest?.manifest.bundleGraph) {
    return getBundles(qrls);
  }
  if (typeof prefetchStrategy?.symbolsToPrefetch === "function") {
    try {
      const prefetchResources = prefetchStrategy.symbolsToPrefetch({
        manifest: resolvedManifest.manifest
      });
      return flattenPrefetchResources(prefetchResources);
    } catch (e) {
      console.error("getPrefetchUrls, symbolsToPrefetch()", e);
    }
  }
  const symbols = /* @__PURE__ */ new Set();
  for (const qrl of qrls) {
    const symbol = getSymbolHash2(qrl.$symbol$);
    if (symbol && symbol.length >= 10) {
      symbols.add(symbol);
    }
  }
  return [...symbols];
}
var expandBundles = (names, resolvedManifest) => {
  if (!resolvedManifest?.manifest.bundleGraph) {
    return [...new Set(names)];
  }
  resetQueue();
  let probability = 0.99;
  for (const name of names) {
    preload3(name, probability);
    probability *= 0.95;
  }
  return getQueue();
};

// packages/qwik/src/server/preload-impl.ts
var simplifyPath = (base2, path) => {
  if (path == null) {
    return null;
  }
  const segments = `${base2}${path}`.split("/");
  const simplified = [];
  for (const segment of segments) {
    if (segment === ".." && simplified.length > 0) {
      simplified.pop();
    } else {
      simplified.push(segment);
    }
  }
  return simplified.join("/");
};
var getBase = (container) => {
  let base2 = container.$buildBase$;
  if (import.meta.env.DEV && !import.meta.env.TEST) {
    base2 = import.meta.env.BASE_URL;
  }
  return base2;
};
var preloaderPre = (container, options, nonce) => {
  const { resolvedManifest } = container;
  const base2 = getBase(container);
  const preloaderBundle = simplifyPath(base2, resolvedManifest?.manifest?.preloader);
  let bundleGraphPath = resolvedManifest?.manifest.bundleGraphAsset;
  if (bundleGraphPath) {
    bundleGraphPath = (import.meta.env.BASE_URL || "/") + bundleGraphPath;
  }
  if (preloaderBundle && bundleGraphPath && options !== false) {
    const preloaderOpts = typeof options === "object" ? {
      debug: options.debug,
      preloadProbability: options.ssrPreloadProbability
    } : void 0;
    const bundleGraph = container.resolvedManifest?.manifest.bundleGraph;
    initPreloader(bundleGraph, preloaderOpts);
    const opts = [];
    if (options) {
      if (options.debug) {
        opts.push("d:1");
      }
      if (options.maxIdlePreloads) {
        opts.push(`P:${options.maxIdlePreloads}`);
      }
      if (options.preloadProbability) {
        opts.push(`Q:${options.preloadProbability}`);
      }
    }
    const optsStr = opts.length ? `,{${opts.join(",")}}` : "";
    const preloaderLinkAttrs = ["rel", "modulepreload", "href", preloaderBundle];
    if (nonce) {
      preloaderLinkAttrs.push("nonce", nonce);
    }
    container.openElement("link", null, preloaderLinkAttrs);
    container.closeElement();
    container.openElement("link", null, [
      "rel",
      "preload",
      "href",
      bundleGraphPath,
      "as",
      "fetch",
      "crossorigin",
      "anonymous"
    ]);
    container.closeElement();
    const script2 = `let b=fetch("${bundleGraphPath}");import("${preloaderBundle}").then(({l})=>l(${JSON.stringify(base2)},b${optsStr}));`;
    const scriptAttrs = ["type", "module", "async", true];
    if (nonce) {
      scriptAttrs.push("nonce", nonce);
    }
    container.openElement("script", null, scriptAttrs);
    container.write(script2);
    container.closeElement();
  }
  const corePath = simplifyPath(base2, resolvedManifest?.manifest.core);
  if (corePath) {
    const linkAttrs = ["rel", "modulepreload", "href", corePath];
    if (nonce) {
      linkAttrs.push("nonce", nonce);
    }
    container.openElement("link", null, linkAttrs);
    container.closeElement();
  }
};
var includePreloader = (container, options, referencedBundles, nonce) => {
  if (referencedBundles.length === 0 || options === false) {
    return null;
  }
  const { ssrPreloads, ssrPreloadProbability } = normalizePreLoaderOptions(
    typeof options === "boolean" ? void 0 : options
  );
  let allowed = ssrPreloads;
  const base2 = getBase(container);
  const links = [];
  const { resolvedManifest } = container;
  if (allowed) {
    const preloaderBundle2 = resolvedManifest?.manifest.preloader;
    const coreBundle = resolvedManifest?.manifest.core;
    const expandedBundles = expandBundles(referencedBundles, resolvedManifest);
    let probability = 4;
    const tenXMinProbability = ssrPreloadProbability * 10;
    for (const hrefOrProbability of expandedBundles) {
      if (typeof hrefOrProbability === "string") {
        if (probability < tenXMinProbability) {
          break;
        }
        if (hrefOrProbability === preloaderBundle2 || hrefOrProbability === coreBundle) {
          continue;
        }
        links.push(hrefOrProbability);
        if (--allowed === 0) {
          break;
        }
      } else {
        probability = hrefOrProbability;
      }
    }
  }
  const preloaderBundle = simplifyPath(base2, resolvedManifest?.manifest.preloader);
  const insertLinks = links.length ? (
    /**
     * We only use modulepreload links because they behave best. Older browsers can rely on the
     * preloader which does feature detection and which will be available soon after inserting these
     * links.
     */
    `${JSON.stringify(links)}.map((l,e)=>{e=document.createElement('link');e.rel='modulepreload';e.href=${JSON.stringify(base2)}+l;document.head.appendChild(e)});`
  ) : "";
  let script2 = insertLinks;
  if (preloaderBundle) {
    script2 += `window.addEventListener('load',f=>{f=_=>import("${preloaderBundle}").then(({p})=>p(${JSON.stringify(referencedBundles)}));try{requestIdleCallback(f,{timeout:2000})}catch(e){setTimeout(f,200)}})`;
  }
  if (script2) {
    const attrs = ["type", "module", "async", true, "q:type", "preload"];
    if (nonce) {
      attrs.push("nonce", nonce);
    }
    container.openElement("script", null, attrs);
    container.write(script2);
    container.closeElement();
  }
  return null;
};
var preloaderPost = (ssrContainer, opts, nonce) => {
  if (opts.preloader !== false) {
    const qrls = Array.from(ssrContainer.serializationCtx.$eventQrls$);
    const preloadBundles = getPreloadPaths(qrls, opts, ssrContainer.resolvedManifest);
    if (preloadBundles.length > 0) {
      includePreloader(ssrContainer, opts.preloader, preloadBundles, nonce);
    }
  }
};
function normalizePreLoaderOptions(input) {
  return { ...preLoaderOptionsDefault, ...input };
}
var preLoaderOptionsDefault = {
  ssrPreloads: 7,
  ssrPreloadProbability: 0.5,
  debug: false,
  maxIdlePreloads: 25,
  preloadProbability: 0.35
  // deprecated
};

// packages/qwik/src/server/scripts.ts
var QWIK_LOADER_DEFAULT_MINIFIED = globalThis.QWIK_LOADER_DEFAULT_MINIFIED;
var QWIK_LOADER_DEFAULT_DEBUG = globalThis.QWIK_LOADER_DEFAULT_DEBUG;
var QWIK_BACKPATCH_EXECUTOR_MINIFIED = globalThis.QWIK_BACKPATCH_EXECUTOR_MINIFIED;
var QWIK_BACKPATCH_EXECUTOR_DEBUG = globalThis.QWIK_BACKPATCH_EXECUTOR_DEBUG;
function getQwikLoaderScript(opts = {}) {
  return opts.debug ? QWIK_LOADER_DEFAULT_DEBUG : QWIK_LOADER_DEFAULT_MINIFIED;
}
var QWIK_PREFETCH_MINIFIED = globalThis.QWIK_PREFETCH_MINIFIED;
var QWIK_PREFETCH_DEBUG = globalThis.QWIK_PREFETCH_DEBUG;
function getQwikBackpatchExecutorScript(opts = {}) {
  return opts.debug ? QWIK_BACKPATCH_EXECUTOR_DEBUG : QWIK_BACKPATCH_EXECUTOR_MINIFIED;
}

// packages/qwik/src/server/ssr-node.ts
import { _isJSXNode as isJSXNode2, _EMPTY_ARRAY, _EFFECT_BACK_REF as _EFFECT_BACK_REF2 } from "@qwik.dev/core/internal";
import { isDev as isDev12 } from "@qwik.dev/core/build";
var SsrNode = class {
  constructor(parentComponent, id, attributesIndex, cleanupQueue, vnodeData, currentFile) {
    this.parentComponent = parentComponent;
    this.attributesIndex = attributesIndex;
    this.cleanupQueue = cleanupQueue;
    this.vnodeData = vnodeData;
    this.currentFile = currentFile;
    __publicField(this, "__brand__", "SsrNode");
    /**
     * ID which the deserialize will use to retrieve the node.
     *
     * @param id - Unique id for the node.
     */
    __publicField(this, "id");
    __publicField(this, "flags");
    __publicField(this, "children", null);
    __publicField(this, "attrs");
    /** Local props which don't serialize; */
    __publicField(this, "localProps", null);
    this.id = id;
    this.flags = 1 /* Updatable */;
    this.attrs = this.attributesIndex >= 0 ? this.vnodeData[this.attributesIndex] : _EMPTY_ARRAY;
    this.parentComponent?.addChild(this);
    if (isDev12 && id.indexOf("undefined") != -1) {
      throw new Error(`Invalid SSR node id: ${id}`);
    }
  }
  get [_EFFECT_BACK_REF2]() {
    return this.getProp(QBackRefs);
  }
  setProp(name, value) {
    if (this.attrs === _EMPTY_ARRAY) {
      this.setEmptyArrayAsVNodeDataAttributes();
    }
    if (name.startsWith(NON_SERIALIZABLE_MARKER_PREFIX)) {
      mapArray_set(this.localProps || (this.localProps = []), name, value, 0);
    } else {
      mapArray_set(this.attrs, name, value, 0);
    }
    if (name == ELEMENT_SEQ && value) {
      this.cleanupQueue.push(value);
    }
  }
  setEmptyArrayAsVNodeDataAttributes() {
    if (this.attributesIndex >= 0) {
      this.vnodeData[this.attributesIndex] = [];
      this.attrs = this.vnodeData[this.attributesIndex];
    } else {
      const newAttributesIndex = this.vnodeData.length > 1 ? 1 : 0;
      this.vnodeData.splice(newAttributesIndex, 0, []);
      this.attributesIndex = newAttributesIndex;
      this.attrs = this.vnodeData[this.attributesIndex];
    }
  }
  getProp(name) {
    if (name.startsWith(NON_SERIALIZABLE_MARKER_PREFIX)) {
      return this.localProps ? mapArray_get(this.localProps, name, 0) : null;
    } else {
      return mapArray_get(this.attrs, name, 0);
    }
  }
  removeProp(name) {
    if (name.startsWith(NON_SERIALIZABLE_MARKER_PREFIX)) {
      if (this.localProps) {
        mapApp_remove(this.localProps, name, 0);
      }
    } else {
      mapApp_remove(this.attrs, name, 0);
    }
  }
  addChild(child) {
    if (!this.children) {
      this.children = [];
    }
    this.children.push(child);
  }
  setTreeNonUpdatable() {
    if (this.flags & 1 /* Updatable */) {
      this.flags &= ~1 /* Updatable */;
      if (this.children) {
        for (const child of this.children) {
          child.setTreeNonUpdatable();
        }
      }
    }
  }
  toString() {
    if (isDev12) {
      let stringifiedAttrs = "";
      for (let i = 0; i < this.attrs.length; i += 2) {
        const key = this.attrs[i];
        const value = this.attrs[i + 1];
        stringifiedAttrs += `${key}=`;
        stringifiedAttrs += `${typeof value === "string" || typeof value === "number" ? JSON.stringify(value) : "*"}`;
        if (i < this.attrs.length - 2) {
          stringifiedAttrs += ", ";
        }
      }
      return `<SSRNode id="${this.id}" ${stringifiedAttrs} />`;
    } else {
      return `<SSRNode id="${this.id}" />`;
    }
  }
};
var DomRef = class {
  constructor($ssrNode$) {
    this.$ssrNode$ = $ssrNode$;
    __publicField(this, "__brand__", "DomRef");
  }
};
var SsrComponentFrame = class {
  constructor(componentNode) {
    this.componentNode = componentNode;
    __publicField(this, "slots", []);
    __publicField(this, "projectionDepth", 0);
    __publicField(this, "scopedStyleIds", /* @__PURE__ */ new Set());
    __publicField(this, "projectionScopedStyle", null);
    __publicField(this, "projectionComponentFrame", null);
  }
  distributeChildrenIntoSlots(children, projectionScopedStyle, projectionComponentFrame) {
    this.projectionScopedStyle = projectionScopedStyle;
    this.projectionComponentFrame = projectionComponentFrame;
    if (isJSXNode2(children)) {
      const slotName = this.getSlotName(children);
      mapArray_set(this.slots, slotName, children, 0);
    } else if (Array.isArray(children) && children.length > 0) {
      const defaultSlot = [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isJSXNode2(child)) {
          const slotName = this.getSlotName(child);
          if (slotName === QDefaultSlot) {
            defaultSlot.push(child);
          } else {
            this.updateSlot(slotName, child);
          }
        } else {
          defaultSlot.push(child);
        }
      }
      defaultSlot.length > 0 && mapArray_set(this.slots, QDefaultSlot, defaultSlot, 0);
    } else {
      mapArray_set(this.slots, QDefaultSlot, children, 0);
    }
  }
  updateSlot(slotName, child) {
    let existingSlots = mapArray_get(this.slots, slotName, 0);
    if (existingSlots === null) {
      existingSlots = child;
    } else if (Array.isArray(existingSlots)) {
      existingSlots.push(child);
    } else {
      existingSlots = [existingSlots, child];
    }
    mapArray_set(this.slots, slotName, existingSlots, 0);
  }
  getSlotName(jsx2) {
    if (jsx2.props[QSlot]) {
      return jsx2.props[QSlot];
    }
    return QDefaultSlot;
  }
  hasSlot(slotName) {
    return mapArray_has(this.slots, slotName, 0);
  }
  consumeChildrenForSlot(projectionNode, slotName) {
    const children = mapApp_remove(this.slots, slotName, 0);
    this.componentNode.setProp(slotName, projectionNode.id);
    projectionNode.setProp(QSlotParent, this.componentNode.id);
    return children;
  }
  releaseUnclaimedProjections(unclaimedProjections) {
    if (this.slots.length) {
      unclaimedProjections.push(this);
      unclaimedProjections.push(this.projectionScopedStyle);
      unclaimedProjections.push.apply(unclaimedProjections, this.slots);
    }
  }
};

// packages/qwik/src/server/vnode-data.ts
var OPEN_FRAGMENT = Number.MAX_SAFE_INTEGER;
var CLOSE_FRAGMENT = Number.MAX_SAFE_INTEGER - 1;
var WRITE_ELEMENT_ATTRS = Number.MAX_SAFE_INTEGER - 2;
function vNodeData_incrementElementCount(vNodeData) {
  const length = vNodeData.length;
  const lastValue = length > 1 ? vNodeData[length - 1] : 0;
  if (lastValue >= 0) {
    vNodeData.push(-1);
  } else {
    vNodeData[length - 1] = lastValue - 1;
  }
}
function vNodeData_addTextSize(vNodeData, size) {
  const length = vNodeData.length;
  const lastValue = length > 1 ? vNodeData[length - 1] : 0;
  if (length > 1 && lastValue >= 0) {
    vNodeData[0] |= 1 /* TEXT_DATA */;
  }
  vNodeData.push(size);
  if (size == 0) {
    vNodeData[0] |= 1 /* TEXT_DATA */;
  }
}
function vNodeData_openFragment(vNodeData, attrs) {
  vNodeData.push(attrs, OPEN_FRAGMENT);
  vNodeData[0] |= 2 /* VIRTUAL_NODE */;
}
function vNodeData_closeFragment(vNodeData) {
  vNodeData.push(CLOSE_FRAGMENT);
}
function vNodeData_openElement(vNodeData) {
  vNodeData.push([], WRITE_ELEMENT_ATTRS);
  vNodeData[0] |= 4 /* ELEMENT_NODE */;
}
function vNodeData_createSsrNodeReference(currentComponentNode, vNodeData, depthFirstElementIdx, cleanupQueue, currentFile) {
  vNodeData[0] |= 8 /* REFERENCE */;
  const stack2 = [-1];
  let attributesIndex = -1;
  for (let i = 1; i < vNodeData.length; i++) {
    const value = vNodeData[i];
    if (Array.isArray(value)) {
      attributesIndex = i;
      i++;
      if (vNodeData[i] !== WRITE_ELEMENT_ATTRS) {
        stack2[stack2.length - 1]++;
        stack2.push(-1);
      }
    } else if (value === CLOSE_FRAGMENT) {
      stack2.pop();
    } else if (value < 0) {
      const numberOfElements = 0 - value;
      stack2[stack2.length - 1] += numberOfElements;
    } else {
      stack2[stack2.length - 1]++;
    }
  }
  let refId = String(depthFirstElementIdx);
  if (vNodeData[0] & (2 /* VIRTUAL_NODE */ | 1 /* TEXT_DATA */)) {
    for (let i = 0; i < stack2.length; i++) {
      const childCount = stack2[i];
      if (childCount >= 0) {
        refId += encodeAsAlphanumeric(childCount);
      }
    }
  }
  return new SsrNode(
    currentComponentNode,
    refId,
    attributesIndex,
    cleanupQueue,
    vNodeData,
    currentFile
  );
}
var ALPHANUMERIC = [];
function encodeAsAlphanumeric(value) {
  while (ALPHANUMERIC.length <= value) {
    let value2 = ALPHANUMERIC.length;
    let text = "";
    do {
      text = String.fromCharCode(
        (text.length === 0 ? 65 : 97) + value2 % 26
        /* A-Z */
      ) + text;
      value2 = Math.floor(
        value2 / 26
        /* A-Z */
      );
    } while (value2 !== 0);
    ALPHANUMERIC.push(text);
  }
  return ALPHANUMERIC[value];
}

// packages/qwik/src/server/ssr-container.ts
function ssrCreateContainer(opts) {
  opts.renderOptions || (opts.renderOptions = {});
  return new SSRContainer({
    tagName: opts.tagName || "div",
    writer: opts.writer || new StringBufferWriter(),
    locale: opts.locale || "",
    timing: opts.timing || {
      firstFlush: 0,
      render: 0,
      snapshot: 0
    },
    buildBase: opts.buildBase || "/build/",
    resolvedManifest: opts.resolvedManifest || {
      mapper: {},
      manifest: {
        manifestHash: "dev",
        mapping: {}
      }
    },
    renderOptions: opts.renderOptions
  });
}
var StringBufferWriter = class {
  constructor() {
    __publicField(this, "buffer", []);
  }
  write(text) {
    this.buffer.push(text);
  }
  toString() {
    return this.buffer.join("");
  }
};
var EMPTY_OBJ2 = {};
var SSRContainer = class extends _SharedContainer2 {
  constructor(opts) {
    super(() => null, opts.renderOptions.serverData ?? EMPTY_OBJ2, opts.locale);
    __publicField(this, "tag");
    __publicField(this, "isHtml");
    __publicField(this, "writer");
    __publicField(this, "timing");
    __publicField(this, "size", 0);
    __publicField(this, "resolvedManifest");
    __publicField(this, "symbolToChunkResolver");
    __publicField(this, "renderOptions");
    __publicField(this, "serializationCtx");
    /**
     * We use this to append additional nodes in the head node
     *
     * - From manifest injections
     * - From useStyles and useScopedStyles hooks
     */
    __publicField(this, "additionalHeadNodes", new Array());
    /**
     * We use this to append additional nodes in the body node
     *
     * - From manifest injections
     */
    __publicField(this, "additionalBodyNodes", new Array());
    __publicField(this, "lastNode", null);
    __publicField(this, "currentComponentNode", null);
    __publicField(this, "styleIds", /* @__PURE__ */ new Set());
    __publicField(this, "isBackpatchExecutorEmitted", false);
    __publicField(this, "backpatchMap", /* @__PURE__ */ new Map());
    __publicField(this, "currentElementFrame", null);
    __publicField(this, "renderTimer");
    /**
     * Current element index.
     *
     * This number must match the depth-first traversal of the DOM elements as returned by the
     * https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker
     */
    __publicField(this, "depthFirstElementCount", -1);
    __publicField(this, "vNodeDatas", []);
    __publicField(this, "componentStack", []);
    __publicField(this, "unclaimedProjections", []);
    __publicField(this, "unclaimedProjectionComponentFrameQueue", []);
    __publicField(this, "cleanupQueue", []);
    __publicField(this, "$instanceHash$", hash2());
    // Temporary flag to find missing roots after the state was serialized
    __publicField(this, "$noMoreRoots$", false);
    __publicField(this, "qlInclude");
    __publicField(this, "promiseAttributes", null);
    __publicField(this, "$noScriptHere$", 0);
    this.symbolToChunkResolver = (symbol) => {
      const idx = symbol.lastIndexOf("_");
      const chunk = this.resolvedManifest.mapper[idx == -1 ? symbol : symbol.substring(idx + 1)];
      return chunk ? chunk[1] : "";
    };
    this.serializationCtx = this.serializationCtxFactory(
      SsrNode,
      DomRef,
      this.symbolToChunkResolver,
      opts.writer
    );
    this.renderTimer = createTimer();
    this.tag = opts.tagName;
    this.isHtml = opts.tagName === "html";
    this.writer = opts.writer;
    this.timing = opts.timing;
    this.$buildBase$ = opts.buildBase;
    this.resolvedManifest = opts.resolvedManifest;
    this.renderOptions = opts.renderOptions;
    this.$currentUniqueId$ = 1e5;
    const qlOpt = this.renderOptions.qwikLoader;
    this.qlInclude = qlOpt ? typeof qlOpt === "object" ? qlOpt.include === "never" ? 2 /* Done */ : 0 /* Module */ : qlOpt === "inline" ? 1 /* Inline */ : qlOpt === "never" ? 2 /* Done */ : 0 /* Module */ : 0 /* Module */;
    if (this.qlInclude === 0 /* Module */) {
      const qwikLoaderChunk = this.resolvedManifest?.manifest.qwikLoader;
      if (!qwikLoaderChunk) {
        this.qlInclude = 1 /* Inline */;
      }
    }
    this.$processInjectionsFromManifest$();
  }
  ensureProjectionResolved(_host) {
  }
  handleError(err, _$host$) {
    throw err;
  }
  addBackpatchEntry(ssrNodeId, attrName, serializedValue) {
    const elementIndex = parseInt(ssrNodeId, 10);
    const entry = {
      attrName,
      value: serializedValue
    };
    const entries = this.backpatchMap.get(elementIndex) || [];
    entries.push(entry);
    this.backpatchMap.set(elementIndex, entries);
  }
  async render(jsx2) {
    this.openContainer();
    await _walkJSX(this, jsx2, {
      currentStyleScoped: null,
      parentComponentFrame: this.getComponentFrame()
    });
    await this.closeContainer();
  }
  setContext(host, context, value) {
    const ssrNode = host;
    let ctx = ssrNode.getProp(QCtxAttr);
    if (ctx == null) {
      ssrNode.setProp(QCtxAttr, ctx = []);
    }
    mapArray_set(ctx, context.id, value, 0, true);
    this.addRoot(ssrNode);
  }
  resolveContext(host, contextId) {
    let ssrNode = host;
    while (ssrNode) {
      const ctx = ssrNode.getProp(QCtxAttr);
      if (ctx != null && mapArray_has(ctx, contextId.id, 0)) {
        return mapArray_get(ctx, contextId.id, 0);
      }
      ssrNode = ssrNode.parentComponent;
    }
    return void 0;
  }
  getParentHost(host) {
    const ssrNode = host;
    return ssrNode.parentComponent;
  }
  setHostProp(host, name, value) {
    const ssrNode = host;
    return ssrNode.setProp(name, value);
  }
  getHostProp(host, name) {
    const ssrNode = host;
    return ssrNode.getProp(name);
  }
  /**
   * Renders opening tag for container. It could be a html tag for regular apps or custom element
   * for micro-frontends
   */
  openContainer() {
    if (this.tag == "html") {
      this.write("<!DOCTYPE html>");
    }
    const containerAttributes = this.renderOptions.containerAttributes || {};
    const qRender = containerAttributes[QRenderAttr];
    containerAttributes[QContainerAttr] = "paused" /* PAUSED */;
    containerAttributes[QRuntimeAttr] = "2";
    containerAttributes[QVersionAttr] = this.$version$ ?? "dev";
    containerAttributes[QRenderAttr] = (qRender ? qRender + "-" : "") + (isDev13 ? "ssr-dev" : "ssr");
    containerAttributes[QBaseAttr] = this.$buildBase$ || "";
    containerAttributes[QLocaleAttr] = this.$locale$;
    containerAttributes[QManifestHashAttr] = this.resolvedManifest.manifest.manifestHash;
    containerAttributes[QInstanceAttr] = this.$instanceHash$;
    this.$serverData$.containerAttributes = containerAttributes;
    const containerAttributeArray = Object.entries(containerAttributes).reduce(
      (acc, [key, value]) => {
        acc.push(key, value);
        return acc;
      },
      []
    );
    this.openElement(this.tag, containerAttributeArray);
  }
  /** Renders closing tag for current container */
  closeContainer() {
    return this.closeElement();
  }
  /** Renders opening tag for DOM element */
  openElement(elementName, varAttrs, constAttrs, currentFile) {
    const isQwikStyle = isQwikStyleElement(elementName, varAttrs) || isQwikStyleElement(elementName, constAttrs);
    if (
      // don't append qwik loader before qwik style elements
      // it will confuse the resuming, because styles are expected to be the first nodes in subtree
      !isQwikStyle && this.qlInclude === 1 /* Inline */
    ) {
      if (this.$noScriptHere$ === 0 && this.size > 30 * 1024 && elementName !== "body") {
        this.emitQwikLoaderInline();
      } else if (elementName === "noscript" || elementName === "template") {
        this.$noScriptHere$++;
      }
    }
    let innerHTML = void 0;
    this.lastNode = null;
    if (!isQwikStyle && this.currentElementFrame) {
      vNodeData_incrementElementCount(this.currentElementFrame.vNodeData);
    }
    this.createAndPushFrame(elementName, this.depthFirstElementCount++, currentFile);
    vNodeData_openElement(this.currentElementFrame.vNodeData);
    this.write("<");
    this.write(elementName);
    const lastNode = this.getOrCreateLastNode();
    if (varAttrs) {
      innerHTML = this.writeAttrs(elementName, varAttrs, false, currentFile);
    }
    this.write(" " + Q_PROPS_SEPARATOR);
    isDev13 && this.write('=""');
    if (constAttrs && constAttrs.length) {
      innerHTML = this.writeAttrs(elementName, constAttrs, true, currentFile) || innerHTML;
    }
    this.write(">");
    if (lastNode) {
      lastNode.setTreeNonUpdatable();
    }
    return innerHTML;
  }
  /** Renders closing tag for DOM element */
  closeElement() {
    if (this.shouldEmitDataBeforeClosingElement()) {
      this.onRenderDone();
      const snapshotTimer = createTimer();
      return maybeThen(
        maybeThen(this.emitContainerData(), () => this._closeElement()),
        () => {
          this.timing.snapshot = snapshotTimer();
        }
      );
    }
    this._closeElement();
  }
  shouldEmitDataBeforeClosingElement() {
    const currentFrame = this.currentElementFrame;
    return (
      /**
       * - Micro-frontends don't have html tag, emit data before closing custom element
       * - Regular applications should emit data inside body
       */
      currentFrame.parent === null && currentFrame.elementName !== "html" || currentFrame.elementName === "body"
    );
  }
  onRenderDone() {
    this.drainCleanupQueue();
    this.timing.render = this.renderTimer();
  }
  /** Drain cleanup queue and cleanup tasks etc. */
  drainCleanupQueue() {
    let sequences = this.cleanupQueue.pop();
    while (sequences) {
      for (let j = 0; j < sequences.length; j++) {
        const item = sequences[j];
        if (hasDestroy(item)) {
          item.$destroy$();
        }
      }
      sequences = this.cleanupQueue.pop();
    }
  }
  _closeElement() {
    const currentFrame = this.popFrame();
    const elementName = currentFrame.elementName;
    if (!isSelfClosingTag(elementName)) {
      this.write("</");
      this.write(elementName);
      this.write(">");
    }
    this.lastNode = null;
    if (this.qlInclude === 1 /* Inline */) {
      if (elementName === "noscript" || elementName === "template") {
        this.$noScriptHere$--;
      }
    }
  }
  /** Writes opening data to vNodeData for fragment boundaries */
  openFragment(attrs) {
    this.lastNode = null;
    vNodeData_openFragment(this.currentElementFrame.vNodeData, attrs);
    this.getOrCreateLastNode();
  }
  /** Writes closing data to vNodeData for fragment boundaries */
  closeFragment() {
    vNodeData_closeFragment(this.currentElementFrame.vNodeData);
    if (this.currentComponentNode) {
      this.currentComponentNode.setTreeNonUpdatable();
    }
    this.lastNode = null;
  }
  openProjection(attrs) {
    this.openFragment(attrs);
    const componentFrame = this.getComponentFrame();
    if (componentFrame) {
      this.serializationCtx.$addRoot$(componentFrame.componentNode);
      componentFrame.projectionDepth++;
    }
  }
  closeProjection() {
    const componentFrame = this.getComponentFrame();
    if (componentFrame) {
      componentFrame.projectionDepth--;
    }
    this.closeFragment();
  }
  /** Writes opening data to vNodeData for component boundaries */
  openComponent(attrs) {
    this.openFragment(attrs);
    this.currentComponentNode = this.getOrCreateLastNode();
    this.componentStack.push(new SsrComponentFrame(this.currentComponentNode));
  }
  /**
   * Returns the current component frame.
   *
   * @param projectionDepth - How many levels of projection to skip. This is needed when projections
   *   are nested inside other projections we need to have a way to read from a frame above.
   * @returns
   */
  getComponentFrame(projectionDepth = 0) {
    const length = this.componentStack.length;
    const idx = length - projectionDepth - 1;
    return idx >= 0 ? this.componentStack[idx] : null;
  }
  getParentComponentFrame() {
    const localProjectionDepth = this.getComponentFrame()?.projectionDepth || 0;
    return this.getComponentFrame(localProjectionDepth);
  }
  /** Writes closing data to vNodeData for component boundaries and mark unclaimed projections */
  closeComponent() {
    const componentFrame = this.componentStack.pop();
    componentFrame.releaseUnclaimedProjections(this.unclaimedProjections);
    this.closeFragment();
    this.currentComponentNode = this.currentComponentNode?.parentComponent || null;
  }
  /** Write a text node with correct escaping. Save the length of the text node in the vNodeData. */
  textNode(text) {
    this.write(escapeHTML(text));
    vNodeData_addTextSize(this.currentElementFrame.vNodeData, text.length);
    this.lastNode = null;
  }
  htmlNode(rawHtml) {
    this.write(rawHtml);
  }
  commentNode(text) {
    this.write("<!--" + text + "-->");
  }
  addRoot(obj) {
    if (this.$noMoreRoots$) {
      return this.serializationCtx.$hasRootId$(obj);
    }
    return this.serializationCtx.$addRoot$(obj);
  }
  getOrCreateLastNode() {
    if (!this.lastNode) {
      this.lastNode = vNodeData_createSsrNodeReference(
        this.currentComponentNode,
        this.currentElementFrame.vNodeData,
        // we start at -1, so we need to add +1
        this.currentElementFrame.depthFirstElementIdx + 1,
        this.cleanupQueue,
        this.currentElementFrame.currentFile
      );
    }
    return this.lastNode;
  }
  addUnclaimedProjection(frame, name, children) {
    this.unclaimedProjections.push(frame, null, name, children);
  }
  $processInjectionsFromManifest$() {
    const injections = this.resolvedManifest.manifest.injections;
    if (!injections) {
      return;
    }
    for (let i = 0; i < injections.length; i++) {
      const injection = injections[i];
      const jsxNode = _jsxSplit2(injection.tag, null, injection.attributes || {}, null, 0, null);
      if (injection.location === "head") {
        this.additionalHeadNodes.push(jsxNode);
      } else {
        this.additionalBodyNodes.push(jsxNode);
      }
    }
  }
  $appendStyle$(content, styleId, host, scoped) {
    if (scoped) {
      const componentFrame = this.getComponentFrame(0);
      componentFrame.scopedStyleIds.add(styleId);
      const scopedStyleIds = convertStyleIdsToString(componentFrame.scopedStyleIds);
      this.setHostProp(host, QScopedStyle, scopedStyleIds);
    }
    if (!this.styleIds.has(styleId)) {
      this.styleIds.add(styleId);
      if (this.currentElementFrame?.elementName === "html") {
        this.additionalHeadNodes.push(
          _jsxSorted2(
            "style",
            null,
            { dangerouslySetInnerHTML: content, [QStyle]: styleId },
            null,
            0,
            styleId
          )
        );
      } else {
        this._styleNode(styleId, content);
      }
    }
  }
  _styleNode(styleId, content) {
    this.openElement("style", [QStyle, styleId]);
    this.write(content);
    this.closeElement();
  }
  ////////////////////////////////////
  emitContainerData() {
    return maybeThen(
      this.resolvePromiseAttributes(),
      () => maybeThen(
        this.emitUnclaimedProjection(),
        () => maybeThen(this.emitStateData(), () => {
          this.$noMoreRoots$ = true;
          this.emitVNodeData();
          preloaderPost(this, this.renderOptions, this.$serverData$?.nonce);
          this.emitSyncFnsData();
          this.emitPatchDataIfNeeded();
          this.emitExecutorIfNeeded();
          this.emitQwikLoaderAtBottomIfNeeded();
        })
      )
    );
  }
  /**
   * Serialize the vNodeData into a string and emit it as a script tag.
   *
   * ## Encoding:
   *
   * - Alphabetical characters are text node lengths.
   * - Numbers are element counts.
   * - `{` is start of virtual node.
   * - `}` is end of virtual node.
   * - `~` Store as reference for data deserialization.
   * - `!"#$%&'()*+'-./` are separators (sequential characters in ASCII table)
   *
   * Attribute and separators encoding described here:
   * `packages/qwik/src/core/v2/shared/vnode-data-types.ts`
   *
   * NOTE: Not every element will need vNodeData. So we need to encode how many elements should be
   * skipped. By choosing different separators we can encode different numbers of elements to skip.
   */
  emitVNodeData() {
    if (!this.serializationCtx.$roots$.length) {
      return;
    }
    this.openElement("script", ["type", "qwik/vnode"]);
    const vNodeAttrsStack = [];
    const vNodeData = this.vNodeDatas;
    let lastSerializedIdx = 0;
    for (let elementIdx = 0; elementIdx < vNodeData.length; elementIdx++) {
      const vNode = vNodeData[elementIdx];
      const flag = vNode[0];
      if (flag & 16 /* SERIALIZE */) {
        lastSerializedIdx = this.emitVNodeSeparators(lastSerializedIdx, elementIdx);
        if (flag & 8 /* REFERENCE */) {
          this.write(VNodeDataSeparator.REFERENCE_CH);
        }
        if (flag & (1 /* TEXT_DATA */ | 2 /* VIRTUAL_NODE */ | 4 /* ELEMENT_NODE */)) {
          let fragmentAttrs = null;
          let depth = 0;
          for (let i = 1; i < vNode.length; i++) {
            const value = vNode[i];
            if (Array.isArray(value)) {
              vNodeAttrsStack.push(fragmentAttrs);
              fragmentAttrs = value;
            } else if (value === OPEN_FRAGMENT) {
              depth++;
              this.write(VNodeDataChar.OPEN_CHAR);
            } else if (value === CLOSE_FRAGMENT) {
              if (fragmentAttrs) {
                this.writeFragmentAttrs(fragmentAttrs);
                fragmentAttrs = vNodeAttrsStack.pop();
              }
              depth--;
              this.write(VNodeDataChar.CLOSE_CHAR);
            } else if (value === WRITE_ELEMENT_ATTRS) {
              if (fragmentAttrs && fragmentAttrs.length) {
                this.write(VNodeDataChar.SEPARATOR_CHAR);
                this.writeFragmentAttrs(fragmentAttrs);
                this.write(VNodeDataChar.SEPARATOR_CHAR);
                fragmentAttrs = vNodeAttrsStack.pop();
              }
            } else if (value >= 0) {
              this.write(encodeAsAlphanumeric(value));
            } else {
              this.write(String(0 - value));
            }
          }
          while (depth-- > 0) {
            if (fragmentAttrs) {
              this.writeFragmentAttrs(fragmentAttrs);
              fragmentAttrs = vNodeAttrsStack.pop();
            }
            this.write(VNodeDataChar.CLOSE_CHAR);
          }
        }
      }
    }
    this.closeElement();
  }
  writeFragmentAttrs(fragmentAttrs) {
    for (let i = 0; i < fragmentAttrs.length; ) {
      const key = fragmentAttrs[i++];
      let value = fragmentAttrs[i++];
      let encodeValue = false;
      if (typeof value !== "string") {
        const rootId = this.addRoot(value);
        if (rootId === void 0) {
          continue;
        }
        value = String(rootId);
      }
      switch (key) {
        case QScopedStyle:
          this.write(VNodeDataChar.SCOPED_STYLE_CHAR);
          break;
        case OnRenderProp:
          this.write(VNodeDataChar.RENDER_FN_CHAR);
          break;
        case ELEMENT_ID:
          this.write(VNodeDataChar.ID_CHAR);
          break;
        case ELEMENT_PROPS:
          this.write(VNodeDataChar.PROPS_CHAR);
          break;
        case ELEMENT_KEY:
          encodeValue = true;
          this.write(VNodeDataChar.KEY_CHAR);
          break;
        case ELEMENT_SEQ:
          this.write(VNodeDataChar.SEQ_CHAR);
          break;
        case ELEMENT_SEQ_IDX:
          this.write(VNodeDataChar.SEQ_IDX_CHAR);
          break;
        case QBackRefs:
          this.write(VNodeDataChar.BACK_REFS_CHAR);
          break;
        case QSlotParent:
          this.write(VNodeDataChar.SLOT_PARENT_CHAR);
          break;
        // Skipping `\` character for now because it is used for escaping.
        case QCtxAttr:
          this.write(VNodeDataChar.CONTEXT_CHAR);
          break;
        case QSlot:
          this.write(VNodeDataChar.SLOT_CHAR);
          break;
        default:
          this.write(VNodeDataChar.SEPARATOR_CHAR);
          this.write(key);
          this.write(VNodeDataChar.SEPARATOR_CHAR);
      }
      const encodedValue = encodeValue ? encodeURI(value) : value;
      const isEncoded = encodeValue ? encodedValue !== value : false;
      if (isEncoded) {
        this.write(VNodeDataChar.SEPARATOR_CHAR);
        this.write(encodedValue);
        this.write(VNodeDataChar.SEPARATOR_CHAR);
      } else {
        this.write(value);
      }
    }
  }
  emitStateData() {
    if (!this.serializationCtx.$roots$.length) {
      return;
    }
    this.openElement("script", ["type", "qwik/state"]);
    return maybeThen(this.serializationCtx.$serialize$(), () => {
      this.closeElement();
    });
  }
  emitSyncFnsData() {
    const fns = this.serializationCtx.$syncFns$;
    if (fns.length) {
      const scriptAttrs = ["q:func", "qwik/json"];
      if (this.renderOptions.serverData?.nonce) {
        scriptAttrs.push("nonce", this.renderOptions.serverData.nonce);
      }
      this.openElement("script", scriptAttrs);
      this.write(Q_FUNCS_PREFIX2.replace("HASH", this.$instanceHash$));
      this.write("[");
      this.writeArray(fns, ",");
      this.write("]");
      this.closeElement();
    }
  }
  emitPatchDataIfNeeded() {
    const patches = [];
    for (const [elementIndex, backpatchEntries] of this.backpatchMap) {
      for (const backpatchEntry of backpatchEntries) {
        patches.push(elementIndex, backpatchEntry.attrName, backpatchEntry.value);
      }
    }
    this.backpatchMap.clear();
    if (patches.length > 0) {
      this.isBackpatchExecutorEmitted = true;
      const scriptAttrs = ["type", ELEMENT_BACKPATCH_DATA];
      if (this.renderOptions.serverData?.nonce) {
        scriptAttrs.push("nonce", this.renderOptions.serverData.nonce);
      }
      this.openElement("script", scriptAttrs);
      this.write(JSON.stringify(patches));
      this.closeElement();
    }
  }
  emitExecutorIfNeeded() {
    if (!this.isBackpatchExecutorEmitted) {
      return;
    }
    const scriptAttrs = ["type", "text/javascript"];
    if (this.renderOptions.serverData?.nonce) {
      scriptAttrs.push("nonce", this.renderOptions.serverData.nonce);
    }
    this.openElement("script", scriptAttrs);
    const backpatchScript = getQwikBackpatchExecutorScript({ debug: isDev13 });
    this.write(backpatchScript);
    this.closeElement();
  }
  emitPreloaderPre() {
    preloaderPre(this, this.renderOptions.preloader, this.renderOptions.serverData?.nonce);
  }
  isStatic() {
    return this.serializationCtx.$eventQrls$.size === 0;
  }
  emitQwikLoaderAtTopIfNeeded() {
    if (this.qlInclude === 0 /* Module */) {
      this.qlInclude = 2 /* Done */;
      const qwikLoaderBundle = this.$buildBase$ + this.resolvedManifest.manifest.qwikLoader;
      const linkAttrs = ["rel", "modulepreload", "href", qwikLoaderBundle];
      const nonce = this.renderOptions.serverData?.nonce;
      if (nonce) {
        linkAttrs.push("nonce", nonce);
      }
      this.openElement("link", linkAttrs);
      this.closeElement();
      const scriptAttrs = ["async", true, "type", "module", "src", qwikLoaderBundle];
      if (nonce) {
        scriptAttrs.push("nonce", nonce);
      }
      this.openElement("script", scriptAttrs);
      this.closeElement();
    }
  }
  emitQwikLoaderInline() {
    this.qlInclude = 2 /* Done */;
    const qwikLoaderScript = getQwikLoaderScript({ debug: this.renderOptions.debug });
    const scriptAttrs = ["id", "qwikloader", "async", true, "type", "module"];
    if (this.renderOptions.serverData?.nonce) {
      scriptAttrs.push("nonce", this.renderOptions.serverData.nonce);
    }
    this.openElement("script", scriptAttrs);
    this.write(qwikLoaderScript);
    this.closeElement();
  }
  emitQwikLoaderAtBottomIfNeeded() {
    if (!this.isStatic()) {
      if (this.qlInclude !== 2 /* Done */) {
        this.emitQwikLoaderInline();
      }
      this.emitQwikEvents(Array.from(this.serializationCtx.$eventNames$, (s) => JSON.stringify(s)));
    }
  }
  emitQwikEvents(eventNames) {
    if (eventNames.length > 0) {
      const scriptAttrs = [];
      const nonce = this.renderOptions.serverData?.nonce;
      if (nonce) {
        scriptAttrs.push("nonce", nonce);
      }
      this.openElement("script", scriptAttrs);
      this.write(`(window.qwikevents||(window.qwikevents=[])).push(`);
      this.writeArray(eventNames, ", ");
      this.write(")");
      this.closeElement();
    }
  }
  async emitUnclaimedProjection() {
    const unclaimedProjections = this.unclaimedProjections;
    if (unclaimedProjections.length) {
      const previousCurrentComponentNode = this.currentComponentNode;
      try {
        this.openElement(QTemplate, ["hidden", true, "aria-hidden", "true"], null);
        let idx = 0;
        let ssrComponentNode = null;
        let ssrComponentFrame = null;
        let scopedStyleId = null;
        for (let i = 0; i < unclaimedProjections.length; i += 4) {
          this.unclaimedProjectionComponentFrameQueue.push(
            unclaimedProjections[i]
          );
        }
        while (idx < unclaimedProjections.length) {
          const value = unclaimedProjections[idx++];
          if (value instanceof SsrComponentFrame) {
            ssrComponentNode = this.currentComponentNode = value.componentNode;
            ssrComponentFrame = value;
            scopedStyleId = unclaimedProjections[idx++];
          } else if (typeof value === "string") {
            const children = unclaimedProjections[idx++];
            if (!ssrComponentFrame?.hasSlot(value)) {
              ssrComponentFrame && ssrComponentFrame.componentNode.removeProp(value);
              continue;
            }
            this.unclaimedProjectionComponentFrameQueue.shift();
            this.openFragment(
              isDev13 ? [DEBUG_TYPE, "P" /* Projection */, QSlotParent, ssrComponentNode.id] : [QSlotParent, ssrComponentNode.id]
            );
            const lastNode = this.getOrCreateLastNode();
            if (lastNode.vnodeData) {
              lastNode.vnodeData[0] |= 16 /* SERIALIZE */;
            }
            ssrComponentNode?.setProp(value, lastNode.id);
            await _walkJSX(this, children, {
              currentStyleScoped: scopedStyleId,
              parentComponentFrame: null
            });
            this.closeFragment();
          } else {
            throw Error();
          }
        }
        this.closeElement();
      } finally {
        this.currentComponentNode = previousCurrentComponentNode;
      }
    }
  }
  // Keep in sync with process-vnode-data.unit.ts
  emitVNodeSeparators(lastSerializedIdx, elementIdx) {
    let skipCount = elementIdx - lastSerializedIdx;
    while (skipCount != 0) {
      if (skipCount >= 8192) {
        this.write(VNodeDataSeparator.ADVANCE_8192_CH);
        skipCount -= 8192;
      } else {
        skipCount & 4096 && this.write(VNodeDataSeparator.ADVANCE_4096_CH);
        skipCount & 2048 && this.write(VNodeDataSeparator.ADVANCE_2048_CH);
        skipCount & 1024 && this.write(VNodeDataSeparator.ADVANCE_1024_CH);
        skipCount & 512 && this.write(VNodeDataSeparator.ADVANCE_512_CH);
        skipCount & 256 && this.write(VNodeDataSeparator.ADVANCE_256_CH);
        skipCount & 128 && this.write(VNodeDataSeparator.ADVANCE_128_CH);
        skipCount & 64 && this.write(VNodeDataSeparator.ADVANCE_64_CH);
        skipCount & 32 && this.write(VNodeDataSeparator.ADVANCE_32_CH);
        skipCount & 16 && this.write(VNodeDataSeparator.ADVANCE_16_CH);
        skipCount & 8 && this.write(VNodeDataSeparator.ADVANCE_8_CH);
        skipCount & 4 && this.write(VNodeDataSeparator.ADVANCE_4_CH);
        skipCount & 2 && this.write(VNodeDataSeparator.ADVANCE_2_CH);
        skipCount & 1 && this.write(VNodeDataSeparator.ADVANCE_1_CH);
        skipCount = 0;
      }
    }
    return elementIdx;
  }
  createAndPushFrame(elementName, depthFirstElementIdx, currentFile) {
    let tagNesting = 10 /* ANYTHING */;
    if (isDev13) {
      if (!this.currentElementFrame) {
        tagNesting = initialTag(elementName);
      } else {
        let frame2 = this.currentElementFrame;
        const previousTagNesting = frame2.tagNesting;
        tagNesting = isTagAllowed(previousTagNesting, elementName);
        if (tagNesting === 0 /* NOT_ALLOWED */) {
          const frames = [];
          while (frame2) {
            frames.unshift(frame2);
            frame2 = frame2.parent;
          }
          const text = [];
          if (currentFile) {
            text.push(`Error found in file: ${currentFile}`);
          }
          text.push(
            `HTML rules do not allow '<${elementName}>' at this location.`,
            `  (The HTML parser will try to recover by auto-closing or inserting additional tags which will confuse Qwik when it resumes.)`,
            `  Offending tag: <${elementName}>`,
            `  Existing tag context:`
          );
          let indent = "    ";
          let lastName = "";
          for (const frame3 of frames) {
            const [name, example] = allowedContent(frame3.tagNesting);
            text.push(
              `${indent}<${frame3.elementName}>${lastName !== name ? ` [${name}]${example ? ` -> ${example}` : ""}` : ""}`
            );
            lastName = name;
            indent += " ";
          }
          text.push(
            `${indent}<${elementName}> <= is not allowed as a child of ${allowedContent(previousTagNesting)[0]}.`
          );
          throw newTagError(text.join("\n"));
        }
      }
    }
    const frame = {
      tagNesting,
      parent: this.currentElementFrame,
      elementName,
      depthFirstElementIdx,
      vNodeData: [0 /* NONE */],
      currentFile: isDev13 ? currentFile || null : null
    };
    this.currentElementFrame = frame;
    this.vNodeDatas.push(frame.vNodeData);
  }
  popFrame() {
    const closingFrame = this.currentElementFrame;
    this.currentElementFrame = closingFrame.parent;
    return closingFrame;
  }
  ////////////////////////////////////
  write(text) {
    this.size += text.length;
    this.writer.write(text);
  }
  writeArray(array, separator) {
    for (let i = 0; i < array.length; i++) {
      const element = array[i];
      if (i > 0) {
        this.write(separator);
      }
      this.write(element);
    }
  }
  writeAttrs(tag, attrs, isConst, currentFile) {
    let innerHTML = void 0;
    if (attrs.length) {
      for (let i = 0; i < attrs.length; i++) {
        let key = attrs[i++];
        let value = attrs[i];
        let styleScopedId = null;
        if (isSSRUnsafeAttr(key)) {
          if (isDev13) {
            throw qError(32 /* unsafeAttr */);
          }
          continue;
        }
        if (key === "class" && Array.isArray(value)) {
          const [signalValue, styleId] = value;
          value = signalValue;
          styleScopedId = styleId;
        }
        if (key === "ref") {
          const lastNode = this.getOrCreateLastNode();
          if (isSignal3(value)) {
            value.$untrackedValue$ = new DomRef(lastNode);
            continue;
          } else if (typeof value === "function") {
            value(new DomRef(lastNode));
            continue;
          } else if (value == null) {
            continue;
          } else {
            throw qError(15 /* invalidRefValue */, [currentFile]);
          }
        }
        if (isSignal3(value)) {
          const lastNode = this.getOrCreateLastNode();
          const signalData = new SubscriptionData2({
            $scopedStyleIdPrefix$: styleScopedId,
            $isConst$: isConst
          });
          const signal = value;
          value = retryOnPromise(
            () => this.trackSignalValue(signal, lastNode, key, signalData)
          );
        }
        if (isPromise(value)) {
          const lastNode = this.getOrCreateLastNode();
          this.addPromiseAttribute(value);
          value.then((resolvedValue) => {
            this.addBackpatchEntry(lastNode.id, key, resolvedValue);
          });
          continue;
        }
        if (key === dangerouslySetInnerHTML) {
          if (value) {
            innerHTML = String(value);
            key = QContainerAttr;
            value = "html" /* HTML */;
          }
          if (tag === "style") {
            continue;
          }
        }
        if (tag === "textarea" && key === "value") {
          if (value && typeof value !== "string") {
            if (isDev13) {
              throw qError(23 /* wrongTextareaValue */, [currentFile, value]);
            }
            continue;
          }
          innerHTML = escapeHTML(value || "");
          key = QContainerAttr;
          value = "text" /* TEXT */;
        }
        const serializedValue = serializeAttribute(key, value, styleScopedId);
        if (serializedValue != null && serializedValue !== false) {
          this.write(" ");
          this.write(key);
          if (serializedValue !== true) {
            this.write('="');
            const strValue = escapeHTML(String(serializedValue));
            this.write(strValue);
            this.write('"');
          }
        }
      }
    }
    return innerHTML;
  }
  addPromiseAttribute(promise) {
    this.promiseAttributes || (this.promiseAttributes = []);
    this.promiseAttributes.push(promise);
  }
  async resolvePromiseAttributes() {
    if (this.promiseAttributes) {
      await Promise.all(this.promiseAttributes);
      this.promiseAttributes = null;
    }
  }
};
var isQwikStyleElement = (tag, attrs) => {
  if (tag === "style" && attrs != null) {
    for (let i = 0; i < attrs.length; i = i + 2) {
      const attr = attrs[i];
      if (attr === QStyle || attr === QScopedStyle) {
        return true;
      }
    }
  }
  return false;
};
function newTagError(text) {
  return qError(12 /* tagError */, [text]);
}
function hasDestroy(obj) {
  return obj && typeof obj === "object" && typeof obj.$destroy$ === "function";
}
function isSSRUnsafeAttr(name) {
  for (let idx = 0; idx < name.length; idx++) {
    const ch = name.charCodeAt(idx);
    if (ch === 62 || ch === 47 || ch === 61 || ch === 34 || ch === 39 || ch === 9 || ch === 10 || ch === 12 || ch === 32) {
      return true;
    }
  }
  return false;
}
function hash2() {
  return Math.random().toString(36).slice(2);
}

// packages/qwik/src/server/ssr-render.ts
import { manifest as builtManifest } from "@qwik-client-manifest";
var renderToString = async (jsx2, opts = {}) => {
  const chunks = [];
  const stream = {
    write(chunk) {
      chunks.push(chunk);
    }
  };
  const result2 = await renderToStream(jsx2, { ...opts, stream });
  return {
    isStatic: result2.isStatic,
    timing: result2.timing,
    manifest: result2.manifest,
    snapshotResult: result2.snapshotResult,
    html: chunks.join("")
  };
};
var renderToStream = async (jsx2, opts) => {
  const timing = {
    firstFlush: 0,
    render: 0,
    snapshot: 0
  };
  const containerTagName = opts.containerTagName ?? "html";
  const buildBase = getBuildBase(opts);
  const resolvedManifest = resolveManifest(opts.manifest);
  const locale = typeof opts.locale === "function" ? opts.locale(opts) : opts.serverData?.locale || opts.locale || opts.containerAttributes?.locale || "";
  const { stream, flush, networkFlushes } = handleStreaming(opts, timing);
  const ssrContainer = ssrCreateContainer({
    tagName: containerTagName,
    locale,
    writer: stream,
    timing,
    buildBase,
    resolvedManifest,
    renderOptions: opts
  });
  await setServerPlatform(opts, resolvedManifest);
  await ssrContainer.render(jsx2);
  await ssrContainer.$scheduler$(255 /* WAIT_FOR_QUEUE */).$returnValue$;
  flush();
  const snapshotResult = getSnapshotResult(ssrContainer);
  const isDynamic = snapshotResult.resources.some((r) => r._cache !== Infinity);
  const result2 = {
    snapshotResult,
    flushes: networkFlushes,
    manifest: resolvedManifest?.manifest,
    size: ssrContainer.size,
    isStatic: !isDynamic,
    timing
  };
  return result2;
};
function getSnapshotResult(ssrContainer) {
  const hasListeners = !ssrContainer.isStatic();
  const canRender = false;
  return hasListeners ? {
    funcs: Array.from(ssrContainer.serializationCtx.$syncFns$),
    mode: canRender ? "render" : "listeners",
    qrls: Array.from(ssrContainer.serializationCtx.$eventQrls$),
    resources: Array.from(ssrContainer.serializationCtx.$resources$)
  } : {
    funcs: [],
    mode: "static",
    qrls: [],
    resources: Array.from(ssrContainer.serializationCtx.$resources$)
  };
}
function handleStreaming(opts, timing) {
  const firstFlushTimer = createTimer();
  let stream = opts.stream;
  let bufferSize = 0;
  let buffer = "";
  let networkFlushes = 0;
  const inOrderStreaming = opts.streaming?.inOrder ?? {
    strategy: "auto",
    maximumInitialChunk: 2e4,
    maximumChunk: 1e4
  };
  const nativeStream = stream;
  function flush() {
    if (buffer) {
      nativeStream.write(buffer);
      buffer = "";
      bufferSize = 0;
      networkFlushes++;
      if (networkFlushes === 1) {
        timing.firstFlush = firstFlushTimer();
      }
    }
  }
  function enqueue(chunk) {
    const len = chunk.length;
    bufferSize += len;
    buffer += chunk;
  }
  switch (inOrderStreaming.strategy) {
    case "disabled":
      stream = {
        write(chunk) {
          if (shouldSkipChunk(chunk)) {
            return;
          }
          enqueue(chunk);
        }
      };
      break;
    case "direct":
      stream = {
        write(chunk) {
          if (shouldSkipChunk(chunk)) {
            return;
          }
          nativeStream.write(chunk);
        }
      };
      break;
    case "auto":
      let openedSSRStreamBlocks = 0;
      let forceFlush = false;
      const minimumChunkSize = inOrderStreaming.maximumChunk ?? 0;
      const initialChunkSize = inOrderStreaming.maximumInitialChunk ?? 0;
      stream = {
        write(chunk) {
          if (chunk === void 0 || chunk === null) {
            return;
          }
          if (chunk === "<!--" + FLUSH_COMMENT + "-->") {
            forceFlush = true;
          } else if (chunk === "<!--" + STREAM_BLOCK_START_COMMENT + "-->") {
            openedSSRStreamBlocks++;
          } else if (chunk === "<!--" + STREAM_BLOCK_END_COMMENT + "-->") {
            openedSSRStreamBlocks--;
            if (openedSSRStreamBlocks === 0) {
              forceFlush = true;
            }
          } else {
            enqueue(chunk);
          }
          const maxBufferSize = networkFlushes === 0 ? initialChunkSize : minimumChunkSize;
          if (openedSSRStreamBlocks === 0 && (forceFlush || bufferSize >= maxBufferSize)) {
            forceFlush = false;
            flush();
          }
        }
      };
      break;
  }
  return {
    stream,
    flush,
    networkFlushes
  };
}
function shouldSkipChunk(chunk) {
  return chunk === void 0 || chunk === null || chunk === "<!--" + FLUSH_COMMENT + "-->" || chunk === "<!--" + STREAM_BLOCK_START_COMMENT + "-->" || chunk === "<!--" + STREAM_BLOCK_END_COMMENT + "-->";
}
function resolveManifest(manifest) {
  const mergedManifest = manifest ? { ...builtManifest, ...manifest } : builtManifest;
  if (!mergedManifest || "mapper" in mergedManifest) {
    return mergedManifest;
  }
  if (mergedManifest.mapping) {
    const mapper = {};
    Object.entries(mergedManifest.mapping).forEach(([symbol, bundleFilename]) => {
      mapper[getSymbolHash2(symbol)] = [symbol, bundleFilename];
    });
    return {
      mapper,
      manifest: mergedManifest,
      injections: mergedManifest.injections || []
    };
  }
  return void 0;
}
var Q_FUNCS_PREFIX2 = 'document["qFuncs_HASH"]=';

// packages/qwik/src/testing/rendering.unit-util.tsx
import { jsx } from "@qwik.dev/core/jsx-runtime";
async function domRender(jsx2, opts = {}) {
  const document2 = createDocument();
  await render(document2.body, jsx2);
  await getTestPlatform().flush();
  const getStyles = getStylesFactory(document2);
  const container = _getDomContainer2(document2.body);
  if (opts.debug) {
    console.log("========================================================");
    console.log("------------------------- CSR --------------------------");
    console.log(container.rootVNode.toString());
    renderStyles(getStyles);
    console.log("--------------------------------------------------------");
  }
  return {
    document: document2,
    container,
    vNode: vnode_getFirstChild(container.rootVNode),
    getStyles: getStylesFactory(document2)
  };
}
function getStylesFactory(document2) {
  return () => {
    const styles = {};
    Array.from(document2.querySelectorAll("style")).forEach((style) => {
      const id = style.hasAttribute(QStyle) ? style.getAttribute(QStyle) : style.getAttribute(QScopedStyle) ? style.getAttribute(QScopedStyle) : null;
      if (id !== null) {
        const text = style.textContent;
        if (id in styles) {
          const existing = styles[id];
          Array.isArray(existing) ? existing.push(text) : styles[id] = [existing, text];
        } else {
          styles[id] = text;
        }
      }
    });
    return styles;
  };
}
async function ssrRenderToDom(jsx2, opts = {}) {
  let html = "";
  const platform = getPlatform();
  try {
    const jsxToRender = opts.raw ? jsx2 : [
      /* @__PURE__ */ jsx("head", { children: /* @__PURE__ */ jsx("title", { children: expect2.getState().testPath }) }),
      /* @__PURE__ */ jsx("body", { children: jsx2 })
    ];
    const result2 = await renderToString(jsxToRender, {
      qwikLoader: opts.qwikLoader ? "inline" : "never"
    });
    html = result2.html;
  } finally {
    setPlatform(platform);
  }
  const document2 = createDocument({ html });
  const containerElement2 = document2.querySelector(QContainerSelector);
  emulateExecutionOfQwikFuncs(document2);
  if (opts.onBeforeResume) {
    opts.onBeforeResume(document2);
  }
  emulateExecutionOfBackpatch(document2);
  const container = _getDomContainer2(containerElement2);
  const getStyles = getStylesFactory(document2);
  if (opts.debug) {
    console.log("========================================================");
    console.log("------------------------- SSR --------------------------");
    console.log(html);
    renderStyles(getStyles);
    console.log("--------------------------------------------------------");
    console.log(vnode_toString.call(container.rootVNode, Number.MAX_SAFE_INTEGER, "", true));
    console.log("------------------- SERIALIZED STATE -------------------");
    const origState = JSON.parse(
      container.element.querySelector('script[type="qwik/state"]')?.textContent || "[]"
    );
    preprocessState(origState, container);
    console.log(origState ? _dumpState(origState, true, "", null) : "No state found", "\n");
    const funcs = container.$qFuncs$;
    console.log("------------------- SERIALIZED QFUNCS -------------------");
    for (let i = 0; i < funcs.length; i++) {
      console.log(("    " + i + ":").substring(-4), funcs[i].toString());
    }
    const backpatchData = container.element.querySelector('script[type="qwik/backpatch"]');
    console.log("--------------- SERIALIZED BACKPATCH DATA ---------------");
    console.log("    " + backpatchData?.textContent || "No backpatch data found");
    console.log("---------------------------------------------------------");
  }
  const containerVNode = opts.raw ? container.rootVNode : vnode_getVNodeForChildNode(container.rootVNode, document2.body);
  const firstContainerChild = vnode_getFirstChild(containerVNode);
  let vNode = null;
  if (!firstContainerChild) {
    vNode = null;
  } else if (!vnode_isVirtualVNode(firstContainerChild)) {
    const fragment = vnode_newVirtual();
    fragment.setProp(DEBUG_TYPE, "F" /* Fragment */);
    const childrenToMove = [];
    let child = firstContainerChild;
    let insertBefore = null;
    while (child) {
      if (vnode_isElementVNode(child) && (vnode_getElementName(child) === "script" && (child.getAttr("type") === "qwik/state" || child.getAttr("type") === ELEMENT_BACKPATCH_DATA || child.getAttr("id") === "qwikloader") || vnode_getElementName(child) === "q:template")) {
        insertBefore = child;
        break;
      }
      childrenToMove.push(child);
      child = child.nextSibling;
    }
    vnode_insertBefore(container.$journal$, containerVNode, fragment, insertBefore);
    for (const child2 of childrenToMove) {
      vnode_moveToVirtual(container.$journal$, fragment, child2, null);
    }
    vNode = fragment;
  } else {
    vNode = firstContainerChild;
  }
  return { container, document: document2, vNode, getStyles };
}
function vnode_moveToVirtual(journal, parent, newChild, insertBefore) {
  const newChildCurrentParent = newChild.parent;
  if (newChildCurrentParent && (newChild.previousSibling || newChild.nextSibling)) {
    vnode_remove(journal, newChildCurrentParent, newChild, false);
  }
  const vNext = insertBefore;
  const vPrevious = vNext ? vNext.previousSibling : parent.lastChild;
  if (vNext) {
    vNext.previousSibling = newChild;
  } else {
    parent.lastChild = newChild;
  }
  if (vPrevious) {
    vPrevious.nextSibling = newChild;
  } else {
    parent.firstChild = newChild;
  }
  newChild.previousSibling = vPrevious;
  newChild.nextSibling = vNext;
  newChild.parent = parent;
}
function emulateExecutionOfQwikFuncs(document) {
  const qFuncs = document.body.querySelector("[q\\:func]");
  const containerElement = document.querySelector(QContainerSelector);
  const hash = containerElement.getAttribute(QInstanceAttr);
  if (qFuncs && hash) {
    let code = qFuncs.textContent || "";
    code = code.replace(Q_FUNCS_PREFIX2.replace("HASH", hash), "");
    if (code) {
      document[QFuncsPrefix + hash] = eval(code);
    }
  }
}
function emulateExecutionOfBackpatch(document) {
  if (typeof NodeFilter === "undefined") {
    globalThis.NodeFilter = {
      SHOW_ELEMENT: 1,
      SHOW_ALL: -1,
      SHOW_ATTRIBUTE: 2,
      SHOW_TEXT: 4,
      SHOW_CDATA_SECTION: 8,
      SHOW_ENTITY_REFERENCE: 16,
      SHOW_ENTITY: 32,
      SHOW_PROCESSING_INSTRUCTION: 64,
      SHOW_COMMENT: 128,
      SHOW_DOCUMENT: 256,
      SHOW_DOCUMENT_TYPE: 512,
      SHOW_DOCUMENT_FRAGMENT: 1024,
      SHOW_NOTATION: 2048
    };
  }
  const __dirname = fileURLToPath2(new URL(".", import.meta.url));
  const tsPath = join(__dirname, "../backpatch-executor.ts");
  const tsSource = readFileSync(tsPath, "utf8");
  const result = (0, import_esbuild.transformSync)(tsSource, {
    loader: "ts",
    target: "es2020",
    format: "esm",
    minify: false,
    sourcemap: false
  });
  const code = `try {${result.code}} catch (e) { console.error(e); }`;
  const script = document.createElement("script");
  document.body.appendChild(script);
  document.currentScript = script;
  try {
    eval(code);
  } finally {
    document.currentScript = null;
    document.body.removeChild(script);
  }
}
function renderStyles(getStyles) {
  const START = "\x1B[34m";
  const END = "\x1B[0m";
  Object.entries(getStyles()).forEach(([key, value], idx) => {
    if (idx == 0) {
      console.log("-  -  -  -  -  -  -  <style>  -  -  -  -  -  -  -  -  -");
    }
    console.log(START + key + ": " + END + value);
  });
}
async function rerenderComponent(element, flush) {
  const container = _getDomContainer2(element);
  const vElement = vnode_locate(container.rootVNode, element);
  const host = getHostVNode(vElement);
  const qrl = container.getHostProp(host, OnRenderProp);
  const props = container.getHostProp(host, ELEMENT_PROPS);
  container.$scheduler$(6 /* COMPONENT */, host, qrl, props);
  if (flush) {
    await getTestPlatform().flush();
  }
}
function getHostVNode(vElement) {
  while (vElement != null) {
    if (vElement.getAttr(OnRenderProp) != null) {
      return vElement;
    }
    vElement = vElement.parent;
  }
  return vElement;
}
var ErrorProvider = Object.assign(
  componentQrl2(
    inlinedQrl(() => {
      ErrorProvider.error = null;
      useContextProvider(ERROR_CONTEXT, ErrorProvider);
      return /* @__PURE__ */ jsx(Slot3, {});
    }, "s_ErrorProvider")
  ),
  { error: null }
);
export {
  ElementFixture,
  createDOM,
  createDocument,
  domRender,
  emulateExecutionOfQwikFuncs,
  expectDOM,
  getTestPlatform,
  ssrRenderToDom,
  trigger,
  vnode_fromJSX,
  waitForDrain,
  walkJSX
};
/*! Bundled license information:

domino/lib/cssparser.js:
  (*!
  Parser-Lib
  Copyright (c) 2009-2011 Nicholas C. Zakas. All rights reserved.
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
  
  *)
*/
