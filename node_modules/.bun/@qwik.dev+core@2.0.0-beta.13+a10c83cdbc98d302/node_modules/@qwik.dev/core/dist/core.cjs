/**
 * @license
 * @qwik.dev/core 2.0.0-beta.13-dev+cb19ff7
 * Copyright QwikDev. All Rights Reserved.
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/QwikDev/qwik/blob/main/LICENSE
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@qwik.dev/core/build'), require('@qwik.dev/core/preloader')) :
    typeof define === 'function' && define.amd ? define(['exports', '@qwik.dev/core/build', '@qwik.dev/core/preloader'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.qwikCore = {}, global.qwikBuild, global.qwikPreloader));
})(this, (function (exports, build, preloader) { 'use strict';

    /**
     * QWIK_VERSION
     *
     * @public
     */
    const version = "2.0.0-beta.13-dev+cb19ff7";

    // same as isDev but separate so we can test
    const qDev = globalThis.qDev !== false;
    const qInspector = globalThis.qInspector === true;
    const qSerialize = globalThis.qSerialize !== false;
    const qDynamicPlatform = globalThis.qDynamicPlatform !== false;
    const qTest = globalThis.qTest === true;
    const qRuntimeQrl = globalThis.qRuntimeQrl === true;
    const seal = (obj) => {
        if (qDev) {
            Object.seal(obj);
        }
    };

    const STYLE = qDev
        ? `background: #564CE0; color: white; padding: 2px 3px; border-radius: 2px; font-size: 0.8em;`
        : '';
    const logError = (message, ...optionalParams) => {
        return createAndLogError(false, message, ...optionalParams);
    };
    const throwErrorAndStop = (message, ...optionalParams) => {
        const error = createAndLogError(false, message, ...optionalParams);
        // eslint-disable-next-line no-debugger
        debugger;
        throw error;
    };
    const logErrorAndStop = (message, ...optionalParams) => {
        const err = createAndLogError(qDev, message, ...optionalParams);
        // eslint-disable-next-line no-debugger
        debugger;
        return err;
    };
    const _printed = /*#__PURE__*/ new Set();
    const logOnceWarn = (message, ...optionalParams) => {
        if (qDev) {
            const key = 'warn' + String(message);
            if (!_printed.has(key)) {
                _printed.add(key);
                logWarn(message, ...optionalParams);
            }
        }
    };
    const logWarn = (message, ...optionalParams) => {
        if (qDev) {
            console.warn('%cQWIK WARN', STYLE, message, ...optionalParams);
        }
    };
    const createAndLogError = (asyncThrow, message, ...optionalParams) => {
        const err = message instanceof Error ? message : new Error(message);
        // display the error message first, then the optional params, and finally the stack trace
        // the stack needs to be displayed last because the given params will be lost among large stack traces so it will
        // provide a bad developer experience
        !qTest && console.error('%cQWIK ERROR', STYLE, err.message, ...optionalParams, err.stack);
        asyncThrow &&
            !qTest &&
            setTimeout(() => {
                // throwing error asynchronously to avoid breaking the current call stack.
                // We throw so that the error is delivered to the global error handler for
                // reporting it to a third-party tools such as Qwik Insights, Sentry or New Relic.
                throw err;
            }, 0);
        return err;
    };

    /** @private */
    const isSerializableObject = (v) => {
        const proto = Object.getPrototypeOf(v);
        return proto === Object.prototype || proto === Array.prototype || proto === null;
    };
    const isObject = (v) => {
        return typeof v === 'object' && v !== null;
    };
    const isArray = (v) => {
        return Array.isArray(v);
    };
    const isString = (v) => {
        return typeof v === 'string';
    };
    const isNumber$1 = (v) => {
        return typeof v === 'number';
    };
    const isFunction = (v) => {
        return typeof v === 'function';
    };
    const isPrimitive = (v) => {
        return typeof v !== 'object' && typeof v !== 'function' && v !== null && v !== undefined;
    };

    const codeToText = (code, ...parts) => {
        if (qDev) {
            // Keep one error, one line to make it easier to search for the error message.
            const MAP = [
                'Error while serializing class or style attributes', // 0
                'Scheduler not found', // 1
                'track() received object, without prop to track', // 2
                'Only primitive and object literals can be serialized. {{0}}', // 3
                'You can render over a existing q:container. Skipping render().', // 4
                'QRL is not a function', // 5
                'Dynamic import not found', // 6
                'Unknown type argument', // 7
                `Actual value for useContext({{0}}) can not be found, make sure some ancestor component has set a value using useContextProvider(). In the browser make sure that the context was used during SSR so its state was serialized.`, // 8
                "Invoking 'use*()' method outside of invocation context.", // 9
                `Calling a 'use*()' method outside 'component$(() => { HERE })' is not allowed. 'use*()' methods provide hooks to the 'component$' state and lifecycle, ie 'use' hooks can only be called synchronously within the 'component$' function or another 'use' method.\nSee https://qwik.dev/docs/core/tasks/#use-method-rules`, // 10
                'The provided Context reference "{{0}}" is not a valid context created by createContextId()', // 11
                'SsrError(tag): {{0}}', // 12
                'QRLs can not be resolved because it does not have an attached container. This means that the QRL does not know where it belongs inside the DOM, so it cant dynamically import() from a relative path.', // 13
                'QRLs can not be dynamically resolved, because it does not have a chunk path', // 14
                '{{0}}\nThe JSX ref attribute must be a Signal', // 15
                'Serialization Error: Deserialization of data type {{0}} is not implemented', // 16
                'Serialization Error: Expected vnode for ref prop, but got {{0}}', // 17
                'Serialization Error: Cannot allocate data type {{0}}', // 18
                'Serialization Error: Missing root id for {{0}}', // 19
                'Serialization Error: Serialization of data type {{0}} is not implemented', // 20
                'Serialization Error: Unvisited {{0}}', // 21
                'Serialization Error: Missing QRL chunk for {{0}}', // 22
                '{{0}}\nThe value of the textarea must be a string found {{1}}', // 23
                'Unable to find q:container', // 24
                "Element must have 'q:container' attribute.", // 25
                'Unknown vnode type {{0}}.', // 26
                'Materialize error: missing element: {{0}} {{1}} {{2}}', // 27
                'Cannot coerce a Signal, use `.value` instead', // 28
                'useComputed$ QRL {{0}} {{1}} cannot return a Promise', // 29
                'ComputedSignal is read-only', // 30
                'WrappedSignal is read-only', // 31
                'Attribute value is unsafe for SSR', // 32
                'SerializerSymbol function returned rejected promise', // 33
                'Serialization Error: Cannot serialize function: {{0}}', // 34
            ];
            let text = MAP[code] ?? '';
            if (parts.length) {
                text = text.replaceAll(/{{(\d+)}}/g, (_, index) => {
                    let v = parts[index];
                    if (v && isObject(v) && v.constructor === Object) {
                        v = JSON.stringify(v).slice(0, 50);
                    }
                    return v;
                });
            }
            return `Code(Q${code}): ${text}`;
        }
        else {
            // cute little hack to give roughly the correct line number. Update the line number if it shifts.
            return `Code(Q${code}) https://github.com/QwikDev/qwik/blob/main/packages/qwik/src/core/error/error.ts#L${8 + code}`;
        }
    };
    const qError = (code, errorMessageArgs = []) => {
        const text = codeToText(code, ...errorMessageArgs);
        return logErrorAndStop(text, ...errorMessageArgs);
    };

    /** QRL related utilities that you can import without importing all of Qwik. */
    const SYNC_QRL = '<sync>';
    /** Sync QRL is a function which is serialized into `<script q:func="qwik/json">` tag. */
    const isSyncQrl = (value) => {
        return isQrl(value) && value.$symbol$ == SYNC_QRL;
    };
    const isQrl = (value) => {
        return typeof value === 'function' && typeof value.getSymbol === 'function';
    };
    function assertQrl(qrl) {
        if (build.isDev) {
            if (!isQrl(qrl)) {
                throw new Error('Not a QRL');
            }
        }
    }
    const getSymbolHash = (symbolName) => {
        const index = symbolName.lastIndexOf('_');
        if (index > -1) {
            return symbolName.slice(index + 1);
        }
        return symbolName;
    };

    /** State factory of the component. */
    const OnRenderProp = 'q:renderFn';
    /** Component style content prefix */
    const ComponentStylesPrefixContent = '⚡️';
    /** `<some-element q:slot="...">` */
    const QSlot = 'q:slot';
    const QSlotParent = 'q:sparent';
    const QSlotS = 'q:s';
    const QStyle = 'q:style';
    const QStyleSelector = 'style[q\\:style]';
    const QStyleSSelector = 'style[q\\:sstyle]';
    const QStylesAllSelector = QStyleSelector + ',' + QStyleSSelector;
    const QScopedStyle = 'q:sstyle';
    const QCtxAttr = 'q:ctx';
    const QBackRefs = 'q:brefs';
    const QFuncsPrefix = 'qFuncs_';
    const getQFuncs = (document, hash) => {
        return document[QFuncsPrefix + hash] || [];
    };
    const QBaseAttr = 'q:base';
    const QLocaleAttr = 'q:locale';
    const QManifestHashAttr = 'q:manifest-hash';
    const QInstanceAttr = 'q:instance';
    const QContainerIsland = 'q:container-island';
    const QContainerIslandEnd = '/' + QContainerIsland;
    const QIgnore = 'q:ignore';
    const QIgnoreEnd = '/' + QIgnore;
    const QContainerAttr = 'q:container';
    const QContainerAttrEnd = '/' + QContainerAttr;
    const QTemplate = 'q:template';
    // the same selector should be inside the qwik loader
    // and the same selector should be inside the qwik router spa-shim and spa-init
    const QContainerSelector = '[q\\:container]:not([q\\:container=' +
        "html" /* QContainerValue.HTML */ +
        ']):not([q\\:container=' +
        "text" /* QContainerValue.TEXT */ +
        '])';
    // Node namespaces
    const HTML_NS = 'http://www.w3.org/1999/xhtml';
    const SVG_NS = 'http://www.w3.org/2000/svg';
    const MATH_NS = 'http://www.w3.org/1998/Math/MathML';
    // Attributes namespaces
    const XLINK_NS = 'http://www.w3.org/1999/xlink';
    const XML_NS = 'http://www.w3.org/XML/1998/namespace';
    const ResourceEvent = 'qResource';
    const RenderEvent = 'qRender';
    const TaskEvent = 'qTask';
    /** `<q:slot name="...">` */
    const QDefaultSlot = '';
    /**
     * Attribute to mark that this VNode has a pointer to itself from the `qwik/json` state.
     *
     * As the VNode get materialized the vnode now becomes eligible for mutation. Once the vnode mutates
     * the `VNode` references from the `qwik/json` may become invalid. For this reason, these references
     * need to be eagerly resolved. `VNODE_REF` stores a pointer to "this" vnode. This allows the system
     * to eagerly resolve these pointes as the vnodes are materialized.
     */
    const ELEMENT_ID = 'q:id';
    const ELEMENT_KEY = 'q:key';
    const ELEMENT_PROPS = 'q:props';
    const ELEMENT_SEQ = 'q:seq';
    const ELEMENT_SEQ_IDX = 'q:seqIdx';
    const Q_PREFIX = 'q:';
    /** Non serializable markers - always begins with `:` character */
    const NON_SERIALIZABLE_MARKER_PREFIX = ':';
    const USE_ON_LOCAL = NON_SERIALIZABLE_MARKER_PREFIX + 'on';
    const USE_ON_LOCAL_SEQ_IDX = NON_SERIALIZABLE_MARKER_PREFIX + 'onIdx';
    const USE_ON_LOCAL_FLAGS = NON_SERIALIZABLE_MARKER_PREFIX + 'onFlags';
    // comment nodes
    const FLUSH_COMMENT = 'qkssr-f';
    const STREAM_BLOCK_START_COMMENT = 'qkssr-pu';
    const STREAM_BLOCK_END_COMMENT = 'qkssr-po';
    const Q_PROPS_SEPARATOR = ':';
    const dangerouslySetInnerHTML = 'dangerouslySetInnerHTML';
    const qwikInspectorAttr = 'data-qwik-inspector';

    // keep this import from core/build so the cjs build works
    const createPlatform = () => {
        return {
            isServer: build.isServer,
            importSymbol(containerEl, url, symbolName) {
                if (build.isServer) {
                    const hash = getSymbolHash(symbolName);
                    const regSym = globalThis.__qwik_reg_symbols?.get(hash);
                    if (regSym) {
                        return regSym;
                    }
                }
                if (!url) {
                    throw qError(14 /* QError.qrlMissingChunk */, [symbolName]);
                }
                if (!containerEl) {
                    throw qError(13 /* QError.qrlMissingContainer */, [url, symbolName]);
                }
                const urlDoc = toUrl(containerEl.ownerDocument, containerEl, url).toString();
                const urlCopy = new URL(urlDoc);
                urlCopy.hash = '';
                const importURL = urlCopy.href;
                return import(/* @vite-ignore */ importURL).then((mod) => {
                    return mod[symbolName];
                });
            },
            raf: (fn) => {
                return new Promise((resolve) => {
                    requestAnimationFrame(() => {
                        resolve(fn());
                    });
                });
            },
            chunkForSymbol(symbolName, chunk) {
                return [symbolName, chunk ?? '_'];
            },
        };
    };
    /**
     * Convert relative base URI and relative URL into a fully qualified URL.
     *
     * @param base -`QRL`s are relative, and therefore they need a base for resolution.
     *
     *   - `Element` use `base.ownerDocument.baseURI`
     *   - `Document` use `base.baseURI`
     *   - `string` use `base` as is
     *   - `QConfig` use `base.baseURI`
     *
     * @param url - Relative URL
     * @returns Fully qualified URL.
     */
    const toUrl = (doc, containerEl, url) => {
        const baseURI = doc.baseURI;
        const base = new URL(containerEl.getAttribute(QBaseAttr) ?? baseURI, baseURI);
        return new URL(url, base);
    };
    let _platform = /*#__PURE__ */ createPlatform();
    // <docs markdown="./readme.md#setPlatform">
    // !!DO NOT EDIT THIS COMMENT DIRECTLY!!!
    // (edit ./readme.md#setPlatform instead and run `pnpm docs.sync`)
    /**
     * Sets the `CorePlatform`.
     *
     * This is useful to override the platform in tests to change the behavior of,
     * `requestAnimationFrame`, and import resolution.
     *
     * @param doc - The document of the application for which the platform is needed.
     * @param platform - The platform to use.
     * @public
     */
    // </docs>
    const setPlatform = (plt) => (_platform = plt);
    // <docs markdown="./readme.md#getPlatform">
    // !!DO NOT EDIT THIS COMMENT DIRECTLY!!!
    // (edit ./readme.md#getPlatform instead and run `pnpm docs.sync`)
    /**
     * Retrieve the `CorePlatform`.
     *
     * The `CorePlatform` is also responsible for retrieving the Manifest, that contains mappings from
     * symbols to javascript import chunks. For this reason, `CorePlatform` can't be global, but is
     * specific to the application currently running. On server it is possible that many different
     * applications are running in a single server instance, and for this reason the `CorePlatform` is
     * associated with the application document.
     *
     * @param docOrNode - The document (or node) of the application for which the platform is needed.
     * @public
     */
    // </docs>
    const getPlatform = () => {
        return _platform;
    };
    const isServerPlatform = () => {
        if (qDynamicPlatform) {
            return _platform.isServer;
        }
        return false;
    };

    const isNode = (value) => {
        return value && typeof value.nodeType === 'number';
    };
    const isDocument = (value) => {
        return value.nodeType === 9;
    };
    const isElement$1 = (value) => {
        return value.nodeType === 1;
    };

    const MAX_RETRY_ON_PROMISE_COUNT = 100;
    const isPromise = (value) => {
        // not using "value instanceof Promise" to have zone.js support
        return !!value && typeof value == 'object' && typeof value.then === 'function';
    };
    const safeCall = (call, thenFn, rejectFn) => {
        try {
            const result = call();
            if (isPromise(result)) {
                return result.then(thenFn, rejectFn);
            }
            else {
                return thenFn(result);
            }
        }
        catch (e) {
            return rejectFn(e);
        }
    };
    const maybeThen = (valueOrPromise, thenFn) => {
        return isPromise(valueOrPromise)
            ? valueOrPromise.then(thenFn, shouldNotError)
            : thenFn(valueOrPromise);
    };
    const shouldNotError = (reason) => {
        throwErrorAndStop(reason);
    };
    const delay = (timeout) => {
        return new Promise((resolve) => {
            setTimeout(resolve, timeout);
        });
    };
    /** Retries a function that throws a promise. */
    function retryOnPromise(fn, retryCount = 0) {
        const retryOrThrow = (e) => {
            if (isPromise(e) && retryCount < MAX_RETRY_ON_PROMISE_COUNT) {
                return e.then(retryOnPromise.bind(null, fn, retryCount++));
            }
            throw e;
        };
        try {
            const result = fn();
            if (isPromise(result)) {
                // not awaited promise is not caught by try/catch block
                return result.catch((e) => retryOrThrow(e));
            }
            return result;
        }
        catch (e) {
            if (build.isDev && build.isServer && e instanceof ReferenceError && e.message.includes('window')) {
                e.message = 'It seems like you forgot to add "if (isBrowser) {...}" here:' + e.message;
                throw e;
            }
            return retryOrThrow(e);
        }
    }

    const ASSERT_DISCLAIMER = 'Internal assert, this is likely caused by a bug in Qwik: ';
    function assertDefined(value, text, ...parts) {
        if (qDev) {
            if (value != null) {
                return;
            }
            throwErrorAndStop(ASSERT_DISCLAIMER + text, ...parts);
        }
    }
    function assertEqual(value1, value2, text, ...parts) {
        if (qDev) {
            if (value1 === value2) {
                return;
            }
            throwErrorAndStop(ASSERT_DISCLAIMER + text, ...parts);
        }
    }
    function assertTrue(value1, text, ...parts) {
        if (qDev) {
            if (value1 === true) {
                return;
            }
            throwErrorAndStop(ASSERT_DISCLAIMER + text, ...parts);
        }
    }
    function assertFalse(value1, text, ...parts) {
        if (qDev) {
            if (value1 === false) {
                return;
            }
            throwErrorAndStop(ASSERT_DISCLAIMER + text, ...parts);
        }
    }
    function assertNumber(value1, text, ...parts) {
        if (qDev) {
            if (typeof value1 === 'number') {
                return;
            }
            throwErrorAndStop(ASSERT_DISCLAIMER + text, ...parts);
        }
    }

    let _locale = undefined;
    let localAsyncStore;
    if (build.isServer) {
        import('node:async_hooks')
            .then((module) => {
            localAsyncStore = new module.AsyncLocalStorage();
        })
            .catch(() => {
            // ignore if AsyncLocalStorage is not available
        });
    }
    /**
     * Retrieve the current locale.
     *
     * If no current locale and there is no `defaultLocale` the function throws an error.
     *
     * @returns The locale.
     * @public
     */
    function getLocale(defaultLocale) {
        // Prefer per-request locale from local AsyncLocalStorage if available (server-side)
        if (localAsyncStore) {
            const locale = localAsyncStore.getStore();
            if (locale) {
                return locale;
            }
        }
        if (_locale === undefined) {
            const ctx = tryGetInvokeContext();
            if (ctx && ctx.$locale$) {
                return ctx.$locale$;
            }
            if (defaultLocale !== undefined) {
                return defaultLocale;
            }
            throw new Error('Reading `locale` outside of context.');
        }
        return _locale;
    }
    /**
     * Override the `getLocale` with `lang` within the `fn` execution.
     *
     * @public
     */
    function withLocale(locale, fn) {
        if (localAsyncStore) {
            return localAsyncStore.run(locale, fn);
        }
        const previousLang = _locale;
        try {
            _locale = locale;
            return fn();
        }
        finally {
            _locale = previousLang;
        }
    }
    /**
     * Globally set a lang.
     *
     * This can be used only in browser. Server execution requires that each request could potentially
     * be a different lang, therefore setting a global lang would produce incorrect responses.
     *
     * @public
     */
    function setLocale(locale) {
        if (localAsyncStore) {
            localAsyncStore.enterWith(locale);
            return;
        }
        _locale = locale;
    }

    /**
     * A friendly name tag for a VirtualVNode.
     *
     * Theses are used to give a name to a VirtualVNode. This is useful for debugging and testing.
     *
     * The name is only added in development mode and is not included in production builds.
     */
    const DEBUG_TYPE = 'q:type';
    const VirtualTypeName = {
        ["V" /* VirtualType.Virtual */]: /* ********* */ 'Virtual', //
        ["F" /* VirtualType.Fragment */]: /* ******** */ 'Fragment', //
        ["S" /* VirtualType.WrappedSignal */]: /* *** */ 'Signal', //
        ["A" /* VirtualType.Awaited */]: /* ********* */ 'Awaited', //
        ["C" /* VirtualType.Component */]: /* ******* */ 'Component', //
        ["I" /* VirtualType.InlineComponent */]: /* * */ 'InlineComponent', //
        ["P" /* VirtualType.Projection */]: /* ****** */ 'Projection', //
    };

    /**
     * @file
     *
     *   VNodeData is additional information which allows the `vnode` to recover virtual VNode information
     *   from the HTML.
     */
    /**
     * VNodeDataSeparator contains information about splitting up the VNodeData and attaching it to the
     * HTML.
     */
    const VNodeDataSeparator = {
        REFERENCE: /* ******** */ 126, // `~` is a reference to the node. Save it.
        ADVANCE_1: /* ********* */ 33, // `!` is vNodeData separator skipping 0. (ie next vNode)
        ADVANCE_8192: /* ****** */ 46, // `.` is vNodeData separator skipping 4096.
    };
    /**
     * VNodeDataChar contains information about the VNodeData used for encoding props.
     *
     * Available character ranges: 59 - 64, 91 - 94, 96, 123 - 126
     */
    const VNodeDataChar = {
        OPEN: /* ************** */ 123, // `{` is the start of the VNodeData for a virtual element.
        CLOSE: /* ************* */ 125, // `}` is the end of the VNodeData for a virtual element.
        SCOPED_STYLE: /* ******* */ 59, // `;` - `q:sstyle` - Style attribute.
        RENDER_FN: /* ********** */ 60, // `<` - `q:renderFn' - Component QRL render function (body)
        ID: /* ***************** */ 61, // `=` - `q:id` - ID of the element.
        PROPS: /* ************** */ 62, // `>` - `q:props' - Component Props
        SLOT_PARENT: /* ******** */ 63, // `?` - `q:sparent` - Slot parent.
        KEY: /* **************** */ 64, // `@` - `q:key` - Element key.
        SEQ: /* **************** */ 91, // `[` - `q:seq' - Seq value from `useSequentialScope()`
        CONTEXT: /* ************ */ 93, // `]` - `q:ctx' - Component context/props
        SEQ_IDX: /* ************ */ 94, // `^` - `q:seqIdx' - Sequential scope id
        BACK_REFS: /* ********** */ 96, // '`' - `q:brefs' - Effect dependencies/subscriptions
        SEPARATOR: /* ********* */ 124, // `|` - Separator char to encode any key/value pairs.
        SLOT: /* ************** */ 126};

    /** @internal */
    const mapApp_findIndx = (array, key, start) => {
        assertTrue(start % 2 === 0, 'Expecting even number.');
        let bottom = start >> 1;
        let top = (array.length - 2) >> 1;
        while (bottom <= top) {
            const mid = bottom + ((top - bottom) >> 1);
            const midKey = array[mid << 1];
            if (midKey === key) {
                return mid << 1;
            }
            if (midKey < key) {
                bottom = mid + 1;
            }
            else {
                top = mid - 1;
            }
        }
        return (bottom << 1) ^ -1;
    };
    /** @internal */
    const mapArray_set = (array, key, value, start, allowNullValue = false) => {
        const indx = mapApp_findIndx(array, key, start);
        if (indx >= 0) {
            if (value == null && !allowNullValue) {
                array.splice(indx, 2);
            }
            else {
                array[indx + 1] = value;
            }
        }
        else if (value != null || allowNullValue) {
            array.splice(indx ^ -1, 0, key, value);
        }
    };
    /** @internal */
    const mapArray_get = (array, key, start) => {
        const indx = mapApp_findIndx(array, key, start);
        if (indx >= 0) {
            return array[indx + 1];
        }
        else {
            return null;
        }
    };
    const mapArray_has = (array, key, start) => {
        return mapApp_findIndx(array, key, start) >= 0;
    };

    const isForeignObjectElement = (elementName) => {
        return build.isDev ? elementName.toLowerCase() === 'foreignobject' : elementName === 'foreignObject';
    };
    const isSvgElement = (elementName) => elementName === 'svg' || isForeignObjectElement(elementName);
    const isMathElement = (elementName) => elementName === 'math';
    const vnode_isDefaultNamespace = (vnode) => {
        const flags = vnode.flags;
        return (flags & 192 /* VNodeFlags.NAMESPACE_MASK */) === 0;
    };
    const vnode_getElementNamespaceFlags = (element) => {
        const namespace = fastNamespaceURI(element);
        switch (namespace) {
            case SVG_NS:
                return 64 /* VNodeFlags.NS_svg */;
            case MATH_NS:
                return 128 /* VNodeFlags.NS_math */;
            default:
                return 0 /* VNodeFlags.NS_html */;
        }
    };
    function vnode_getDomChildrenWithCorrectNamespacesToInsert(journal, domParentVNode, newChild) {
        const { elementNamespace, elementNamespaceFlag } = getNewElementNamespaceData(domParentVNode, newChild);
        let domChildren = [];
        if (elementNamespace === HTML_NS) {
            // parent is in the default namespace, so just get the dom children. This is the fast path.
            domChildren = vnode_getDOMChildNodes(journal, newChild);
        }
        else {
            // parent is in a different namespace, so we need to clone the children with the correct namespace.
            // The namespace cannot be changed on nodes, so we need to clone these nodes
            const children = vnode_getDOMChildNodes(journal, newChild, true);
            for (let i = 0; i < children.length; i++) {
                const childVNode = children[i];
                if (vnode_isTextVNode(childVNode)) {
                    // text nodes are always in the default namespace
                    domChildren.push(childVNode.textNode);
                    continue;
                }
                if ((childVNode.flags & 192 /* VNodeFlags.NAMESPACE_MASK */) ===
                    (domParentVNode.flags & 192 /* VNodeFlags.NAMESPACE_MASK */)) {
                    // if the child and parent have the same namespace, we don't need to clone the element
                    domChildren.push(childVNode.element);
                    continue;
                }
                // clone the element with the correct namespace
                const newChildElement = vnode_cloneElementWithNamespace(childVNode, domParentVNode, elementNamespace, elementNamespaceFlag);
                if (newChildElement) {
                    domChildren.push(newChildElement);
                }
            }
        }
        return domChildren;
    }
    /** This function clones an element with a different namespace, including the children */
    function cloneDomTreeWithNamespace(element, elementName, namespace, deep = false) {
        const newElement = element.ownerDocument.createElementNS(namespace, elementName);
        // Copy all attributes
        for (const attr of element.attributes) {
            if (attr.name !== Q_PROPS_SEPARATOR) {
                newElement.setAttribute(attr.name, attr.value);
            }
        }
        if (deep) {
            // Recursively clone all child nodes
            for (const child of element.childNodes) {
                const nodeType = child.nodeType;
                if (nodeType === 3 /* Node.TEXT_NODE */) {
                    newElement.appendChild(child.cloneNode());
                }
                else if (nodeType === 1 /* Node.ELEMENT_NODE */) {
                    newElement.appendChild(cloneDomTreeWithNamespace(child, child.localName, namespace, deep));
                }
            }
        }
        return newElement;
    }
    /**
     * This function clones an ElementVNode with a different namespace, including the children. This
     * traverse the tree using depth-first search and clones the elements using
     * `cloneElementWithNamespace`.
     */
    function vnode_cloneElementWithNamespace(elementVNode, parentVNode, namespace, namespaceFlag) {
        ensureElementVNode(elementVNode);
        let vCursor = elementVNode;
        let vParent = null;
        let rootElement = null;
        let parentElement = null;
        while (vCursor) {
            let childElement = null;
            let newChildElement = null;
            if (vnode_isElementVNode(vCursor)) {
                // Clone the element
                childElement = vCursor.element;
                const childElementTag = vnode_getElementName(vCursor);
                // We need to check if the parent is a foreignObject element
                // and get a new namespace data.
                const vCursorParent = vCursor.parent;
                // For the first vNode parentNode is not parent from vNode tree, but parent from DOM tree
                // this is because vNode is not moved yet.
                // rootElement is null only for the first vNode
                const vCursorDomParent = rootElement == null ? parentVNode : vCursorParent && vnode_getDomParentVNode(vCursorParent);
                if (vCursorDomParent) {
                    const namespaceData = getNewElementNamespaceData(vCursorDomParent, vnode_getElementName(vCursor));
                    namespace = namespaceData.elementNamespace;
                    namespaceFlag = namespaceData.elementNamespaceFlag;
                }
                const vFirstChild = vnode_getFirstChild(vCursor);
                newChildElement = cloneDomTreeWithNamespace(childElement, childElementTag, namespace, 
                // deep if there is no vnode children, children are probably inserted via innerHTML
                !vFirstChild);
                childElement.remove();
                if (rootElement == null) {
                    rootElement = newChildElement;
                }
                if (parentElement) {
                    parentElement.appendChild(newChildElement);
                }
                // Descend into children
                // We need first get the first child, if any
                // Then we can overwrite the cursor with newly created element.
                // This is because we need to materialize the children before we assign new element
                vCursor.element = newChildElement;
                // Set correct namespace flag
                vCursor.flags &= -193 /* VNodeFlags.NEGATED_NAMESPACE_MASK */;
                vCursor.flags |= namespaceFlag;
                if (vFirstChild) {
                    vCursor = vFirstChild;
                    parentElement = newChildElement;
                    continue;
                }
                else if (shouldIgnoreChildren(childElement)) {
                    // If we should ignore children of the element this means that the element is a container
                    // We need to get the first child of the container
                    const container = getDomContainerFromQContainerElement(childElement);
                    if (container) {
                        const innerContainerFirstVNode = vnode_getFirstChild(container.rootVNode);
                        if (innerContainerFirstVNode) {
                            vCursor = innerContainerFirstVNode;
                            parentElement = newChildElement;
                            continue;
                        }
                    }
                }
            }
            if (vCursor === elementVNode) {
                // we are where we started, this means that vNode has no children, so we are done.
                return rootElement;
            }
            // Out of children, go to next sibling
            const vNextSibling = vCursor.nextSibling;
            if (vNextSibling) {
                vCursor = vNextSibling;
                continue;
            }
            // Out of siblings, go to parent
            vParent = vCursor.parent;
            while (vParent) {
                if (vParent === elementVNode) {
                    // We are back where we started, we are done.
                    return rootElement;
                }
                const vNextParentSibling = vParent.nextSibling;
                if (vNextParentSibling) {
                    vCursor = vNextParentSibling;
                    return rootElement;
                }
                vParent = vParent.parent;
            }
            if (vParent == null) {
                // We are done.
                return rootElement;
            }
        }
        return rootElement;
    }
    function isSvg(tagOrVNode) {
        return typeof tagOrVNode === 'string'
            ? isSvgElement(tagOrVNode)
            : (tagOrVNode.flags & 64 /* VNodeFlags.NS_svg */) !== 0;
    }
    function isMath(tagOrVNode) {
        return typeof tagOrVNode === 'string'
            ? isMathElement(tagOrVNode)
            : (tagOrVNode.flags & 128 /* VNodeFlags.NS_math */) !== 0;
    }
    function getNewElementNamespaceData(domParentVNode, tagOrVNode) {
        const parentIsDefaultNamespace = domParentVNode
            ? !!vnode_getElementName(domParentVNode) && vnode_isDefaultNamespace(domParentVNode)
            : true;
        const parentIsForeignObject = !parentIsDefaultNamespace
            ? isForeignObjectElement(vnode_getElementName(domParentVNode))
            : false;
        let elementNamespace = HTML_NS;
        let elementNamespaceFlag = 0 /* VNodeFlags.NS_html */;
        const isElementVNodeOrString = typeof tagOrVNode === 'string' || vnode_isElementVNode(tagOrVNode);
        if (isElementVNodeOrString && isSvg(tagOrVNode)) {
            elementNamespace = SVG_NS;
            elementNamespaceFlag = 64 /* VNodeFlags.NS_svg */;
        }
        else if (isElementVNodeOrString && isMath(tagOrVNode)) {
            elementNamespace = MATH_NS;
            elementNamespaceFlag = 128 /* VNodeFlags.NS_math */;
        }
        else if (domParentVNode && !parentIsForeignObject && !parentIsDefaultNamespace) {
            const isParentSvg = (domParentVNode.flags & 64 /* VNodeFlags.NS_svg */) !== 0;
            const isParentMath = (domParentVNode.flags & 128 /* VNodeFlags.NS_math */) !== 0;
            elementNamespace = isParentSvg ? SVG_NS : isParentMath ? MATH_NS : HTML_NS;
            elementNamespaceFlag = domParentVNode.flags & 192 /* VNodeFlags.NAMESPACE_MASK */;
        }
        return {
            elementNamespace,
            elementNamespaceFlag,
        };
    }
    function getAttributeNamespace(attributeName) {
        switch (attributeName) {
            case 'xlink:href':
            case 'xlink:actuate':
            case 'xlink:arcrole':
            case 'xlink:role':
            case 'xlink:show':
            case 'xlink:title':
            case 'xlink:type':
                return XLINK_NS;
            case 'xml:base':
            case 'xml:lang':
            case 'xml:space':
                return XML_NS;
            default:
                return null;
        }
    }

    const mergeMaps = (map1, map2) => {
        for (const [k, v] of map2) {
            map1.set(k, v);
        }
        return map1;
    };

    /**
     * # ================================
     *
     * Signal Types
     *
     * # ================================
     */
    /**
     * Special value used to mark that a given signal needs to be computed. This is essentially a
     * "marked as dirty" flag.
     */
    const NEEDS_COMPUTATION = Symbol('invalid');
    /** @internal */
    const _EFFECT_BACK_REF = Symbol('backRef');
    /**
     * # ================================
     *
     * Store Types
     *
     * # ================================
     */
    const STORE_TARGET = Symbol('store.target');
    const STORE_HANDLER = Symbol('store.handler');
    const STORE_ALL_PROPS = Symbol('store.all');

    class SignalImpl {
        $untrackedValue$;
        /** Store a list of effects which are dependent on this signal. */
        $effects$ = null;
        $container$ = null;
        $wrappedSignal$ = null;
        constructor(container, value) {
            this.$container$ = container;
            this.$untrackedValue$ = value;
        }
        /**
         * Use this to force running subscribers, for example when the calculated value has mutated but
         * remained the same object
         */
        force() {
            this.$container$?.$scheduler$(7 /* ChoreType.RECOMPUTE_AND_SCHEDULE_EFFECTS */, null, this, this.$effects$);
        }
        get untrackedValue() {
            return this.$untrackedValue$;
        }
        // TODO: should we disallow setting the value directly?
        set untrackedValue(value) {
            this.$untrackedValue$ = value;
        }
        get value() {
            return setupSignalValueAccess(this, () => (this.$effects$ ||= new Set()), () => this.untrackedValue);
        }
        set value(value) {
            if (value !== this.$untrackedValue$) {
                this.$untrackedValue$ = value;
                this.$container$?.$scheduler$(7 /* ChoreType.RECOMPUTE_AND_SCHEDULE_EFFECTS */, null, this, this.$effects$);
            }
        }
        // prevent accidental use as value
        valueOf() {
            if (qDev) {
                throw qError(28 /* QError.cannotCoerceSignal */);
            }
        }
        toString() {
            if (build.isDev) {
                return (`[${this.constructor.name}${this.$flags$ & 1 /* SignalFlags.INVALID */ ? ' INVALID' : ''} ${String(this.$untrackedValue$)}]` +
                    (Array.from(this.$effects$ || [])
                        .map((e) => '\n -> ' + pad(qwikDebugToString(e[0]), '    '))
                        .join('\n') || ''));
            }
            else {
                return this.constructor.name;
            }
        }
        toJSON() {
            return { value: this.$untrackedValue$ };
        }
    }
    const addEffect = (signal, effectSubscriber, effects) => {
        // Let's make sure that we have a reference to this effect.
        // Adding reference is essentially adding a subscription, so if the signal
        // changes we know who to notify.
        ensureContainsSubscription(effects, effectSubscriber);
        // But when effect is scheduled in needs to be able to know which signals
        // to unsubscribe from. So we need to store the reference from the effect back
        // to this signal.
        ensureContainsBackRef(effectSubscriber, signal);
        addQrlToSerializationCtx(effectSubscriber, signal.$container$);
    };
    const setupSignalValueAccess = (target, effectsFn, returnValueFn) => {
        const ctx = tryGetInvokeContext();
        if (ctx) {
            if (target.$container$ === null) {
                if (!ctx.$container$) {
                    return returnValueFn();
                }
                // Grab the container now we have access to it
                target.$container$ = ctx.$container$;
            }
            else {
                assertTrue(!ctx.$container$ || ctx.$container$ === target.$container$, 'Do not use signals across containers');
            }
            const effectSubscriber = ctx.$effectSubscriber$;
            if (effectSubscriber) {
                addEffect(target, effectSubscriber, effectsFn());
            }
        }
        return returnValueFn();
    };

    /** @internal */
    const _CONST_PROPS = Symbol('CONST');
    /** @internal */
    const _VAR_PROPS = Symbol('VAR');
    /** @internal */
    const _OWNER = Symbol('OWNER');
    /** @internal @deprecated v1 compat */
    const _IMMUTABLE = Symbol('IMMUTABLE');
    /** @internal */
    const _UNINITIALIZED = Symbol('UNINITIALIZED');

    /**
     * Think of `-` as an escape character which makes the next character uppercase. `--` is just `-`.
     *
     * Rules for JSX property event names starting with `on`:
     *
     * - Are case insensitive: `onClick$` is same `onclick$`
     * - A `--` is `-`: `dbl--click` => `dbl-click`
     * - Become case sensitive if prefixed by `-`: `-Click` is `Click`
     * - A `-` (not at the beginning) makes next character uppercase: `dbl-click` => `dblClick`
     */
    const EVENT_SUFFIX = '$';
    const isHtmlAttributeAnEventName = (name) => {
        return (name.startsWith("on:" /* EventNameHtmlScope.on */) ||
            name.startsWith("on-window:" /* EventNameHtmlScope.window */) ||
            name.startsWith("on-document:" /* EventNameHtmlScope.document */));
    };
    function jsxEventToHtmlAttribute(jsxEvent) {
        if (jsxEvent.endsWith(EVENT_SUFFIX)) {
            const [prefix, idx] = getEventScopeDataFromJsxEvent(jsxEvent);
            if (idx !== -1) {
                const name = jsxEvent.slice(idx, -1);
                return name === 'DOMContentLoaded'
                    ? // The only DOM event that is not all lowercase
                        prefix + '-d-o-m-content-loaded'
                    : createEventName(name.charAt(0) === '-'
                        ? // marker for case sensitive event name
                            name.slice(1)
                        : name.toLowerCase(), prefix);
            }
        }
        return null; // Return null if not matching expected format
    }
    function createEventName(event, prefix) {
        const eventName = fromCamelToKebabCase(event);
        return prefix + eventName;
    }
    function getEventScopeDataFromJsxEvent(eventName) {
        let prefix = "on:" /* EventNameHtmlScope.on */;
        let idx = -1;
        // set prefix and idx based on the scope
        if (eventName.startsWith("on" /* EventNameJSXScope.on */)) {
            prefix = "on:" /* EventNameHtmlScope.on */;
            idx = 2;
        }
        else if (eventName.startsWith("window:on" /* EventNameJSXScope.window */)) {
            prefix = "on-window:" /* EventNameHtmlScope.window */;
            idx = 9;
        }
        else if (eventName.startsWith("document:on" /* EventNameJSXScope.document */)) {
            prefix = "on-document:" /* EventNameHtmlScope.document */;
            idx = 11;
        }
        return [prefix, idx];
    }
    function isPreventDefault(key) {
        return key.startsWith('preventdefault:');
    }
    /** Converts a camelCase string to kebab-case. This is used for event names. */
    const fromCamelToKebabCase = (text) => {
        return text.replace(/([A-Z-])/g, (a) => '-' + a.toLowerCase());
    };
    const getEventDataFromHtmlAttribute = (htmlKey) => {
        if (htmlKey.startsWith("on:" /* EventNameHtmlScope.on */)) {
            return ['', htmlKey.substring(3)];
        }
        if (htmlKey.startsWith("on-window:" /* EventNameHtmlScope.window */)) {
            return ['window', htmlKey.substring(10)];
        }
        return ['document', htmlKey.substring(12)];
    };

    /** @internal */
    const EMPTY_ARRAY = [];
    const EMPTY_OBJ = {};
    Object.freeze(EMPTY_ARRAY);
    Object.freeze(EMPTY_OBJ);

    function createPropsProxy(owner) {
        // TODO don't make a proxy but populate getters? benchmark
        return new Proxy({}, new PropsProxyHandler(owner));
    }
    class PropsProxyHandler {
        owner;
        constructor(owner) {
            this.owner = owner;
        }
        get(_, prop) {
            // escape hatch to get the separated props from a component
            if (prop === _CONST_PROPS) {
                return this.owner.constProps;
            }
            if (prop === _VAR_PROPS) {
                return this.owner.varProps;
            }
            if (prop === _OWNER) {
                return this.owner;
            }
            let value;
            if (prop === 'children') {
                value = this.owner.children;
            }
            else {
                if (typeof prop === 'string' && typeof this.owner.type === 'string') {
                    const attr = jsxEventToHtmlAttribute(prop);
                    if (attr) {
                        prop = attr;
                    }
                }
                value = directGetPropsProxyProp(this.owner, prop);
            }
            // a proxied value that the optimizer made
            return value instanceof WrappedSignalImpl && value.$flags$ & 4 /* WrappedSignalFlags.UNWRAP */
                ? value.value
                : value;
        }
        set(_, prop, value) {
            if (prop === _OWNER) {
                // used for deserialization
                this.owner = value;
            }
            else if (prop === 'children') {
                this.owner.children = value;
            }
            else {
                if (typeof prop === 'string' && typeof this.owner.type === 'string') {
                    const attr = jsxEventToHtmlAttribute(prop);
                    if (attr) {
                        prop = attr;
                    }
                }
                if (this.owner.constProps && prop in this.owner.constProps) {
                    this.owner.constProps[prop] = undefined;
                    if (!(prop in this.owner.varProps)) {
                        this.owner.toSort = true;
                    }
                    this.owner.varProps[prop] = value;
                }
                else {
                    if (this.owner.varProps === EMPTY_OBJ) {
                        this.owner.varProps = {};
                    }
                    else {
                        if (!(prop in this.owner.varProps)) {
                            this.owner.toSort = true;
                        }
                    }
                    this.owner.varProps[prop] = value;
                }
            }
            return true;
        }
        deleteProperty(_, prop) {
            let didDelete = delete this.owner.varProps[prop];
            if (this.owner.constProps) {
                didDelete = delete this.owner.constProps[prop] || didDelete;
            }
            if (this.owner.children != null && prop === 'children') {
                this.owner.children = null;
                didDelete = true;
            }
            return didDelete;
        }
        has(_, prop) {
            if (prop === 'children') {
                return this.owner.children != null;
            }
            else if (prop === _CONST_PROPS || prop === _VAR_PROPS) {
                return true;
            }
            if (typeof prop === 'string' && typeof this.owner.type === 'string') {
                const attr = jsxEventToHtmlAttribute(prop);
                if (attr) {
                    prop = attr;
                }
            }
            return (prop in this.owner.varProps || (this.owner.constProps ? prop in this.owner.constProps : false));
        }
        getOwnPropertyDescriptor(_, p) {
            const value = p === 'children'
                ? this.owner.children
                : this.owner.constProps && p in this.owner.constProps
                    ? this.owner.constProps[p]
                    : this.owner.varProps[p];
            return {
                configurable: true,
                enumerable: true,
                value: value,
            };
        }
        ownKeys() {
            const out = Object.keys(this.owner.varProps);
            if (this.owner.children != null) {
                out.push('children');
            }
            if (this.owner.constProps) {
                for (const key in this.owner.constProps) {
                    if (out.indexOf(key) === -1) {
                        out.push(key);
                    }
                }
            }
            return out;
        }
    }
    /**
     * Instead of using PropsProxyHandler getter (which could create a component-level subscription).
     * Use this function to get the props directly from a const or var props.
     *
     * This does not convert jsx event names.
     */
    const directGetPropsProxyProp = (jsx, prop) => {
        return (jsx.constProps && prop in jsx.constProps ? jsx.constProps[prop] : jsx.varProps[prop]);
    };
    /** Used by the optimizer for spread props operations @internal */
    const _getVarProps = (props) => {
        if (!props) {
            return null;
        }
        return _VAR_PROPS in props
            ? 'children' in props
                ? { ...props[_VAR_PROPS], children: props.children }
                : props[_VAR_PROPS]
            : props;
    };
    /** Used by the optimizer for spread props operations @internal */
    const _getConstProps = (props) => {
        if (!props) {
            return null;
        }
        return _CONST_PROPS in props ? props[_CONST_PROPS] : null;
    };
    const isPropsProxy = (obj) => {
        return obj && _VAR_PROPS in obj;
    };

    function getSubscriber(effect, prop, data) {
        if (!effect[_EFFECT_BACK_REF]) {
            if (build.isServer && isSsrNode(effect)) {
                effect.setProp(QBackRefs, new Map());
            }
            else {
                effect[_EFFECT_BACK_REF] = new Map();
            }
        }
        const subMap = effect[_EFFECT_BACK_REF];
        let sub = subMap.get(prop);
        if (!sub) {
            sub = [effect, prop];
            subMap.set(prop, sub);
        }
        if (data) {
            sub[3 /* EffectSubscriptionProp.DATA */] = data;
        }
        return sub;
    }
    function isSsrNode(value) {
        return '__brand__' in value && value.__brand__ === 'SsrNode';
    }

    const trackFn = (target, container) => (obj, prop) => {
        const ctx = newInvokeContext();
        ctx.$effectSubscriber$ = getSubscriber(target, ":" /* EffectProperty.COMPONENT */);
        ctx.$container$ = container || undefined;
        return invoke(ctx, () => {
            if (isFunction(obj)) {
                return obj();
            }
            if (prop) {
                return obj[prop];
            }
            else if (isSignal(obj)) {
                return obj.value;
            }
            else if (isObject(obj) && isStore(obj)) {
                // track whole store
                addStoreEffect(getStoreTarget(obj), STORE_ALL_PROPS, getStoreHandler(obj), ctx.$effectSubscriber$);
                return obj;
            }
            else {
                throw qError(2 /* QError.trackObjectWithoutProp */);
            }
        });
    };
    const cleanupFn = (target, handleError) => {
        let cleanupFns = null;
        const cleanup = (fn) => {
            if (typeof fn == 'function') {
                if (!cleanupFns) {
                    cleanupFns = [];
                    target.$destroy$ = noSerialize(() => {
                        target.$destroy$ = null;
                        cleanupFns.forEach((fn) => {
                            try {
                                fn();
                            }
                            catch (err) {
                                handleError(err);
                            }
                        });
                    });
                }
                cleanupFns.push(fn);
            }
        };
        return [cleanup, cleanupFns ?? []];
    };

    const DEBUG$1 = false;
    // eslint-disable-next-line no-console
    const log = (...args) => console.log('COMPUTED SIGNAL', ...args.map(qwikDebugToString));
    /**
     * A signal which is computed from other signals.
     *
     * The value is available synchronously, but the computation is done lazily.
     */
    class ComputedSignalImpl extends SignalImpl {
        /**
         * The compute function is stored here.
         *
         * The computed functions must be executed synchronously (because of this we need to eagerly
         * resolve the QRL during the mark dirty phase so that any call to it will be synchronous). )
         */
        $computeQrl$;
        $flags$;
        [_EFFECT_BACK_REF] = null;
        constructor(container, fn, 
        // We need a separate flag to know when the computation needs running because
        // we need the old value to know if effects need running after computation
        flags = 1 /* SignalFlags.INVALID */ |
            32 /* SerializationSignalFlags.SERIALIZATION_STRATEGY_ALWAYS */) {
            // The value is used for comparison when signals trigger, which can only happen
            // when it was calculated before. Therefore we can pass whatever we like.
            super(container, NEEDS_COMPUTATION);
            this.$computeQrl$ = fn;
            this.$flags$ = flags;
        }
        invalidate() {
            this.$flags$ |= 1 /* SignalFlags.INVALID */;
            this.$container$?.$scheduler$(7 /* ChoreType.RECOMPUTE_AND_SCHEDULE_EFFECTS */, null, this, this.$effects$);
        }
        /**
         * Use this to force running subscribers, for example when the calculated value has mutated but
         * remained the same object
         */
        force() {
            this.$flags$ |= 2 /* SignalFlags.RUN_EFFECTS */;
            super.force();
        }
        get untrackedValue() {
            this.$computeIfNeeded$();
            assertFalse(this.$untrackedValue$ === NEEDS_COMPUTATION, 'Invalid state');
            return this.$untrackedValue$;
        }
        $computeIfNeeded$() {
            if (!(this.$flags$ & 1 /* SignalFlags.INVALID */)) {
                return;
            }
            const computeQrl = this.$computeQrl$;
            throwIfQRLNotResolved(computeQrl);
            const ctx = tryGetInvokeContext();
            const previousEffectSubscription = ctx?.$effectSubscriber$;
            ctx && (ctx.$effectSubscriber$ = getSubscriber(this, "." /* EffectProperty.VNODE */));
            try {
                const untrackedValue = computeQrl.getFn(ctx)();
                if (isPromise(untrackedValue)) {
                    throw qError(29 /* QError.computedNotSync */, [
                        computeQrl.dev ? computeQrl.dev.file : '',
                        computeQrl.$hash$,
                    ]);
                }
                DEBUG$1 && log('Signal.$compute$', untrackedValue);
                this.$flags$ &= ~1 /* SignalFlags.INVALID */;
                const didChange = untrackedValue !== this.$untrackedValue$;
                if (didChange) {
                    // skip first computation when value is not changed
                    if (this.$untrackedValue$ !== NEEDS_COMPUTATION) {
                        this.$flags$ |= 2 /* SignalFlags.RUN_EFFECTS */;
                    }
                    this.$untrackedValue$ = untrackedValue;
                }
            }
            finally {
                if (ctx) {
                    ctx.$effectSubscriber$ = previousEffectSubscription;
                }
            }
        }
        // Make this signal read-only
        set value(_) {
            throw qError(30 /* QError.computedReadOnly */);
        }
        // Getters don't get inherited when overriding a setter
        get value() {
            return super.value;
        }
    }

    /**
     * # ================================
     *
     * AsyncComputedSignalImpl
     *
     * # ================================
     */
    class AsyncComputedSignalImpl extends ComputedSignalImpl {
        $untrackedLoading$ = false;
        $untrackedError$ = null;
        $loadingEffects$ = null;
        $errorEffects$ = null;
        $destroy$;
        $promiseValue$ = NEEDS_COMPUTATION;
        [_EFFECT_BACK_REF] = null;
        constructor(container, fn, flags = 1 /* SignalFlags.INVALID */) {
            super(container, fn, flags);
        }
        /**
         * Loading is true if the signal is still waiting for the promise to resolve, false if the promise
         * has resolved or rejected.
         */
        get loading() {
            return setupSignalValueAccess(this, () => (this.$loadingEffects$ ||= new Set()), () => this.untrackedLoading);
        }
        set untrackedLoading(value) {
            if (value !== this.$untrackedLoading$) {
                this.$untrackedLoading$ = value;
                this.$container$?.$scheduler$(7 /* ChoreType.RECOMPUTE_AND_SCHEDULE_EFFECTS */, null, this, this.$loadingEffects$);
            }
        }
        get untrackedLoading() {
            return this.$untrackedLoading$;
        }
        /** The error that occurred when the signal was resolved. */
        get error() {
            return setupSignalValueAccess(this, () => (this.$errorEffects$ ||= new Set()), () => this.untrackedError);
        }
        set untrackedError(value) {
            if (value !== this.$untrackedError$) {
                this.$untrackedError$ = value;
                this.$container$?.$scheduler$(7 /* ChoreType.RECOMPUTE_AND_SCHEDULE_EFFECTS */, null, this, this.$errorEffects$);
            }
        }
        get untrackedError() {
            return this.$untrackedError$;
        }
        invalidate() {
            super.invalidate();
            this.$promiseValue$ = NEEDS_COMPUTATION;
        }
        async resolve() {
            await retryOnPromise(() => this.$computeIfNeeded$());
            return this.$untrackedValue$;
        }
        $computeIfNeeded$() {
            if (!(this.$flags$ & 1 /* SignalFlags.INVALID */)) {
                return;
            }
            const [cleanup] = cleanupFn(this, (err) => this.$container$?.handleError(err, null));
            const untrackedValue = this.$promiseValue$ === NEEDS_COMPUTATION
                ? this.$computeQrl$.getFn()({
                    track: trackFn(this, this.$container$),
                    cleanup,
                })
                : this.$promiseValue$;
            if (isPromise(untrackedValue)) {
                this.untrackedLoading = true;
                this.untrackedError = null;
                throw untrackedValue
                    .then((promiseValue) => {
                    this.$promiseValue$ = promiseValue;
                    this.untrackedLoading = false;
                    this.untrackedError = null;
                })
                    .catch((err) => {
                    this.$promiseValue$ = err;
                    this.untrackedLoading = false;
                    this.untrackedError = err;
                });
            }
            this.$promiseValue$ = NEEDS_COMPUTATION;
            this.$flags$ &= -2 /* SignalFlags.INVALID */;
            const didChange = untrackedValue !== this.$untrackedValue$;
            if (didChange) {
                this.$flags$ |= 2 /* SignalFlags.RUN_EFFECTS */;
                this.$untrackedValue$ = untrackedValue;
            }
            return didChange;
        }
    }

    // <docs markdown="../../readme.md#implicit$FirstArg">
    // !!DO NOT EDIT THIS COMMENT DIRECTLY!!!
    // (edit ../../readme.md#implicit$FirstArg instead and run `pnpm docs.sync`)
    /**
     * Create a `____$(...)` convenience method from `___(...)`.
     *
     * It is very common for functions to take a lazy-loadable resource as a first argument. For this
     * reason, the Qwik Optimizer automatically extracts the first argument from any function which ends
     * in `$`.
     *
     * This means that `foo$(arg0)` and `foo($(arg0))` are equivalent with respect to Qwik Optimizer.
     * The former is just a shorthand for the latter.
     *
     * For example, these function calls are equivalent:
     *
     * - `component$(() => {...})` is same as `component($(() => {...}))`
     *
     * ```tsx
     * export function myApi(callback: QRL<() => void>): void {
     *   // ...
     * }
     *
     * export const myApi$ = implicit$FirstArg(myApi);
     * // type of myApi$: (callback: () => void): void
     *
     * // can be used as:
     * myApi$(() => console.log('callback'));
     *
     * // will be transpiled to:
     * // FILE: <current file>
     * myApi(qrl('./chunk-abc.js', 'callback'));
     *
     * // FILE: chunk-abc.js
     * export const callback = () => console.log('callback');
     * ```
     *
     * @param fn - A function that should have its first argument automatically `$`.
     * @public
     */
    // </docs>
    const implicit$FirstArg = (fn) => {
        return function (first, ...rest) {
            return fn.call(null, dollar(first), ...rest);
        };
    };

    /**
     * A signal which provides a non-serializable value. It works like a computed signal, but it is
     * handled slightly differently during serdes.
     *
     * @public
     */
    class SerializerSignalImpl extends ComputedSignalImpl {
        constructor(container, argQrl) {
            super(container, argQrl, 1 /* SignalFlags.INVALID */ | 32 /* SerializationSignalFlags.SERIALIZATION_STRATEGY_ALWAYS */);
        }
        $didInitialize$ = false;
        $computeIfNeeded$() {
            if (!(this.$flags$ & 1 /* SignalFlags.INVALID */)) {
                return;
            }
            throwIfQRLNotResolved(this.$computeQrl$);
            let arg = this.$computeQrl$.resolved;
            if (typeof arg === 'function') {
                arg = arg();
            }
            const { deserialize, initial } = arg;
            const update = arg.update;
            const currentValue = this.$untrackedValue$ === NEEDS_COMPUTATION ? initial : this.$untrackedValue$;
            const untrackedValue = trackSignal(() => this.$didInitialize$
                ? update?.(currentValue) || currentValue
                : deserialize(currentValue), this, "." /* EffectProperty.VNODE */, this.$container$);
            const didChange = (this.$didInitialize$ && untrackedValue !== 'undefined') ||
                untrackedValue !== this.$untrackedValue$;
            this.$flags$ &= -2 /* SignalFlags.INVALID */;
            this.$didInitialize$ = true;
            if (didChange) {
                this.$flags$ |= 2 /* SignalFlags.RUN_EFFECTS */;
                this.$untrackedValue$ = untrackedValue;
            }
        }
    }

    /** @internal */
    const createSignal$1 = (value) => {
        return new SignalImpl(null, value);
    };
    /** @internal */
    const createComputedSignal = (qrl, options) => {
        return new ComputedSignalImpl(options?.container || null, qrl, getComputedSignalFlags(options?.serializationStrategy || 'always'));
    };
    /** @internal */
    const createAsyncComputedSignal = (qrl, options) => {
        return new AsyncComputedSignalImpl(options?.container || null, qrl, getComputedSignalFlags(options?.serializationStrategy || 'never'));
    };
    /** @internal */
    const createSerializerSignal = (arg) => {
        return new SerializerSignalImpl(null, arg);
    };

    /**
     * Creates a Signal with the given value. If no value is given, the signal is created with
     * `undefined`.
     *
     * @public
     */
    const createSignal = createSignal$1;
    /**
     * Create a computed signal which is calculated from the given QRL. A computed signal is a signal
     * which is calculated from other signals. When the signals change, the computed signal is
     * recalculated.
     *
     * The QRL must be a function which returns the value of the signal. The function must not have side
     * effects, and it must be synchronous.
     *
     * If you need the function to be async, use `useAsyncComputed$` instead.
     *
     * @public
     */
    const createComputed$ = /*#__PURE__*/ implicit$FirstArg(createComputedSignal);
    /**
     * Create an async computed signal which is calculated from the given QRL. A computed signal is a
     * signal which is calculated from other signals or async operation. When the signals change, the
     * computed signal is recalculated.
     *
     * The QRL must be a function which returns the value of the signal. The function must not have side
     * effects, and it can be async.
     *
     * @public
     */
    const createAsyncComputed$ = /*#__PURE__*/ implicit$FirstArg(createAsyncComputedSignal);
    /**
     * Create a signal that holds a custom serializable value. See {@link useSerializer$} for more
     * details.
     *
     * @public
     */
    const createSerializer$ = implicit$FirstArg(createSerializerSignal);

    // Keep these properties named like this so they're the same as from wrapSignal
    const getValueProp = (p0) => p0.value;
    const getProp = (p0, p1) => p0[p1];
    const getWrapped = (args) => {
        if (args.length === 1) {
            if (isSignal(args[0])) {
                return (args[0].$wrappedSignal$ ||= new WrappedSignalImpl(null, getValueProp, args, null));
            }
            else if (isStore(args[0])) {
                return new WrappedSignalImpl(null, getValueProp, args, null);
            }
            return args[0].value;
        }
        else {
            return new WrappedSignalImpl(null, getProp, args, null);
        }
    };
    /**
     * This wraps a property access of a possible Signal/Store into a WrappedSignal. The optimizer does
     * this automatically when a prop is only used as a prop on JSX.
     *
     * When a WrappedSignal is read via the PropsProxy, it will be unwrapped. This allows forwarding the
     * reactivity of a prop to the point of actual use.
     *
     * For efficiency, if you pass only one argument, the property is 'value'.
     *
     * @internal
     */
    const _wrapProp = (...args) => {
        const obj = args[0];
        const prop = args.length < 2 ? 'value' : args[1];
        if (!isObject(obj)) {
            return obj[prop];
        }
        if (isSignal(obj)) {
            if (!(obj instanceof AsyncComputedSignalImpl)) {
                assertEqual(prop, 'value', 'Left side is a signal, prop must be value');
            }
            if (obj instanceof WrappedSignalImpl && obj.$flags$ & 4 /* WrappedSignalFlags.UNWRAP */) {
                return obj;
            }
            return getWrapped(args);
        }
        if (isPropsProxy(obj)) {
            const constProps = obj[_CONST_PROPS];
            if (constProps && prop in constProps) {
                // Const props don't need wrapping
                return constProps[prop];
            }
        }
        else {
            const target = getStoreTarget(obj);
            if (target) {
                const value = target[prop];
                const wrappedValue = isSignal(value)
                    ? // If the value is already a signal, we don't need to wrap it again
                        value
                    : getWrapped(args);
                return wrappedValue;
            }
        }
        // the object is not reactive, so we can just return the value
        return obj[prop];
    };
    /** @internal @deprecated v1 compat */
    const _wrapSignal = (obj, prop) => {
        const r = _wrapProp(obj, prop);
        if (r === _IMMUTABLE) {
            return obj[prop];
        }
        return r;
    };

    class WrappedSignalImpl extends SignalImpl {
        $args$;
        $func$;
        $funcStr$;
        $flags$;
        $hostElement$ = null;
        [_EFFECT_BACK_REF] = null;
        constructor(container, fn, args, fnStr, 
        // We need a separate flag to know when the computation needs running because
        // we need the old value to know if effects need running after computation
        flags = 1 /* SignalFlags.INVALID */ | 4 /* WrappedSignalFlags.UNWRAP */) {
            super(container, NEEDS_COMPUTATION);
            this.$args$ = args;
            this.$func$ = fn;
            this.$funcStr$ = fnStr;
            this.$flags$ = flags;
        }
        invalidate() {
            this.$flags$ |= 1 /* SignalFlags.INVALID */;
            // we are trying to run computation without creating a chore, which can be expensive
            // for many signals. If it fails, we schedule a chore to run the computation.
            try {
                this.$computeIfNeeded$();
            }
            catch (_) {
                this.$container$?.$scheduler$(7 /* ChoreType.RECOMPUTE_AND_SCHEDULE_EFFECTS */, this.$hostElement$, this, this.$effects$);
            }
            // if the computation not failed, we can run the effects directly
            if (this.$flags$ & 2 /* SignalFlags.RUN_EFFECTS */) {
                this.$flags$ &= -3 /* SignalFlags.RUN_EFFECTS */;
                scheduleEffects(this.$container$, this, this.$effects$);
            }
        }
        /**
         * Use this to force running subscribers, for example when the calculated value has mutated but
         * remained the same object.
         */
        force() {
            this.$flags$ |= 2 /* SignalFlags.RUN_EFFECTS */;
            this.$container$?.$scheduler$(7 /* ChoreType.RECOMPUTE_AND_SCHEDULE_EFFECTS */, this.$hostElement$, this, this.$effects$);
        }
        get untrackedValue() {
            this.$computeIfNeeded$();
            assertFalse(this.$untrackedValue$ === NEEDS_COMPUTATION, 'Invalid state');
            return this.$untrackedValue$;
        }
        $computeIfNeeded$() {
            if (!(this.$flags$ & 1 /* SignalFlags.INVALID */)) {
                return;
            }
            const untrackedValue = trackSignal(() => this.$func$(...this.$args$), this, "." /* EffectProperty.VNODE */, this.$container$);
            // TODO: we should remove invalid flag here, but some tests are failing
            // Sometimes we may call .value on wrapped signals without ctx. This means subscription will be
            // not created and effects will not be triggered. After wrapping this with if (this.$container$)
            // less tests are failing, but still some are failing.
            // this.$flags$ &= ~SignalFlags.INVALID;
            // reset flag in case we call computedIfNeeded twice and the value was changed only the first time
            // TODO: change to version number?
            this.$flags$ &= -3 /* SignalFlags.RUN_EFFECTS */;
            const didChange = untrackedValue !== this.$untrackedValue$;
            if (didChange) {
                this.$flags$ |= 2 /* SignalFlags.RUN_EFFECTS */;
                this.$untrackedValue$ = untrackedValue;
            }
        }
        $unwrapIfSignal$() {
            return this.$func$ === getValueProp && isSignal(this.$args$[0])
                ? this.$args$[0]
                : this;
        }
        // Make this signal read-only
        set value(_) {
            throw qError(31 /* QError.wrappedReadOnly */);
        }
        // Getters don't get inherited when overriding a setter
        get value() {
            return super.value;
        }
    }

    /** Class for back reference to the EffectSubscription */
    let BackRef$1 = class BackRef {
        [_EFFECT_BACK_REF] = null;
    };
    function clearAllEffects(container, consumer) {
        if (vnode_isVNode(consumer) && vnode_isElementVNode(consumer)) {
            ensureMaterialized(consumer);
        }
        const effects = consumer[_EFFECT_BACK_REF];
        if (!effects) {
            return;
        }
        for (const [, effect] of effects) {
            clearEffectSubscription(container, effect);
        }
    }
    function clearEffectSubscription(container, effect) {
        const backRefs = effect[2 /* EffectSubscriptionProp.BACK_REF */];
        if (!backRefs) {
            return;
        }
        for (const producer of backRefs) {
            if (producer instanceof SignalImpl) {
                clearSignal(container, producer, effect);
            }
            else if (producer instanceof AsyncComputedSignalImpl) {
                clearAsyncComputedSignal(producer, effect);
            }
            else if (container.$storeProxyMap$.has(producer)) {
                const target = container.$storeProxyMap$.get(producer);
                const storeHandler = getStoreHandler(target);
                clearStore(storeHandler, effect);
            }
        }
    }
    function clearSignal(container, producer, effect) {
        const effects = producer.$effects$;
        if (effects && effects.has(effect)) {
            effects.delete(effect);
        }
        if (producer instanceof WrappedSignalImpl) {
            producer.$hostElement$ = null;
            clearAllEffects(container, producer);
        }
    }
    function clearAsyncComputedSignal(producer, effect) {
        const effects = producer.$effects$;
        if (effects && effects.has(effect)) {
            effects.delete(effect);
        }
        const pendingEffects = producer.$loadingEffects$;
        if (pendingEffects && pendingEffects.has(effect)) {
            pendingEffects.delete(effect);
        }
    }
    function clearStore(producer, effect) {
        const effects = producer?.$effects$;
        if (effects) {
            for (const propEffects of effects.values()) {
                if (propEffects.has(effect)) {
                    propEffects.delete(effect);
                }
            }
        }
    }

    /** @internal */
    class VNode extends BackRef$1 {
        flags;
        parent;
        previousSibling;
        nextSibling;
        props = null;
        slotParent = null;
        // scheduled chores for this vnode
        chores = null;
        // blocked chores for this vnode
        blockedChores = null;
        constructor(flags, parent, previousSibling, nextSibling) {
            super();
            this.flags = flags;
            this.parent = parent;
            this.previousSibling = previousSibling;
            this.nextSibling = nextSibling;
        }
        getProp(key, getObject) {
            const type = this.flags;
            if ((type & 3 /* VNodeFlags.ELEMENT_OR_VIRTUAL_MASK */) !== 0) {
                type & 1 /* VNodeFlags.Element */ && vnode_ensureElementInflated(this);
                this.props ||= [];
                const idx = mapApp_findIndx(this.props, key, 0);
                if (idx >= 0) {
                    let value = this.props[idx + 1];
                    if (typeof value === 'string' && getObject) {
                        this.props[idx + 1] = value = getObject(value);
                    }
                    return value;
                }
            }
            return null;
        }
        setProp(key, value) {
            this.props ||= [];
            const idx = mapApp_findIndx(this.props, key, 0);
            if (idx >= 0) {
                this.props[idx + 1] = value;
            }
            else if (value != null) {
                this.props.splice(idx ^ -1, 0, key, value);
            }
        }
        getAttr(key) {
            if ((this.flags & 3 /* VNodeFlags.ELEMENT_OR_VIRTUAL_MASK */) !== 0) {
                vnode_ensureElementInflated(this);
                this.props ||= [];
                return mapArray_get(this.props, key, 0);
            }
            return null;
        }
        setAttr(key, value, journal) {
            const type = this.flags;
            if ((type & 3 /* VNodeFlags.ELEMENT_OR_VIRTUAL_MASK */) !== 0) {
                vnode_ensureElementInflated(this);
                this.props ||= [];
                const idx = mapApp_findIndx(this.props, key, 0);
                if (idx >= 0) {
                    if (this.props[idx + 1] != value && this instanceof ElementVNode) {
                        // Values are different, update DOM
                        journal && journal.push(2 /* VNodeJournalOpCode.SetAttribute */, this.element, key, value);
                    }
                    if (value == null) {
                        this.props.splice(idx, 2);
                    }
                    else {
                        this.props[idx + 1] = value;
                    }
                }
                else if (value != null) {
                    this.props.splice(idx ^ -1, 0, key, value);
                    if (this instanceof ElementVNode) {
                        // New value, update DOM
                        journal && journal.push(2 /* VNodeJournalOpCode.SetAttribute */, this.element, key, value);
                    }
                }
            }
        }
        toString() {
            if (build.isDev) {
                return vnode_toString.call(this);
            }
            return String(this);
        }
    }
    /** @internal */
    class TextVNode extends VNode {
        textNode;
        text;
        constructor(flags, parent, previousSibling, nextSibling, textNode, text) {
            super(flags, parent, previousSibling, nextSibling);
            this.textNode = textNode;
            this.text = text;
        }
    }
    /** @internal */
    class VirtualVNode extends VNode {
        firstChild;
        lastChild;
        constructor(flags, parent, previousSibling, nextSibling, firstChild, lastChild) {
            super(flags, parent, previousSibling, nextSibling);
            this.firstChild = firstChild;
            this.lastChild = lastChild;
        }
    }
    /** @internal */
    class ElementVNode extends VNode {
        firstChild;
        lastChild;
        element;
        elementName;
        constructor(flags, parent, previousSibling, nextSibling, firstChild, lastChild, element, elementName) {
            super(flags, parent, previousSibling, nextSibling);
            this.firstChild = firstChild;
            this.lastChild = lastChild;
            this.element = element;
            this.elementName = elementName;
        }
    }

    /**
     * @file
     *
     *   VNode is a DOM like API for walking the DOM but it:
     *
     *   1. Encodes virtual nodes which don't exist in the DOM
     *   2. Can serialize as part of SSR and than deserialize on the client.
     *
     *   # Virtual
     *
     *   You can think of a Virtual node just like an additional `<div>` in that it groups related child
     *   nodes together. But unlike a `<div>` which has a real DOM node and hence implications for CSS,
     *   Virtual nodes have no DOM impact, they are invisible.
     *
     *   # Portal
     *
     *   Two Virtual nodes can be linked together to form a Portal. Portals are useful for projecting
     *   content or just rendering content in a different location in the tree, while maintaining a
     *   logical relationship.
     *
     *   Portals have:
     *
     *   - Portal Source: A Virtual node which can refer to one ore more Destination Portals by name.
     *   - Destination Portal: A Virtual node which acts as a destination but also has a pointer back to the
     *       Portal Source
     *
     *   ## Example:
     *
     *   Given this code:
     *
     *   ```typescript
     *   const Parent = component$(() => {
     *     return (
     *       <Child>
     *         Projection Content
     *         <span q:slot="secondary">Secondary Content</span>
     *         <span q:slot="other">Other Content</span>
     *       </Child>
     *     };
     *   });
     *
     *   const Child = component$(() => {
     *     return (
     *       <div>
     *         <Slot>Default Primary</Slot>
     *         <Slot name="secondary">Default Secondary</Slot>
     *       </div>
     *     );
     *   });
     *
     *   render(<body><main><Parent/></main><body>);
     * ```
     *
     *   Will render like so:
     *
     *   ```html
     *   <body>
     *     <main>
     *       <Virtual Parent q:portal=":3A;secondary:3B;other:5A" q:id="2A">
     *         <Virtual Child>
     *           <div>
     *             <Virtual Slot q:id="3A" q:portal="^:2A;:3A"> Projection Content </Virtual>
     *             <Virtual Slot q:id="3B" q:portal="^:2A;:3B">
     *               <span q:slot="secondary">Secondary Content</span>
     *             </Virtual>
     *           </div>
     *         </Virtual>
     *       </Virtual>
     *     </main>
     *     <q:template>
     *       <Virtual q:portal="^:2A" q:id="5A">
     *         <span q:slot="other">Other Content</span>
     *       </Virtual>
     *       <Virtual q:portal="^:2A" q:id="3A">
     *         Default Primary
     *       </Virtual>
     *       <Virtual q:portal="^:2A" q:id="3B">
     *         Default Secondary
     *       </Virtual>
     *     <q:template>
     *   </body>
     * ```
     *
     *   Explanation:
     *
     *   - `q:portal=":3A;secondary:3B;other:5A"`
     *
     *       - Name: ``; Ref: `3A` - Where the default content went.
     *       - Name: `secondary`; Ref: `3B` - Where the 'secondary' content went.
     *       - Name: `other`; Ref: `%A` - Where the `other` content went. (Notice in this case the content is
     *               left over and os it ends up en the `q:templates`. We can share one '<q:template>`
     *               for all left over content.)
     *   - `q:portal="^:2A;:3A"`
     *
     *       - Name: `^`; Ref: `2A` - Special pointer to the parent portal
     *       - Name: ``; Ref: `3A` - Location of the default content in case there is nothing projected here.
     *
     *   ## Rendering
     *
     *   During SSR, the rendered can delay rendering the JSX nodes until correct portal comes up. The ID
     *   system is already can make lazy references to the Nodes.
     *
     *   Client side rendering does not need to deal with IDs or `<q:template>` as un-rendered vNodes do
     *   not need to be serialized into DOM, and can remain on heap.
     *
     *   ## Context
     *
     *   When looking up context it is possible to follow you real render parents or follow the portals.
     *   All information is encoded in the portals.
     *
     *   ## Slot Projection
     *
     *   The ultimate user of portals is Slot projection. But the vNode do not understand slots, rather
     *   they understand portal primitives which makes Slot implementation much simpler.
     *
     *   NOTE: The portals need to have IDs during serialization only. Once runtime takes over, there is
     *   no need to have IDs or to write overflow to the `<q:template>`
     */
    //////////////////////////////////////////////////////////////////////////////////////////////////////
    const vnode_newElement = (element, elementName) => {
        assertEqual(fastNodeType(element), 1 /* ELEMENT_NODE */, 'Expecting element node.');
        const vnode = new ElementVNode(1 /* VNodeFlags.Element */ | 8 /* VNodeFlags.Inflated */ | (-1 << 8 /* VNodeFlagsIndex.shift */), // Flag
        null, null, null, null, null, element, elementName);
        assertTrue(vnode_isElementVNode(vnode), 'Incorrect format of ElementVNode.');
        assertFalse(vnode_isTextVNode(vnode), 'Incorrect format of ElementVNode.');
        assertFalse(vnode_isVirtualVNode(vnode), 'Incorrect format of ElementVNode.');
        element.vNode = vnode;
        return vnode;
    };
    const vnode_newUnMaterializedElement = (element) => {
        assertEqual(fastNodeType(element), 1 /* ELEMENT_NODE */, 'Expecting element node.');
        const vnode = new ElementVNode(1 /* VNodeFlags.Element */ | (-1 << 8 /* VNodeFlagsIndex.shift */), // Flag
        null, null, null, undefined, undefined, element, undefined);
        assertTrue(vnode_isElementVNode(vnode), 'Incorrect format of ElementVNode.');
        assertFalse(vnode_isTextVNode(vnode), 'Incorrect format of ElementVNode.');
        assertFalse(vnode_isVirtualVNode(vnode), 'Incorrect format of ElementVNode.');
        element.vNode = vnode;
        return vnode;
    };
    const vnode_newSharedText = (previousTextNode, sharedTextNode, textContent) => {
        sharedTextNode &&
            assertEqual(fastNodeType(sharedTextNode), 3 /* TEXT_NODE */, 'Expecting element node.');
        const vnode = new TextVNode(4 /* VNodeFlags.Text */ | (-1 << 8 /* VNodeFlagsIndex.shift */), // Flag
        null, // Parent
        previousTextNode, // Previous TextNode (usually first child)
        null, // Next sibling
        sharedTextNode, // SharedTextNode
        textContent // Text Content
        );
        assertFalse(vnode_isElementVNode(vnode), 'Incorrect format of TextVNode.');
        assertTrue(vnode_isTextVNode(vnode), 'Incorrect format of TextVNode.');
        assertFalse(vnode_isVirtualVNode(vnode), 'Incorrect format of TextVNode.');
        return vnode;
    };
    const vnode_newText = (textNode, textContent) => {
        const vnode = new TextVNode(4 /* VNodeFlags.Text */ | 8 /* VNodeFlags.Inflated */ | (-1 << 8 /* VNodeFlagsIndex.shift */), // Flags
        null, // Parent
        null, // No previous sibling
        null, // We may have a next sibling.
        textNode, // TextNode
        textContent // Text Content
        );
        assertEqual(fastNodeType(textNode), 3 /* TEXT_NODE */, 'Expecting element node.');
        assertFalse(vnode_isElementVNode(vnode), 'Incorrect format of TextVNode.');
        assertTrue(vnode_isTextVNode(vnode), 'Incorrect format of TextVNode.');
        assertFalse(vnode_isVirtualVNode(vnode), 'Incorrect format of TextVNode.');
        return vnode;
    };
    const vnode_newVirtual = () => {
        const vnode = new VirtualVNode(2 /* VNodeFlags.Virtual */ | (-1 << 8 /* VNodeFlagsIndex.shift */), // Flags
        null, null, null, null, null);
        assertFalse(vnode_isElementVNode(vnode), 'Incorrect format of TextVNode.');
        assertFalse(vnode_isTextVNode(vnode), 'Incorrect format of TextVNode.');
        assertTrue(vnode_isVirtualVNode(vnode), 'Incorrect format of TextVNode.');
        return vnode;
    };
    //////////////////////////////////////////////////////////////////////////////////////////////////////
    const vnode_isVNode = (vNode) => {
        return vNode instanceof VNode;
    };
    const vnode_isElementVNode = (vNode) => {
        assertDefined(vNode, 'Missing vNode');
        const flag = vNode.flags;
        return (flag & 1 /* VNodeFlags.Element */) === 1 /* VNodeFlags.Element */;
    };
    const vnode_isElementOrTextVNode = (vNode) => {
        assertDefined(vNode, 'Missing vNode');
        const flag = vNode.flags;
        return (flag & 5 /* VNodeFlags.ELEMENT_OR_TEXT_MASK */) !== 0;
    };
    /** @internal */
    const vnode_isMaterialized = (vNode) => {
        assertDefined(vNode, 'Missing vNode');
        const flag = vNode.flags;
        return ((flag & 1 /* VNodeFlags.Element */) === 1 /* VNodeFlags.Element */ &&
            vNode.firstChild !== undefined &&
            vNode.lastChild !== undefined);
    };
    /** @internal */
    const vnode_isTextVNode = (vNode) => {
        assertDefined(vNode, 'Missing vNode');
        const flag = vNode.flags;
        return (flag & 4 /* VNodeFlags.Text */) === 4 /* VNodeFlags.Text */;
    };
    /** @internal */
    const vnode_isVirtualVNode = (vNode) => {
        assertDefined(vNode, 'Missing vNode');
        const flag = vNode.flags;
        return (flag & 2 /* VNodeFlags.Virtual */) === 2 /* VNodeFlags.Virtual */;
    };
    const vnode_isProjection = (vNode) => {
        assertDefined(vNode, 'Missing vNode');
        const flag = vNode.flags;
        return (flag & 2 /* VNodeFlags.Virtual */) === 2 /* VNodeFlags.Virtual */ && vNode.getProp(QSlot, null) !== null;
    };
    const ensureTextVNode = (vNode) => {
        assertTrue(vnode_isTextVNode(vNode), 'Expecting TextVNode was: ' + vnode_getNodeTypeName(vNode));
        return vNode;
    };
    const ensureElementOrVirtualVNode = (vNode) => {
        assertDefined(vNode, 'Missing vNode');
        assertTrue((vNode.flags & 3 /* VNodeFlags.ELEMENT_OR_VIRTUAL_MASK */) !== 0, 'Expecting ElementVNode or VirtualVNode was: ' + vnode_getNodeTypeName(vNode));
    };
    const ensureElementVNode = (vNode) => {
        assertTrue(vnode_isElementVNode(vNode), 'Expecting ElementVNode was: ' + vnode_getNodeTypeName(vNode));
        return vNode;
    };
    const vnode_getNodeTypeName = (vNode) => {
        if (vNode) {
            const flags = vNode.flags;
            switch (flags & 7 /* VNodeFlags.TYPE_MASK */) {
                case 1 /* VNodeFlags.Element */:
                    return 'Element';
                case 2 /* VNodeFlags.Virtual */:
                    return 'Virtual';
                case 4 /* VNodeFlags.Text */:
                    return 'Text';
            }
        }
        return '<unknown>';
    };
    /** @internal */
    const vnode_ensureElementInflated = (vnode) => {
        const flags = vnode.flags;
        if ((flags & 15 /* VNodeFlags.INFLATED_TYPE_MASK */) === 1 /* VNodeFlags.Element */) {
            const elementVNode = vnode;
            elementVNode.flags ^= 8 /* VNodeFlags.Inflated */;
            const element = elementVNode.element;
            const attributes = element.attributes;
            for (let idx = 0; idx < attributes.length; idx++) {
                const attr = attributes[idx];
                const key = attr.name;
                if (key === Q_PROPS_SEPARATOR || !key) {
                    // SVG in Domino does not support ':' so it becomes an empty string.
                    // all attributes after the ':' are considered immutable, and so we ignore them.
                    break;
                }
                else if (key.startsWith(QContainerAttr)) {
                    const props = vnode_getProps(elementVNode);
                    if (attr.value === "html" /* QContainerValue.HTML */) {
                        mapArray_set(props, dangerouslySetInnerHTML, element.innerHTML, 0);
                    }
                    else if (attr.value === "text" /* QContainerValue.TEXT */ && 'value' in element) {
                        mapArray_set(props, 'value', element.value, 0);
                    }
                }
                else if (!key.startsWith("on:" /* EventNameHtmlScope.on */)) {
                    const value = attr.value;
                    const props = vnode_getProps(elementVNode);
                    mapArray_set(props, key, value, 0);
                }
            }
        }
    };
    /** Walks the VNode tree and materialize it using `vnode_getFirstChild`. */
    function vnode_walkVNode(vNode, callback) {
        let vCursor = vNode;
        // Depth first traversal
        if (vnode_isTextVNode(vNode)) {
            // Text nodes don't have subscriptions or children;
            return;
        }
        let vParent = null;
        do {
            if (callback?.(vCursor, vParent)) {
                return;
            }
            const vFirstChild = vnode_getFirstChild(vCursor);
            if (vFirstChild) {
                vCursor = vFirstChild;
                continue;
            }
            // Out of children
            if (vCursor === vNode) {
                // we are where we started, this means that vNode has no children, so we are done.
                return;
            }
            // Out of children, go to next sibling
            const vNextSibling = vCursor.nextSibling;
            if (vNextSibling) {
                vCursor = vNextSibling;
                continue;
            }
            // Out of siblings, go to parent
            vParent = vCursor.parent;
            while (vParent) {
                if (vParent === vNode) {
                    // We are back where we started, we are done.
                    return;
                }
                const vNextParentSibling = vParent.nextSibling;
                if (vNextParentSibling) {
                    vCursor = vNextParentSibling;
                    break;
                }
                vParent = vParent.parent;
            }
            if (vParent == null) {
                // We are done.
                return;
            }
        } while (true);
    }
    function vnode_getDOMChildNodes(journal, root, isVNode = false, childNodes = []) {
        if (vnode_isElementOrTextVNode(root)) {
            if (vnode_isTextVNode(root)) {
                /**
                 * If we are collecting text nodes, we need to ensure that they are inflated. If not inflated
                 * we would return a single text node which represents many actual text nodes, or removing a
                 * single text node would remove many text nodes.
                 */
                vnode_ensureTextInflated(journal, root);
            }
            childNodes.push(isVNode ? root : vnode_getNode(root));
            return childNodes;
        }
        let vNode = vnode_getFirstChild(root);
        while (vNode) {
            if (vnode_isElementVNode(vNode)) {
                childNodes.push(isVNode ? vNode : vnode_getNode(vNode));
            }
            else if (vnode_isTextVNode(vNode)) {
                /**
                 * If we are collecting text nodes, we need to ensure that they are inflated. If not inflated
                 * we would return a single text node which represents many actual text nodes, or removing a
                 * single text node would remove many text nodes.
                 */
                vnode_ensureTextInflated(journal, vNode);
                childNodes.push(isVNode ? vNode : vnode_getNode(vNode));
            }
            else {
                isVNode
                    ? vnode_getDOMChildNodes(journal, vNode, true, childNodes)
                    : vnode_getDOMChildNodes(journal, vNode, false, childNodes);
            }
            vNode = vNode.nextSibling;
        }
        return childNodes;
    }
    /**
     * Returns the previous/next sibling but from the point of view of the DOM.
     *
     * Given:
     *
     * ```
     * <div>
     *   <>a</>
     *   <>
     *     <></>
     *     <>b</>
     *     <></>
     *   </>
     *   <>c</>
     * </div>
     * ```
     *
     * Then:
     *
     * - Next: if we start at `a` the next DOM sibling is `b`, than `c`.
     * - Previous: if we start at `c` the next DOM sibling is `b`, than `a`.
     *
     * @param vNode - Starting node
     * @param nextDirection - Direction to search true=next, false=previous
     * @param descend - If true, than we will descend into the children first.
     * @returns
     */
    const vnode_getDomSibling = (vNode, nextDirection, descend) => {
        const childProp = nextDirection ? 'firstChild' : 'lastChild';
        const siblingProp = nextDirection ? 'nextSibling' : 'previousSibling';
        let cursor = vNode;
        // first make sure we have a DOM node or no children.
        while (descend && cursor && vnode_isVirtualVNode(cursor)) {
            const child = cursor[childProp];
            if (!child) {
                break;
            }
            if (child.flags & 5 /* VNodeFlags.ELEMENT_OR_TEXT_MASK */) {
                return child;
            }
            cursor = child;
        }
        while (cursor) {
            // Look at the previous/next sibling.
            let sibling = cursor[siblingProp];
            if (sibling && sibling.flags & 5 /* VNodeFlags.ELEMENT_OR_TEXT_MASK */) {
                // we found a previous/next DOM node, return it.
                return sibling;
            }
            else if (!sibling) {
                // If we don't have a sibling than walk up the tree until you find one.
                let virtual = cursor.parent;
                if (virtual && !vnode_isVirtualVNode(virtual)) {
                    return null;
                }
                while (virtual && !(sibling = virtual[siblingProp])) {
                    virtual = virtual.parent;
                    if (virtual && !vnode_isVirtualVNode(virtual)) {
                        // the parent node is not virtual, so we are done here.
                        return null;
                    }
                }
                if (!sibling) {
                    // If we did not find a sibling, than we are done.
                    return null;
                }
                if (vnode_isTextVNode(sibling) && virtual && vnode_isElementVNode(virtual)) {
                    // sibling to the real element is a text node, this is not a sibling
                    return null;
                }
            }
            // At this point `sibling` is a next node to look at.
            // Next step is to descend until we find a DOM done.
            while (sibling) {
                cursor = sibling;
                if (cursor.flags & 5 /* VNodeFlags.ELEMENT_OR_TEXT_MASK */ && vnode_getNode(cursor)) {
                    // we have to check that we actually have a node, because it could be a text node which is
                    // zero length and which does not have a representation in the DOM.
                    return cursor;
                }
                sibling = cursor[childProp];
            }
            // If we are here we did not find anything and we need to go up the tree again.
        }
        return null;
    };
    const vnode_ensureInflatedIfText = (journal, vNode) => {
        if (vnode_isTextVNode(vNode)) {
            vnode_ensureTextInflated(journal, vNode);
        }
    };
    const vnode_ensureTextInflated = (journal, vnode) => {
        const textVNode = ensureTextVNode(vnode);
        const flags = textVNode.flags;
        if ((flags & 8 /* VNodeFlags.Inflated */) === 0) {
            const parentNode = vnode_getDomParent(vnode);
            assertDefined(parentNode, 'Missing parent node.');
            const sharedTextNode = textVNode.textNode;
            const doc = parentNode.ownerDocument;
            // Walk the previous siblings and inflate them.
            let cursor = vnode_getDomSibling(vnode, false, true);
            // If text node is 0 length, than there is no text node.
            // In that case we use the next node as a reference, in which
            // case we know that the next node MUST be either NULL or an Element.
            const node = vnode_getDomSibling(vnode, true, true);
            const insertBeforeNode = sharedTextNode ||
                ((node instanceof ElementVNode ? node.element : node?.textNode) || null);
            let lastPreviousTextNode = insertBeforeNode;
            while (cursor && vnode_isTextVNode(cursor)) {
                if ((cursor.flags & 8 /* VNodeFlags.Inflated */) === 0) {
                    const textNode = doc.createTextNode(cursor.text);
                    journal.push(6 /* VNodeJournalOpCode.Insert */, parentNode, lastPreviousTextNode, textNode);
                    lastPreviousTextNode = textNode;
                    cursor.textNode = textNode;
                    cursor.flags |= 8 /* VNodeFlags.Inflated */;
                }
                cursor = vnode_getDomSibling(cursor, false, true);
            }
            // Walk the next siblings and inflate them.
            cursor = vnode;
            while (cursor && vnode_isTextVNode(cursor)) {
                const next = vnode_getDomSibling(cursor, true, true);
                const isLastNode = next ? !vnode_isTextVNode(next) : true;
                if ((cursor.flags & 8 /* VNodeFlags.Inflated */) === 0) {
                    if (isLastNode && sharedTextNode) {
                        journal.push(1 /* VNodeJournalOpCode.SetText */, sharedTextNode, cursor.text);
                    }
                    else {
                        const textNode = doc.createTextNode(cursor.text);
                        journal.push(6 /* VNodeJournalOpCode.Insert */, parentNode, insertBeforeNode, textNode);
                        cursor.textNode = textNode;
                    }
                    cursor.flags |= 8 /* VNodeFlags.Inflated */;
                }
                cursor = next;
            }
        }
    };
    const vnode_locate = (rootVNode, id) => {
        ensureElementVNode(rootVNode);
        let vNode = rootVNode;
        const containerElement = rootVNode.element;
        const { qVNodeRefs } = containerElement;
        let elementOffset = -1;
        let refElement;
        if (typeof id === 'string') {
            assertDefined(qVNodeRefs, 'Missing qVNodeRefs.');
            elementOffset = parseInt(id);
            refElement = qVNodeRefs.get(elementOffset);
        }
        else {
            refElement = id;
            const vNode = refElement.vNode;
            if (vNode) {
                return vNode;
            }
        }
        assertDefined(refElement, 'Missing refElement.');
        if (!vnode_isVNode(refElement)) {
            assertTrue(containerElement.contains(refElement), `Couldn't find the element inside the container while locating the VNode.`);
            // We need to find the vnode.
            let parent = refElement;
            const elementPath = [refElement];
            while (parent && parent !== containerElement && !parent.vNode) {
                parent = parent.parentElement;
                elementPath.push(parent);
            }
            if (parent.vNode) {
                vNode = parent.vNode;
            }
            // Start at rootVNode and follow the `elementPath` to find the vnode.
            for (let i = elementPath.length - 2; i >= 0; i--) {
                vNode = vnode_getVNodeForChildNode(vNode, elementPath[i]);
            }
            if (elementOffset != -1) {
                refElement.vNode = vNode;
                qVNodeRefs.set(elementOffset, vNode);
            }
        }
        else {
            vNode = refElement;
        }
        if (typeof id === 'string') {
            // process virtual node search.
            const idLength = id.length;
            let idx = indexOfAlphanumeric(id, idLength);
            let childIdx = 0;
            while (idx < idLength) {
                const ch = id.charCodeAt(idx);
                childIdx *= 26 /* a-z */;
                if (ch >= 97 /* a */) {
                    // is lowercase
                    childIdx += ch - 97 /* a */;
                }
                else {
                    // is uppercase
                    childIdx += ch - 65 /* A */;
                    vNode = vnode_getChildWithIdx(vNode, childIdx);
                    childIdx = 0;
                }
                idx++;
            }
        }
        return vNode;
    };
    const vnode_getChildWithIdx = (vNode, childIdx) => {
        let child = vnode_getFirstChild(vNode);
        assertDefined(child, 'Missing child.');
        while (child.flags >>> 8 /* VNodeFlagsIndex.shift */ !== childIdx) {
            child = child.nextSibling;
            assertDefined(child, 'Missing child.');
        }
        return child;
    };
    const vNodeStack = [];
    const vnode_getVNodeForChildNode = (vNode, childElement) => {
        ensureElementVNode(vNode);
        let child = vnode_getFirstChild(vNode);
        assertDefined(child, 'Missing child.');
        while (child && (child instanceof ElementVNode ? child.element !== childElement : true)) {
            if (vnode_isVirtualVNode(child)) {
                const next = child.nextSibling;
                const firstChild = vnode_getFirstChild(child);
                if (firstChild) {
                    next && vNodeStack.push(next);
                    child = firstChild;
                }
                else {
                    child = next || (vNodeStack.length ? vNodeStack.pop() : null);
                }
            }
            else {
                const next = child.nextSibling;
                if (next) {
                    child = next;
                }
                else {
                    child = next || vNodeStack.pop();
                }
            }
            assertDefined(child, 'Missing child.');
        }
        while (vNodeStack.length) {
            vNodeStack.pop();
        }
        ensureElementVNode(child);
        assertEqual(child.element, childElement, 'Child not found.');
        // console.log('FOUND', child[VNodeProps.node]?.outerHTML);
        return child;
    };
    const indexOfAlphanumeric = (id, length) => {
        let idx = 0;
        while (idx < length) {
            if (id.charCodeAt(idx) <= 57 /* 9 */) {
                idx++;
            }
            else {
                return idx;
            }
        }
        return length;
    };
    const vnode_createErrorDiv = (document, host, err, journal) => {
        const errorDiv = document.createElement('errored-host');
        if (err && err instanceof Error) {
            errorDiv.props = { error: err };
        }
        errorDiv.setAttribute('q:key', '_error_');
        const vErrorDiv = vnode_newElement(errorDiv, 'errored-host');
        vnode_getDOMChildNodes(journal, host, true).forEach((child) => {
            vnode_insertBefore(journal, vErrorDiv, child, null);
        });
        return vErrorDiv;
    };
    const parseBoolean = (value) => {
        if (value === 'false') {
            return false;
        }
        return Boolean(value);
    };
    const isBooleanAttr = (element, key) => {
        const isBoolean = key == 'allowfullscreen' ||
            key == 'async' ||
            key == 'autofocus' ||
            key == 'autoplay' ||
            key == 'checked' ||
            key == 'controls' ||
            key == 'default' ||
            key == 'defer' ||
            key == 'disabled' ||
            key == 'formnovalidate' ||
            key == 'inert' ||
            key == 'ismap' ||
            key == 'itemscope' ||
            key == 'loop' ||
            key == 'multiple' ||
            key == 'muted' ||
            key == 'nomodule' ||
            key == 'novalidate' ||
            key == 'open' ||
            key == 'playsinline' ||
            key == 'readonly' ||
            key == 'required' ||
            key == 'reversed' ||
            key == 'selected';
        return isBoolean && key in element;
    };
    const vnode_applyJournal = (journal) => {
        // console.log('APPLY JOURNAL', vnode_journalToString(journal));
        let idx = 0;
        const length = journal.length;
        while (idx < length) {
            const op = journal[idx++];
            switch (op) {
                case 1 /* VNodeJournalOpCode.SetText */:
                    const text = journal[idx++];
                    text.nodeValue = journal[idx++];
                    break;
                case 2 /* VNodeJournalOpCode.SetAttribute */:
                    const element = journal[idx++];
                    let key = journal[idx++];
                    if (key === 'className') {
                        key = 'class';
                    }
                    const value = journal[idx++];
                    if (isBooleanAttr(element, key)) {
                        element[key] = parseBoolean(value);
                    }
                    else if (key === 'value' && key in element) {
                        element.value = String(value);
                    }
                    else if (key === dangerouslySetInnerHTML) {
                        element.innerHTML = value;
                        element.setAttribute(QContainerAttr, "html" /* QContainerValue.HTML */);
                    }
                    else {
                        if (value == null || value === false) {
                            element.removeAttribute(key);
                        }
                        else {
                            element.setAttribute(key, String(value));
                        }
                    }
                    break;
                case 3 /* VNodeJournalOpCode.HoistStyles */:
                    const document = journal[idx++];
                    const head = document.head;
                    const styles = document.querySelectorAll(QStylesAllSelector);
                    for (let i = 0; i < styles.length; i++) {
                        head.appendChild(styles[i]);
                    }
                    break;
                case 4 /* VNodeJournalOpCode.Remove */:
                    const removeParent = journal[idx++];
                    let nodeToRemove;
                    while (idx < length && typeof (nodeToRemove = journal[idx]) !== 'number') {
                        removeParent.removeChild(nodeToRemove);
                        idx++;
                    }
                    break;
                case 5 /* VNodeJournalOpCode.RemoveAll */:
                    const removeAllParent = journal[idx++];
                    if (removeAllParent.replaceChildren) {
                        removeAllParent.replaceChildren();
                    }
                    else {
                        // fallback if replaceChildren is not supported
                        removeAllParent.textContent = '';
                    }
                    break;
                case 6 /* VNodeJournalOpCode.Insert */:
                    const insertParent = journal[idx++];
                    const insertBefore = journal[idx++];
                    let newChild;
                    while (idx < length && typeof (newChild = journal[idx]) !== 'number') {
                        insertParent.insertBefore(newChild, insertBefore);
                        idx++;
                    }
                    break;
            }
        }
        journal.length = 0;
    };
    //////////////////////////////////////////////////////////////////////////////////////////////////////
    const vnode_insertBefore = (journal, parent, newChild, insertBefore) => {
        ensureElementOrVirtualVNode(parent);
        if (vnode_isElementVNode(parent)) {
            ensureMaterialized(parent);
        }
        const newChildCurrentParent = newChild.parent;
        if (newChild === insertBefore) {
            // invalid insertBefore. We can't insert before self reference
            // prevent infinity loop and putting self reference to next sibling
            if (newChildCurrentParent) {
                // early return, as the newChild is already in the tree and we are already in the correct position
                return;
            }
            else {
                // if the newChild is not in the tree, than we insert it at the end of the list
                insertBefore = null;
            }
        }
        /**
         * Find the parent node and the dom children with the correct namespaces before we unlink the
         * previous node. If we don't do this, we will end up with situations where we inflate text nodes
         * from shared text node not correctly.
         *
         * Example:
         *
         * ```
         * <Component>
         *   <Projection>a</Projection>
         *   <Projection>b</Projection>
         * </Component>
         * ```
         *
         * Projection nodes are virtual nodes, so they don't have a dom parent. They will be written to
         * the q:template element if not visible at the start. Inside the q:template element, the
         * projection nodes will be streamed as single text node "ab". We need to split it, but if we
         * unlink the previous or next sibling, we don't know that after "a" node is "b". So we need to
         * find children first (and inflate them).
         */
        const domParentVNode = vnode_getDomParentVNode(parent, false);
        const parentNode = domParentVNode && domParentVNode.element;
        let domChildren = null;
        if (domParentVNode) {
            domChildren = vnode_getDomChildrenWithCorrectNamespacesToInsert(journal, domParentVNode, newChild);
        }
        /**
         * Ensure that the previous node is unlinked.
         *
         * We need to do it before finding the adjustedInsertBefore. The problem is when you try to render
         * the same projection multiple times in the same node but under different conditions. We reuse
         * projection nodes, so when this happens, we can end up with a situation where the node is
         * inserted before node above it.
         *
         * Example:
         *
         * ```
         * <>
         *   {props.toggle && <Slot />}
         *   {!props.toggle && (
         *     <>
         *       <Slot />
         *     </>
         *   )}
         * </>
         * ```
         *
         * Projected content:
         *
         * ```
         * <h1>Test</h1>
         * <p>Test content</p>
         * ```
         *
         * If we don't unlink the previous node, we will end up at some point with the following:
         *
         * ```
         * <h1>Test</h1>
         * <p>Test content</p> // <-- inserted before the first h1
         * <h1>Test</h1> // <-- to remove, but still in the tree
         * <p>Test content</p> // <-- to remove
         * ```
         */
        if (newChildCurrentParent &&
            (newChild.previousSibling || newChild.nextSibling || newChildCurrentParent !== parent)) {
            vnode_remove(journal, newChildCurrentParent, newChild, false);
        }
        const parentIsDeleted = parent.flags & 32 /* VNodeFlags.Deleted */;
        // if the parent is deleted, then we don't need to insert the new child
        if (!parentIsDeleted) {
            let adjustedInsertBefore = null;
            if (insertBefore == null) {
                if (vnode_isVirtualVNode(parent)) {
                    // If `insertBefore` is null, than we need to insert at the end of the list.
                    // Well, not quite. If the parent is a virtual node, our "last node" is not the same
                    // as the DOM "last node". So in that case we need to look for the "next node" from
                    // our parent.
                    adjustedInsertBefore = vnode_getDomSibling(parent, true, false);
                }
            }
            else if (vnode_isVirtualVNode(insertBefore)) {
                // If the `insertBefore` is virtual, than we need to descend into the virtual and find e actual
                adjustedInsertBefore = vnode_getDomSibling(insertBefore, true, true);
            }
            else {
                adjustedInsertBefore = insertBefore;
            }
            adjustedInsertBefore && vnode_ensureInflatedIfText(journal, adjustedInsertBefore);
            // Here we know the insertBefore node
            if (domChildren && domChildren.length) {
                journal.push(6 /* VNodeJournalOpCode.Insert */, parentNode, vnode_getNode(adjustedInsertBefore), ...domChildren);
            }
        }
        // link newChild into the previous/next list
        const vNext = insertBefore;
        const vPrevious = vNext ? vNext.previousSibling : parent.lastChild;
        if (vNext) {
            vNext.previousSibling = newChild;
        }
        else {
            parent.lastChild = newChild;
        }
        if (vPrevious) {
            vPrevious.nextSibling = newChild;
        }
        else {
            parent.firstChild = newChild;
        }
        newChild.previousSibling = vPrevious;
        newChild.nextSibling = vNext;
        newChild.parent = parent;
        if (parentIsDeleted) {
            // if the parent is deleted, then the new child is also deleted
            newChild.flags |= 32 /* VNodeFlags.Deleted */;
        }
    };
    const vnode_getDomParent = (vnode, includeProjection = true) => {
        vnode = vnode_getDomParentVNode(vnode, includeProjection);
        return (vnode && vnode.element);
    };
    const vnode_getDomParentVNode = (vnode, includeProjection = true) => {
        while (vnode && !vnode_isElementVNode(vnode)) {
            vnode = vnode.parent || (includeProjection ? vnode.slotParent : null);
        }
        return vnode;
    };
    const vnode_remove = (journal, vParent, vToRemove, removeDOM) => {
        assertEqual(vParent, vToRemove.parent, 'Parent mismatch.');
        if (vnode_isTextVNode(vToRemove)) {
            vnode_ensureTextInflated(journal, vToRemove);
        }
        if (removeDOM) {
            const domParent = vnode_getDomParent(vParent, false);
            const isInnerHTMLParent = vParent.getAttr(dangerouslySetInnerHTML);
            if (isInnerHTMLParent) {
                // ignore children, as they are inserted via innerHTML
                return;
            }
            const children = vnode_getDOMChildNodes(journal, vToRemove);
            domParent && children.length && journal.push(4 /* VNodeJournalOpCode.Remove */, domParent, ...children);
        }
        const vPrevious = vToRemove.previousSibling;
        const vNext = vToRemove.nextSibling;
        if (vPrevious) {
            vPrevious.nextSibling = vNext;
        }
        else {
            vParent.firstChild = vNext;
        }
        if (vNext) {
            vNext.previousSibling = vPrevious;
        }
        else {
            vParent.lastChild = vPrevious;
        }
        vToRemove.previousSibling = null;
        vToRemove.nextSibling = null;
    };
    const vnode_truncate = (journal, vParent, vDelete) => {
        assertDefined(vDelete, 'Missing vDelete.');
        const parent = vnode_getDomParent(vParent);
        if (parent) {
            if (vnode_isElementVNode(vParent)) {
                journal.push(5 /* VNodeJournalOpCode.RemoveAll */, parent);
            }
            else {
                const children = vnode_getDOMChildNodes(journal, vParent);
                children.length && journal.push(4 /* VNodeJournalOpCode.Remove */, parent, ...children);
            }
        }
        const vPrevious = vDelete.previousSibling;
        if (vPrevious) {
            vPrevious.nextSibling = null;
        }
        else {
            vParent.firstChild = null;
        }
        vParent.lastChild = vPrevious;
    };
    //////////////////////////////////////////////////////////////////////////////////////////////////////
    const vnode_getElementName = (vnode) => {
        const elementVNode = ensureElementVNode(vnode);
        let elementName = elementVNode.elementName;
        if (elementName === undefined) {
            const element = elementVNode.element;
            const nodeName = fastNodeName(element).toLowerCase();
            elementName = elementVNode.elementName = nodeName;
            elementVNode.flags |= vnode_getElementNamespaceFlags(element);
        }
        return elementName;
    };
    const vnode_getText = (textVNode) => {
        let text = textVNode.text;
        if (text === undefined) {
            text = textVNode.text = textVNode.textNode.nodeValue;
        }
        return text;
    };
    const vnode_setText = (journal, textVNode, text) => {
        vnode_ensureTextInflated(journal, textVNode);
        const textNode = textVNode.textNode;
        journal.push(1 /* VNodeJournalOpCode.SetText */, textNode, (textVNode.text = text));
    };
    /** @internal */
    const vnode_getFirstChild = (vnode) => {
        if (vnode_isTextVNode(vnode)) {
            return null;
        }
        let vFirstChild = vnode.firstChild;
        if (vFirstChild === undefined) {
            vFirstChild = ensureMaterialized(vnode);
        }
        return vFirstChild;
    };
    const vnode_materialize = (vNode) => {
        const element = vNode.element;
        const firstChild = fastFirstChild(element);
        const vNodeData = element.ownerDocument?.qVNodeData?.get(element);
        const vFirstChild = materialize(vNode, element, firstChild, vNodeData);
        return vFirstChild;
    };
    const materialize = (vNode, element, firstChild, vNodeData) => {
        if (vNodeData) {
            if (vNodeData.charCodeAt(0) === VNodeDataChar.SEPARATOR) {
                /**
                 * If vNodeData start with the `VNodeDataChar.SEPARATOR` then it means that the vNodeData
                 * contains some data for DOM element. We need to split it to DOM element vNodeData and
                 * virtual element vNodeData.
                 *
                 * For example `|=6`4|2{J=7`3|q:type|S}` should split into `=6`4`and`2{J=7`3|q:type|S}`, where
                 * `=6`4` is vNodeData for the DOM element.
                 */
                const elementVNodeDataStartIdx = 1;
                let elementVNodeDataEndIdx = 1;
                while (vNodeData.charCodeAt(elementVNodeDataEndIdx) !== VNodeDataChar.SEPARATOR) {
                    elementVNodeDataEndIdx++;
                }
                const elementVNodeData = vNodeData.substring(elementVNodeDataStartIdx, elementVNodeDataEndIdx);
                // Override vNodeData variable for materializing a virtual element
                vNodeData = vNodeData.substring(elementVNodeDataEndIdx + 1);
                // Materialize DOM element from HTML. If the `vNodeData` is not empty,
                // then also materialize virtual element from vNodeData
                const vFirstChild = materializeFromDOM(vNode, firstChild, elementVNodeData);
                if (!vNodeData) {
                    //  If it is empty then we don't need to call the `materializeFromVNodeData`.
                    return vFirstChild;
                }
            }
            // Materialize virtual element form vNodeData
            return materializeFromVNodeData(vNode, vNodeData, element, firstChild);
        }
        else {
            // Materialize DOM element from HTML only
            return materializeFromDOM(vNode, firstChild);
        }
    };
    const ensureMaterialized = (vnode) => {
        const vParent = ensureElementVNode(vnode);
        let vFirstChild = vParent.firstChild;
        if (vFirstChild === undefined) {
            // need to materialize the vNode.
            const element = vParent.element;
            if (vParent.parent && shouldIgnoreChildren(element)) {
                // We have a container with html value, must ignore the content.
                vFirstChild = vParent.firstChild = vParent.lastChild = null;
            }
            else {
                vFirstChild = vnode_materialize(vParent);
            }
        }
        assertTrue(vParent.firstChild !== undefined, 'Did not materialize.');
        assertTrue(vParent.lastChild !== undefined, 'Did not materialize.');
        return vFirstChild;
    };
    let _fastHasAttribute = null;
    const shouldIgnoreChildren = (node) => {
        if (!_fastHasAttribute) {
            _fastHasAttribute = node.hasAttribute;
        }
        return _fastHasAttribute.call(node, QContainerAttr);
    };
    let _fastNodeType = null;
    const fastNodeType = (node) => {
        if (!_fastNodeType) {
            _fastNodeType = fastGetter(node, 'nodeType');
        }
        return _fastNodeType.call(node);
    };
    const fastIsTextOrElement = (node) => {
        const type = fastNodeType(node);
        return type === /* Node.TEXT_NODE */ 3 || type === /* Node.ELEMENT_NODE */ 1;
    };
    let _fastNextSibling = null;
    const fastNextSibling = (node) => {
        if (!_fastNextSibling) {
            _fastNextSibling = fastGetter(node, 'nextSibling');
        }
        if (!_fastFirstChild) {
            _fastFirstChild = fastGetter(node, 'firstChild');
        }
        while (node) {
            node = _fastNextSibling.call(node);
            if (node !== null) {
                const type = fastNodeType(node);
                if (type === /* Node.TEXT_NODE */ 3 || type === /* Node.ELEMENT_NODE */ 1) {
                    break;
                }
                else if (type === /* Node.COMMENT_NODE */ 8) {
                    const nodeValue = node.nodeValue;
                    if (nodeValue?.startsWith(QIgnore)) {
                        return getNodeAfterCommentNode(node, QContainerIsland, _fastNextSibling, _fastFirstChild);
                    }
                    else if (node.nodeValue?.startsWith(QContainerIslandEnd)) {
                        return getNodeAfterCommentNode(node, QIgnoreEnd, _fastNextSibling, _fastFirstChild);
                    }
                    else if (nodeValue?.startsWith(QContainerAttr)) {
                        while (node && (node = _fastNextSibling.call(node))) {
                            if (fastNodeType(node) === /* Node.COMMENT_NODE */ 8 &&
                                node.nodeValue?.startsWith(QContainerAttrEnd)) {
                                break;
                            }
                        }
                    }
                }
            }
        }
        return node;
    };
    function getNodeAfterCommentNode(node, commentValue, nextSibling, firstChild) {
        while (node) {
            if (node.nodeValue?.startsWith(commentValue)) {
                node = nextSibling.call(node) || null;
                return node;
            }
            let nextNode = firstChild.call(node);
            if (!nextNode) {
                nextNode = nextSibling.call(node);
            }
            if (!nextNode) {
                nextNode = fastParentNode(node);
                if (nextNode) {
                    nextNode = nextSibling.call(nextNode);
                }
            }
            node = nextNode;
        }
        return null;
    }
    let _fastParentNode = null;
    const fastParentNode = (node) => {
        if (!_fastParentNode) {
            _fastParentNode = fastGetter(node, 'parentNode');
        }
        return _fastParentNode.call(node);
    };
    let _fastFirstChild = null;
    const fastFirstChild = (node) => {
        if (!_fastFirstChild) {
            _fastFirstChild = fastGetter(node, 'firstChild');
        }
        node = node && _fastFirstChild.call(node);
        while (node && !fastIsTextOrElement(node)) {
            node = fastNextSibling(node);
        }
        return node;
    };
    let _fastNamespaceURI = null;
    const fastNamespaceURI = (element) => {
        if (!_fastNamespaceURI) {
            _fastNamespaceURI = fastGetter(element, 'namespaceURI');
        }
        return _fastNamespaceURI.call(element);
    };
    let _fastNodeName = null;
    const fastNodeName = (element) => {
        if (!_fastNodeName) {
            _fastNodeName = fastGetter(element, 'nodeName');
        }
        return _fastNodeName.call(element);
    };
    const fastGetter = (prototype, name) => {
        let getter;
        while (prototype && !(getter = Object.getOwnPropertyDescriptor(prototype, name)?.get)) {
            prototype = Object.getPrototypeOf(prototype);
        }
        return (getter ||
            function () {
                return this[name];
            });
    };
    const hasQStyleAttribute = (element) => {
        return (element.nodeName === 'STYLE' &&
            (element.hasAttribute(QScopedStyle) || element.hasAttribute(QStyle)));
    };
    const hasPropsSeparator = (element) => {
        return element.hasAttribute(Q_PROPS_SEPARATOR);
    };
    const materializeFromDOM = (vParent, firstChild, vData) => {
        let vFirstChild = null;
        const skipElements = () => {
            while (isElement(child) && shouldSkipElement(child)) {
                child = fastNextSibling(child);
            }
        };
        // materialize from DOM
        let child = firstChild;
        skipElements();
        let vChild = null;
        while (child) {
            const nodeType = fastNodeType(child);
            let vNextChild = null;
            if (nodeType === /* Node.TEXT_NODE */ 3) {
                vNextChild = vnode_newText(child, child.textContent ?? undefined);
            }
            else if (nodeType === /* Node.ELEMENT_NODE */ 1) {
                vNextChild = vnode_newUnMaterializedElement(child);
            }
            if (vNextChild) {
                vNextChild.parent = vParent;
                vChild && (vChild.nextSibling = vNextChild);
                vNextChild.previousSibling = vChild;
                vChild = vNextChild;
            }
            if (!vFirstChild) {
                vParent.firstChild = vFirstChild = vChild;
            }
            child = fastNextSibling(child);
            skipElements();
        }
        vParent.lastChild = vChild || null;
        vParent.firstChild = vFirstChild;
        if (vData) {
            /**
             * If we need to materialize from DOM and we have vNodeData it means that we have some virtual
             * props for that node.
             */
            let container = null;
            processVNodeData$1(vData, (peek, consumeValue) => {
                if (peek() === VNodeDataChar.ID) {
                    if (!container) {
                        container = getDomContainer(vParent.element);
                    }
                    const id = consumeValue();
                    container.$setRawState$(parseInt(id), vParent);
                    build.isDev && vParent.setAttr(ELEMENT_ID, id, null);
                }
                else if (peek() === VNodeDataChar.BACK_REFS) {
                    if (!container) {
                        container = getDomContainer(vParent.element);
                    }
                    setEffectBackRefFromVNodeData(vParent, consumeValue(), container);
                }
                else {
                    // prevent infinity loop if there are some characters outside the range
                    consumeValue();
                }
            });
        }
        return vFirstChild;
    };
    function setEffectBackRefFromVNodeData(vParent, value, container) {
        if (!vParent[_EFFECT_BACK_REF]) {
            // get data lazily
            // this is because effects back refs can point to vnodes which are not yet materialized
            // (are after the current vnode)
            Object.defineProperty(vParent, _EFFECT_BACK_REF, {
                get() {
                    const subMap = container.$getObjectById$(value);
                    vParent[_EFFECT_BACK_REF] = subMap;
                    return subMap;
                },
                set(value) {
                    Object.defineProperty(vParent, _EFFECT_BACK_REF, {
                        value,
                        writable: true,
                        enumerable: true,
                        configurable: true,
                    });
                },
                enumerable: true,
                configurable: true,
            });
        }
        else {
            const subMap = vParent[_EFFECT_BACK_REF];
            mergeMaps(subMap, container.$getObjectById$(value));
        }
    }
    const processVNodeData$1 = (vData, callback) => {
        let nextToConsumeIdx = 0;
        let ch = 0;
        let peekCh = 0;
        const getChar = (idx) => {
            return idx < vData.length ? vData.charCodeAt(idx) : 0;
        };
        const peek = () => {
            if (peekCh !== 0) {
                return peekCh;
            }
            else {
                return (peekCh = getChar(nextToConsumeIdx));
            }
        };
        const consume = () => {
            ch = peek();
            peekCh = 0;
            nextToConsumeIdx++;
            return ch;
        };
        const consumeValue = () => {
            consume();
            const start = nextToConsumeIdx;
            while ((peek() <= 58 /* `:` */ && peekCh !== 0) ||
                peekCh === 95 /* `_` */ ||
                (peekCh >= 65 /* `A` */ && peekCh <= 90) /* `Z` */ ||
                (peekCh >= 97 /* `a` */ && peekCh <= 122) /* `z` */) {
                consume();
            }
            return vData.substring(start, nextToConsumeIdx);
        };
        while (peek() !== 0) {
            callback(peek, consumeValue, consume, getChar, nextToConsumeIdx);
        }
    };
    /** @internal */
    const vnode_getAttrKeys = (vnode) => {
        const type = vnode.flags;
        if ((type & 3 /* VNodeFlags.ELEMENT_OR_VIRTUAL_MASK */) !== 0) {
            vnode_ensureElementInflated(vnode);
            const keys = [];
            const props = vnode_getProps(vnode);
            for (let i = 0; i < props.length; i = i + 2) {
                const key = props[i];
                if (!key.startsWith(Q_PROPS_SEPARATOR)) {
                    keys.push(key);
                }
            }
            return keys;
        }
        return [];
    };
    /** @internal */
    const vnode_getProps = (vnode) => {
        vnode.props ||= [];
        return vnode.props;
    };
    const vnode_isDescendantOf = (vnode, ancestor) => {
        let parent = vnode_getProjectionParentOrParent(vnode);
        while (parent) {
            if (parent === ancestor) {
                return true;
            }
            parent = vnode_getProjectionParentOrParent(parent);
        }
        return false;
    };
    const vnode_getProjectionParentOrParent = (vnode) => {
        return vnode.parent || vnode.slotParent;
    };
    const vnode_getNode = (vnode) => {
        if (vnode === null || vnode_isVirtualVNode(vnode)) {
            return null;
        }
        if (vnode_isElementVNode(vnode)) {
            return vnode.element;
        }
        assertTrue(vnode_isTextVNode(vnode), 'Expecting Text Node.');
        return vnode.textNode;
    };
    /** @internal */
    function vnode_toString(depth = 20, offset = '', materialize = false, siblings = false, colorize = true) {
        let vnode = this;
        if (depth === 0) {
            return '...';
        }
        if (vnode === null) {
            return 'null';
        }
        if (vnode === undefined) {
            return 'undefined';
        }
        const strings = [];
        const NAME_COL_PREFIX = '\x1b[34m';
        const NAME_COL_SUFFIX = '\x1b[0m';
        do {
            if (vnode_isTextVNode(vnode)) {
                strings.push(qwikDebugToString(vnode_getText(vnode)));
            }
            else if (vnode_isVirtualVNode(vnode)) {
                const idx = vnode.flags >>> 8 /* VNodeFlagsIndex.shift */;
                const attrs = ['[' + String(idx) + ']'];
                vnode_getAttrKeys(vnode).forEach((key) => {
                    if (key !== DEBUG_TYPE) {
                        const value = vnode.getAttr(key);
                        attrs.push(' ' + key + '=' + qwikDebugToString(value));
                    }
                });
                const name = (colorize ? NAME_COL_PREFIX : '') +
                    (VirtualTypeName[vnode.getAttr(DEBUG_TYPE) || "V" /* VirtualType.Virtual */] ||
                        VirtualTypeName["V" /* VirtualType.Virtual */]) +
                    (colorize ? NAME_COL_SUFFIX : '');
                strings.push('<' + name + attrs.join('') + '>');
                const child = vnode_getFirstChild(vnode);
                child &&
                    strings.push('  ' + vnode_toString.call(child, depth - 1, offset + '  ', true, true, colorize));
                strings.push('</' + name + '>');
            }
            else if (vnode_isElementVNode(vnode)) {
                const tag = vnode_getElementName(vnode);
                const attrs = [];
                const keys = vnode_getAttrKeys(vnode);
                keys.forEach((key) => {
                    const value = vnode.getAttr(key);
                    attrs.push(' ' + key + '=' + qwikDebugToString(value));
                });
                const node = vnode_getNode(vnode);
                if (node) {
                    const vnodeData = node.ownerDocument.qVNodeData?.get(node);
                    if (vnodeData) {
                        attrs.push(' q:vnodeData=' + qwikDebugToString(vnodeData));
                    }
                }
                const domAttrs = node.attributes;
                for (let i = 0; i < domAttrs.length; i++) {
                    const attr = domAttrs[i];
                    if (keys.indexOf(attr.name) === -1) {
                        attrs.push(' ' + attr.name + (attr.value ? '=' + qwikDebugToString(attr.value) : ''));
                    }
                }
                strings.push('<' + tag + attrs.join('') + '>');
                if (vnode_isMaterialized(vnode) || materialize) {
                    const child = vnode_getFirstChild(vnode);
                    child &&
                        strings.push('  ' + vnode_toString.call(child, depth - 1, offset + '  ', true, true, colorize));
                }
                else {
                    strings.push('  <!-- not materialized --!>');
                }
                strings.push('</' + tag + '>');
            }
            vnode = (siblings && vnode.nextSibling) || null;
        } while (vnode);
        return strings.join('\n' + offset);
    }
    const isNumber = (ch) => /* `0` */ 48 <= ch && ch <= 57; /* `9` */
    const isLowercase = (ch) => /* `a` */ 97 <= ch && ch <= 122; /* `z` */
    function shouldSkipElement(element) {
        return (
        // Skip over elements that don't have a props separator. They are not rendered by Qwik.
        !hasPropsSeparator(element) ||
            // We pretend that style element's don't exist as they can get moved out.
            // skip over style elements, as those need to be moved to the head
            // and are not included in the counts.
            hasQStyleAttribute(element));
    }
    const stack = [];
    function materializeFromVNodeData(vParent, vData, element, child) {
        let idx = 0;
        let vFirst = null;
        let vLast = null;
        let previousTextNode = null;
        const addVNode = (node) => {
            node.flags = (node.flags & 255 /* VNodeFlagsIndex.mask */) | (idx << 8 /* VNodeFlagsIndex.shift */);
            idx++;
            vLast && (vLast.nextSibling = node);
            node.previousSibling = vLast;
            node.parent = vParent;
            if (!vFirst) {
                vParent.firstChild = vFirst = node;
            }
            vLast = node;
        };
        let textIdx = 0;
        let combinedText = null;
        let container = null;
        const shouldSkipNode = (node) => {
            const nodeIsElement = isElement(node);
            return !nodeIsElement || (nodeIsElement && shouldSkipElement(node));
        };
        processVNodeData$1(vData, (peek, consumeValue, consume, getChar, nextToConsumeIdx) => {
            if (isNumber(peek())) {
                // Element counts get encoded as numbers.
                while (shouldSkipNode(child)) {
                    child = fastNextSibling(child);
                    if (!child) {
                        throw qError(27 /* QError.materializeVNodeDataError */, [vData, peek(), nextToConsumeIdx]);
                    }
                }
                combinedText = null;
                previousTextNode = null;
                let value = 0;
                while (isNumber(peek())) {
                    value *= 10;
                    value += consume() - 48; /* `0` */
                }
                while (value--) {
                    addVNode(vnode_newUnMaterializedElement(child));
                    child = fastNextSibling(child);
                }
                // collect the elements;
            }
            else if (peek() === VNodeDataChar.SCOPED_STYLE) {
                vParent.setAttr(QScopedStyle, consumeValue(), null);
            }
            else if (peek() === VNodeDataChar.RENDER_FN) {
                vParent.setAttr(OnRenderProp, consumeValue(), null);
            }
            else if (peek() === VNodeDataChar.ID) {
                if (!container) {
                    container = getDomContainer(element);
                }
                const id = consumeValue();
                container.$setRawState$(parseInt(id), vParent);
                build.isDev && vParent.setAttr(ELEMENT_ID, id, null);
            }
            else if (peek() === VNodeDataChar.PROPS) {
                vParent.setAttr(ELEMENT_PROPS, consumeValue(), null);
            }
            else if (peek() === VNodeDataChar.KEY) {
                const isEscapedValue = getChar(nextToConsumeIdx + 1) === VNodeDataChar.SEPARATOR;
                let value;
                if (isEscapedValue) {
                    consume();
                    value = decodeURI(consumeValue());
                    consume();
                }
                else {
                    value = consumeValue();
                }
                vParent.setAttr(ELEMENT_KEY, value, null);
            }
            else if (peek() === VNodeDataChar.SEQ) {
                vParent.setAttr(ELEMENT_SEQ, consumeValue(), null);
            }
            else if (peek() === VNodeDataChar.SEQ_IDX) {
                vParent.setAttr(ELEMENT_SEQ_IDX, consumeValue(), null);
            }
            else if (peek() === VNodeDataChar.BACK_REFS) {
                if (!container) {
                    container = getDomContainer(element);
                }
                setEffectBackRefFromVNodeData(vParent, consumeValue(), container);
            }
            else if (peek() === VNodeDataChar.SLOT_PARENT) {
                if (!container) {
                    container = getDomContainer(element);
                }
                vParent.slotParent = vnode_locate(container.rootVNode, consumeValue());
            }
            else if (peek() === VNodeDataChar.CONTEXT) {
                vParent.setAttr(QCtxAttr, consumeValue(), null);
            }
            else if (peek() === VNodeDataChar.OPEN) {
                consume();
                addVNode(vnode_newVirtual());
                stack.push(vParent, vFirst, vLast, previousTextNode, idx);
                idx = 0;
                vParent = vLast;
                vFirst = vLast = null;
            }
            else if (peek() === VNodeDataChar.SEPARATOR) {
                const key = consumeValue();
                const value = consumeValue();
                vParent.setAttr(key, value, null);
            }
            else if (peek() === VNodeDataChar.CLOSE) {
                consume();
                vParent.lastChild = vLast;
                idx = stack.pop();
                previousTextNode = stack.pop();
                vLast = stack.pop();
                vFirst = stack.pop();
                vParent = stack.pop();
            }
            else if (peek() === VNodeDataChar.SLOT) {
                vParent.setAttr(QSlot, consumeValue(), null);
            }
            else {
                // skip over style or non-qwik elements in front of text nodes, where text node is the first child (except the style node)
                while (isElement(child) && shouldSkipElement(child)) {
                    child = fastNextSibling(child);
                }
                const textNode = child && fastNodeType(child) === /* Node.TEXT_NODE */ 3 ? child : null;
                // must be alphanumeric
                if (combinedText === null) {
                    combinedText = textNode ? textNode.nodeValue : null;
                    textIdx = 0;
                }
                let length = 0;
                while (isLowercase(peek())) {
                    length += consume() - 97; /* `a` */
                    length *= 26;
                }
                length += consume() - 65; /* `A` */
                const text = combinedText === null ? '' : combinedText.substring(textIdx, textIdx + length);
                addVNode((previousTextNode = vnode_newSharedText(previousTextNode, textNode, text)));
                textIdx += length;
                // Text nodes get encoded as alphanumeric characters.
            }
        });
        vParent.lastChild = vLast;
        return vFirst;
    }
    const vnode_getType = (vnode) => {
        const type = vnode.flags;
        if (type & 1 /* VNodeFlags.Element */) {
            return 1 /* Element */;
        }
        else if (type & 2 /* VNodeFlags.Virtual */) {
            return 11 /* Virtual */;
        }
        else if (type & 4 /* VNodeFlags.Text */) {
            return 3 /* Text */;
        }
        throw qError(26 /* QError.invalidVNodeType */, [type]);
    };
    const isElement = (node) => node && typeof node == 'object' && fastNodeType(node) === /** Node.ELEMENT_NODE* */ 1;
    /**
     * Use this method to find the parent component for projection.
     *
     * Normally the parent component is just the first component which we encounter while traversing the
     * parents.
     *
     * However, if during traversal we encounter a projection, than we have to follow the projection,
     * and node with the projection component is further away (it is the parent's parent of the
     * projection's)
     *
     * So in general we have to go up as many parent components as there are projections nestings.
     *
     * - No projection nesting first parent component.
     * - One projection nesting, second parent component (parent's parent).
     * - Three projection nesting, third parent component (parent's parent's parent).
     * - And so on.
     *
     * @param vHost
     * @param rootVNode
     * @returns
     */
    const vnode_getProjectionParentComponent = (vHost) => {
        let projectionDepth = 1;
        while (projectionDepth--) {
            while (vHost &&
                (vnode_isVirtualVNode(vHost) ? vHost.getProp(OnRenderProp, null) === null : true)) {
                const qSlotParent = vHost.slotParent;
                const vProjectionParent = vnode_isVirtualVNode(vHost) && qSlotParent;
                if (vProjectionParent) {
                    // We found a projection, so we need to go up one more level.
                    projectionDepth++;
                }
                vHost = vProjectionParent || vHost.parent;
            }
            if (projectionDepth > 0) {
                vHost = vHost.parent;
            }
        }
        return vHost;
    };

    let _context;
    const tryGetInvokeContext = () => {
        if (!_context) {
            const context = typeof document !== 'undefined' && document && document.__q_context__;
            if (!context) {
                return undefined;
            }
            if (isArray(context)) {
                return (document.__q_context__ = newInvokeContextFromTuple(context));
            }
            return context;
        }
        return _context;
    };
    const getInvokeContext = () => {
        const ctx = tryGetInvokeContext();
        if (!ctx) {
            throw qError(9 /* QError.useMethodOutsideContext */);
        }
        return ctx;
    };
    /** @internal */
    const useInvokeContext = () => {
        const ctx = tryGetInvokeContext();
        if (!ctx || ctx.$event$ !== RenderEvent) {
            throw qError(10 /* QError.useInvokeContext */);
        }
        assertDefined(ctx.$hostElement$, `invoke: $hostElement$ must be defined`, ctx);
        assertDefined(ctx.$effectSubscriber$, `invoke: $effectSubscriber$ must be defined`, ctx);
        return ctx;
    };
    function useBindInvokeContext(fn) {
        if (fn == null) {
            return fn;
        }
        const ctx = getInvokeContext();
        return function (...args) {
            return (invokeApply).call(this, ctx, fn, args);
        };
    }
    /** Call a function with the given InvokeContext and given arguments. */
    function invoke(context, fn, ...args) {
        return invokeApply.call(this, context, fn, args);
    }
    /** Call a function with the given InvokeContext and array of arguments. */
    function invokeApply(context, fn, args) {
        const previousContext = _context;
        let returnValue;
        try {
            _context = context;
            returnValue = fn.apply(this, args);
        }
        finally {
            _context = previousContext;
        }
        return returnValue;
    }
    const newInvokeContextFromTuple = ([element, event, url]) => {
        const domContainer = getDomContainer(element);
        const hostElement = vnode_locate(domContainer.rootVNode, element);
        const locale = domContainer.$locale$;
        locale && setLocale(locale);
        return newInvokeContext(locale, hostElement, element, event, url);
    };
    // TODO how about putting url and locale (and event/custom?) in to a "static" object
    const newInvokeContext = (locale, hostElement, element, event, url) => {
        // ServerRequestEvent has .locale, but it's not always defined.
        const $locale$ = locale || (event && isObject(event) && 'locale' in event ? event.locale : undefined);
        const ctx = {
            $url$: url,
            $hostElement$: hostElement,
            $element$: element,
            $event$: event,
            $qrl$: undefined,
            $effectSubscriber$: undefined,
            $locale$,
            $container$: undefined,
        };
        seal(ctx);
        return ctx;
    };
    /**
     * Don't track listeners for this callback
     *
     * @public
     */
    const untrack = (fn) => {
        if (_context) {
            const sub = _context.$effectSubscriber$;
            try {
                _context.$effectSubscriber$ = undefined;
                return fn();
            }
            finally {
                _context.$effectSubscriber$ = sub;
            }
        }
        else {
            return fn();
        }
    };
    const trackInvocation = /*#__PURE__*/ newInvokeContext(undefined, undefined, undefined, RenderEvent);
    /**
     * @param fn
     * @param subscriber
     * @param property `true` - subscriber is component `false` - subscriber is VNode `string` -
     *   subscriber is property
     * @param container
     * @param data - Additional subscription data
     * @returns
     */
    const trackSignal = (fn, subscriber, property, container, data) => {
        const previousSubscriber = trackInvocation.$effectSubscriber$;
        const previousContainer = trackInvocation.$container$;
        try {
            trackInvocation.$effectSubscriber$ = getSubscriber(subscriber, property, data);
            trackInvocation.$container$ = container;
            return invoke(trackInvocation, fn);
        }
        finally {
            trackInvocation.$effectSubscriber$ = previousSubscriber;
            trackInvocation.$container$ = previousContainer;
        }
    };
    const trackSignalAndAssignHost = (value, host, property, container, data) => {
        if (value instanceof WrappedSignalImpl && value.$hostElement$ !== host && host) {
            value.$hostElement$ = host;
        }
        return trackSignal(() => value.value, host, property, container, data);
    };
    /** @internal */
    const _getContextElement = () => {
        const iCtx = tryGetInvokeContext();
        if (iCtx) {
            const hostElement = iCtx.$hostElement$;
            let element = null;
            if (hostElement != null) {
                if (vnode_isVNode(hostElement)) {
                    if (vnode_isElementVNode(hostElement)) {
                        element = vnode_getNode(hostElement);
                    }
                }
                else {
                    // isSSRnode
                    element = hostElement;
                }
            }
            return element ?? iCtx.$qrl$?.$setContainer$(undefined);
        }
    };
    /** @internal */
    const _getContextEvent = () => {
        const iCtx = tryGetInvokeContext();
        if (iCtx) {
            return iCtx.$event$;
        }
    };
    /** @internal */
    const _getContextContainer = () => {
        const iCtx = tryGetInvokeContext();
        if (iCtx) {
            return iCtx.$container$;
        }
    };
    /** @internal */
    const _jsxBranch = (input) => {
        return input;
    };
    /** @internal */
    const _waitUntilRendered = (elm) => {
        const container = _getQContainerElement(elm)?.qContainer;
        if (!container) {
            return Promise.resolve();
        }
        // Multi-cycle idle: loop WAIT_FOR_QUEUE until the flush epoch stays stable
        // across an extra microtask, which signals that no new work re-scheduled.
        return (async () => {
            for (;;) {
                await container.$scheduler$(255 /* ChoreType.WAIT_FOR_QUEUE */).$returnValue$;
                const firstEpoch = container.$flushEpoch$ || 0;
                // Give a microtask for any immediate follow-up scheduling to enqueue
                await Promise.resolve();
                const secondEpoch = container.$flushEpoch$ || 0;
                // If no epoch change occurred during and after WAIT_FOR_QUEUE, we are idle.
                if (firstEpoch === secondEpoch) {
                    return;
                }
                // Continue loop if epoch advanced, meaning more work flushed.
            }
        })();
    };

    /**
     * @internal
     * The storage provider for hooks. Each invocation increases index i. Data is stored in an array.
     */
    const useSequentialScope = () => {
        const iCtx = useInvokeContext();
        const hostElement = iCtx.$hostElement$;
        const host = hostElement;
        let seq = iCtx.$container$.getHostProp(host, ELEMENT_SEQ);
        if (seq === null) {
            seq = [];
            iCtx.$container$.setHostProp(host, ELEMENT_SEQ, seq);
        }
        let seqIdx = iCtx.$container$.getHostProp(host, ELEMENT_SEQ_IDX);
        if (seqIdx === null) {
            seqIdx = 0;
        }
        iCtx.$container$.setHostProp(host, ELEMENT_SEQ_IDX, seqIdx + 1);
        while (seq.length <= seqIdx) {
            seq.push(undefined);
        }
        const set = (value) => {
            if (qDev && qSerialize) {
                verifySerializable(value);
            }
            return (seq[seqIdx] = value);
        };
        return {
            val: seq[seqIdx],
            set,
            i: seqIdx,
            iCtx,
        };
    };

    // <docs markdown="../readme.md#createContextId">
    // !!DO NOT EDIT THIS COMMENT DIRECTLY!!!
    // (edit ../readme.md#createContextId instead and run `pnpm docs.sync`)
    /**
     * Create a context ID to be used in your application. The name should be written with no spaces.
     *
     * Context is a way to pass stores to the child components without prop-drilling.
     *
     * Use `createContextId()` to create a `ContextId`. A `ContextId` is just a serializable identifier
     * for the context. It is not the context value itself. See `useContextProvider()` and
     * `useContext()` for the values. Qwik needs a serializable ID for the context so that the it can
     * track context providers and consumers in a way that survives resumability.
     *
     * ### Example
     *
     * ```tsx
     * // Declare the Context type.
     * interface TodosStore {
     *   items: string[];
     * }
     * // Create a Context ID (no data is saved here.)
     * // You will use this ID to both create and retrieve the Context.
     * export const TodosContext = createContextId<TodosStore>('Todos');
     *
     * // Example of providing context to child components.
     * export const App = component$(() => {
     *   useContextProvider(
     *     TodosContext,
     *     useStore<TodosStore>({
     *       items: ['Learn Qwik', 'Build Qwik app', 'Profit'],
     *     })
     *   );
     *
     *   return <Items />;
     * });
     *
     * // Example of retrieving the context provided by a parent component.
     * export const Items = component$(() => {
     *   const todos = useContext(TodosContext);
     *   return (
     *     <ul>
     *       {todos.items.map((item) => (
     *         <li>{item}</li>
     *       ))}
     *     </ul>
     *   );
     * });
     *
     * ```
     *
     * @param name - The name of the context.
     * @public
     */
    // </docs>
    const createContextId = (name) => {
        assertTrue(/^[\w/.-]+$/.test(name), 'Context name must only contain A-Z,a-z,0-9,_,.,-', name);
        return /*#__PURE__*/ Object.freeze({
            id: fromCamelToKebabCase(name),
        });
    };
    // <docs markdown="../readme.md#useContextProvider">
    // !!DO NOT EDIT THIS COMMENT DIRECTLY!!!
    // (edit ../readme.md#useContextProvider instead and run `pnpm docs.sync`)
    /**
     * Assign a value to a Context.
     *
     * Use `useContextProvider()` to assign a value to a context. The assignment happens in the
     * component's function. Once assigned, use `useContext()` in any child component to retrieve the
     * value.
     *
     * Context is a way to pass stores to the child components without prop-drilling. Note that scalar
     * values are allowed, but for reactivity you need signals or stores.
     *
     * ### Example
     *
     * ```tsx
     * // Declare the Context type.
     * interface TodosStore {
     *   items: string[];
     * }
     * // Create a Context ID (no data is saved here.)
     * // You will use this ID to both create and retrieve the Context.
     * export const TodosContext = createContextId<TodosStore>('Todos');
     *
     * // Example of providing context to child components.
     * export const App = component$(() => {
     *   useContextProvider(
     *     TodosContext,
     *     useStore<TodosStore>({
     *       items: ['Learn Qwik', 'Build Qwik app', 'Profit'],
     *     })
     *   );
     *
     *   return <Items />;
     * });
     *
     * // Example of retrieving the context provided by a parent component.
     * export const Items = component$(() => {
     *   const todos = useContext(TodosContext);
     *   return (
     *     <ul>
     *       {todos.items.map((item) => (
     *         <li>{item}</li>
     *       ))}
     *     </ul>
     *   );
     * });
     *
     * ```
     *
     * @param context - The context to assign a value to.
     * @param value - The value to assign to the context.
     * @public
     */
    // </docs>
    const useContextProvider = (context, newValue) => {
        const { val, set, iCtx } = useSequentialScope();
        if (val !== undefined) {
            return;
        }
        if (qDev) {
            validateContext(context);
        }
        if (qDev && qSerialize) {
            verifySerializable(newValue);
        }
        iCtx.$container$.setContext(iCtx.$hostElement$, context, newValue);
        set(1);
    };
    // <docs markdown="../readme.md#useContext">
    // !!DO NOT EDIT THIS COMMENT DIRECTLY!!!
    // (edit ../readme.md#useContext instead and run `pnpm docs.sync`)
    /**
     * Retrieve Context value.
     *
     * Use `useContext()` to retrieve the value of context in a component. To retrieve a value a parent
     * component needs to invoke `useContextProvider()` to assign a value.
     *
     * ### Example
     *
     * ```tsx
     * // Declare the Context type.
     * interface TodosStore {
     *   items: string[];
     * }
     * // Create a Context ID (no data is saved here.)
     * // You will use this ID to both create and retrieve the Context.
     * export const TodosContext = createContextId<TodosStore>('Todos');
     *
     * // Example of providing context to child components.
     * export const App = component$(() => {
     *   useContextProvider(
     *     TodosContext,
     *     useStore<TodosStore>({
     *       items: ['Learn Qwik', 'Build Qwik app', 'Profit'],
     *     })
     *   );
     *
     *   return <Items />;
     * });
     *
     * // Example of retrieving the context provided by a parent component.
     * export const Items = component$(() => {
     *   const todos = useContext(TodosContext);
     *   return (
     *     <ul>
     *       {todos.items.map((item) => (
     *         <li>{item}</li>
     *       ))}
     *     </ul>
     *   );
     * });
     *
     * ```
     *
     * @param context - The context to retrieve a value from.
     * @public
     */
    // </docs>
    const useContext = (context, defaultValue) => {
        const { val, set, iCtx } = useSequentialScope();
        if (val !== undefined) {
            return val;
        }
        if (qDev) {
            validateContext(context);
        }
        const value = iCtx.$container$.resolveContext(iCtx.$hostElement$, context);
        if (typeof defaultValue === 'function') {
            return set(invoke(undefined, defaultValue, value));
        }
        if (value !== undefined) {
            return set(value);
        }
        if (defaultValue !== undefined) {
            return set(defaultValue);
        }
        throw qError(8 /* QError.notFoundContext */, [context.id]);
    };
    const validateContext = (context) => {
        if (!isObject(context) || typeof context.id !== 'string' || context.id.length === 0) {
            throw qError(11 /* QError.invalidContext */, [context]);
        }
    };
    /** @internal */
    const _resolveContextWithoutSequentialScope = (context) => {
        const iCtx = getInvokeContext();
        const hostElement = iCtx.$hostElement$;
        if (!hostElement) {
            return undefined;
        }
        return iCtx.$container$?.resolveContext(hostElement, context);
    };

    const ERROR_CONTEXT = /*#__PURE__*/ createContextId('qk-error');
    const isRecoverable = (err) => {
        if (err && err instanceof Error) {
            if ('plugin' in err) {
                return false;
            }
        }
        return true;
    };

    /** @internal */
    class SubscriptionData {
        data;
        constructor(data) {
            this.data = data;
        }
    }

    // <docs markdown="../readme.md#useLexicalScope">
    // !!DO NOT EDIT THIS COMMENT DIRECTLY!!!
    // (edit ../readme.md#useLexicalScope instead and run `pnpm docs.sync`)
    /**
     * Used by the Qwik Optimizer to restore the lexically scoped variables.
     *
     * This method should not be present in the application source code.
     *
     * NOTE: `useLexicalScope` method can only be used in the synchronous portion of the callback
     * (before any `await` statements.)
     *
     * @internal
     */
    // </docs>
    const useLexicalScope = () => {
        const context = getInvokeContext();
        let qrl = context.$qrl$;
        if (!qrl) {
            const el = context.$element$;
            assertDefined(el, 'invoke: element must be defined inside useLexicalScope()', context);
            const containerElement = _getQContainerElement(el);
            assertDefined(containerElement, `invoke: cant find parent q:container of`, el);
            const container = getDomContainer(containerElement);
            qrl = container.parseQRL(decodeURIComponent(String(context.$url$)));
        }
        else {
            assertQrl(qrl);
            assertDefined(qrl.$captureRef$, 'invoke: qrl $captureRef$ must be defined inside useLexicalScope()', qrl);
        }
        return qrl.$captureRef$;
    };

    /**
     * Handles events for bind:value
     *
     * @internal
     */
    const _val = (_, element) => {
        const [signal] = useLexicalScope();
        signal.value = element.type === 'number' ? element.valueAsNumber : element.value;
    };
    /**
     * Handles events for bind:checked
     *
     * @internal
     */
    const _chk = (_, element) => {
        const [signal] = useLexicalScope();
        signal.value = element.checked;
    };

    const BIND_VALUE = 'bind:value';
    const BIND_CHECKED = 'bind:checked';
    // TODO store props as the arrays the vnodes also use?
    class JSXNodeImpl {
        type;
        toSort;
        key;
        varProps;
        constProps;
        children;
        dev;
        _proxy = null;
        constructor(type, varProps, constProps, children, key, toSort, dev) {
            this.type = type;
            this.toSort = !!toSort;
            this.key = key == null ? null : String(key);
            this.varProps = !varProps || isEmpty(varProps) ? EMPTY_OBJ : varProps;
            this.constProps = !constProps || isEmpty(constProps) ? null : constProps;
            this.children = children;
            if (qDev && dev) {
                this.dev = {
                    ...dev,
                    stack: new Error().stack?.split('\n').slice(2).join('\n'),
                };
            }
            if (typeof type === 'string') {
                // convert onEvent$ to on:event
                for (const k in this.constProps) {
                    const attr = jsxEventToHtmlAttribute(k);
                    if (attr) {
                        mergeHandlers(this.constProps, attr, this.constProps[k]);
                        delete this.constProps[k];
                    }
                }
                for (const k in this.varProps) {
                    const attr = jsxEventToHtmlAttribute(k);
                    if (attr) {
                        // constProps always wins
                        if (!constProps || !(k in constProps)) {
                            toSort = mergeHandlers(this.varProps, attr, this.varProps[k]) || toSort;
                        }
                        delete this.varProps[k];
                    }
                }
                // bind:*
                if (BIND_CHECKED in this.varProps) {
                    toSort = handleBindProp(this.varProps, BIND_CHECKED) || toSort;
                }
                else if (BIND_VALUE in this.varProps) {
                    toSort = handleBindProp(this.varProps, BIND_VALUE) || toSort;
                }
                else if (this.constProps) {
                    if (BIND_CHECKED in this.constProps) {
                        handleBindProp(this.constProps, BIND_CHECKED);
                    }
                    else {
                        if (BIND_VALUE in this.constProps) {
                            handleBindProp(this.constProps, BIND_VALUE);
                        }
                    }
                }
                // TODO let the optimizer do this instead
                if ('className' in this.varProps) {
                    this.varProps.class = this.varProps.className;
                    this.varProps.className = undefined;
                    toSort = true;
                    if (qDev) {
                        logOnceWarn(`jsx${dev ? ` ${dev.fileName}${dev?.lineNumber ? `:${dev.lineNumber}` : ''}` : ''}: \`className\` is deprecated. Use \`class\` instead.`);
                    }
                }
                if (this.constProps && 'className' in this.constProps) {
                    this.constProps.class = this.constProps.className;
                    this.constProps.className = undefined;
                    if (qDev) {
                        logOnceWarn(`jsx${dev ? ` ${dev.fileName}${dev?.lineNumber ? `:${dev.lineNumber}` : ''}` : ''}: \`className\` is deprecated. Use \`class\` instead.`);
                    }
                }
            }
            seal(this);
        }
        get props() {
            // We use a proxy to merge the constProps if they exist and to evaluate derived signals
            return (this._proxy ||= createPropsProxy(this));
        }
    }
    /** @returns `true` if the event is new to the object */
    const mergeHandlers = (obj, event, handler) => {
        let current = obj[event];
        if (current) {
            if (Array.isArray(current)) {
                current.push(handler);
            }
            else {
                current = obj[event] = [current, handler];
            }
        }
        else {
            obj[event] = handler;
            return true;
        }
    };
    /** @internal */
    const isJSXNode = (n) => {
        if (qDev) {
            if (n instanceof JSXNodeImpl) {
                return true;
            }
            if (isObject(n) && 'key' in n && 'props' in n && 'type' in n) {
                logWarn(`Duplicate implementations of "JSXNode" found`);
                return true;
            }
            return false;
        }
        else {
            return n instanceof JSXNodeImpl;
        }
    };
    const isEmpty = (obj) => {
        for (const prop in obj) {
            if (obj[prop] !== undefined) {
                return false;
            }
        }
        return true;
    };
    const handleBindProp = (props, prop) => {
        const value = props[prop];
        props[prop] = undefined;
        if (value) {
            if (prop === BIND_CHECKED) {
                props.checked = value;
                props['on:input'] = createQRL(null, '_chk', _chk, null, null, [value]);
            }
            else {
                props.value = value;
                props['on:input'] = createQRL(null, '_val', _val, null, null, [value]);
            }
            return true;
        }
    };

    /**
     * Create a JSXNode with the properties fully split into variable and constant parts, and children
     * separated out. Furthermore, the varProps must be a sorted object, that is, the keys must be
     * sorted in ascending utf-8 value order.
     *
     * The constant parts are expected to be the same on every render, and are not checked for changes.
     * This means that they are constant scalars or refs. When the ref is a signal or a store, it can
     * still update the attribute on the vnode.
     *
     * @param type - The JSX type
     * @param varProps - The properties of the tag, sorted, excluding children, key and any constProps
     * @param constProps - The properties of the tag that are known to be constant references and don't
     *   need checking for changes on re-render
     * @param children - JSX children. Any `children` in the props objects are ignored.
     * @internal
     */
    const _jsxSorted = (type, varProps, constProps, children, flags, key, dev) => {
        return untrack(() => new JSXNodeImpl(type, varProps, constProps, children, key, false, dev));
    };
    /**
     * Create a JSXNode, with the properties split into variable and constant parts, but the variable
     * parts could include keys from `constProps`, as well as `key` and `children`.
     *
     * `constProps` cannot include `key` or `children`. The constant parts are expected to be the same
     * on every render, and are not checked for changes. This means that they are constant scalars or
     * refs. When the ref is a signal or a store, it can still update the attribute on the vnode.
     *
     * If `children` or `key` are defined, any `children`/`key` in the props will be ignored.
     *
     * @param type - The tag type
     * @param varProps - The properties of the tag that could change, including children
     * @param constProps - The properties of the tag that are known to be static and don't need checking
     *   for changes on re-render
     * @internal
     */
    const _jsxSplit = (type, varProps, constProps, children, flags, key, dev) => {
        return untrack(() => {
            if (varProps) {
                for (const k in varProps) {
                    if (k === 'children') {
                        children ||= varProps.children;
                        varProps.children = undefined;
                    }
                    else if (k === 'key') {
                        key ||= varProps.key;
                        varProps.key = undefined;
                    }
                    else if (constProps && k in constProps) {
                        varProps[k] = undefined;
                    }
                }
            }
            return new JSXNodeImpl(type, varProps, constProps, children, key, true, dev);
        });
    };
    /** @internal @deprecated v1 compat */
    const _jsxC = (type, mutable, _flags, key) => jsx(type, mutable, key);
    /** @internal @deprecated v1 compat */
    const _jsxS = (type, mutable, immutable, _flags, key) => jsx(type, { ...immutable, ...mutable }, key);
    /** @internal @deprecated v1 compat */
    const _jsxQ = (type, mutable, immutable, children, _flags, key) => jsx(type, { ...immutable, ...mutable, children }, key); /** @private */
    const Virtual = (props) => props.children;

    /**
     * Used by the JSX transpilers to create a JSXNode. Note that the optimizer will normally not use
     * this, instead using _jsxSplit and _jsxSorted directly.
     *
     * The optimizer will also replace all `jsx()` calls with the more optimized versions.
     *
     * The exception is when the props are not a literal object, which can only happen when the `jsx`
     * call is written directly.
     *
     * @public
     */
    const jsx = (type, props, key, _isStatic, dev) => {
        return _jsxSplit(type, props, null, null, 0, key, dev);
    };
    /**
     * Alias of `jsx` for development purposes.
     *
     * @public
     */
    const jsxDEV = jsx;
    /**
     * Alias of `jsx` to support JSX syntax.
     *
     * @public
     */
    const jsxs = jsx;
    /**
     * The legacy transform, used by some JSX transpilers. The optimizer normally replaces this with
     * optimized calls, with the same caveat as `jsx()`.
     *
     * @public
     */
    function h(type, props, ...children) {
        const normalizedProps = {
            children: arguments.length > 2 ? children.flat(100) : null,
        };
        let key = null;
        for (const i in props) {
            if (i == 'key') {
                key = props[i];
            }
            else {
                normalizedProps[i] = props[i];
            }
        }
        if (typeof type === 'string' && !key && 'dangerouslySetInnerHTML' in normalizedProps) {
            key = 'innerhtml';
        }
        return _jsxSplit(type, props, null, normalizedProps.children, 0, key);
    }
    /** @public */
    const Fragment = (props) => props.children;
    /** @public */
    const RenderOnce = (props, key) => {
        return new JSXNodeImpl(Virtual, null, null, props.children, key);
    };

    /** @internal */
    const useTaskQrl = (qrl) => {
        const { val, set, iCtx, i } = useSequentialScope();
        if (val) {
            return;
        }
        assertQrl(qrl);
        set(1);
        const task = new Task(8 /* TaskFlags.DIRTY */ | 2 /* TaskFlags.TASK */, i, iCtx.$hostElement$, qrl, undefined, null);
        // In V2 we add the task to the sequential scope. We need to do this
        // in order to be able to retrieve it later when the parent element is
        // deleted and we need to be able to release the task subscriptions.
        set(task);
        const container = iCtx.$container$;
        const result = runTask(task, container, iCtx.$hostElement$);
        if (isPromise(result)) {
            throw result;
        }
    };
    const runTask = (task, container, host) => {
        task.$flags$ &= -9 /* TaskFlags.DIRTY */;
        cleanupTask(task);
        const iCtx = newInvokeContext(container.$locale$, host, undefined, TaskEvent);
        iCtx.$container$ = container;
        const taskFn = task.$qrl$.getFn(iCtx, () => clearAllEffects(container, task));
        const track = trackFn(task, container);
        const [cleanup] = cleanupFn(task, (reason) => container.handleError(reason, host));
        const taskApi = { track, cleanup };
        return safeCall(() => taskFn(taskApi), cleanup, (err) => {
            // If a Promise is thrown, that means we need to re-run the task.
            if (isPromise(err)) {
                return err.then(() => runTask(task, container, host));
            }
            else {
                throw err;
            }
        });
    };
    const cleanupTask = (task) => {
        const destroy = task.$destroy$;
        if (destroy) {
            task.$destroy$ = null;
            try {
                destroy();
            }
            catch (err) {
                logError(err);
            }
        }
    };
    class Task extends BackRef$1 {
        $flags$;
        $index$;
        $el$;
        $qrl$;
        $state$;
        $destroy$;
        constructor($flags$, $index$, $el$, $qrl$, $state$, $destroy$) {
            super();
            this.$flags$ = $flags$;
            this.$index$ = $index$;
            this.$el$ = $el$;
            this.$qrl$ = $qrl$;
            this.$state$ = $state$;
            this.$destroy$ = $destroy$;
        }
    }
    /** @internal */
    const isTask = (value) => {
        return value instanceof Task;
    };
    /**
     * Used internally as a qrl event handler to schedule a task.
     *
     * @internal
     */
    const scheduleTask = (_event, element) => {
        const [task] = useLexicalScope();
        const type = task.$flags$ & 1 /* TaskFlags.VISIBLE_TASK */ ? 16 /* ChoreType.VISIBLE */ : 3 /* ChoreType.TASK */;
        const container = getDomContainer(element);
        container.$scheduler$(type, task);
    };

    /** @internal */
    const useResourceQrl = (qrl, opts) => {
        const { val, set, i, iCtx } = useSequentialScope();
        if (val != null) {
            return val;
        }
        assertQrl(qrl);
        const container = iCtx.$container$;
        const resource = createResourceReturn(container, opts);
        const el = iCtx.$hostElement$;
        const task = new Task(8 /* TaskFlags.DIRTY */ | 4 /* TaskFlags.RESOURCE */, i, el, qrl, resource, null);
        set(resource);
        runResource(task, container, el);
        return resource;
    };
    // <docs markdown="../readme.md#useResource">
    // !!DO NOT EDIT THIS COMMENT DIRECTLY!!!
    // (edit ../readme.md#useResource instead and run `pnpm docs.sync`)
    /**
     * This method works like an async memoized function that runs whenever some tracked value changes
     * and returns some data.
     *
     * `useResource` however returns immediate a `ResourceReturn` object that contains the data and a
     * state that indicates if the data is available or not.
     *
     * The status can be one of the following:
     *
     * - `pending` - the data is not yet available.
     * - `resolved` - the data is available.
     * - `rejected` - the data is not available due to an error or timeout.
     *
     * Be careful when using a `try/catch` statement in `useResource$`. If you catch the error and don't
     * re-throw it (or a new Error), the resource status will never be `rejected`.
     *
     * ### Example
     *
     * Example showing how `useResource` to perform a fetch to request the weather, whenever the input
     * city name changes.
     *
     * ```tsx
     * const Cmp = component$(() => {
     *   const cityS = useSignal('');
     *
     *   const weatherResource = useResource$(async ({ track, cleanup }) => {
     *     const cityName = track(cityS);
     *     const abortController = new AbortController();
     *     cleanup(() => abortController.abort('cleanup'));
     *     const res = await fetch(`http://weatherdata.com?city=${cityName}`, {
     *       signal: abortController.signal,
     *     });
     *     const data = await res.json();
     *     return data as { temp: number };
     *   });
     *
     *   return (
     *     <div>
     *       <input name="city" bind:value={cityS} />
     *       <Resource
     *         value={weatherResource}
     *         onResolved={(weather) => {
     *           return <div>Temperature: {weather.temp}</div>;
     *         }}
     *       />
     *     </div>
     *   );
     * });
     * ```
     *
     * @public
     * @see Resource
     * @see ResourceReturn
     */
    // </docs>
    const Resource = (props) => {
        // Resource path
        return _jsxSorted(Fragment, null, null, getResourceValueAsPromise(props), 0, null);
    };
    function getResourceValueAsPromise(props) {
        const resource = props.value;
        if (isResourceReturn(resource)) {
            // create a subscription for the resource._state changes
            const state = resource._state;
            const isBrowser = !isServerPlatform();
            if (isBrowser) {
                if (state === 'pending' && props.onPending) {
                    return Promise.resolve().then(useBindInvokeContext(props.onPending));
                }
                else if (state === 'rejected' && props.onRejected) {
                    return Promise.resolve(resource._error).then(useBindInvokeContext(props.onRejected));
                }
                else {
                    const resolvedValue = untrack(() => resource._resolved);
                    if (resolvedValue !== undefined) {
                        // resolved, pending without onPending prop or rejected without onRejected prop
                        return Promise.resolve(resolvedValue).then(useBindInvokeContext(props.onResolved));
                    }
                }
            }
            return untrack(() => resource.value).then(useBindInvokeContext(props.onResolved), useBindInvokeContext(props.onRejected));
        }
        else if (isPromise(resource)) {
            return resource.then(useBindInvokeContext(props.onResolved), useBindInvokeContext(props.onRejected));
        }
        else if (isSignal(resource)) {
            const value = retryOnPromise(() => resource.value);
            const promise = isPromise(value) ? value : Promise.resolve(value);
            return promise.then(useBindInvokeContext(props.onResolved));
        }
        else {
            return Promise.resolve(resource).then(useBindInvokeContext(props.onResolved));
        }
    }
    const _createResourceReturn = (opts) => {
        const resource = {
            __brand: 'resource',
            value: undefined,
            loading: !isServerPlatform(),
            _resolved: undefined,
            _error: undefined,
            _state: 'pending',
            _timeout: opts?.timeout ?? -1,
            _cache: 0,
        };
        return resource;
    };
    const createResourceReturn = (container, opts, initialPromise) => {
        const result = _createResourceReturn(opts);
        result.value = initialPromise;
        return createStore(container, result, 1 /* StoreFlags.RECURSIVE */);
    };
    const isResourceReturn = (obj) => {
        return isObject(obj) && (getStoreTarget(obj) || obj).__brand === 'resource';
    };
    const runResource = (task, container, host) => {
        task.$flags$ &= -9 /* TaskFlags.DIRTY */;
        cleanupTask(task);
        const iCtx = newInvokeContext(container.$locale$, host, undefined, ResourceEvent);
        iCtx.$container$ = container;
        const taskFn = task.$qrl$.getFn(iCtx, () => clearAllEffects(container, task));
        const resource = task.$state$;
        assertDefined(resource, 'useResource: when running a resource, "task.resource" must be a defined.', task);
        const track = trackFn(task, container);
        const [cleanup, cleanups] = cleanupFn(task, (reason) => container.handleError(reason, host));
        const resourceTarget = unwrapStore(resource);
        const opts = {
            track,
            cleanup,
            cache(policy) {
                let milliseconds = 0;
                if (policy === 'immutable') {
                    milliseconds = Infinity;
                }
                else {
                    milliseconds = policy;
                }
                resource._cache = milliseconds;
            },
            previous: resourceTarget._resolved,
        };
        let resolve;
        let reject;
        let done = false;
        const setState = (resolved, value) => {
            if (!done) {
                done = true;
                if (resolved) {
                    done = true;
                    resourceTarget.loading = false;
                    resourceTarget._state = 'resolved';
                    resourceTarget._resolved = value;
                    resourceTarget._error = undefined;
                    resolve(value);
                }
                else {
                    done = true;
                    resourceTarget.loading = false;
                    resourceTarget._state = 'rejected';
                    resourceTarget._error = value;
                    reject(value);
                }
                if (!isServerPlatform()) {
                    forceStoreEffects(resource, '_state');
                }
                return true;
            }
            return false;
        };
        /**
         * Add cleanup to resolve the resource if we are trying to run the same resource again while the
         * previous one is not resolved yet. The next `runResource` run will call this cleanup
         */
        cleanups.push(() => {
            if (untrack(() => resource.loading) === true) {
                const value = untrack(() => resource._resolved);
                setState(true, value);
            }
        });
        // Execute mutation inside empty invocation
        // TODO: is it right? why we need to invoke inside context and trigger effects?
        invoke(iCtx, () => {
            // console.log('RESOURCE.pending: ');
            resource._state = 'pending';
            resource.loading = !isServerPlatform();
            resource.value = new Promise((r, re) => {
                resolve = r;
                reject = re;
            });
        });
        const promise = safeCall(() => taskFn(opts), (value) => {
            setState(true, value);
        }, (err) => {
            if (isPromise(err)) {
                return err.then(() => runResource(task, container, host));
            }
            else {
                setState(false, err);
            }
        });
        const timeout = resourceTarget._timeout;
        if (timeout > 0) {
            return Promise.race([
                promise,
                delay(timeout).then(() => {
                    if (setState(false, new Error('timeout'))) {
                        cleanupTask(task);
                    }
                }),
            ]);
        }
        return promise;
    };

    /**
     * Allows to project the children of the current component. `<Slot/>` can only be used within the
     * context of a component defined with `component$`.
     *
     * @public
     */
    const Slot = (props) => {
        return _jsxSorted(Virtual, null, { [QSlotS]: '' }, props.children, 0, props.name ?? '');
    };

    // Used for allocate, make sure they are in sync with Constants
    const _constants = [
        undefined,
        null,
        true,
        false,
        '',
        EMPTY_ARRAY,
        EMPTY_OBJ,
        NEEDS_COMPUTATION,
        STORE_ALL_PROPS,
        _UNINITIALIZED,
        Slot,
        Fragment,
        NaN,
        Infinity,
        -Infinity,
        Number.MAX_SAFE_INTEGER,
        Number.MAX_SAFE_INTEGER - 1,
        Number.MIN_SAFE_INTEGER,
    ];
    // Used for dumpState, make sure they are in sync with Constants
    const _constantNames = [
        'undefined',
        'null',
        'true',
        'false',
        "''",
        'EMPTY_ARRAY',
        'EMPTY_OBJ',
        'NEEDS_COMPUTATION',
        'STORE_ALL_PROPS',
        '_UNINITIALIZED',
        'Slot',
        'Fragment',
        'NaN',
        'Infinity',
        '-Infinity',
        'MAX_SAFE_INTEGER',
        'MAX_SAFE_INTEGER-1',
        'MIN_SAFE_INTEGER',
    ];
    // Used for dumpState, make sure they are in sync with TypeIds
    const _typeIdNames = [
        'Plain',
        'RootRef',
        'ForwardRef',
        'Constant',
        'Array',
        'Object',
        'URL',
        'Date',
        'Regex',
        'VNode',
        'RefVNode',
        'BigInt',
        'URLSearchParams',
        'ForwardRefs',
        'Error',
        'Promise',
        'Set',
        'Map',
        'Uint8Array',
        'QRL',
        'PreloadQRL',
        'Task',
        'Resource',
        'Component',
        'Signal',
        'WrappedSignal',
        'ComputedSignal',
        'AsyncComputedSignal',
        'SerializerSignal',
        'Store',
        'FormData',
        'JSXNode',
        'PropsProxy',
        'SubscriptionData',
    ];

    function qrlToString(serializationContext, value, raw) {
        let symbol = value.$symbol$;
        let chunk = value.$chunk$;
        const platform = getPlatform();
        if (platform) {
            const result = platform.chunkForSymbol(symbol, chunk, value.dev?.file);
            if (result) {
                chunk = result[1];
                symbol = result[0];
            }
        }
        const isSync = isSyncQrl(value);
        if (!isSync) {
            // If we have a symbol we need to resolve the chunk.
            if (!chunk) {
                chunk = serializationContext.$symbolToChunkResolver$(value.$hash$);
            }
            // in Dev mode we need to keep track of the symbols
            if (build.isDev) {
                const backChannel = (globalThis.__qrl_back_channel__ ||=
                    new Map());
                // During tests the resolved value is always available
                backChannel.set(value.$symbol$, value.resolved);
                if (!chunk) {
                    chunk = QRL_RUNTIME_CHUNK;
                }
            }
            if (!chunk) {
                throw qError(14 /* QError.qrlMissingChunk */, [value.$symbol$]);
            }
            if (chunk.startsWith('./')) {
                chunk = chunk.slice(2);
            }
        }
        else {
            const fn = value.resolved;
            chunk = '';
            // TODO test that provided stringified fn is used
            symbol = String(serializationContext.$addSyncFn$(null, 0, fn));
        }
        if (!value.$capture$ && Array.isArray(value.$captureRef$) && value.$captureRef$.length > 0) {
            // We refer by id so every capture needs to be a root
            value.$capture$ = value.$captureRef$.map((ref) => `${serializationContext.$addRoot$(ref)}`);
        }
        if (raw) {
            return [chunk, symbol, value.$capture$];
        }
        let qrlStringInline = `${chunk}#${symbol}`;
        if (value.$capture$ && value.$capture$.length > 0) {
            qrlStringInline += `[${value.$capture$.join(' ')}]`;
        }
        return qrlStringInline;
    }
    function createQRLWithBackChannel(chunk, symbol, captureIds) {
        let qrlRef = null;
        if (build.isDev && chunk === QRL_RUNTIME_CHUNK) {
            const backChannel = globalThis.__qrl_back_channel__;
            assertDefined(backChannel, 'Missing QRL_RUNTIME_CHUNK');
            qrlRef = backChannel.get(symbol);
        }
        return createQRL(chunk, symbol, qrlRef, null, captureIds, null);
    }
    /** Parses "chunk#hash[...rootRef]" */
    function parseQRL(qrl) {
        const hashIdx = qrl.indexOf('#');
        const captureStart = qrl.indexOf('[', hashIdx);
        const captureEnd = qrl.indexOf(']', captureStart);
        const chunk = hashIdx > -1 ? qrl.slice(0, hashIdx) : qrl.slice(0, captureStart);
        const symbol = captureStart > -1 ? qrl.slice(hashIdx + 1, captureStart) : qrl.slice(hashIdx + 1);
        const captureIds = captureStart > -1 && captureEnd > -1
            ? qrl
                .slice(captureStart + 1, captureEnd)
                .split(' ')
                .filter((v) => v.length)
                .map((s) => parseInt(s, 10))
            : null;
        return createQRLWithBackChannel(chunk, symbol, captureIds);
    }
    const QRL_RUNTIME_CHUNK = 'mock-chunk';

    const resolvers = new WeakMap();
    const pendingStoreTargets = new Map();
    const allocate = (container, typeId, value) => {
        switch (typeId) {
            case 0 /* TypeIds.Plain */:
                return value;
            case 1 /* TypeIds.RootRef */:
                return container.$getObjectById$(value);
            case 2 /* TypeIds.ForwardRef */:
                if (!container.$forwardRefs$) {
                    return _UNINITIALIZED;
                }
                const rootRef = container.$forwardRefs$[value];
                if (rootRef === -1 || rootRef === undefined) {
                    return _UNINITIALIZED;
                }
                else {
                    return container.$getObjectById$(rootRef);
                }
            case 13 /* TypeIds.ForwardRefs */:
                return value;
            case 3 /* TypeIds.Constant */:
                return _constants[value];
            case 4 /* TypeIds.Array */:
                return Array(value.length / 2);
            case 5 /* TypeIds.Object */:
                return {};
            case 19 /* TypeIds.QRL */:
            case 20 /* TypeIds.PreloadQRL */: {
                if (typeof value === 'string') {
                    const data = value.split(' ').map(Number);
                    const chunk = container.$getObjectById$(data[0]);
                    const symbol = container.$getObjectById$(data[1]);
                    const captureIds = data.length > 2 ? data.slice(2) : null;
                    return createQRLWithBackChannel(chunk, symbol, captureIds);
                }
                else {
                    return createQRLWithBackChannel('', String(value));
                }
            }
            case 21 /* TypeIds.Task */:
                return new Task(-1, -1, null, null, null, null);
            case 22 /* TypeIds.Resource */: {
                const res = createResourceReturn(container, 
                // we don't care about the timeout value
                undefined, undefined);
                res.loading = false;
                return res;
            }
            case 6 /* TypeIds.URL */:
                return new URL(value);
            case 7 /* TypeIds.Date */:
                return new Date(value);
            case 8 /* TypeIds.Regex */:
                const idx = value.lastIndexOf('/');
                return new RegExp(value.slice(1, idx), value.slice(idx + 1));
            case 14 /* TypeIds.Error */:
                return new Error();
            case 23 /* TypeIds.Component */:
                return componentQrl(null);
            case 24 /* TypeIds.Signal */:
                return new SignalImpl(container, 0);
            case 25 /* TypeIds.WrappedSignal */:
                return new WrappedSignalImpl(container, null, null, null);
            case 26 /* TypeIds.ComputedSignal */:
                return new ComputedSignalImpl(container, null);
            case 27 /* TypeIds.AsyncComputedSignal */:
                return new AsyncComputedSignalImpl(container, null);
            case 28 /* TypeIds.SerializerSignal */:
                return new SerializerSignalImpl(container, null);
            case 29 /* TypeIds.Store */: {
                const data = value;
                // We need to allocate the store first, before we inflate its data, because the data can
                // reference the store itself (circular)
                // Note: the actual store data will be inflated in inflate()
                const t = data[0];
                const v = data[1];
                const storeValue = allocate(container, t, v);
                const store = getOrCreateStore(storeValue, 0 /* StoreFlags.NONE */, container);
                if (needsInflation(t)) {
                    pendingStoreTargets.set(storeValue, { t, v });
                }
                // We must store the reference so it doesn't get deserialized again in inflate()
                data[0] = 0 /* TypeIds.Plain */;
                data[1] = storeValue;
                return store;
            }
            case 12 /* TypeIds.URLSearchParams */:
                return new URLSearchParams(value);
            case 30 /* TypeIds.FormData */:
                return new FormData();
            case 31 /* TypeIds.JSXNode */:
                return new JSXNodeImpl(null);
            case 11 /* TypeIds.BigInt */:
                return BigInt(value);
            case 16 /* TypeIds.Set */:
                return new Set();
            case 17 /* TypeIds.Map */:
                return new Map();
            case 15 /* TypeIds.Promise */:
                let resolve;
                let reject;
                const promise = new Promise((res, rej) => {
                    resolve = res;
                    reject = rej;
                });
                resolvers.set(promise, [resolve, reject]);
                // Don't leave unhandled promise rejections
                promise.catch(() => { });
                return promise;
            case 18 /* TypeIds.Uint8Array */:
                const encodedLength = value.length;
                const blocks = encodedLength >>> 2;
                const rest = encodedLength & 3;
                const decodedLength = blocks * 3 + (rest ? rest - 1 : 0);
                return new Uint8Array(decodedLength);
            case 32 /* TypeIds.PropsProxy */:
                return createPropsProxy(null);
            case 9 /* TypeIds.VNode */:
                return retrieveVNodeOrDocument(container, value);
            case 10 /* TypeIds.RefVNode */:
                const vNode = retrieveVNodeOrDocument(container, value);
                if (vnode_isVNode(vNode)) {
                    /**
                     * If we have a ref, we need to ensure the element is materialized.
                     *
                     * Example:
                     *
                     * ```
                     * const Cmp = component$(() => {
                     *       const element = useSignal<HTMLDivElement>();
                     *
                     *       useVisibleTask$(() => {
                     *         element.value!.innerHTML = 'I am the innerHTML content!';
                     *       });
                     *
                     *       return (
                     *          <div ref={element} />
                     *       );
                     * });
                     * ```
                     *
                     * If we don't materialize early element with ref property, and change element innerHTML it
                     * will be applied to a vnode tree during the lazy materialization, and it is wrong.
                     *
                     * Next if we rerender component it will remove applied innerHTML, because the system thinks
                     * it is a part of the vnode tree.
                     */
                    ensureMaterialized(vNode);
                    return vnode_getNode(vNode);
                }
                else {
                    throw qError(17 /* QError.serializeErrorExpectedVNode */, [typeof vNode]);
                }
            case 33 /* TypeIds.SubscriptionData */:
                return new SubscriptionData({});
            default:
                throw qError(18 /* QError.serializeErrorCannotAllocate */, [typeId]);
        }
    };
    function retrieveVNodeOrDocument(container, value) {
        return value
            ? container.rootVNode
                ? vnode_locate(container.rootVNode, value)
                : undefined
            : container.element?.ownerDocument;
    }

    // https://regexr.com/68v72
    // @ts-expect-error this is a valid regex
    const EXTRACT_IMPORT_PATH = /\(\s*(['"])([^\1]+)\1\s*\)/;
    // https://regexr.com/690ds
    const EXTRACT_SELF_IMPORT = /Promise\s*\.\s*resolve/;
    // https://regexr.com/6a83h
    const EXTRACT_FILE_NAME = /[\\/(]([\w\d.\-_]+\.(js|ts)x?):/;
    // <docs markdown="../../readme.md#qrl">
    // !!DO NOT EDIT THIS COMMENT DIRECTLY!!!
    // (edit ../../readme.md#qrl instead and run `pnpm docs.sync`)
    /**
     * Used by Qwik Optimizer to point to lazy-loaded resources.
     *
     * This function should be used by the Qwik Optimizer only. The function should not be directly
     * referred to in the source code of the application.
     *
     * @param chunkOrFn - Chunk name (or function which is stringified to extract chunk name)
     * @param symbol - Symbol to lazy load
     * @param lexicalScopeCapture - A set of lexically scoped variables to capture.
     * @public
     * @see `QRL`, `$(...)`
     */
    // </docs>
    const qrl = (chunkOrFn, symbol, lexicalScopeCapture = EMPTY_ARRAY, stackOffset = 0) => {
        let chunk = null;
        let symbolFn = null;
        if (isFunction(chunkOrFn)) {
            symbolFn = chunkOrFn;
            if (qSerialize) {
                let match;
                const srcCode = String(chunkOrFn);
                if ((match = srcCode.match(EXTRACT_IMPORT_PATH)) && match[2]) {
                    chunk = match[2];
                }
                else if ((match = srcCode.match(EXTRACT_SELF_IMPORT))) {
                    const ref = 'QWIK-SELF';
                    const frames = new Error(ref).stack.split('\n');
                    const start = frames.findIndex((f) => f.includes(ref));
                    const frame = frames[start + 2 + stackOffset];
                    match = frame.match(EXTRACT_FILE_NAME);
                    if (!match) {
                        chunk = 'main';
                    }
                    else {
                        chunk = match[1];
                    }
                }
                else {
                    throw qError(6 /* QError.dynamicImportFailed */, [srcCode]);
                }
            }
        }
        else if (isString(chunkOrFn)) {
            chunk = chunkOrFn;
        }
        else {
            throw qError(7 /* QError.unknownTypeArgument */, [chunkOrFn]);
        }
        // Unwrap subscribers
        return createQRL(chunk, symbol, null, symbolFn, null, lexicalScopeCapture);
    };
    /**
     * Create an inlined QRL. This is mostly useful on the server side for serialization.
     *
     * @param symbol - The object/function to register, or `null` to retrieve a previously registered
     *   one by hash
     * @param symbolName - The name of the symbol.
     * @param lexicalScopeCapture - A set of lexically scoped variables to capture.
     * @public
     */
    const inlinedQrl = (symbol, symbolName, lexicalScopeCapture = EMPTY_ARRAY) => {
        // Unwrap subscribers
        return createQRL(null, symbolName, symbol, null, null, lexicalScopeCapture);
    };
    /** @internal */
    const _noopQrl = (symbolName, lexicalScopeCapture = EMPTY_ARRAY) => {
        return createQRL(null, symbolName, null, null, null, lexicalScopeCapture);
    };
    /** @internal */
    const _noopQrlDEV = (symbolName, opts, lexicalScopeCapture = EMPTY_ARRAY) => {
        const newQrl = _noopQrl(symbolName, lexicalScopeCapture);
        newQrl.dev = opts;
        return newQrl;
    };
    /** @internal */
    const qrlDEV = (chunkOrFn, symbol, opts, lexicalScopeCapture = EMPTY_ARRAY) => {
        const newQrl = qrl(chunkOrFn, symbol, lexicalScopeCapture, 1);
        newQrl.dev = opts;
        return newQrl;
    };
    /** @internal */
    const inlinedQrlDEV = (symbol, symbolName, opts, lexicalScopeCapture = EMPTY_ARRAY) => {
        const qrl = inlinedQrl(symbol, symbolName, lexicalScopeCapture);
        qrl.dev = opts;
        return qrl;
    };
    /**
     * Register a QRL symbol globally for lookup by its hash. This is used by the optimizer to register
     * the names passed in `reg_ctx_name`.
     *
     * @internal
     */
    const _regSymbol = (symbol, hash) => {
        if (typeof globalThis.__qwik_reg_symbols === 'undefined') {
            globalThis.__qwik_reg_symbols = new Map();
        }
        globalThis.__qwik_reg_symbols.set(hash, symbol);
        return symbol;
    };

    /**
     * Use `executeComponent` to execute a component.
     *
     * Component execution can be complex because of:
     *
     * - It can by async
     * - It can contain many tasks which need to be awaited
     * - Each task can run multiple times if they track signals which change.
     * - The JSX may be re-generated multiple times of a task needs to be rerun due to signal change.
     * - It needs to keep track of hook state.
     *
     * For `component$`: `renderHost` === `subscriptionHost` For inlined-components: the
     * `subscriptionHost` is a parent `component$` which needs to re-execute.
     *
     * @param container
     * @param renderHost - VNode into which the component is rendered into.
     * @param subscriptionHost - VNode which will be re-executed if the component needs to re-render.
     * @param componentQRL
     * @param props
     * @returns
     */
    const executeComponent = (container, renderHost, subscriptionHost, componentQRL, props) => {
        const iCtx = newInvokeContext(container.$locale$, subscriptionHost || undefined, undefined, RenderEvent);
        if (subscriptionHost) {
            iCtx.$effectSubscriber$ = getSubscriber(subscriptionHost, ":" /* EffectProperty.COMPONENT */);
            iCtx.$container$ = container;
        }
        let componentFn;
        container.ensureProjectionResolved(renderHost);
        let isInlineComponent = false;
        if (componentQRL === null) {
            componentQRL = container.getHostProp(renderHost, OnRenderProp);
            assertDefined(componentQRL, 'No Component found at this location');
        }
        if (isQrl(componentQRL)) {
            props = props || container.getHostProp(renderHost, ELEMENT_PROPS) || EMPTY_OBJ;
            if ('children' in props) {
                delete props.children;
            }
            componentFn = componentQRL.getFn(iCtx);
        }
        else if (isQwikComponent(componentQRL)) {
            const qComponentFn = componentQRL;
            componentFn = () => invokeApply(iCtx, qComponentFn, [props || EMPTY_OBJ, null, 0]);
        }
        else {
            isInlineComponent = true;
            const inlineComponent = componentQRL;
            componentFn = () => invokeApply(iCtx, inlineComponent, [props || EMPTY_OBJ]);
        }
        const executeComponentWithPromiseExceptionRetry = (retryCount = 0) => safeCall(() => {
            if (!isInlineComponent) {
                container.setHostProp(renderHost, ELEMENT_SEQ_IDX, null);
                container.setHostProp(renderHost, USE_ON_LOCAL_SEQ_IDX, null);
            }
            if (retryCount > 0 && vnode_isVNode(renderHost)) {
                clearAllEffects(container, renderHost);
            }
            return componentFn(props);
        }, (jsx) => {
            const useOnEvents = container.getHostProp(renderHost, USE_ON_LOCAL);
            if (useOnEvents) {
                return addUseOnEvents(jsx, useOnEvents);
            }
            return jsx;
        }, (err) => {
            if (isPromise(err) && retryCount < MAX_RETRY_ON_PROMISE_COUNT) {
                return err.then(() => executeComponentWithPromiseExceptionRetry(++retryCount));
            }
            else {
                if (retryCount >= MAX_RETRY_ON_PROMISE_COUNT) {
                    throw new Error(`Max retry count of component execution reached`);
                }
                throw err;
            }
        });
        return executeComponentWithPromiseExceptionRetry();
    };
    /**
     * Adds `useOn` events to the JSX output.
     *
     * @param jsx The JSX output to modify.
     * @param useOnEvents The `useOn` events to add.
     * @returns The modified JSX output.
     */
    function addUseOnEvents(jsx, useOnEvents) {
        const jsxElement = findFirstElementNode(jsx);
        let jsxResult = jsx;
        const qVisibleEvent = 'on:qvisible';
        return maybeThen(jsxElement, (jsxElement) => {
            // headless components are components that don't render a real DOM element
            const isHeadless = !jsxElement;
            // placeholder element is a <script> element that is used to add events to the document or window
            let placeholderElement = null;
            for (const key in useOnEvents) {
                if (Object.prototype.hasOwnProperty.call(useOnEvents, key)) {
                    let targetElement = jsxElement;
                    let eventKey = key;
                    if (isHeadless) {
                        // if the component is headless, we need to add the event to the placeholder element
                        if (key === qVisibleEvent ||
                            key.startsWith("on-document:" /* EventNameHtmlScope.document */) ||
                            key.startsWith("on-window:" /* EventNameHtmlScope.window */)) {
                            if (!placeholderElement) {
                                const [createdElement, newJsx] = injectPlaceholderElement(jsxResult);
                                jsxResult = newJsx;
                                placeholderElement = createdElement;
                            }
                            targetElement = placeholderElement;
                        }
                        else {
                            if (build.isDev) {
                                logWarn('You are trying to add an event "' +
                                    key +
                                    '" using `useOn` hook, ' +
                                    'but a node to which you can add an event is not found. ' +
                                    'Please make sure that the component has a valid element node. ');
                            }
                            continue;
                        }
                    }
                    if (targetElement) {
                        if (targetElement.type === 'script' && key === qVisibleEvent) {
                            eventKey = 'on-document:qinit';
                            if (build.isDev) {
                                logWarn('You are trying to add an event "' +
                                    key +
                                    '" using the `useVisibleTask$` hook with the "intersection-observer" strategy, ' +
                                    'but a node to which you can add an event is not found. ' +
                                    'Using "document-ready" or "document-idle" instead.');
                            }
                        }
                        addUseOnEvent(targetElement, eventKey, useOnEvents[key]);
                    }
                }
            }
            return jsxResult;
        });
    }
    /**
     * Adds an event to the JSX element.
     *
     * @param jsxElement The JSX element to add the event to.
     * @param key The event name.
     * @param value The event value.
     */
    function addUseOnEvent(jsxElement, key, value) {
        // These handlers are always there, so they go in constProps
        const props = (jsxElement.constProps ||= {});
        const propValue = props[key];
        if (propValue == null) {
            props[key] = value;
        }
        else if (Array.isArray(propValue)) {
            propValue.push(...value);
        }
        else {
            props[key] = [propValue, ...value];
        }
        const varProp = jsxElement.varProps[key];
        if (varProp) {
            // we need to demote the handlers to varProps
            if (Array.isArray(propValue)) {
                propValue.push(...props[key]);
            }
            else {
                jsxElement.varProps[key] = [propValue, ...value];
            }
            props[key] = undefined;
        }
    }
    /**
     * Finds the first element node in the JSX output.
     *
     * @param jsx The JSX output to search.
     * @returns The first element node or null if no element node is found.
     */
    function findFirstElementNode(jsx) {
        const queue = [jsx];
        while (queue.length) {
            const jsx = queue.shift();
            if (isJSXNode(jsx)) {
                if (typeof jsx.type === 'string') {
                    return jsx;
                }
                queue.push(jsx.children);
            }
            else if (isArray(jsx)) {
                queue.push(...jsx);
            }
            else if (isPromise(jsx)) {
                return maybeThen(jsx, (jsx) => findFirstElementNode(jsx));
            }
            else if (isSignal(jsx)) {
                return findFirstElementNode(untrack(() => jsx.value));
            }
        }
        return null;
    }
    /**
     * Injects a placeholder <script> element into the JSX output.
     *
     * This is necessary for headless components (components that don't render a real DOM element) to
     * have an anchor point for `useOn` event listeners that target the document or window.
     *
     * @param jsx The JSX output to modify.
     * @returns A tuple containing the created placeholder element and the modified JSX output.
     */
    function injectPlaceholderElement(jsx) {
        // For regular JSX nodes, we can append the placeholder to its children.
        if (isJSXNode(jsx)) {
            const placeholder = createPlaceholderScriptNode();
            // Inline components don't always render children, so we wrap them in Fragment which does.
            if (jsx.type !== Fragment && !isQwikComponent(jsx.type)) {
                return [placeholder, _jsxSorted(Fragment, null, null, [jsx, placeholder], 0, null)];
            }
            if (jsx.children == null) {
                jsx.children = placeholder;
            }
            else if (isArray(jsx.children)) {
                jsx.children.push(placeholder);
            }
            else {
                jsx.children = [jsx.children, placeholder];
            }
            return [placeholder, jsx];
        }
        // For primitives, we can't add children, so we wrap them in a fragment.
        if (isPrimitive(jsx)) {
            const placeholder = createPlaceholderScriptNode();
            return [placeholder, _jsxSorted(Fragment, null, null, [jsx, placeholder], 0, null)];
        }
        // For an array of nodes, we inject the placeholder into the first element.
        if (isArray(jsx) && jsx.length > 0) {
            const [createdElement, _] = injectPlaceholderElement(jsx[0]);
            return [createdElement, jsx];
        }
        // For anything else we do nothing.
        return [null, jsx];
    }
    /** @returns An empty <script> element for adding qwik metadata attributes to */
    function createPlaceholderScriptNode() {
        return new JSXNodeImpl('script', null, { hidden: '' });
    }

    /** @public */
    const SkipRender = Symbol('skip render');
    /** @public */
    const SSRRaw = () => null;
    /** @public */
    const SSRComment = () => null;
    /** @public */
    const SSRStreamBlock = (props) => {
        return [
            jsx(SSRComment, { data: STREAM_BLOCK_START_COMMENT }),
            props.children,
            jsx(SSRComment, { data: STREAM_BLOCK_END_COMMENT }),
        ];
    };
    /** @public */
    const SSRStream = (props, key) => jsx(RenderOnce, { children: jsx(InternalSSRStream, props) }, key);
    const InternalSSRStream = () => null;

    function escapeHTML(html) {
        let escapedHTML = '';
        const length = html.length;
        let idx = 0;
        let lastIdx = idx;
        for (; idx < length; idx++) {
            // We get the charCode NOT string. String would allocate memory.
            const ch = html.charCodeAt(idx);
            // Every time we concat a string we allocate memory. We want to minimize that.
            if (ch === 60 /* < */) {
                escapedHTML += html.substring(lastIdx, idx) + '&lt;';
            }
            else if (ch === 62 /* > */) {
                escapedHTML += html.substring(lastIdx, idx) + '&gt;';
            }
            else if (ch === 38 /* & */) {
                escapedHTML += html.substring(lastIdx, idx) + '&amp;';
            }
            else if (ch === 34 /* " */) {
                escapedHTML += html.substring(lastIdx, idx) + '&quot;';
            }
            else if (ch === 39 /* ' */) {
                escapedHTML += html.substring(lastIdx, idx) + '&#39;';
            }
            else {
                continue;
            }
            lastIdx = idx + 1;
        }
        if (lastIdx === 0) {
            // This is most common case, just return previous string no memory allocation.
            return html;
        }
        else {
            // Add the tail of replacement.
            return escapedHTML + html.substring(lastIdx);
        }
    }

    function getFileLocationFromJsx(jsxDev) {
        if (!jsxDev) {
            return null;
        }
        const sanitizedFileName = jsxDev.fileName?.replace(/\\/g, '/');
        if (sanitizedFileName) {
            return `${sanitizedFileName}:${jsxDev.lineNumber}:${jsxDev.columnNumber}`;
        }
        return null;
    }

    function isSlotProp(prop) {
        return !prop.startsWith('q:') && !prop.startsWith(NON_SERIALIZABLE_MARKER_PREFIX);
    }
    /** @internal */
    const _restProps = (props, omit = [], target = {}) => {
        let constPropsTarget = null;
        const constProps = props[_CONST_PROPS];
        if (constProps) {
            for (const key in constProps) {
                if (!omit.includes(key)) {
                    constPropsTarget ||= {};
                    constPropsTarget[key] = constProps[key];
                }
            }
        }
        const varPropsTarget = target;
        const varProps = props[_VAR_PROPS];
        for (const key in varProps) {
            if (!omit.includes(key)) {
                varPropsTarget[key] = varProps[key];
            }
        }
        return createPropsProxy(new JSXNodeImpl(null, varPropsTarget, constPropsTarget));
    };

    const styleContent = (styleId) => {
        return ComponentStylesPrefixContent + styleId;
    };
    function hasClassAttr(props) {
        return 'class' in props || 'className' in props;
    }
    function isClassAttr(key) {
        return key === 'class' || key === 'className';
    }
    function convertScopedStyleIdsToArray(scopedStyleIds) {
        return scopedStyleIds?.split(' ') ?? null;
    }
    function convertStyleIdsToString(scopedStyleIds) {
        return Array.from(scopedStyleIds).join(' ');
    }
    const addComponentStylePrefix = (styleId) => {
        if (styleId) {
            let idx = 0;
            do {
                styleId = styleId.substring(0, idx) + styleContent(styleId.substring(idx));
            } while ((idx = styleId.indexOf(' ', idx) + 1) !== 0);
        }
        return styleId || null;
    };

    /** CSS properties which accept numbers but are not in units of "px". */
    const unitlessNumbers = new Set([
        'animationIterationCount',
        'aspectRatio',
        'borderImageOutset',
        'borderImageSlice',
        'borderImageWidth',
        'boxFlex',
        'boxFlexGroup',
        'boxOrdinalGroup',
        'columnCount',
        'columns',
        'flex',
        'flexGrow',
        'flexShrink',
        'gridArea',
        'gridRow',
        'gridRowEnd',
        'gridRowStart',
        'gridColumn',
        'gridColumnEnd',
        'gridColumnStart',
        'fontWeight',
        'lineClamp',
        'lineHeight',
        'opacity',
        'order',
        'orphans',
        'scale',
        'tabSize',
        'widows',
        'zIndex',
        'zoom',
        'MozAnimationIterationCount', // Known Prefixed Properties
        'MozBoxFlex', // TODO: Remove these since they shouldn't be used in modern code
        'msFlex',
        'msFlexPositive',
        'WebkitAnimationIterationCount',
        'WebkitBoxFlex',
        'WebkitBoxOrdinalGroup',
        'WebkitColumnCount',
        'WebkitColumns',
        'WebkitFlex',
        'WebkitFlexGrow',
        'WebkitFlexShrink',
        'WebkitLineClamp',
    ]);
    const isUnitlessNumber = (name) => {
        return unitlessNumbers.has(name);
    };

    const hashCode = (text, hash = 0) => {
        for (let i = 0; i < text.length; i++) {
            const chr = text.charCodeAt(i);
            hash = (hash << 5) - hash + chr;
            hash |= 0; // Convert to 32bit integer
        }
        return Number(Math.abs(hash)).toString(36);
    };

    const serializeClass = (obj) => {
        if (!obj) {
            return '';
        }
        if (isString(obj)) {
            return obj.trim();
        }
        const classes = [];
        if (isArray(obj)) {
            for (const o of obj) {
                const classList = serializeClass(o);
                if (classList) {
                    classes.push(classList);
                }
            }
        }
        else {
            for (const [key, value] of Object.entries(obj)) {
                if (value) {
                    classes.push(key.trim());
                }
            }
        }
        return classes.join(' ');
    };
    // Unlike fromCamelToKebabCase, this leaves `-` so that `background-color` stays `background-color`
    const fromCamelToKebabCaseWithDash = (text) => {
        return text.replace(/([A-Z])/g, '-$1').toLowerCase();
    };
    const stringifyStyle = (obj) => {
        if (obj == null) {
            return '';
        }
        if (typeof obj == 'object') {
            if (isArray(obj)) {
                throw qError(0 /* QError.stringifyClassOrStyle */, [obj, 'style']);
            }
            else {
                const chunks = [];
                for (const key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) {
                        const value = obj[key];
                        if (value != null && typeof value !== 'function') {
                            if (key.startsWith('--')) {
                                chunks.push(key + ':' + value);
                            }
                            else {
                                chunks.push(fromCamelToKebabCaseWithDash(key) + ':' + setValueForStyle(key, value));
                            }
                        }
                    }
                }
                return chunks.join(';');
            }
        }
        return String(obj);
    };
    const serializeBooleanOrNumberAttribute = (value) => {
        return value != null ? String(value) : null;
    };
    function serializeAttribute(key, value, styleScopedId) {
        if (isClassAttr(key)) {
            const serializedClass = serializeClass(value);
            value = styleScopedId
                ? styleScopedId + (serializedClass.length ? ' ' + serializedClass : serializedClass)
                : serializedClass;
        }
        else if (key === 'style') {
            value = stringifyStyle(value);
        }
        else if (isEnumeratedBooleanAttribute(key) || typeof value === 'number') {
            // aria attrs, tabindex etc.
            value = serializeBooleanOrNumberAttribute(value);
        }
        else if (value === false || value == null) {
            value = null;
        }
        else if (value === true && isPreventDefault(key)) {
            value = '';
        }
        return value;
    }
    function isEnumeratedBooleanAttribute(key) {
        return isAriaAttribute(key) || ['spellcheck', 'draggable', 'contenteditable'].includes(key);
    }
    const setValueForStyle = (styleName, value) => {
        if (typeof value === 'number' && value !== 0 && !isUnitlessNumber(styleName)) {
            return value + 'px';
        }
        return value;
    };
    function isAriaAttribute(prop) {
        return prop.startsWith('aria-');
    }
    const styleKey = (qStyles, index) => {
        assertQrl(qStyles);
        return `${hashCode(qStyles.$hash$)}-${index}`;
    };

    const vnode_diff = (container, jsxNode, vStartNode, scopedStyleIdPrefix) => {
        let journal = container.$journal$;
        /**
         * Stack is used to keep track of the state of the traversal.
         *
         * We push current state into the stack before descending into the child, and we pop the state
         * when we are done with the child.
         */
        const stack = [];
        const asyncQueue = [];
        ////////////////////////////////
        //// Traverse state variables
        ////////////////////////////////
        let vParent = null;
        /// Current node we compare against. (Think of it as a cursor.)
        /// (Node can be null, if we are at the end of the list.)
        let vCurrent = null;
        /// When we insert new node we start it here so that we can descend into it.
        /// NOTE: it can't be stored in `vCurrent` because `vNewNode` is in journal
        /// and is not connected to the tree.
        let vNewNode = null;
        let vSiblings = null;
        /// The array even indices will contains keys and odd indices the non keyed siblings.
        let vSiblingsArray = null;
        /// Side buffer to store nodes that are moved out of order during key scanning.
        /// This contains nodes that were found before the target key and need to be moved later.
        let vSideBuffer = null;
        /// Current set of JSX children.
        let jsxChildren = null;
        // Current JSX child.
        let jsxValue = null;
        let jsxIdx = 0;
        let jsxCount = 0;
        // When we descend into children, we need to skip advance() because we just descended.
        let shouldAdvance = true;
        const CONST_SUBSCRIPTION_DATA = new SubscriptionData({
            $scopedStyleIdPrefix$: scopedStyleIdPrefix,
            $isConst$: true,
        });
        const NON_CONST_SUBSCRIPTION_DATA = new SubscriptionData({
            $scopedStyleIdPrefix$: scopedStyleIdPrefix,
            $isConst$: false,
        });
        ////////////////////////////////
        diff(jsxNode, vStartNode);
        return drainAsyncQueue();
        //////////////////////////////////////////////
        //////////////////////////////////////////////
        //////////////////////////////////////////////
        function diff(jsxNode, vStartNode) {
            assertFalse(vnode_isVNode(jsxNode), 'JSXNode should not be a VNode');
            assertTrue(vnode_isVNode(vStartNode), 'vStartNode should be a VNode');
            vParent = vStartNode;
            vNewNode = null;
            vCurrent = vnode_getFirstChild(vStartNode);
            stackPush(jsxNode, true);
            if (vParent.flags & 32 /* VNodeFlags.Deleted */) {
                // Ignore diff if the parent is deleted.
                return;
            }
            while (stack.length) {
                while (jsxIdx < jsxCount) {
                    assertFalse(vParent === vCurrent, "Parent and current can't be the same");
                    if (typeof jsxValue === 'string') {
                        expectText(jsxValue);
                    }
                    else if (typeof jsxValue === 'number') {
                        expectText(String(jsxValue));
                    }
                    else if (jsxValue && typeof jsxValue === 'object') {
                        if (Array.isArray(jsxValue)) {
                            descend(jsxValue, false);
                        }
                        else if (isSignal(jsxValue)) {
                            expectVirtual("S" /* VirtualType.WrappedSignal */, null);
                            const unwrappedSignal = jsxValue instanceof WrappedSignalImpl ? jsxValue.$unwrapIfSignal$() : jsxValue;
                            const currentSignal = vCurrent?.[_EFFECT_BACK_REF]?.get("." /* EffectProperty.VNODE */)?.[0 /* EffectSubscriptionProp.CONSUMER */];
                            if (currentSignal !== unwrappedSignal) {
                                const vHost = (vNewNode || vCurrent);
                                descend(resolveSignalAndDescend(() => trackSignalAndAssignHost(unwrappedSignal, vHost, "." /* EffectProperty.VNODE */, container)), true);
                            }
                        }
                        else if (isPromise(jsxValue)) {
                            expectVirtual("A" /* VirtualType.Awaited */, null);
                            asyncQueue.push(jsxValue, vNewNode || vCurrent);
                        }
                        else if (isJSXNode(jsxValue)) {
                            const type = jsxValue.type;
                            if (typeof type === 'string') {
                                expectNoMoreTextNodes();
                                expectElement(jsxValue, type);
                                descend(jsxValue.children, true);
                            }
                            else if (typeof type === 'function') {
                                if (type === Fragment) {
                                    expectNoMoreTextNodes();
                                    expectVirtual("F" /* VirtualType.Fragment */, jsxValue.key);
                                    descend(jsxValue.children, true);
                                }
                                else if (type === Slot) {
                                    expectNoMoreTextNodes();
                                    if (!expectSlot()) {
                                        // nothing to project, so try to render the Slot default content.
                                        descend(jsxValue.children, true);
                                    }
                                }
                                else if (type === Projection) {
                                    expectProjection();
                                    descend(jsxValue.children, true, 
                                    // special case for projection, we don't want to expect no children
                                    // because the projection's children are not removed
                                    false);
                                }
                                else if (type === SSRComment) {
                                    expectNoMore();
                                }
                                else if (type === SSRRaw) {
                                    expectNoMore();
                                }
                                else {
                                    // Must be a component
                                    expectNoMoreTextNodes();
                                    expectComponent(type);
                                }
                            }
                        }
                    }
                    else if (jsxValue === SkipRender) {
                        // do nothing, we are skipping this node
                        journal = [];
                    }
                    else {
                        expectText('');
                    }
                    advance();
                }
                expectNoMore();
                cleanupSideBuffer();
                ascend();
            }
        }
        function resolveSignalAndDescend(fn) {
            try {
                return fn();
            }
            catch (e) {
                // Signal threw a promise (async computed signal) - handle retry and async queue
                if (isPromise(e)) {
                    // The thrown promise will resolve when the signal is ready, then retry fn() with retry logic
                    const retryPromise = e.then(() => retryOnPromise(fn));
                    asyncQueue.push(retryPromise, vNewNode || vCurrent);
                    return null;
                }
                throw e;
            }
        }
        function advance() {
            if (!shouldAdvance) {
                shouldAdvance = true;
                return;
            }
            jsxIdx++;
            if (jsxIdx < jsxCount) {
                jsxValue = jsxChildren[jsxIdx];
            }
            else if (stack[stack.length - 1] === false) {
                // this was special `descendVNode === false` so pop and try again
                return ascend();
            }
            if (vNewNode !== null) {
                // We have a new Node.
                // This means that the `vCurrent` was deemed not useful and we inserted in front of it.
                // This means that the next node we should look at is the `vCurrent` so just clear the
                // vNewNode  and try again.
                vNewNode = null;
            }
            else {
                advanceToNextSibling();
            }
        }
        /** Advance the `vCurrent` to the next sibling. */
        function peekNextSibling() {
            // If we don't have a `vNewNode`, than that means we just reconciled the current node.
            // So advance it.
            return vCurrent ? vCurrent.nextSibling : null;
        }
        /** Advance the `vCurrent` to the next sibling. */
        function advanceToNextSibling() {
            vCurrent = peekNextSibling();
        }
        /**
         * @param children
         * @param descendVNode - If true we are descending into vNode; This is set to false if we come
         *   across an array in jsx, and we need to descend into the array without actually descending
         *   into the vNode.
         *
         *   Example:
         *
         *   ```
         *   <>
         *   before
         *   {[1,2].map((i) => <span>{i}</span>)}
         *   after
         *   </>
         * ```
         *
         *   In the above example all nodes are on same level so we don't `descendVNode` even thought there
         *   is an array produced by the `map` function.
         */
        function descend(children, descendVNode, shouldExpectNoChildren = true) {
            if (shouldExpectNoChildren &&
                (children == null || (descendVNode && isArray(children) && children.length === 0))) {
                expectNoChildren();
                return;
            }
            stackPush(children, descendVNode);
            if (descendVNode) {
                assertDefined(vCurrent || vNewNode, 'Expecting vCurrent to be defined.');
                vSideBuffer = null;
                vSiblings = null;
                vSiblingsArray = null;
                vParent = (vNewNode || vCurrent);
                vCurrent = vnode_getFirstChild(vParent);
                vNewNode = null;
            }
            shouldAdvance = false;
        }
        function ascend() {
            const descendVNode = stack.pop(); // boolean: descendVNode
            if (descendVNode) {
                vSideBuffer = stack.pop();
                vSiblings = stack.pop();
                vSiblingsArray = stack.pop();
                vNewNode = stack.pop();
                vCurrent = stack.pop();
                vParent = stack.pop();
            }
            jsxValue = stack.pop();
            jsxCount = stack.pop();
            jsxIdx = stack.pop();
            jsxChildren = stack.pop();
            advance();
        }
        function stackPush(children, descendVNode) {
            stack.push(jsxChildren, jsxIdx, jsxCount, jsxValue);
            if (descendVNode) {
                stack.push(vParent, vCurrent, vNewNode, vSiblingsArray, vSiblings, vSideBuffer);
            }
            stack.push(descendVNode);
            if (Array.isArray(children)) {
                jsxIdx = 0;
                jsxCount = children.length;
                jsxChildren = children;
                jsxValue = jsxCount > 0 ? children[0] : null;
            }
            else if (children === undefined) {
                // no children
                jsxIdx = 0;
                jsxValue = null;
                jsxChildren = null;
                jsxCount = 0;
            }
            else {
                jsxIdx = 0;
                jsxValue = children;
                jsxChildren = null;
                jsxCount = 1;
            }
        }
        function getInsertBefore() {
            if (vNewNode) {
                return vCurrent;
            }
            else {
                return peekNextSibling();
            }
        }
        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////////////////////////
        function descendContentToProject(children, host) {
            const projectionChildren = Array.isArray(children) ? children : [children];
            const createProjectionJSXNode = (slotName) => {
                return new JSXNodeImpl(Projection, null, null, [], slotName);
            };
            const projections = [];
            if (host) {
                const props = vnode_getProps(host);
                // we need to create empty projections for all the slots to remove unused slots content
                for (let i = 0; i < props.length; i = i + 2) {
                    const prop = props[i];
                    if (isSlotProp(prop)) {
                        const slotName = prop;
                        projections.push(slotName);
                        projections.push(createProjectionJSXNode(slotName));
                    }
                }
            }
            if (projections.length === 0 && children == null) {
                // We did not find any existing slots and we don't have any children to project.
                return;
            }
            /// STEP 1: Bucketize the children based on the projection name.
            for (let i = 0; i < projectionChildren.length; i++) {
                const child = projectionChildren[i];
                const slotName = String((isJSXNode(child) && directGetPropsProxyProp(child, QSlot)) || QDefaultSlot);
                const idx = mapApp_findIndx(projections, slotName, 0);
                let jsxBucket;
                if (idx >= 0) {
                    jsxBucket = projections[idx + 1];
                }
                else {
                    projections.splice(~idx, 0, slotName, (jsxBucket = createProjectionJSXNode(slotName)));
                }
                const removeProjection = child === false;
                if (!removeProjection) {
                    jsxBucket.children.push(child);
                }
            }
            /// STEP 2: remove the names
            for (let i = projections.length - 2; i >= 0; i = i - 2) {
                projections.splice(i, 1);
            }
            descend(projections, true);
        }
        function expectProjection() {
            const jsxNode = jsxValue;
            const slotName = jsxNode.key;
            // console.log('expectProjection', JSON.stringify(slotName));
            // The parent is the component and it should have our portal.
            vCurrent = vParent.getProp(slotName, (id) => vnode_locate(container.rootVNode, id));
            // if projection is marked as deleted then we need to create a new one
            vCurrent = vCurrent && vCurrent.flags & 32 /* VNodeFlags.Deleted */ ? null : vCurrent;
            if (vCurrent == null) {
                vNewNode = vnode_newVirtual();
                // you may be tempted to add the projection into the current parent, but
                // that is wrong. We don't yet know if the projection will be projected, so
                // we should leave it unattached.
                // vNewNode[VNodeProps.parent] = vParent;
                build.isDev && vNewNode.setProp(DEBUG_TYPE, "P" /* VirtualType.Projection */);
                build.isDev && vNewNode.setProp('q:code', 'expectProjection');
                vNewNode.setProp(QSlot, slotName);
                vNewNode.slotParent = vParent;
                vParent.setProp(slotName, vNewNode);
            }
        }
        function expectSlot() {
            const vHost = vnode_getProjectionParentComponent(vParent);
            const slotNameKey = getSlotNameKey(vHost);
            // console.log('expectSlot', JSON.stringify(slotNameKey));
            const vProjectedNode = vHost
                ? vHost.getProp(slotNameKey, 
                // for slots this id is vnode ref id
                null // Projections should have been resolved through container.ensureProjectionResolved
                //(id) => vnode_locate(container.rootVNode, id)
                )
                : null;
            // console.log('   ', String(vHost), String(vProjectedNode));
            if (vProjectedNode == null) {
                // Nothing to project, so render content of the slot.
                vnode_insertBefore(journal, vParent, (vNewNode = vnode_newVirtual()), vCurrent && getInsertBefore());
                vNewNode.setProp(QSlot, slotNameKey);
                vHost && vHost.setProp(slotNameKey, vNewNode);
                build.isDev && vNewNode.setProp(DEBUG_TYPE, "P" /* VirtualType.Projection */);
                build.isDev && vNewNode.setProp('q:code', 'expectSlot' + count++);
                return false;
            }
            else if (vProjectedNode === vCurrent) ;
            else {
                // move from q:template to the target node
                vnode_insertBefore(journal, vParent, (vNewNode = vProjectedNode), vCurrent && getInsertBefore());
                vNewNode.setProp(QSlot, slotNameKey);
                vHost && vHost.setProp(slotNameKey, vNewNode);
                build.isDev && vNewNode.setProp(DEBUG_TYPE, "P" /* VirtualType.Projection */);
                build.isDev && vNewNode.setProp('q:code', 'expectSlot' + count++);
            }
            return true;
        }
        function getSlotNameKey(vHost) {
            const jsxNode = jsxValue;
            const constProps = jsxNode.constProps;
            if (constProps && typeof constProps == 'object' && 'name' in constProps) {
                const constValue = constProps.name;
                if (vHost && constValue instanceof WrappedSignalImpl) {
                    return trackSignalAndAssignHost(constValue, vHost, ":" /* EffectProperty.COMPONENT */, container);
                }
            }
            return directGetPropsProxyProp(jsxNode, 'name') || QDefaultSlot;
        }
        function cleanupSideBuffer() {
            if (vSideBuffer) {
                // Remove all nodes in the side buffer as they are no longer needed
                for (const vNode of vSideBuffer.values()) {
                    if (vNode.flags & 32 /* VNodeFlags.Deleted */) {
                        continue;
                    }
                    cleanup(container, vNode);
                    vnode_remove(journal, vParent, vNode, true);
                }
                vSideBuffer.clear();
                vSideBuffer = null;
            }
            vCurrent = null;
        }
        function drainAsyncQueue() {
            while (asyncQueue.length) {
                const jsxNode = asyncQueue.shift();
                const vHostNode = asyncQueue.shift();
                if (isPromise(jsxNode)) {
                    return jsxNode
                        .then((jsxNode) => {
                        diff(jsxNode, vHostNode);
                        return drainAsyncQueue();
                    })
                        .catch((e) => {
                        container.handleError(e, vHostNode);
                        return drainAsyncQueue();
                    });
                }
                else {
                    diff(jsxNode, vHostNode);
                }
            }
        }
        function expectNoChildren() {
            const vFirstChild = vCurrent && vnode_getFirstChild(vCurrent);
            if (vFirstChild !== null) {
                let vChild = vFirstChild;
                while (vChild) {
                    cleanup(container, vChild);
                    vChild = vChild.nextSibling;
                }
                vnode_truncate(journal, vCurrent, vFirstChild);
            }
        }
        /** Expect no more nodes - Any nodes which are still at cursor, need to be removed. */
        function expectNoMore() {
            assertFalse(vParent === vCurrent, "Parent and current can't be the same");
            if (vCurrent !== null) {
                while (vCurrent) {
                    const toRemove = vCurrent;
                    advanceToNextSibling();
                    if (vParent === toRemove.parent) {
                        cleanup(container, toRemove);
                        // If we are diffing projection than the parent is not the parent of the node.
                        // If that is the case we don't want to remove the node from the parent.
                        vnode_remove(journal, vParent, toRemove, true);
                    }
                }
            }
        }
        function expectNoMoreTextNodes() {
            while (vCurrent !== null && vnode_isTextVNode(vCurrent)) {
                cleanup(container, vCurrent);
                const toRemove = vCurrent;
                advanceToNextSibling();
                vnode_remove(journal, vParent, toRemove, true);
            }
        }
        /**
         * Returns whether `qDispatchEvent` needs patching. This is true when one of the `jsx` argument's
         * const props has the name of an event.
         *
         * @returns {boolean}
         */
        function createNewElement(jsx, elementName, currentFile) {
            const element = createElementWithNamespace(elementName);
            function setAttribute(key, value, vHost) {
                value = serializeAttribute(key, value, scopedStyleIdPrefix);
                if (value != null) {
                    if (vHost.flags & 64 /* VNodeFlags.NS_svg */) {
                        // only svg elements can have namespace attributes
                        const namespace = getAttributeNamespace(key);
                        if (namespace) {
                            element.setAttributeNS(namespace, key, String(value));
                            return;
                        }
                    }
                    element.setAttribute(key, String(value));
                }
            }
            const { constProps } = jsx;
            let needsQDispatchEventPatch = false;
            if (constProps) {
                // Const props are, well, constant, they will never change!
                // For this reason we can cheat and write them directly into the DOM.
                // We never tell the vNode about them saving us time and memory.
                for (const key in constProps) {
                    let value = constProps[key];
                    if (isHtmlAttributeAnEventName(key)) {
                        const data = getEventDataFromHtmlAttribute(key);
                        if (data) {
                            const scope = data[0];
                            const eventName = data[1];
                            if (eventName) {
                                vNewNode.setProp(HANDLER_PREFIX + ':' + scope + ':' + eventName, value);
                                if (scope) {
                                    // window and document need attrs so qwik loader can find them
                                    vNewNode.setAttr(key, '', journal);
                                }
                                registerQwikLoaderEvent(eventName);
                            }
                        }
                        needsQDispatchEventPatch = true;
                        continue;
                    }
                    if (key === 'ref') {
                        if (isSignal(value)) {
                            value.value = element;
                            continue;
                        }
                        else if (typeof value === 'function') {
                            value(element);
                            continue;
                        }
                        else if (value == null) {
                            continue;
                        }
                        else {
                            throw qError(15 /* QError.invalidRefValue */, [currentFile]);
                        }
                    }
                    if (isSignal(value)) {
                        const vHost = vNewNode;
                        const signal = value;
                        value = retryOnPromise(() => trackSignalAndAssignHost(signal, vHost, key, container, CONST_SUBSCRIPTION_DATA));
                    }
                    if (isPromise(value)) {
                        const vHost = vNewNode;
                        value.then((resolvedValue) => setAttribute(key, resolvedValue, vHost));
                        continue;
                    }
                    if (key === dangerouslySetInnerHTML) {
                        if (value) {
                            element.innerHTML = String(value);
                            element.setAttribute(QContainerAttr, "html" /* QContainerValue.HTML */);
                        }
                        continue;
                    }
                    if (elementName === 'textarea' && key === 'value') {
                        if (value && typeof value !== 'string') {
                            if (build.isDev) {
                                throw qError(23 /* QError.wrongTextareaValue */, [currentFile, value]);
                            }
                            continue;
                        }
                        element.value = escapeHTML(value || '');
                        continue;
                    }
                    setAttribute(key, value, vNewNode);
                }
            }
            const key = jsx.key;
            if (key) {
                vNewNode.setProp(ELEMENT_KEY, key);
            }
            // append class attribute if styleScopedId exists and there is no class attribute
            if (scopedStyleIdPrefix) {
                const classAttributeExists = hasClassAttr(jsx.varProps) || (jsx.constProps && hasClassAttr(jsx.constProps));
                if (!classAttributeExists) {
                    element.setAttribute('class', scopedStyleIdPrefix);
                }
            }
            vnode_insertBefore(journal, vParent, vNewNode, vCurrent);
            return needsQDispatchEventPatch;
        }
        function createElementWithNamespace(elementName) {
            const domParentVNode = vnode_getDomParentVNode(vParent);
            const { elementNamespace, elementNamespaceFlag } = getNewElementNamespaceData(domParentVNode, elementName);
            const element = container.document.createElementNS(elementNamespace, elementName);
            vNewNode = vnode_newElement(element, elementName);
            vNewNode.flags |= elementNamespaceFlag;
            return element;
        }
        function expectElement(jsx, elementName) {
            const isSameElementName = vCurrent && vnode_isElementVNode(vCurrent) && elementName === vnode_getElementName(vCurrent);
            const jsxKey = jsx.key;
            let needsQDispatchEventPatch = false;
            const currentKey = getKey(vCurrent);
            if (!isSameElementName || jsxKey !== currentKey) {
                const sideBufferKey = getSideBufferKey(elementName, jsxKey);
                const createNew = () => (needsQDispatchEventPatch = createNewElement(jsx, elementName));
                moveOrCreateKeyedNode(elementName, jsxKey, sideBufferKey, vParent, createNew);
            }
            else {
                // delete the key from the side buffer if it is the same element
                deleteFromSideBuffer(elementName, jsxKey);
            }
            // reconcile attributes
            const jsxAttrs = [];
            const props = jsx.varProps;
            if (jsx.toSort) {
                const keys = Object.keys(props).sort();
                for (const key of keys) {
                    const value = props[key];
                    if (value != null) {
                        jsxAttrs.push(key, value);
                    }
                }
            }
            else {
                for (const key in props) {
                    const value = props[key];
                    if (value != null) {
                        jsxAttrs.push(key, value);
                    }
                }
            }
            if (jsxKey !== null) {
                mapArray_set(jsxAttrs, ELEMENT_KEY, jsxKey, 0);
            }
            const vNode = (vNewNode || vCurrent);
            const element = vNode.element;
            if (!element.vNode) {
                element.vNode = vNode;
            }
            needsQDispatchEventPatch =
                setBulkProps(vNode, jsxAttrs, (build.isDev && getFileLocationFromJsx(jsx.dev)) || null) ||
                    needsQDispatchEventPatch;
            if (needsQDispatchEventPatch) {
                // Event handler needs to be patched onto the element.
                if (!element.qDispatchEvent) {
                    element.qDispatchEvent = (event, scope) => {
                        const eventName = fromCamelToKebabCase(event.type);
                        const eventProp = ':' + scope.substring(1) + ':' + eventName;
                        const qrls = [
                            vNode.getProp(eventProp, null),
                            vNode.getProp(HANDLER_PREFIX + eventProp, null),
                        ];
                        let returnValue = false;
                        qrls.flat(2).forEach((qrl) => {
                            if (qrl) {
                                if (isSyncQrl(qrl)) {
                                    qrl(event, element);
                                }
                                else {
                                    const value = container.$scheduler$(2 /* ChoreType.RUN_QRL */, vNode, qrl, [event, element]);
                                    returnValue = returnValue || value === true;
                                }
                            }
                        });
                        return returnValue;
                    };
                }
            }
        }
        /** @returns True if `qDispatchEvent` needs patching */
        function setBulkProps(vnode, srcAttrs, currentFile) {
            vnode_ensureElementInflated(vnode);
            const dstAttrs = vnode_getProps(vnode);
            let srcIdx = 0;
            let dstIdx = 0;
            let patchEventDispatch = false;
            const setAttribute = (key, value, vHost) => {
                vHost.setAttr(key, value !== null ? serializeAttribute(key, value, scopedStyleIdPrefix) : null, journal);
            };
            const record = (key, value) => {
                if (key.startsWith(':')) {
                    vnode.setProp(key, value);
                    return;
                }
                if (key === 'ref') {
                    const element = vnode.element;
                    if (isSignal(value)) {
                        value.value = element;
                        return;
                    }
                    else if (typeof value === 'function') {
                        value(element);
                        return;
                    }
                    // handling null value is not needed here, because we are filtering null values earlier
                    else {
                        throw qError(15 /* QError.invalidRefValue */, [currentFile]);
                    }
                }
                const currentEffect = vnode[_EFFECT_BACK_REF]?.get(key);
                if (isSignal(value)) {
                    const unwrappedSignal = value instanceof WrappedSignalImpl ? value.$unwrapIfSignal$() : value;
                    const currentSignal = currentEffect?.[0 /* EffectSubscriptionProp.CONSUMER */];
                    if (currentSignal === unwrappedSignal) {
                        return;
                    }
                    if (currentEffect) {
                        // Clear current effect subscription if it exists
                        // Only if we want to track the signal again
                        clearEffectSubscription(container, currentEffect);
                    }
                    const vHost = vnode;
                    value = retryOnPromise(() => trackSignalAndAssignHost(unwrappedSignal, vHost, key, container, NON_CONST_SUBSCRIPTION_DATA));
                }
                else {
                    if (currentEffect) {
                        // Clear current effect subscription if it exists
                        // and the value is not a signal
                        // It means that the previous value was a signal and we need to clear the effect subscription
                        clearEffectSubscription(container, currentEffect);
                    }
                }
                if (isPromise(value)) {
                    const vHost = vnode;
                    value.then((resolvedValue) => setAttribute(key, resolvedValue, vHost));
                    return;
                }
                setAttribute(key, value, vnode);
            };
            const recordJsxEvent = (key, value) => {
                const data = getEventDataFromHtmlAttribute(key);
                if (data) {
                    const [scope, eventName] = data;
                    record(':' + scope + ':' + eventName, value);
                    // register an event for qwik loader
                    registerQwikLoaderEvent(eventName);
                    patchEventDispatch = true;
                }
            };
            // Two-pointer merge algorithm: both arrays are sorted by key
            // Note: dstAttrs mutates during iteration (setAttr uses splice), so we re-read keys each iteration
            while (srcIdx < srcAttrs.length || dstIdx < dstAttrs.length) {
                const srcKey = srcIdx < srcAttrs.length ? srcAttrs[srcIdx] : undefined;
                const dstKey = dstIdx < dstAttrs.length ? dstAttrs[dstIdx] : undefined;
                // Skip special keys in destination (HANDLER_PREFIX, Q_PREFIX)
                if (dstKey?.startsWith(HANDLER_PREFIX) || dstKey?.startsWith(Q_PREFIX)) {
                    dstIdx += 2; // skip key and value
                    continue;
                }
                if (srcKey === undefined) {
                    // Source exhausted: remove remaining destination keys
                    if (isHtmlAttributeAnEventName(dstKey)) {
                        // HTML event attributes are immutable and not removed from DOM
                        dstIdx += 2; // skip key and value
                    }
                    else {
                        record(dstKey, null);
                        // After removal, dstAttrs shrinks by 2, so don't advance dstIdx
                    }
                }
                else if (dstKey === undefined) {
                    // Destination exhausted: add remaining source keys
                    const srcValue = srcAttrs[srcIdx + 1];
                    if (isHtmlAttributeAnEventName(srcKey)) {
                        recordJsxEvent(srcKey, srcValue);
                    }
                    else {
                        record(srcKey, srcValue);
                    }
                    srcIdx += 2; // skip key and value
                    // After addition, dstAttrs grows by 2 at sorted position, advance dstIdx
                    dstIdx += 2;
                }
                else if (srcKey === dstKey) {
                    // Keys match: update if values differ
                    const srcValue = srcAttrs[srcIdx + 1];
                    const dstValue = dstAttrs[dstIdx + 1];
                    const isEventHandler = isHtmlAttributeAnEventName(srcKey);
                    if (srcValue !== dstValue) {
                        if (isEventHandler) {
                            recordJsxEvent(srcKey, srcValue);
                        }
                        else {
                            record(srcKey, srcValue);
                        }
                    }
                    else if (isEventHandler && !vnode.element.qDispatchEvent) {
                        // Special case: add event handlers after resume
                        recordJsxEvent(srcKey, srcValue);
                    }
                    // Update in place doesn't change array length
                    srcIdx += 2; // skip key and value
                    dstIdx += 2; // skip key and value
                }
                else if (srcKey < dstKey) {
                    // Source has a key not in destination: add it
                    const srcValue = srcAttrs[srcIdx + 1];
                    if (isHtmlAttributeAnEventName(srcKey)) {
                        recordJsxEvent(srcKey, srcValue);
                    }
                    else {
                        record(srcKey, srcValue);
                    }
                    srcIdx += 2; // skip key and value
                    // After addition, dstAttrs grows at sorted position (before dstIdx), advance dstIdx
                    dstIdx += 2;
                }
                else {
                    // Destination has a key not in source: remove it (dstKey > srcKey)
                    if (isHtmlAttributeAnEventName(dstKey)) {
                        // HTML event attributes are immutable and not removed from DOM
                        dstIdx += 2; // skip key and value
                    }
                    else {
                        record(dstKey, null);
                        // After removal, dstAttrs shrinks at dstIdx, so don't advance dstIdx
                    }
                }
            }
            return patchEventDispatch;
        }
        function registerQwikLoaderEvent(eventName) {
            const window = container.document.defaultView;
            if (window) {
                (window.qwikevents ||= []).push(eventName);
            }
        }
        function retrieveChildWithKey(nodeName, key) {
            let vNodeWithKey = null;
            if (vSiblings === null) {
                // it is not materialized; so materialize it.
                vSiblings = new Map();
                vSiblingsArray = [];
                let vNode = vCurrent;
                while (vNode) {
                    const name = vnode_isElementVNode(vNode) ? vnode_getElementName(vNode) : null;
                    const vKey = getKey(vNode) || getComponentHash(vNode, container.$getObjectById$);
                    if (vNodeWithKey === null && vKey == key && name == nodeName) {
                        vNodeWithKey = vNode;
                    }
                    else {
                        if (vKey === null) {
                            vSiblingsArray.push(name, vNode);
                        }
                        else {
                            // we only add the elements which we did not find yet.
                            vSiblings.set(getSideBufferKey(name, vKey), vNode);
                        }
                    }
                    vNode = vNode.nextSibling;
                }
            }
            else {
                if (key === null) {
                    for (let i = 0; i < vSiblingsArray.length; i += 2) {
                        if (vSiblingsArray[i] === nodeName) {
                            vNodeWithKey = vSiblingsArray[i + 1];
                            vSiblingsArray.splice(i, 2);
                            break;
                        }
                    }
                }
                else {
                    const siblingsKey = getSideBufferKey(nodeName, key);
                    if (vSiblings.has(siblingsKey)) {
                        vNodeWithKey = vSiblings.get(siblingsKey);
                        vSiblings.delete(siblingsKey);
                    }
                }
            }
            collectSideBufferSiblings(vNodeWithKey);
            return vNodeWithKey;
        }
        function collectSideBufferSiblings(targetNode) {
            if (!targetNode) {
                if (vCurrent) {
                    const name = vnode_isElementVNode(vCurrent) ? vnode_getElementName(vCurrent) : null;
                    const vKey = getKey(vCurrent) || getComponentHash(vCurrent, container.$getObjectById$);
                    if (vKey != null) {
                        const sideBufferKey = getSideBufferKey(name, vKey);
                        vSideBuffer ||= new Map();
                        vSideBuffer.set(sideBufferKey, vCurrent);
                        vSiblings?.delete(sideBufferKey);
                    }
                }
                return;
            }
            // Walk from vCurrent up to the target node and collect all keyed siblings
            let vNode = vCurrent;
            while (vNode && vNode !== targetNode) {
                const name = vnode_isElementVNode(vNode) ? vnode_getElementName(vNode) : null;
                const vKey = getKey(vNode) || getComponentHash(vNode, container.$getObjectById$);
                if (vKey != null) {
                    const sideBufferKey = getSideBufferKey(name, vKey);
                    vSideBuffer ||= new Map();
                    vSideBuffer.set(sideBufferKey, vNode);
                    vSiblings?.delete(sideBufferKey);
                }
                vNode = vNode.nextSibling;
            }
        }
        function getSideBufferKey(nodeName, key) {
            if (key == null) {
                return null;
            }
            return nodeName ? nodeName + ':' + key : key;
        }
        function deleteFromSideBuffer(nodeName, key) {
            const sbKey = getSideBufferKey(nodeName, key);
            if (sbKey && vSideBuffer?.has(sbKey)) {
                vSideBuffer.delete(sbKey);
                return true;
            }
            return false;
        }
        /**
         * Shared utility to resolve a keyed node by:
         *
         * 1. Scanning forward siblings via `retrieveChildWithKey`
         * 2. Falling back to the side buffer using the provided `sideBufferKey`
         * 3. Creating a new node via `createNew` when not found
         *
         * If a node is moved from the side buffer, it is inserted before `vCurrent` under
         * `parentForInsert`. The function updates `vCurrent`/`vNewNode` accordingly and returns the value
         * from `createNew` when a new node is created.
         */
        function moveOrCreateKeyedNode(nodeName, lookupKey, sideBufferKey, parentForInsert, createNew, addCurrentToSideBufferOnSideInsert) {
            // 1) Try to find the node among upcoming siblings
            vNewNode = retrieveChildWithKey(nodeName, lookupKey);
            if (vNewNode) {
                vCurrent = vNewNode;
                vNewNode = null;
                return;
            }
            // 2) Try side buffer
            if (sideBufferKey != null) {
                const buffered = vSideBuffer?.get(sideBufferKey) || null;
                if (buffered) {
                    vSideBuffer.delete(sideBufferKey);
                    if (addCurrentToSideBufferOnSideInsert && vCurrent) {
                        const currentKey = getKey(vCurrent) || getComponentHash(vCurrent, container.$getObjectById$);
                        if (currentKey != null) {
                            const currentName = vnode_isElementVNode(vCurrent)
                                ? vnode_getElementName(vCurrent)
                                : null;
                            const currentSideKey = getSideBufferKey(currentName, currentKey);
                            if (currentSideKey != null) {
                                vSideBuffer ||= new Map();
                                vSideBuffer.set(currentSideKey, vCurrent);
                            }
                        }
                    }
                    vnode_insertBefore(journal, parentForInsert, buffered, vCurrent);
                    vCurrent = buffered;
                    vNewNode = null;
                    return;
                }
            }
            // 3) Create new
            return createNew();
        }
        function expectVirtual(type, jsxKey) {
            const checkKey = type === "F" /* VirtualType.Fragment */;
            const currentKey = getKey(vCurrent);
            const currentIsVirtual = vCurrent && vnode_isVirtualVNode(vCurrent);
            const isSameNode = currentIsVirtual && currentKey === jsxKey && (checkKey ? !!jsxKey : true);
            if (isSameNode) {
                // All is good.
                deleteFromSideBuffer(null, currentKey);
                return;
            }
            const createNew = () => {
                vnode_insertBefore(journal, vParent, (vNewNode = vnode_newVirtual()), vCurrent && getInsertBefore());
                vNewNode.setProp(ELEMENT_KEY, jsxKey);
                build.isDev && vNewNode.setProp(DEBUG_TYPE, type);
            };
            // For fragments without a key, always create a new virtual node (ensures rerender semantics)
            if (jsxKey === null) {
                createNew();
                return;
            }
            moveOrCreateKeyedNode(null, jsxKey, getSideBufferKey(null, jsxKey), vParent, createNew, true);
        }
        function expectComponent(component) {
            const componentMeta = component[SERIALIZABLE_STATE];
            let host = (vNewNode || vCurrent);
            const jsxNode = jsxValue;
            if (componentMeta) {
                const jsxProps = jsxNode.props;
                // QComponent
                let shouldRender = false;
                const [componentQRL] = componentMeta;
                const componentHash = componentQRL.$hash$;
                const vNodeComponentHash = getComponentHash(host, container.$getObjectById$);
                const lookupKey = jsxNode.key || componentHash;
                const vNodeLookupKey = getKey(host) || vNodeComponentHash;
                const lookupKeysAreEqual = lookupKey === vNodeLookupKey;
                const hashesAreEqual = componentHash === vNodeComponentHash;
                if (!lookupKeysAreEqual) {
                    const createNew = () => {
                        insertNewComponent(host, componentQRL, jsxProps);
                        shouldRender = true;
                    };
                    moveOrCreateKeyedNode(null, lookupKey, lookupKey, vParent, createNew);
                    host = (vNewNode || vCurrent);
                }
                else if (!hashesAreEqual || !jsxNode.key) {
                    insertNewComponent(host, componentQRL, jsxProps);
                    host = vNewNode;
                    shouldRender = true;
                }
                else {
                    // delete the key from the side buffer if it is the same component
                    deleteFromSideBuffer(null, lookupKey);
                }
                if (host) {
                    let vNodeProps = host.getProp(ELEMENT_PROPS, container.$getObjectById$);
                    let propsAreDifferent = false;
                    if (!shouldRender) {
                        propsAreDifferent =
                            propsDiffer(jsxProps[_CONST_PROPS], vNodeProps?.[_CONST_PROPS]) ||
                                propsDiffer(jsxProps[_VAR_PROPS], vNodeProps?.[_VAR_PROPS]);
                        shouldRender = shouldRender || propsAreDifferent;
                    }
                    if (shouldRender) {
                        if (propsAreDifferent) {
                            if (vNodeProps) {
                                // Reuse the same props instance, qrls can use the current props instance
                                // as a capture ref, so we can't change it.
                                // We need to do this directly, because normally we would subscribe to the signals
                                // if any signal is there.
                                vNodeProps[_CONST_PROPS] = jsxProps[_CONST_PROPS];
                                vNodeProps[_VAR_PROPS] = jsxProps[_VAR_PROPS];
                                vNodeProps[_OWNER] = jsxProps[_OWNER];
                            }
                            else if (jsxProps) {
                                // If there is no props instance, create a new one.
                                // We can do this because we are not using the props instance for anything else.
                                host.setProp(ELEMENT_PROPS, jsxProps);
                                vNodeProps = jsxProps;
                            }
                        }
                        // Assign the new QRL instance to the host.
                        // Unfortunately it is created every time, something to fix in the optimizer.
                        host.setProp(OnRenderProp, componentQRL);
                        /**
                         * Mark host as not deleted. The host could have been marked as deleted if it there was a
                         * cleanup run. Now we found it and want to reuse it, so we need to mark it as not
                         * deleted.
                         */
                        host.flags &= -33 /* VNodeFlags.Deleted */;
                        container.$scheduler$(6 /* ChoreType.COMPONENT */, host, componentQRL, vNodeProps);
                    }
                }
                descendContentToProject(jsxNode.children, host);
            }
            else {
                const lookupKey = jsxNode.key;
                const vNodeLookupKey = getKey(host);
                const lookupKeysAreEqual = lookupKey === vNodeLookupKey;
                const vNodeComponentHash = getComponentHash(host, container.$getObjectById$);
                const isInlineComponent = vNodeComponentHash == null;
                if ((host && !isInlineComponent) || lookupKey == null) {
                    insertNewInlineComponent();
                    host = vNewNode;
                }
                else if (!lookupKeysAreEqual) {
                    const createNew = () => {
                        // We did not find the inline component, create it.
                        insertNewInlineComponent();
                    };
                    moveOrCreateKeyedNode(null, lookupKey, lookupKey, vParent, createNew);
                    host = (vNewNode || vCurrent);
                }
                else {
                    // delete the key from the side buffer if it is the same component
                    deleteFromSideBuffer(null, lookupKey);
                }
                if (host) {
                    let componentHost = host;
                    // Find the closest component host which has `OnRender` prop. This is need for subscriptions context.
                    while (componentHost &&
                        (vnode_isVirtualVNode(componentHost)
                            ? componentHost.getProp(OnRenderProp, null) === null
                            : true)) {
                        componentHost = componentHost.parent;
                    }
                    const jsxOutput = executeComponent(container, host, (componentHost || container.rootVNode), component, jsxNode.props);
                    asyncQueue.push(jsxOutput, host);
                }
            }
        }
        function insertNewComponent(host, componentQRL, jsxProps) {
            if (host) {
                clearAllEffects(container, host);
            }
            vnode_insertBefore(journal, vParent, (vNewNode = vnode_newVirtual()), vCurrent && getInsertBefore());
            const jsxNode = jsxValue;
            build.isDev && vNewNode.setProp(DEBUG_TYPE, "C" /* VirtualType.Component */);
            container.setHostProp(vNewNode, OnRenderProp, componentQRL);
            container.setHostProp(vNewNode, ELEMENT_PROPS, jsxProps);
            container.setHostProp(vNewNode, ELEMENT_KEY, jsxNode.key);
        }
        function insertNewInlineComponent() {
            vnode_insertBefore(journal, vParent, (vNewNode = vnode_newVirtual()), vCurrent && getInsertBefore());
            const jsxNode = jsxValue;
            build.isDev && vNewNode.setProp(DEBUG_TYPE, "I" /* VirtualType.InlineComponent */);
            vNewNode.setProp(ELEMENT_PROPS, jsxNode.props);
            if (jsxNode.key) {
                vNewNode.setProp(ELEMENT_KEY, jsxNode.key);
            }
        }
        function expectText(text) {
            if (vCurrent !== null) {
                const type = vnode_getType(vCurrent);
                if (type === 3 /* Text */) {
                    if (text !== vnode_getText(vCurrent)) {
                        vnode_setText(journal, vCurrent, text);
                        return;
                    }
                    return;
                }
            }
            vnode_insertBefore(journal, vParent, (vNewNode = vnode_newText(container.document.createTextNode(text), text)), vCurrent);
        }
    };
    /**
     * Retrieve the key from the VNode.
     *
     * @param vNode - VNode to retrieve the key from
     * @returns Key
     */
    function getKey(vNode) {
        if (vNode == null) {
            return null;
        }
        return vNode.getProp(ELEMENT_KEY, null);
    }
    /**
     * Retrieve the component hash from the VNode.
     *
     * @param vNode - VNode to retrieve the key from
     * @param getObject - Function to retrieve the object by id for QComponent QRL
     * @returns Hash
     */
    function getComponentHash(vNode, getObject) {
        if (vNode == null) {
            return null;
        }
        const qrl = vNode.getProp(OnRenderProp, getObject);
        return qrl ? qrl.$hash$ : null;
    }
    /**
     * Marker class for JSX projection.
     *
     * Assume you have component like so
     *
     * ```
     * <SomeComponent>
     *   some-text
     *   <span q:slot="name">some more text</span>
     *   more-text
     * </SomeComponent>
     * ```
     *
     * Before the `<SomeCompetent/>` is processed its children are transformed into:
     *
     * ```
     *   <Projection q:slot="">
     *     some-text
     *     more-text
     *   </Projection>
     *   <Projection q:slot="name">
     *     <span q:slot="name">some more text</span>
     *   </Projection>
     * ```
     */
    function Projection() { }
    function propsDiffer(src, dst) {
        const srcEmpty = isPropsEmpty(src);
        const dstEmpty = isPropsEmpty(dst);
        if (srcEmpty && dstEmpty) {
            return false;
        }
        if (srcEmpty || dstEmpty) {
            return true;
        }
        const srcKeys = Object.keys(src);
        const dstKeys = Object.keys(dst);
        let srcLen = srcKeys.length;
        let dstLen = dstKeys.length;
        if ('children' in src) {
            srcLen--;
        }
        if (QBackRefs in src) {
            srcLen--;
        }
        if ('children' in dst) {
            dstLen--;
        }
        if (QBackRefs in dst) {
            dstLen--;
        }
        if (srcLen !== dstLen) {
            return true;
        }
        for (const key of srcKeys) {
            if (key === 'children' || key === QBackRefs) {
                continue;
            }
            if (!Object.prototype.hasOwnProperty.call(dst, key) || src[key] !== dst[key]) {
                return true;
            }
        }
        return false;
    }
    function isPropsEmpty(props) {
        if (!props) {
            return true;
        }
        return Object.keys(props).length === 0;
    }
    /**
     * If vnode is removed, it is necessary to release all subscriptions associated with it.
     *
     * This function will traverse the vnode tree in depth-first order and release all subscriptions.
     *
     * The function takes into account:
     *
     * - Projection nodes by not recursing into them.
     * - Component nodes by recursing into the component content nodes (which may be projected).
     */
    function cleanup(container, vNode) {
        let vCursor = vNode;
        // Depth first traversal
        if (vnode_isTextVNode(vNode)) {
            markVNodeAsDeleted(vCursor);
            // Text nodes don't have subscriptions or children;
            return;
        }
        let vParent = null;
        do {
            const type = vCursor.flags;
            if (type & 3 /* VNodeFlags.ELEMENT_OR_VIRTUAL_MASK */) {
                clearAllEffects(container, vCursor);
                markVNodeAsDeleted(vCursor);
                // Only elements and virtual nodes need to be traversed for children
                if (type & 2 /* VNodeFlags.Virtual */) {
                    const seq = container.getHostProp(vCursor, ELEMENT_SEQ);
                    if (seq) {
                        for (let i = 0; i < seq.length; i++) {
                            const obj = seq[i];
                            if (isTask(obj)) {
                                const task = obj;
                                clearAllEffects(container, task);
                                if (task.$flags$ & 1 /* TaskFlags.VISIBLE_TASK */) {
                                    container.$scheduler$(32 /* ChoreType.CLEANUP_VISIBLE */, task);
                                }
                                else {
                                    cleanupTask(task);
                                }
                            }
                        }
                    }
                }
                const isComponent = type & 2 /* VNodeFlags.Virtual */ &&
                    vCursor.getProp(OnRenderProp, null) !== null;
                if (isComponent) {
                    // SPECIAL CASE: If we are a component, we need to descend into the projected content and release the content.
                    const attrs = vnode_getProps(vCursor);
                    for (let i = 0; i < attrs.length; i = i + 2) {
                        const key = attrs[i];
                        if (isSlotProp(key)) {
                            const value = attrs[i + 1];
                            if (value) {
                                attrs[i + 1] = null; // prevent infinite loop
                                const projection = typeof value === 'string'
                                    ? vnode_locate(container.rootVNode, value)
                                    : value;
                                let projectionChild = vnode_getFirstChild(projection);
                                while (projectionChild) {
                                    cleanup(container, projectionChild);
                                    projectionChild = projectionChild.nextSibling;
                                }
                                cleanupStaleUnclaimedProjection(container.$journal$, projection);
                            }
                        }
                    }
                }
                const isProjection = vnode_isProjection(vCursor);
                // Descend into children
                if (!isProjection) {
                    // Only if it is not a projection
                    const vFirstChild = vnode_getFirstChild(vCursor);
                    if (vFirstChild) {
                        vCursor = vFirstChild;
                        continue;
                    }
                }
                else if (vCursor === vNode) {
                    /**
                     * If it is a projection and we are at the root, then we should only walk the children to
                     * materialize the projection content. This is because we could have references in the vnode
                     * refs map which need to be materialized before cleanup.
                     */
                    const vFirstChild = vnode_getFirstChild(vCursor);
                    if (vFirstChild) {
                        vnode_walkVNode(vFirstChild, (vNode) => {
                            /**
                             * Instead of an ID, we store a direct reference to the VNode. This is necessary to
                             * locate the slot's parent in a detached subtree, as the ID would become invalid.
                             */
                            if (vNode.flags & 2 /* VNodeFlags.Virtual */) {
                                // The QSlotParent is used to find the slot parent during scheduling
                                vNode.slotParent;
                            }
                        });
                        return;
                    }
                }
            }
            else if (type & 4 /* VNodeFlags.Text */) {
                markVNodeAsDeleted(vCursor);
            }
            // Out of children
            if (vCursor === vNode) {
                // we are where we started, this means that vNode has no children, so we are done.
                return;
            }
            // Out of children, go to next sibling
            const vNextSibling = vCursor.nextSibling;
            if (vNextSibling) {
                vCursor = vNextSibling;
                continue;
            }
            // Out of siblings, go to parent
            vParent = vCursor.parent;
            while (vParent) {
                if (vParent === vNode) {
                    // We are back where we started, we are done.
                    return;
                }
                const vNextParentSibling = vParent.nextSibling;
                if (vNextParentSibling) {
                    vCursor = vNextParentSibling;
                    break;
                }
                vParent = vParent.parent;
            }
            if (vParent == null) {
                // We are done.
                return;
            }
        } while (true);
    }
    function cleanupStaleUnclaimedProjection(journal, projection) {
        // we are removing a node where the projection would go after slot render.
        // This is not needed, so we need to cleanup still unclaimed projection
        const projectionParent = projection.parent;
        if (projectionParent) {
            const projectionParentType = projectionParent.flags;
            if (projectionParentType & 1 /* VNodeFlags.Element */ &&
                vnode_getElementName(projectionParent) === QTemplate) {
                // if parent is the q:template element then projection is still unclaimed - remove it
                vnode_remove(journal, projectionParent, projection, true);
            }
        }
    }
    function markVNodeAsDeleted(vCursor) {
        /**
         * Marks vCursor as deleted. We need to do this to prevent chores from running after the vnode is
         * removed. (for example signal subscriptions)
         */
        vCursor.flags |= 32 /* VNodeFlags.Deleted */;
    }
    /**
     * This marks the property as immutable. It is needed for the QRLs so that QwikLoader can get a hold
     * of them. This character must be `:` so that the `vnode_getAttr` can ignore them.
     */
    const HANDLER_PREFIX = ':';
    let count = 0;

    /**
     * Rules for determining if a chore is blocked by another chore. Some chores can block other chores.
     * They cannot run until the blocking chore has completed.
     *
     * The match function is used to determine if the blocked chore is blocked by the blocking chore.
     * The match function is called with the blocked chore, the blocking chore, and the container.
     */
    const VISIBLE_BLOCKING_RULES = [
        // NODE_DIFF blocks VISIBLE on same host,
        // if the blocked chore is a child of the blocking chore
        // or the blocked chore is a sibling of the blocking chore
        {
            blockedType: 16 /* ChoreType.VISIBLE */,
            blockingType: 4 /* ChoreType.NODE_DIFF */,
            match: (blocked, blocking) => isDescendant(blocked, blocking) || isDescendant(blocking, blocked),
        },
        // COMPONENT blocks VISIBLE on same host
        // if the blocked chore is a child of the blocking chore
        // or the blocked chore is a sibling of the blocking chore
        {
            blockedType: 16 /* ChoreType.VISIBLE */,
            blockingType: 6 /* ChoreType.COMPONENT */,
            match: (blocked, blocking) => isDescendant(blocked, blocking) || isDescendant(blocking, blocked),
        },
    ];
    const BLOCKING_RULES = [
        // QRL_RESOLVE blocks RUN_QRL, TASK, VISIBLE on same host
        {
            blockedType: 2 /* ChoreType.RUN_QRL */,
            blockingType: 1 /* ChoreType.QRL_RESOLVE */,
            match: (blocked, blocking) => {
                const blockedQrl = blocked.$target$;
                const blockingQrl = blocking.$target$;
                return isSameHost(blocked, blocking) && isSameQrl(blockedQrl, blockingQrl);
            },
        },
        {
            blockedType: 3 /* ChoreType.TASK */,
            blockingType: 1 /* ChoreType.QRL_RESOLVE */,
            match: (blocked, blocking) => {
                const blockedTask = blocked.$payload$;
                const blockingQrl = blocking.$target$;
                return isSameHost(blocked, blocking) && isSameQrl(blockedTask.$qrl$, blockingQrl);
            },
        },
        {
            blockedType: 16 /* ChoreType.VISIBLE */,
            blockingType: 1 /* ChoreType.QRL_RESOLVE */,
            match: (blocked, blocking) => {
                const blockedTask = blocked.$payload$;
                const blockingQrl = blocking.$target$;
                return isSameHost(blocked, blocking) && isSameQrl(blockedTask.$qrl$, blockingQrl);
            },
        },
        // COMPONENT blocks NODE_DIFF, NODE_PROP on same host
        {
            blockedType: 4 /* ChoreType.NODE_DIFF */,
            blockingType: 6 /* ChoreType.COMPONENT */,
            match: (blocked, blocking) => blocked.$host$ === blocking.$host$,
        },
        {
            blockedType: 5 /* ChoreType.NODE_PROP */,
            blockingType: 6 /* ChoreType.COMPONENT */,
            match: (blocked, blocking) => blocked.$host$ === blocking.$host$,
        },
        ...VISIBLE_BLOCKING_RULES,
        // TASK blocks subsequent TASKs in the same component
        {
            blockedType: 3 /* ChoreType.TASK */,
            blockingType: 3 /* ChoreType.TASK */,
            match: (blocked, blocking, container) => {
                if (blocked.$host$ !== blocking.$host$) {
                    return false;
                }
                const blockedIdx = blocked.$idx$;
                if (!isNumber$1(blockedIdx) || blockedIdx <= 0) {
                    return false;
                }
                const previousTask = findPreviousTaskInComponent(blocked.$host$, blockedIdx, container);
                return previousTask === blocking.$payload$;
            },
        },
    ];
    function isDescendant(descendantChore, ancestorChore) {
        const descendantHost = descendantChore.$host$;
        const ancestorHost = ancestorChore.$host$;
        if (!vnode_isVNode(descendantHost) || !vnode_isVNode(ancestorHost)) {
            return false;
        }
        return vnode_isDescendantOf(descendantHost, ancestorHost);
    }
    function isSameHost(a, b) {
        return a.$host$ === b.$host$;
    }
    function isSameQrl(a, b) {
        return a.$symbol$ === b.$symbol$;
    }
    function findAncestorBlockingChore(chore, type) {
        const host = chore.$host$;
        if (!vnode_isVNode(host)) {
            return null;
        }
        const isNormalQueue = type === 0 /* ChoreSetType.CHORES */;
        // Walk up the ancestor tree and check the map
        let current = host;
        current = vnode_getProjectionParentOrParent(current);
        while (current) {
            const blockingChores = isNormalQueue ? current.chores : current.blockedChores;
            if (blockingChores) {
                for (const blockingChore of blockingChores) {
                    if (blockingChore.$type$ < 16 /* ChoreType.VISIBLE */ &&
                        blockingChore.$type$ !== 3 /* ChoreType.TASK */ &&
                        blockingChore.$type$ !== 1 /* ChoreType.QRL_RESOLVE */ &&
                        blockingChore.$type$ !== 2 /* ChoreType.RUN_QRL */) {
                        return blockingChore;
                    }
                }
            }
            current = vnode_getProjectionParentOrParent(current);
        }
        return null;
    }
    function findBlockingChore(chore, choreQueue, blockedChores, runningChores, container) {
        const blockingChoreInChoreQueue = findAncestorBlockingChore(chore, 0 /* ChoreSetType.CHORES */);
        if (blockingChoreInChoreQueue) {
            return blockingChoreInChoreQueue;
        }
        const blockingChoreInBlockedChores = findAncestorBlockingChore(chore, 1 /* ChoreSetType.BLOCKED_CHORES */);
        if (blockingChoreInBlockedChores) {
            return blockingChoreInBlockedChores;
        }
        for (const rule of BLOCKING_RULES) {
            if (chore.$type$ !== rule.blockedType) {
                continue;
            }
            // Check in choreQueue
            // TODO(perf): better to iterate in reverse order?
            for (const candidate of choreQueue) {
                if (candidate.$type$ === rule.blockingType && rule.match(chore, candidate, container)) {
                    return candidate;
                }
            }
            // Check in blockedChores
            for (const candidate of blockedChores) {
                if (candidate.$type$ === rule.blockingType && rule.match(chore, candidate, container)) {
                    return candidate;
                }
            }
            // Check in runningChores
            for (const candidate of runningChores) {
                if (candidate.$type$ === rule.blockingType && rule.match(chore, candidate, container)) {
                    return candidate;
                }
            }
        }
        return null;
    }
    function findPreviousTaskInComponent(host, currentTaskIdx, container) {
        const elementSeq = container.getHostProp(host, ELEMENT_SEQ);
        if (!elementSeq || elementSeq.length <= currentTaskIdx) {
            return null;
        }
        for (let i = currentTaskIdx - 1; i >= 0; i--) {
            const candidate = elementSeq[i];
            if (candidate instanceof Task && candidate.$flags$ & 2 /* TaskFlags.TASK */) {
                return candidate;
            }
        }
        return null;
    }
    function findBlockingChoreForVisible(chore, runningChores, container) {
        for (const rule of VISIBLE_BLOCKING_RULES) {
            if (chore.$type$ !== rule.blockedType) {
                continue;
            }
            for (const candidate of runningChores) {
                if (candidate.$type$ === rule.blockingType && rule.match(chore, candidate, container)) {
                    return candidate;
                }
            }
        }
        return null;
    }

    // This can't be in platform.ts because it uses MessageChannel which cannot post messages with functions
    // TODO: move this to platform.ts somehow
    const createNextTick = (fn) => {
        let nextTick;
        // according to the https://developer.mozilla.org/en-US/docs/Web/API/Window/setImmediate#notes
        if (typeof setImmediate === 'function') {
            // setImmediate is the fastest way to schedule a task, but works only in node.js
            nextTick = () => {
                setImmediate(fn);
            };
        }
        else if (typeof MessageChannel !== 'undefined') {
            const channel = new MessageChannel();
            channel.port1.onmessage = () => {
                fn();
            };
            nextTick = () => {
                channel.port2.postMessage(null);
            };
        }
        else {
            // setTimeout is a fallback, creates 4ms delay
            nextTick = () => {
                setTimeout(fn);
            };
        }
        return nextTick;
    };

    /// These global variables are used to avoid creating new arrays for each call to `vnode_documentPosition`.
    const aVNodePath = [];
    const bVNodePath = [];
    /**
     * Compare two VNodes and determine their document position relative to each other.
     *
     * @param a VNode to compare
     * @param b VNode to compare
     * @returns -1 if `a` is before `b`, 0 if `a` is the same as `b`, 1 if `a` is after `b`.
     */
    const vnode_documentPosition = (a, b) => {
        if (a === b) {
            return 0;
        }
        let aDepth = -1;
        let bDepth = -1;
        while (a) {
            const vNode = (aVNodePath[++aDepth] = a);
            a = (vNode.parent || a.slotParent);
        }
        while (b) {
            const vNode = (bVNodePath[++bDepth] = b);
            b = (vNode.parent || b.slotParent);
        }
        while (aDepth >= 0 && bDepth >= 0) {
            a = aVNodePath[aDepth];
            b = bVNodePath[bDepth];
            if (a === b) {
                // if the nodes are the same, we need to check the next level.
                aDepth--;
                bDepth--;
            }
            else {
                // We found a difference so we need to scan nodes at this level.
                let cursor = b;
                do {
                    cursor = cursor.nextSibling;
                    if (cursor === a) {
                        return 1;
                    }
                } while (cursor);
                cursor = b;
                do {
                    cursor = cursor.previousSibling;
                    if (cursor === a) {
                        return -1;
                    }
                } while (cursor);
                if (b.slotParent) {
                    // The "b" node is a projection, so we need to set it after "a" node,
                    // because the "a" node could be a context provider.
                    return -1;
                }
                // The node is not in the list of siblings, that means it must be disconnected.
                return 1;
            }
        }
        return aDepth < bDepth ? -1 : 1;
    };
    /// These global variables are used to avoid creating new arrays for each call to `ssrNodeDocumentPosition`.
    const aSsrNodePath = [];
    const bSsrNodePath = [];
    /**
     * Compare two SSR nodes and determine their document position relative to each other. Compares only
     * position between parent and child.
     *
     * @param a SSR node to compare
     * @param b SSR node to compare
     * @returns -1 if `a` is before `b`, 0 if `a` is the same as `b`, 1 if `a` is after `b`.
     */
    const ssrNodeDocumentPosition = (a, b) => {
        if (a === b) {
            return 0;
        }
        let aDepth = -1;
        let bDepth = -1;
        while (a) {
            const ssrNode = (aSsrNodePath[++aDepth] = a);
            a = ssrNode.parentComponent;
        }
        while (b) {
            const ssrNode = (bSsrNodePath[++bDepth] = b);
            b = ssrNode.parentComponent;
        }
        while (aDepth >= 0 && bDepth >= 0) {
            a = aSsrNodePath[aDepth];
            b = bSsrNodePath[bDepth];
            if (a === b) {
                // if the nodes are the same, we need to check the next level.
                aDepth--;
                bDepth--;
            }
            else {
                return 1;
            }
        }
        return aDepth < bDepth ? -1 : 1;
    };

    class ChoreArray extends Array {
        add(value) {
            /// We need to ensure that the `queue` is sorted by priority.
            /// 1. Find a place where to insert into.
            const idx = sortedFindIndex(this, value);
            if (idx < 0) {
                /// 2. Insert the chore into the queue.
                this.splice(~idx, 0, value);
                return idx;
            }
            const existing = this[idx];
            /**
             * When a derived signal is updated we need to run vnode_diff. However the signal can update
             * multiple times during component execution. For this reason it is necessary for us to update
             * the chore with the latest result of the signal.
             */
            if (existing.$payload$ !== value.$payload$) {
                existing.$payload$ = value.$payload$;
            }
            return idx;
        }
        delete(value) {
            const idx = this.indexOf(value);
            if (idx >= 0) {
                this.splice(idx, 1);
            }
            return idx;
        }
    }
    function sortedFindIndex(sortedArray, value) {
        /// We need to ensure that the `queue` is sorted by priority.
        /// 1. Find a place where to insert into.
        let bottom = 0;
        let top = sortedArray.length;
        while (bottom < top) {
            const middle = bottom + ((top - bottom) >> 1);
            const midChore = sortedArray[middle];
            const comp = choreComparator(value, midChore);
            if (comp < 0) {
                top = middle;
            }
            else if (comp > 0) {
                bottom = middle + 1;
            }
            else {
                // We already have the host in the queue.
                return middle;
            }
        }
        return ~bottom;
    }
    /**
     * Compares two chores to determine their execution order in the scheduler's queue.
     *
     * @param a - The first chore to compare
     * @param b - The second chore to compare
     * @returns A number indicating the relative order of the chores. A negative number means `a` runs
     *   before `b`.
     */
    function choreComparator(a, b) {
        const macroTypeDiff = (a.$type$ & 240 /* ChoreType.MACRO */) - (b.$type$ & 240 /* ChoreType.MACRO */);
        if (macroTypeDiff !== 0) {
            return macroTypeDiff;
        }
        const aHost = a.$host$;
        const bHost = b.$host$;
        if (aHost !== bHost && aHost !== null && bHost !== null) {
            if (vnode_isVNode(aHost) && vnode_isVNode(bHost)) {
                // we are running on the client.
                const hostDiff = vnode_documentPosition(aHost, bHost);
                if (hostDiff !== 0) {
                    return hostDiff;
                }
            }
            else {
                assertFalse(vnode_isVNode(aHost), 'expected aHost to be SSRNode but it is a VNode');
                assertFalse(vnode_isVNode(bHost), 'expected bHost to be SSRNode but it is a VNode');
                const hostDiff = ssrNodeDocumentPosition(aHost, bHost);
                if (hostDiff !== 0) {
                    return hostDiff;
                }
            }
        }
        const microTypeDiff = (a.$type$ & 15 /* ChoreType.MICRO */) - (b.$type$ & 15 /* ChoreType.MICRO */);
        if (microTypeDiff !== 0) {
            return microTypeDiff;
        }
        // types are the same
        const idxDiff = toNumber(a.$idx$) - toNumber(b.$idx$);
        if (idxDiff !== 0) {
            return idxDiff;
        }
        // If the host is the same (or missing), and the type is the same,  we need to compare the target.
        if (a.$target$ !== b.$target$) {
            if (isQrl(a.$target$) && isQrl(b.$target$) && a.$target$.$hash$ === b.$target$.$hash$) {
                return 0;
            }
            // 1 means that we are going to process chores as FIFO
            return 1;
        }
        // ensure that the effect chores are scheduled for the same target
        // TODO: can we do this better?
        if (a.$type$ === 7 /* ChoreType.RECOMPUTE_AND_SCHEDULE_EFFECTS */ &&
            b.$type$ === 7 /* ChoreType.RECOMPUTE_AND_SCHEDULE_EFFECTS */ &&
            ((a.$target$ instanceof StoreHandler && b.$target$ instanceof StoreHandler) ||
                (a.$target$ instanceof AsyncComputedSignalImpl &&
                    b.$target$ instanceof AsyncComputedSignalImpl)) &&
            a.$payload$ !== b.$payload$) {
            return 1;
        }
        // The chores are the same and will run only once
        return 0;
    }
    function toNumber(value) {
        return typeof value === 'number' ? value : -1;
    }

    /**
     * Scheduler is responsible for running application code in predictable order.
     *
     * ## What is a Chore?
     *
     * A Chore is a unit of work that needs to be done. It can be:
     *
     * - Task / Resource
     * - Visible Task
     * - Component
     * - Computed
     * - Node Diff
     *
     * ## Order of execution
     *
     * - Parent component chores should run before child component chores.
     * - Visible Tasks should run after journal flush (visible tasks often read DOM layout.)
     *
     * ## Example
     *
     * ```typescript
     * const Child = component$(() => {
     *   useTask$(() => {
     *     console.log('Child task');
     *   });
     *   useVisibleTask$(() => {
     *     console.log('Child visible-task');
     *   });
     *   console.log('Child render');
     *   return <div>Child</div>;
     * });
     *
     * const Parent = component$(() => {
     *   const count = useSignal(0);
     *   useTask$(() => {
     *     console.log('Parent task', count.value);
     *   });
     *   useVisibleTask$(() => {
     *     console.log('Parent visible-task', count.value);
     *     count.value++;
     *   });
     *   console.log('Parent render', count.value);
     *   return <Child/>;
     * });
     * ```
     *
     * ## In the above example, the order of execution is:
     *
     * 1. Parent task 0
     * 2. Parent render 0
     * 3. Child task 0
     * 4. Child render 0
     * 5. Journal flush
     * 6. Parent visible-task 0
     * 7. Parent render 1
     * 8. Journal flush
     * 9. Child visible-task
     *
     * If at any point a new chore is scheduled it will insert itself into the correct order.
     *
     * ## Implementation
     *
     * Chores are kept in a sorted array. When a new chore is scheduled it is inserted into the correct
     * location. Processing of the chores always starts from the beginning of the array. This ensures
     * that parent chores are processed before child chores.
     *
     * ## Sorting
     *
     * Chores are sorted in three levels:
     *
     * - Macro: beforeJournalFlush, journalFlush, afterJournalFlush
     * - Component: depth first order of components
     * - Micro: order of chores within a component.
     *
     * Example of sorting:
     *
     * - Tasks are beforeJournalFlush, than depth first on component and finally in declaration order
     *   within component.
     * - Visible Tasks are sorted afterJournalFlush, than depth first on component and finally in
     *   declaration order within component.
     */
    // Turn this on to get debug output of what the scheduler is doing.
    const DEBUG = false;
    var ChoreState;
    (function (ChoreState) {
        ChoreState[ChoreState["NONE"] = 0] = "NONE";
        ChoreState[ChoreState["RUNNING"] = 1] = "RUNNING";
        ChoreState[ChoreState["FAILED"] = 2] = "FAILED";
        ChoreState[ChoreState["DONE"] = 3] = "DONE";
    })(ChoreState || (ChoreState = {}));
    const getChorePromise = (chore) => chore.$state$ === ChoreState.NONE
        ? (chore.$returnValue$ ||= new Promise((resolve, reject) => {
            chore.$resolve$ = resolve;
            chore.$reject$ = reject;
        }))
        : chore.$returnValue$;
    const createScheduler = (container, journalFlush, choreQueue, blockedChores, runningChores) => {
        let drainChore = null;
        let drainScheduled = false;
        let isDraining = false;
        let isJournalFlushRunning = false;
        let flushBudgetStart = 0;
        let currentTime = performance.now();
        const nextTick = createNextTick(drainChoreQueue);
        let flushTimerId = null;
        function drainInNextTick() {
            if (!drainScheduled) {
                drainScheduled = true;
                nextTick();
            }
        }
        // Drain for ~16.67ms, then apply journal flush for ~16.67ms, then repeat
        // We divide by 60 because we want to run at 60fps
        const FREQUENCY_MS = Math.floor(1000 / 60);
        return schedule;
        ///// IMPLEMENTATION /////
        function schedule(type, hostOrTask = null, targetOrQrl = null, payload = null) {
            if (type === 255 /* ChoreType.WAIT_FOR_QUEUE */ && drainChore) {
                return drainChore;
            }
            const isTask = type === 3 /* ChoreType.TASK */ || type === 16 /* ChoreType.VISIBLE */ || type === 32 /* ChoreType.CLEANUP_VISIBLE */;
            if (isTask) {
                hostOrTask.$flags$ |= 8 /* TaskFlags.DIRTY */;
            }
            const chore = {
                $type$: type,
                $idx$: isTask
                    ? hostOrTask.$index$
                    : typeof targetOrQrl === 'string'
                        ? targetOrQrl
                        : 0,
                $host$: isTask ? hostOrTask.$el$ : hostOrTask,
                $target$: targetOrQrl,
                $payload$: isTask ? hostOrTask : payload,
                $state$: ChoreState.NONE,
                $blockedChores$: null,
                $startTime$: undefined,
                $endTime$: undefined,
                $resolve$: undefined,
                $reject$: undefined,
                $returnValue$: null,
            };
            if (type === 255 /* ChoreType.WAIT_FOR_QUEUE */) {
                getChorePromise(chore);
                drainChore = chore;
                drainInNextTick();
                return chore;
            }
            const isServer = isServerPlatform();
            const isClientOnly = type === 4 /* ChoreType.NODE_DIFF */ || type === 1 /* ChoreType.QRL_RESOLVE */;
            if (isServer && isClientOnly) {
                // Mark skipped client-only chores as completed on the server
                finishChore(chore, undefined);
                return chore;
            }
            if (isServer && chore.$host$ && isSsrNode(chore.$host$)) {
                const isUpdatable = !!(chore.$host$.flags & 1 /* SsrNodeFlags.Updatable */);
                if (!isUpdatable) {
                    if (
                    // backpatching exceptions:
                    // - node prop is allowed because it is used to update the node property
                    // - recompute and schedule effects because it triggers effects (so node prop too)
                    chore.$type$ !== 5 /* ChoreType.NODE_PROP */ &&
                        chore.$type$ !== 7 /* ChoreType.RECOMPUTE_AND_SCHEDULE_EFFECTS */) {
                        // We are running on the server.
                        // On server we can't schedule task for a different host!
                        // Server is SSR, and therefore scheduling for anything but the current host
                        // implies that things need to be re-run and that is not supported because of streaming.
                        const warningMessage = `A '${choreTypeToName(chore.$type$)}' chore was scheduled on a host element that has already been streamed to the client.
This can lead to inconsistencies between Server-Side Rendering (SSR) and Client-Side Rendering (CSR).

Problematic chore:
  - Type: ${choreTypeToName(chore.$type$)}
  - Host: ${chore.$host$.toString()}
  - Nearest element location: ${chore.$host$.currentFile}

This is often caused by modifying a signal in an already rendered component during SSR.`;
                        logWarn(warningMessage);
                        return chore;
                    }
                }
            }
            const shouldBlock = chore.$type$ !== 1 /* ChoreType.QRL_RESOLVE */ && chore.$type$ !== 2 /* ChoreType.RUN_QRL */;
            if (shouldBlock) {
                const blockingChore = findBlockingChore(chore, choreQueue, blockedChores, runningChores, container);
                if (blockingChore) {
                    addBlockedChore(chore, blockingChore, blockedChores);
                    return chore;
                }
                const runningChore = getRunningChore(chore);
                if (runningChore) {
                    addBlockedChore(chore, runningChore, blockedChores);
                    return chore;
                }
            }
            addChore(chore, choreQueue);
            const runImmediately = (isServer && type === 6 /* ChoreType.COMPONENT */) || type === 2 /* ChoreType.RUN_QRL */;
            if (runImmediately && !isDraining) {
                immediateDrain();
            }
            else {
                drainInNextTick();
            }
            return chore;
        }
        function immediateDrain() {
            drainScheduled = true;
            drainChoreQueue();
        }
        ////////////////////////////////////////////////////////////////////////////////
        // Drain queue helpers
        ////////////////////////////////////////////////////////////////////////////////
        function cancelFlushTimer() {
            if (flushTimerId != null) {
                clearTimeout(flushTimerId);
                flushTimerId = null;
            }
        }
        function scheduleFlushTimer() {
            const isServer = isServerPlatform();
            // Never schedule timers on the server
            if (isServer) {
                return;
            }
            // Ignore if a timer is already scheduled
            if (flushTimerId != null) {
                return;
            }
            const now = performance.now();
            const elapsed = now - flushBudgetStart;
            const delay = Math.max(0, FREQUENCY_MS - elapsed);
            // Deadline already reached, flush now
            if (delay === 0) {
                if (!isDraining) {
                    applyJournalFlush();
                }
                return;
            }
            flushTimerId = setTimeout(() => {
                flushTimerId = null;
                applyJournalFlush();
            }, delay);
        }
        function applyJournalFlush() {
            if (!isJournalFlushRunning) {
                // prevent multiple journal flushes from running at the same time
                isJournalFlushRunning = true;
                journalFlush();
                isJournalFlushRunning = false;
                flushBudgetStart = performance.now();
                cancelFlushTimer();
            }
        }
        function shouldApplyJournalFlush(isServer) {
            return !isServer && currentTime - flushBudgetStart >= FREQUENCY_MS;
        }
        function drainChoreQueue() {
            const isServer = isServerPlatform();
            drainScheduled = false;
            if (isDraining) {
                return;
            }
            // early return if the queue is empty
            if (!choreQueue.length) {
                applyJournalFlush();
                if (drainChore && !runningChores.size) {
                    // resolve drainChore only if there are no running chores, because
                    // we are sure that we are done
                    drainChore.$resolve$(null);
                    drainChore = null;
                }
                return;
            }
            isDraining = true;
            flushBudgetStart = performance.now();
            cancelFlushTimer();
            const maybeFinishDrain = () => {
                if (choreQueue.length) {
                    drainInNextTick();
                    return false;
                }
                if (drainChore && runningChores.size) {
                    if (shouldApplyJournalFlush(isServer)) {
                        // apply journal flush even if we are not finished draining the queue
                        applyJournalFlush();
                    }
                    return false;
                }
                currentChore = null;
                applyJournalFlush();
                drainChore?.$resolve$(null);
                drainChore = null;
                return true;
            };
            const scheduleBlockedChoresAndDrainIfNeeded = (chore) => {
                let blockedChoresScheduled = false;
                if (chore.$blockedChores$) {
                    for (const blockedChore of chore.$blockedChores$) {
                        const blockingChore = findBlockingChore(blockedChore, choreQueue, blockedChores, runningChores, container);
                        if (blockingChore) {
                            // Chore is still blocked, move it to the new blocking chore's list
                            // Note: chore is already in blockedChores Set and vnode.blockedChores,
                            // so we only add to the new blocking chore's list
                            (blockingChore.$blockedChores$ ||= new ChoreArray()).add(blockedChore);
                        }
                        else {
                            blockedChores.delete(blockedChore);
                            if (vnode_isVNode(blockedChore.$host$)) {
                                blockedChore.$host$.blockedChores?.delete(blockedChore);
                            }
                            addChore(blockedChore, choreQueue);
                            blockedChoresScheduled = true;
                        }
                    }
                    chore.$blockedChores$ = null;
                }
                if (blockedChoresScheduled && !isDraining) {
                    drainInNextTick();
                }
            };
            let currentChore = null;
            try {
                while (choreQueue.length) {
                    currentTime = performance.now();
                    const chore = (currentChore = choreQueue.shift());
                    if (chore.$state$ !== ChoreState.NONE) {
                        continue;
                    }
                    if (vNodeAlreadyDeleted(chore) &&
                        // we need to process cleanup tasks for deleted nodes
                        chore.$type$ !== 32 /* ChoreType.CLEANUP_VISIBLE */) {
                        // skip deleted chore
                        DEBUG && debugTrace('skip chore', chore, choreQueue, blockedChores);
                        if (vnode_isVNode(chore.$host$)) {
                            chore.$host$.chores?.delete(chore);
                        }
                        continue;
                    }
                    if (chore.$type$ === 16 /* ChoreType.VISIBLE */) {
                        // ensure that the journal flush is applied before the visible chore is executed
                        // so that the visible chore can see the latest DOM changes
                        applyJournalFlush();
                        const blockingChore = findBlockingChoreForVisible(chore, runningChores, container);
                        if (blockingChore && blockingChore.$state$ === ChoreState.RUNNING) {
                            addBlockedChore(chore, blockingChore, blockedChores);
                            continue;
                        }
                    }
                    // Note that this never throws
                    chore.$startTime$ = performance.now();
                    const result = executeChore(chore, isServer);
                    chore.$returnValue$ = result;
                    if (isPromise(result)) {
                        runningChores.add(chore);
                        chore.$state$ = ChoreState.RUNNING;
                        result
                            .then((value) => {
                            finishChore(chore, value);
                        })
                            .catch((e) => {
                            if (chore.$state$ !== ChoreState.RUNNING) {
                                // we already handled an error but maybe it's a different one so we log it
                                console.error(e);
                                return;
                            }
                            handleError(chore, e);
                        })
                            .finally(() => {
                            runningChores.delete(chore);
                            // Note that we ignore failed chores so the app keeps working
                            // TODO decide if this is ok and document it
                            scheduleBlockedChoresAndDrainIfNeeded(chore);
                            // If drainChore is not null, we are waiting for it to finish.
                            // If there are no running chores, we can finish the drain.
                            let finished = false;
                            if (drainChore && !runningChores.size) {
                                finished = maybeFinishDrain();
                            }
                            if (!finished && !isDraining) {
                                scheduleFlushTimer();
                            }
                        });
                    }
                    else {
                        finishChore(chore, result);
                        scheduleBlockedChoresAndDrainIfNeeded(chore);
                    }
                    if (shouldApplyJournalFlush(isServer)) {
                        applyJournalFlush();
                        drainInNextTick();
                        return;
                    }
                }
            }
            catch (e) {
                handleError(currentChore, e);
                scheduleBlockedChoresAndDrainIfNeeded(currentChore);
            }
            finally {
                isDraining = false;
                maybeFinishDrain();
            }
        }
        function finishChore(chore, value) {
            chore.$endTime$ = performance.now();
            chore.$state$ = ChoreState.DONE;
            chore.$returnValue$ = value;
            chore.$resolve$?.(value);
            if (vnode_isVNode(chore.$host$)) {
                chore.$host$.chores?.delete(chore);
            }
        }
        function handleError(chore, e) {
            chore.$endTime$ = performance.now();
            chore.$state$ = ChoreState.FAILED;
            // If we used the result as promise, this won't exist
            chore.$reject$?.(e);
            container.handleError(e, chore.$host$);
        }
        function executeChore(chore, isServer) {
            const host = chore.$host$;
            let returnValue;
            switch (chore.$type$) {
                case 6 /* ChoreType.COMPONENT */:
                    {
                        returnValue = safeCall(() => executeComponent(container, host, host, chore.$target$, chore.$payload$), (jsx) => {
                            if (isServer) {
                                return jsx;
                            }
                            else {
                                const styleScopedId = container.getHostProp(host, QScopedStyle);
                                return retryOnPromise(() => vnode_diff(container, jsx, host, addComponentStylePrefix(styleScopedId)));
                            }
                        }, (err) => {
                            handleError(chore, err);
                        });
                    }
                    break;
                case 2 /* ChoreType.RUN_QRL */:
                    {
                        const fn = chore.$target$.getFn();
                        returnValue = retryOnPromise(() => fn(...chore.$payload$));
                    }
                    break;
                case 3 /* ChoreType.TASK */:
                case 16 /* ChoreType.VISIBLE */:
                    {
                        const payload = chore.$payload$;
                        if (payload.$flags$ & 4 /* TaskFlags.RESOURCE */) {
                            returnValue = runResource(payload, container, host);
                        }
                        else {
                            returnValue = runTask(payload, container, host);
                        }
                    }
                    break;
                case 32 /* ChoreType.CLEANUP_VISIBLE */:
                    {
                        const task = chore.$payload$;
                        cleanupTask(task);
                    }
                    break;
                case 4 /* ChoreType.NODE_DIFF */:
                    {
                        const parentVirtualNode = chore.$target$;
                        let jsx = chore.$payload$;
                        if (isSignal(jsx)) {
                            jsx = jsx.value;
                        }
                        returnValue = retryOnPromise(() => vnode_diff(container, jsx, parentVirtualNode, null));
                    }
                    break;
                case 5 /* ChoreType.NODE_PROP */:
                    {
                        const virtualNode = chore.$host$;
                        const payload = chore.$payload$;
                        let value = payload.$value$;
                        if (isSignal(value)) {
                            value = value.value;
                        }
                        const isConst = payload.$isConst$;
                        const journal = container.$journal$;
                        const property = chore.$idx$;
                        const serializedValue = serializeAttribute(property, value, payload.$scopedStyleIdPrefix$);
                        if (isServer) {
                            container.addBackpatchEntry(chore.$host$.id, property, serializedValue);
                            returnValue = null;
                        }
                        else {
                            if (isConst) {
                                const element = virtualNode.element;
                                journal.push(2 /* VNodeJournalOpCode.SetAttribute */, element, property, serializedValue);
                            }
                            else {
                                virtualNode.setAttr(property, serializedValue, journal);
                            }
                            returnValue = undefined;
                        }
                    }
                    break;
                case 1 /* ChoreType.QRL_RESOLVE */: {
                    {
                        const target = chore.$target$;
                        returnValue = (!target.resolved ? target.resolve() : null);
                    }
                    break;
                }
                case 7 /* ChoreType.RECOMPUTE_AND_SCHEDULE_EFFECTS */: {
                    {
                        const target = chore.$target$;
                        const effects = chore.$payload$;
                        if (!effects?.size) {
                            break;
                        }
                        let shouldCompute = target instanceof ComputedSignalImpl || target instanceof WrappedSignalImpl;
                        // for .error and .loading effects
                        if (target instanceof AsyncComputedSignalImpl && effects !== target.$effects$) {
                            shouldCompute = false;
                        }
                        if (shouldCompute) {
                            const ctx = newInvokeContext();
                            ctx.$container$ = container;
                            // needed for computed signals and throwing QRLs
                            returnValue = maybeThen(retryOnPromise(() => invoke.call(target, ctx, target.$computeIfNeeded$)), () => {
                                if (target.$flags$ & 2 /* SignalFlags.RUN_EFFECTS */) {
                                    target.$flags$ &= -3 /* SignalFlags.RUN_EFFECTS */;
                                    return retryOnPromise(() => scheduleEffects(container, target, effects));
                                }
                            });
                        }
                        else {
                            returnValue = retryOnPromise(() => {
                                scheduleEffects(container, target, effects);
                            });
                        }
                    }
                    break;
                }
            }
            return returnValue;
        }
        function getRunningChore(chore) {
            if (runningChores.size) {
                // 1.1. Check if the chore is already running.
                for (const runningChore of runningChores) {
                    const comp = choreComparator(chore, runningChore);
                    if (comp === 0) {
                        return runningChore;
                    }
                }
            }
            return null;
        }
    };
    function vNodeAlreadyDeleted(chore) {
        return !!(chore.$host$ && vnode_isVNode(chore.$host$) && chore.$host$.flags & 32 /* VNodeFlags.Deleted */);
    }
    function addBlockedChore(blockedChore, blockingChore, blockedChores) {
        (blockingChore.$blockedChores$ ||= new ChoreArray()).add(blockedChore);
        blockedChores.add(blockedChore);
        if (vnode_isVNode(blockedChore.$host$)) {
            (blockedChore.$host$.blockedChores ||= new ChoreArray()).add(blockedChore);
        }
    }
    function addChore(chore, choreArray) {
        const idx = choreArray.add(chore);
        if (idx < 0 && vnode_isVNode(chore.$host$)) {
            (chore.$host$.chores ||= new ChoreArray()).add(chore);
        }
    }
    function choreTypeToName(type) {
        return ({
            [1 /* ChoreType.QRL_RESOLVE */]: 'Resolve QRL',
            [2 /* ChoreType.RUN_QRL */]: 'Run QRL',
            [3 /* ChoreType.TASK */]: 'Task',
            [4 /* ChoreType.NODE_DIFF */]: 'Changes diffing',
            [5 /* ChoreType.NODE_PROP */]: 'Updating node property',
            [6 /* ChoreType.COMPONENT */]: 'Component',
            [7 /* ChoreType.RECOMPUTE_AND_SCHEDULE_EFFECTS */]: 'Signal recompute',
            [16 /* ChoreType.VISIBLE */]: 'Visible',
            [32 /* ChoreType.CLEANUP_VISIBLE */]: 'Cleanup visible',
            [255 /* ChoreType.WAIT_FOR_QUEUE */]: 'Wait for queue',
        }[type] || 'Unknown: ' + type);
    }
    function debugChoreTypeToString(type) {
        return ({
            [1 /* ChoreType.QRL_RESOLVE */]: 'QRL_RESOLVE',
            [2 /* ChoreType.RUN_QRL */]: 'RUN_QRL',
            [3 /* ChoreType.TASK */]: 'TASK',
            [4 /* ChoreType.NODE_DIFF */]: 'NODE_DIFF',
            [5 /* ChoreType.NODE_PROP */]: 'NODE_PROP',
            [6 /* ChoreType.COMPONENT */]: 'COMPONENT',
            [7 /* ChoreType.RECOMPUTE_AND_SCHEDULE_EFFECTS */]: 'RECOMPUTE_SIGNAL',
            [16 /* ChoreType.VISIBLE */]: 'VISIBLE',
            [32 /* ChoreType.CLEANUP_VISIBLE */]: 'CLEANUP_VISIBLE',
            [255 /* ChoreType.WAIT_FOR_QUEUE */]: 'WAIT_FOR_QUEUE',
        }[type] || 'UNKNOWN: ' + type);
    }
    function debugTrace(action, arg, queue, blockedChores) {
        const lines = [];
        // Header
        lines.push(`Scheduler: ${action}`);
        // Argument section
        if (arg) {
            lines.push('');
            if (arg && '$type$' in arg) {
                const chore = arg;
                const type = debugChoreTypeToString(chore.$type$);
                const host = String(chore.$host$).replaceAll(/\n.*/gim, '');
                const qrlTarget = chore.$target$?.$symbol$;
                const targetOrHost = chore.$type$ === 1 /* ChoreType.QRL_RESOLVE */ || chore.$type$ === 2 /* ChoreType.RUN_QRL */
                    ? qrlTarget
                    : host;
                lines.push(`🎯 Current Chore:`);
                lines.push(`  Type: ${type}`);
                lines.push(`  Host: ${targetOrHost}`);
                // Show execution time if available
                if (chore.$startTime$ && chore.$endTime$) {
                    const executionTime = chore.$endTime$ - chore.$startTime$;
                    lines.push(`  Time: ${executionTime.toFixed(2)}ms`);
                }
                else if (chore.$startTime$) {
                    const elapsedTime = performance.now() - chore.$startTime$;
                    lines.push(`  Time: ${elapsedTime.toFixed(2)}ms (running)`);
                }
                // Show blocked chores for this chore
                if (chore.$blockedChores$ && chore.$blockedChores$.length > 0) {
                    lines.push(`  ⛔ Blocked Chores:`);
                    chore.$blockedChores$.forEach((blockedChore, index) => {
                        const blockedType = debugChoreTypeToString(blockedChore.$type$);
                        const blockedTarget = String(blockedChore.$host$).replaceAll(/\n.*/gim, '');
                        lines.push(`    ${index + 1}. ${blockedType} ${blockedTarget} ${blockedChore.$idx$}`);
                    });
                }
            }
            else {
                lines.push(`📝 Argument: ${String(arg).replaceAll(/\n.*/gim, '')}`);
            }
        }
        // Queue section
        if (queue && queue.length > 0) {
            lines.push('');
            lines.push(`📋 Queue (${queue.length} items):`);
            for (let i = 0; i < queue.length; i++) {
                const chore = queue[i];
                const isActive = chore === arg;
                const activeMarker = isActive ? `▶ ` : '  ';
                const type = debugChoreTypeToString(chore.$type$);
                const state = chore.$state$ ? `[${ChoreState[chore.$state$]}]` : '';
                const host = String(chore.$host$).replaceAll(/\n.*/gim, '');
                const qrlTarget = chore.$target$?.$symbol$;
                const target = chore.$type$ === 1 /* ChoreType.QRL_RESOLVE */ || chore.$type$ === 2 /* ChoreType.RUN_QRL */
                    ? qrlTarget
                    : host;
                const line = `${activeMarker}${state} ${type} ${target} ${chore.$idx$}`;
                lines.push(line);
            }
        }
        // Blocked chores section
        if (blockedChores && blockedChores.size > 0) {
            lines.push('');
            lines.push(`🚫 Blocked Chores (${blockedChores.size} items):`);
            Array.from(blockedChores).forEach((chore, index) => {
                const type = debugChoreTypeToString(chore.$type$);
                const host = String(chore.$host$).replaceAll(/\n.*/gim, '');
                const qrlTarget = chore.$target$?.$symbol$;
                const target = chore.$type$ === 1 /* ChoreType.QRL_RESOLVE */ || chore.$type$ === 2 /* ChoreType.RUN_QRL */
                    ? qrlTarget
                    : host;
                lines.push(`  ${index + 1}. ${type} ${target} ${chore.$idx$}`);
            });
        }
        // Footer
        lines.push('');
        lines.push('─'.repeat(60));
        // eslint-disable-next-line no-console
        console.log(lines.join('\n') + '\n');
    }

    /**
     * This is called by qwik-loader to run a QRL. It has to be synchronous.
     *
     * @internal
     */
    const _run = (...args) => {
        // This will already check container
        const [runQrl] = useLexicalScope();
        const context = getInvokeContext();
        const hostElement = context.$hostElement$;
        if (!hostElement) {
            // silently ignore if there is no host element, the element might have been removed
            return;
        }
        const container = getDomContainer(context.$element$);
        const scheduler = container.$scheduler$;
        if (!scheduler) {
            throw qError(1 /* QError.schedulerNotFound */);
        }
        // We don't return anything, the scheduler is in charge now
        const chore = scheduler(2 /* ChoreType.RUN_QRL */, hostElement, runQrl, args);
        return getChorePromise(chore);
    };

    /** @file Shared types */
    /** @internal */
    function isStringifiable(value) {
        return (value === null ||
            typeof value === 'string' ||
            typeof value === 'number' ||
            typeof value === 'boolean');
    }

    /** @internal */
    const _fnSignal = (fn, args, fnStr) => {
        return new WrappedSignalImpl(null, fn, args, fnStr || null);
    };

    /**
     * Format:
     *
     * - This encodes the $roots$ array.
     * - The output is a string of comma separated JSON values.
     * - Even values are always numbers, specifying the type of the next value.
     * - Odd values are numbers, strings (JSON stringified with `</` escaping) or arrays (same format).
     * - Therefore root indexes need to be doubled to get the actual index.
     */
    async function serialize(serializationContext) {
        const { $writer$, $isSsrNode$, $isDomRef$, $storeProxyMap$, $addRoot$, $promoteToRoot$, getSeenRef, $markSeen$, } = serializationContext;
        let rootIdx = 0;
        const forwardRefs = [];
        let forwardRefsId = 0;
        const promises = new Set();
        const preloadQrls = new Set();
        const s11nWeakRefs = new Map();
        let parent;
        const qrlMap = new Map();
        /** Helper to output an array */
        const outputArray = (value, keepNulls, writeFn) => {
            $writer$.write('[');
            let separator = false;
            let length;
            if (keepNulls) {
                length = value.length;
            }
            else {
                length = value.length - 1;
                while (length >= 0 && value[length] === null) {
                    length--;
                }
                length++;
            }
            for (let i = 0; i < length; i++) {
                if (separator) {
                    $writer$.write(',');
                }
                else {
                    separator = true;
                }
                writeFn(value[i], i);
            }
            $writer$.write(']');
        };
        /** Output a type,value pair. If the value is an array, it calls writeValue on each item. */
        const output = (type, value, keepNulls) => {
            $writer$.write(`${type},`);
            if (typeof value === 'number') {
                $writer$.write(value.toString());
            }
            else if (typeof value === 'string') {
                const s = JSON.stringify(value);
                let angleBracketIdx = -1;
                let lastIdx = 0;
                while ((angleBracketIdx = s.indexOf('</', lastIdx)) !== -1) {
                    $writer$.write(s.slice(lastIdx, angleBracketIdx));
                    $writer$.write('<\\/');
                    lastIdx = angleBracketIdx + 2;
                }
                $writer$.write(lastIdx === 0 ? s : s.slice(lastIdx));
            }
            else {
                outputArray(value, keepNulls, (valueItem, idx) => {
                    writeValue(valueItem, idx);
                });
            }
        };
        const addPreloadQrl = (qrl) => {
            if (!isSyncQrl(qrl)) {
                preloadQrls.add(qrl);
                serializationContext.$addRoot$(qrl);
            }
        };
        const getSeenRefOrOutput = (value, index, keepWeak) => {
            let seen = getSeenRef(value);
            const forwardRefIdx = !keepWeak && s11nWeakRefs.get(value);
            if (!seen) {
                if (keepWeak) {
                    // we're testing a weakref, so don't mark it as seen yet
                    return true;
                }
                // Maybe it's a weakref and that should count as seen
                if (typeof forwardRefIdx === 'number') {
                    // Yes, no longer a weakref
                    seen = $addRoot$(value, true);
                }
                else {
                    return $markSeen$(value, parent, index);
                }
            }
            // Now that we saw it a second time, make sure it's a root
            if (seen.$parent$) {
                // Note, this means it was output before so we always need a backref
                // Special case: we're a root so instead of adding a backref, we replace ourself
                if (!parent) {
                    $promoteToRoot$(seen, index);
                    value = serializationContext.$roots$[index];
                }
                else {
                    $promoteToRoot$(seen);
                }
            }
            // Check if there was a weakref to us
            if (typeof forwardRefIdx === 'number') {
                forwardRefs[forwardRefIdx] = seen.$index$;
                s11nWeakRefs.delete(value);
            }
            // Now we know it's a root and we should output a RootRef
            const rootIdx = value instanceof BackRef ? value.$path$ : seen.$index$;
            // But make sure we do output ourselves
            if (!parent && rootIdx === index) {
                return seen;
            }
            output(1 /* TypeIds.RootRef */, rootIdx);
        };
        // First check for scalars, then do objects with seen checks
        // Make sure to only get the SeenRef once, it's expensive
        const writeValue = (value, index) => {
            if (fastSkipSerialize(value)) {
                output(3 /* TypeIds.Constant */, 0 /* Constants.Undefined */);
            }
            else {
                switch (typeof value) {
                    case 'undefined':
                        output(3 /* TypeIds.Constant */, 0 /* Constants.Undefined */);
                        break;
                    case 'boolean':
                        output(3 /* TypeIds.Constant */, value ? 2 /* Constants.True */ : 3 /* Constants.False */);
                        break;
                    case 'number':
                        if (Number.isNaN(value)) {
                            output(3 /* TypeIds.Constant */, 12 /* Constants.NaN */);
                        }
                        else if (!Number.isFinite(value)) {
                            output(3 /* TypeIds.Constant */, value < 0 ? 14 /* Constants.NegativeInfinity */ : 13 /* Constants.PositiveInfinity */);
                        }
                        else if (value === Number.MAX_SAFE_INTEGER) {
                            output(3 /* TypeIds.Constant */, 15 /* Constants.MaxSafeInt */);
                        }
                        else if (value === Number.MAX_SAFE_INTEGER - 1) {
                            output(3 /* TypeIds.Constant */, 16 /* Constants.AlmostMaxSafeInt */);
                        }
                        else if (value === Number.MIN_SAFE_INTEGER) {
                            output(3 /* TypeIds.Constant */, 17 /* Constants.MinSafeInt */);
                        }
                        else {
                            output(0 /* TypeIds.Plain */, value);
                        }
                        break;
                    case 'string':
                        if (value.length === 0) {
                            output(3 /* TypeIds.Constant */, 4 /* Constants.EmptyString */);
                        }
                        else {
                            // If the string is short, we output directly
                            // Very short strings add overhead to tracking
                            if (value.length < 4 || getSeenRefOrOutput(value, index)) {
                                output(0 /* TypeIds.Plain */, value);
                            }
                        }
                        break;
                    case 'bigint':
                        if ((value < 10000 && value > -1e3) || getSeenRefOrOutput(value, index)) {
                            output(11 /* TypeIds.BigInt */, value.toString());
                        }
                        break;
                    case 'symbol':
                        if (value === NEEDS_COMPUTATION) {
                            output(3 /* TypeIds.Constant */, 7 /* Constants.NEEDS_COMPUTATION */);
                        }
                        else if (value === STORE_ALL_PROPS) {
                            output(3 /* TypeIds.Constant */, 8 /* Constants.STORE_ALL_PROPS */);
                        }
                        else if (value === _UNINITIALIZED) {
                            output(3 /* TypeIds.Constant */, 9 /* Constants.UNINITIALIZED */);
                        }
                        break;
                    case 'function':
                        if (value === Slot) {
                            output(3 /* TypeIds.Constant */, 10 /* Constants.Slot */);
                        }
                        else if (value === Fragment) {
                            output(3 /* TypeIds.Constant */, 11 /* Constants.Fragment */);
                        }
                        else if (isQrl(value)) {
                            if (getSeenRefOrOutput(value, index)) {
                                const [chunk, symbol, captureIds] = qrlToString(serializationContext, value, true);
                                let data;
                                let type;
                                if (chunk !== '') {
                                    // not a sync QRL, replace all parts with string references
                                    data = `${$addRoot$(chunk)} ${$addRoot$(symbol)}${captureIds ? ' ' + captureIds.join(' ') : ''}`;
                                    // Since we map QRLs to strings, we need to keep track of this secondary mapping
                                    const existing = qrlMap.get(data);
                                    if (existing) {
                                        // We encountered the same QRL again, make it a root
                                        const ref = $addRoot$(existing);
                                        output(1 /* TypeIds.RootRef */, ref);
                                        return;
                                    }
                                    else {
                                        qrlMap.set(data, value);
                                    }
                                    type = preloadQrls.has(value) ? 20 /* TypeIds.PreloadQRL */ : 19 /* TypeIds.QRL */;
                                }
                                else {
                                    data = Number(symbol);
                                    type = 19 /* TypeIds.QRL */;
                                }
                                output(type, data);
                            }
                        }
                        else if (isQwikComponent(value)) {
                            const [qrl] = value[SERIALIZABLE_STATE];
                            serializationContext.$renderSymbols$.add(qrl.$symbol$);
                            output(23 /* TypeIds.Component */, [qrl]);
                        }
                        else {
                            throw qError(34 /* QError.serializeErrorCannotSerializeFunction */, [value.toString()]);
                        }
                        break;
                    case 'object':
                        if (value === EMPTY_ARRAY) {
                            output(3 /* TypeIds.Constant */, 5 /* Constants.EMPTY_ARRAY */);
                        }
                        else if (value === EMPTY_OBJ) {
                            output(3 /* TypeIds.Constant */, 6 /* Constants.EMPTY_OBJ */);
                        }
                        else if (value === null) {
                            output(3 /* TypeIds.Constant */, 1 /* Constants.Null */);
                        }
                        else if (value instanceof BackRef) {
                            output(1 /* TypeIds.RootRef */, value.$path$);
                        }
                        else {
                            const newSeenRef = getSeenRefOrOutput(value, index);
                            if (newSeenRef) {
                                const oldParent = parent;
                                parent = newSeenRef;
                                // separate function for readability
                                writeObjectValue(value);
                                parent = oldParent;
                            }
                        }
                        break;
                    default:
                        throw qError(20 /* QError.serializeErrorUnknownType */, [typeof value]);
                }
            }
        };
        const writeObjectValue = (value) => {
            if (isPropsProxy(value)) {
                const owner = value[_OWNER];
                output(32 /* TypeIds.PropsProxy */, [_serializationWeakRef(owner), owner.varProps, owner.constProps]);
            }
            else if (value instanceof SubscriptionData) {
                output(33 /* TypeIds.SubscriptionData */, [value.data.$scopedStyleIdPrefix$, value.data.$isConst$]);
            }
            else if (isStore(value)) {
                if (isResource(value)) {
                    // let render know about the resource
                    serializationContext.$resources$.add(value);
                    // TODO the effects include the resource return which has duplicate data
                    const forwardRefId = resolvePromise(value.value, $addRoot$, (resolved, resolvedValue) => {
                        return new PromiseResult(22 /* TypeIds.Resource */, resolved, resolvedValue, getStoreHandler(value).$effects$);
                    });
                    output(2 /* TypeIds.ForwardRef */, forwardRefId);
                }
                else {
                    const storeHandler = getStoreHandler(value);
                    const storeTarget = getStoreTarget(value);
                    const flags = storeHandler.$flags$;
                    const effects = storeHandler.$effects$;
                    // We need to retain the nested stores too, they won't be found from the target
                    const innerStores = [];
                    for (const prop in storeTarget) {
                        const propValue = storeTarget[prop];
                        const innerStore = $storeProxyMap$.get(propValue);
                        if (innerStore) {
                            innerStores.push(innerStore);
                        }
                    }
                    const out = [storeTarget, flags, effects, ...innerStores];
                    while (out[out.length - 1] == null) {
                        out.pop();
                    }
                    output(29 /* TypeIds.Store */, out);
                }
            }
            else if (isSerializerObj(value)) {
                const result = value[SerializerSymbol](value);
                if (isPromise(result)) {
                    const forwardRef = resolvePromise(result, $addRoot$, (resolved, resolvedValue) => {
                        return new PromiseResult(28 /* TypeIds.SerializerSignal */, resolved, resolvedValue, null, null);
                    });
                    output(2 /* TypeIds.ForwardRef */, forwardRef);
                }
                else {
                    // We replace ourselves with this value
                    const index = parent.$index$;
                    parent = parent.$parent$;
                    writeValue(result, index);
                }
            }
            else if (isObjectLiteral(value)) {
                if (Array.isArray(value)) {
                    output(4 /* TypeIds.Array */, value);
                }
                else {
                    const out = [];
                    for (const key in value) {
                        if (Object.prototype.hasOwnProperty.call(value, key)) {
                            const subVal = value[key];
                            if (!fastSkipSerialize(subVal)) {
                                out.push(key, subVal);
                            }
                        }
                    }
                    output(5 /* TypeIds.Object */, out.length ? out : 0);
                }
            }
            else if ($isDomRef$(value)) {
                value.$ssrNode$.vnodeData[0] |= 16 /* VNodeDataFlag.SERIALIZE */;
                output(10 /* TypeIds.RefVNode */, value.$ssrNode$.id);
            }
            else if (value instanceof SignalImpl) {
                if (value instanceof SerializerSignalImpl) {
                    addPreloadQrl(value.$computeQrl$);
                    const forwardRefId = resolvePromise(getCustomSerializerPromise(value, value.$untrackedValue$), $addRoot$, (resolved, resolvedValue) => {
                        return new PromiseResult(28 /* TypeIds.SerializerSignal */, resolved, resolvedValue, value.$effects$, value.$computeQrl$);
                    });
                    output(2 /* TypeIds.ForwardRef */, forwardRefId);
                    return;
                }
                if (value instanceof WrappedSignalImpl) {
                    output(25 /* TypeIds.WrappedSignal */, [
                        ...serializeWrappingFn(serializationContext, value),
                        filterEffectBackRefs(value[_EFFECT_BACK_REF]),
                        value.$flags$,
                        value.$hostElement$,
                        ...(value.$effects$ || []),
                    ]);
                }
                else if (value instanceof ComputedSignalImpl) {
                    let v = value.$untrackedValue$;
                    const shouldAlwaysSerialize = value.$flags$ & 32 /* SerializationSignalFlags.SERIALIZATION_STRATEGY_ALWAYS */;
                    const shouldNeverSerialize = value.$flags$ & 16 /* SerializationSignalFlags.SERIALIZATION_STRATEGY_NEVER */;
                    const isInvalid = value.$flags$ & 1 /* SignalFlags.INVALID */;
                    const isSkippable = fastSkipSerialize(value.$untrackedValue$);
                    if (shouldAlwaysSerialize) {
                        v = value.$untrackedValue$;
                    }
                    else if (shouldNeverSerialize) {
                        v = NEEDS_COMPUTATION;
                    }
                    else if (isInvalid || isSkippable) {
                        v = NEEDS_COMPUTATION;
                    }
                    addPreloadQrl(value.$computeQrl$);
                    const out = [value.$computeQrl$, value.$effects$];
                    const isAsync = value instanceof AsyncComputedSignalImpl;
                    if (isAsync) {
                        out.push(value.$loadingEffects$, value.$errorEffects$, value.$untrackedLoading$, value.$untrackedError$);
                    }
                    if (v !== NEEDS_COMPUTATION) {
                        out.push(v);
                    }
                    output(isAsync ? 27 /* TypeIds.AsyncComputedSignal */ : 26 /* TypeIds.ComputedSignal */, out);
                }
                else {
                    output(24 /* TypeIds.Signal */, [value.$untrackedValue$, ...(value.$effects$ || [])]);
                }
            }
            else if (value instanceof URL) {
                output(6 /* TypeIds.URL */, value.href);
            }
            else if (value instanceof Date) {
                output(7 /* TypeIds.Date */, Number.isNaN(value.valueOf()) ? '' : value.valueOf());
            }
            else if (value instanceof RegExp) {
                output(8 /* TypeIds.Regex */, value.toString());
            }
            else if (value instanceof Error) {
                const out = [value.message];
                // flatten gives us the right output
                out.push(...Object.entries(value).flat());
                /// In production we don't want to leak the stack trace.
                if (build.isDev) {
                    out.push('stack', value.stack);
                }
                output(14 /* TypeIds.Error */, out);
            }
            else if ($isSsrNode$(value)) {
                const rootIndex = $addRoot$(value);
                serializationContext.$setProp$(value, ELEMENT_ID, String(rootIndex));
                // we need to output before the vnode overwrites its values
                output(9 /* TypeIds.VNode */, value.id);
                const vNodeData = value.vnodeData;
                if (vNodeData) {
                    discoverValuesForVNodeData(vNodeData, (vNodeDataValue) => $addRoot$(vNodeDataValue));
                    vNodeData[0] |= 16 /* VNodeDataFlag.SERIALIZE */;
                }
                if (value.children) {
                    // can be static, but we need to save vnode data structure + discover the back refs
                    for (const child of value.children) {
                        const childVNodeData = child.vnodeData;
                        if (childVNodeData) {
                            // add all back refs to the roots
                            for (const value of childVNodeData) {
                                if (isSsrAttrs(value)) {
                                    const backRefKeyIndex = value.findIndex((v) => v === QBackRefs);
                                    if (backRefKeyIndex !== -1) {
                                        $addRoot$(value[backRefKeyIndex + 1]);
                                    }
                                }
                            }
                            childVNodeData[0] |= 16 /* VNodeDataFlag.SERIALIZE */;
                        }
                    }
                }
            }
            else if (typeof FormData !== 'undefined' && value instanceof FormData) {
                // FormData is generally used only once so don't bother with references
                const array = [];
                value.forEach((value, key) => {
                    if (typeof value === 'string') {
                        array.push(key, value);
                    }
                    else {
                        array.push(key, value.name);
                    }
                });
                output(30 /* TypeIds.FormData */, array);
            }
            else if (value instanceof URLSearchParams) {
                output(12 /* TypeIds.URLSearchParams */, value.toString());
            }
            else if (value instanceof Set) {
                output(16 /* TypeIds.Set */, [...value.values()]);
            }
            else if (value instanceof Map) {
                const combined = [];
                for (const [k, v] of value.entries()) {
                    combined.push(k, v);
                }
                output(17 /* TypeIds.Map */, combined);
            }
            else if (isJSXNode(value)) {
                const out = [
                    value.type,
                    value.key,
                    value.varProps,
                    value.constProps,
                    value.children,
                    value.toSort || null,
                ];
                while (out[out.length - 1] == null) {
                    out.pop();
                }
                output(31 /* TypeIds.JSXNode */, out);
            }
            else if (value instanceof Task) {
                const out = [
                    value.$qrl$,
                    value.$flags$,
                    value.$index$,
                    value.$el$,
                    value[_EFFECT_BACK_REF],
                    value.$state$,
                ];
                while (out[out.length - 1] == null) {
                    out.pop();
                }
                output(21 /* TypeIds.Task */, out);
            }
            else if (isPromise(value)) {
                const forwardRefId = resolvePromise(value, $addRoot$, (resolved, resolvedValue) => {
                    return new PromiseResult(15 /* TypeIds.Promise */, resolved, resolvedValue);
                });
                output(2 /* TypeIds.ForwardRef */, forwardRefId);
            }
            else if (value instanceof PromiseResult) {
                if (value.$type$ === 22 /* TypeIds.Resource */) {
                    output(22 /* TypeIds.Resource */, [value.$resolved$, value.$value$, value.$effects$]);
                }
                else if (value.$type$ === 28 /* TypeIds.SerializerSignal */) {
                    if (value.$qrl$) {
                        output(28 /* TypeIds.SerializerSignal */, [value.$qrl$, value.$effects$, value.$value$]);
                    }
                    else if (value.$resolved$) {
                        // We replace ourselves with this value
                        const index = parent.$index$;
                        parent = parent.$parent$;
                        writeValue(value.$value$, index);
                    }
                    else {
                        console.error(value.$value$);
                        throw qError(33 /* QError.serializerSymbolRejectedPromise */);
                    }
                }
                else {
                    output(15 /* TypeIds.Promise */, [value.$resolved$, value.$value$]);
                }
            }
            else if (value instanceof Uint8Array) {
                let buf = '';
                for (const c of value) {
                    buf += String.fromCharCode(c);
                }
                const out = btoa(buf).replace(/=+$/, '');
                output(18 /* TypeIds.Uint8Array */, out);
            }
            else if (value instanceof SerializationWeakRef) {
                const obj = value.$obj$;
                // This will return a fake SeenRef if it's not been seen before
                if (getSeenRefOrOutput(obj, parent.$index$, true)) {
                    let forwardRefId = s11nWeakRefs.get(obj);
                    if (forwardRefId === undefined) {
                        forwardRefId = forwardRefsId++;
                        s11nWeakRefs.set(obj, forwardRefId);
                        forwardRefs[forwardRefId] = -1;
                    }
                    output(2 /* TypeIds.ForwardRef */, forwardRefId);
                }
            }
            else if (vnode_isVNode(value)) {
                output(3 /* TypeIds.Constant */, 0 /* Constants.Undefined */);
            }
            else {
                throw qError(20 /* QError.serializeErrorUnknownType */, [typeof value]);
            }
        };
        function resolvePromise(promise, $addRoot$, classCreator) {
            const forwardRefId = forwardRefsId++;
            promise
                .then((resolvedValue) => {
                promises.delete(promise);
                forwardRefs[forwardRefId] = $addRoot$(classCreator(true, resolvedValue));
            })
                .catch((err) => {
                promises.delete(promise);
                forwardRefs[forwardRefId] = $addRoot$(classCreator(false, err));
            });
            promises.add(promise);
            return forwardRefId;
        }
        const outputRoots = async () => {
            $writer$.write('[');
            const { $roots$ } = serializationContext;
            while (rootIdx < $roots$.length || promises.size) {
                if (rootIdx !== 0) {
                    $writer$.write(',');
                }
                let separator = false;
                for (; rootIdx < $roots$.length; rootIdx++) {
                    if (separator) {
                        $writer$.write(',');
                    }
                    else {
                        separator = true;
                    }
                    writeValue($roots$[rootIdx], rootIdx);
                }
                if (promises.size) {
                    try {
                        await Promise.race(promises);
                    }
                    catch {
                        // ignore rejections, they will be serialized as rejected promises
                    }
                }
            }
            if (forwardRefs.length) {
                let lastIdx = forwardRefs.length - 1;
                while (lastIdx >= 0 && forwardRefs[lastIdx] === -1) {
                    lastIdx--;
                }
                if (lastIdx >= 0) {
                    $writer$.write(',');
                    $writer$.write(13 /* TypeIds.ForwardRefs */ + ',');
                    const out = lastIdx === forwardRefs.length - 1 ? forwardRefs : forwardRefs.slice(0, lastIdx + 1);
                    // We could also implement RLE of -1 values
                    outputArray(out, true, (value) => {
                        $writer$.write(String(value));
                    });
                }
            }
            $writer$.write(']');
        };
        await outputRoots();
    }
    class PromiseResult {
        $type$;
        $resolved$;
        $value$;
        $effects$;
        $qrl$;
        constructor($type$, $resolved$, $value$, $effects$ = null, $qrl$ = null) {
            this.$type$ = $type$;
            this.$resolved$ = $resolved$;
            this.$value$ = $value$;
            this.$effects$ = $effects$;
            this.$qrl$ = $qrl$;
        }
    }
    function getCustomSerializerPromise(signal, value) {
        return new Promise((resolve) => {
            signal.$computeQrl$.resolve().then((arg) => {
                let data;
                if (arg.serialize) {
                    data = arg.serialize(value);
                }
                else if (SerializerSymbol in value) {
                    data = value[SerializerSymbol](value);
                }
                if (data === undefined) {
                    data = NEEDS_COMPUTATION;
                }
                resolve(data);
            });
        });
    }
    const discoverValuesForVNodeData = (vnodeData, callback) => {
        for (const value of vnodeData) {
            if (isSsrAttrs(value)) {
                for (let i = 1; i < value.length; i += 2) {
                    const keyValue = value[i - 1];
                    const attrValue = value[i];
                    if (attrValue == null ||
                        typeof attrValue === 'string' ||
                        // skip empty props
                        (keyValue === ELEMENT_PROPS &&
                            Object.keys(attrValue).length === 0)) {
                        continue;
                    }
                    callback(attrValue);
                }
            }
        }
    };
    const isSsrAttrs = (value) => Array.isArray(value) && value.length > 0;
    /**
     * When serializing the object we need check if it is URL, RegExp, Map, Set, etc. This is time
     * consuming. So if we could know that this is a basic object literal we could skip the check, and
     * only run the checks for objects which are not object literals.
     *
     * So this function is here for performance to short circuit many checks later.
     *
     * @param obj
     */
    function isObjectLiteral(obj) {
        // We are an object literal if:
        // - we are a direct instance of object OR
        // - we are an array
        // In all other cases it is a subclass which requires more checks.
        const prototype = Object.getPrototypeOf(obj);
        return prototype == null || prototype === Object.prototype || prototype === Array.prototype;
    }
    function isResource(value) {
        return '__brand' in value && value.__brand === 'resource';
    }
    function serializeWrappingFn(serializationContext, value) {
        // if value is an object then we need to wrap this in ()
        if (value.$funcStr$ && value.$funcStr$[0] === '{') {
            value.$funcStr$ = `(${value.$funcStr$})`;
        }
        const syncFnId = serializationContext.$addSyncFn$(value.$funcStr$, value.$args$.length, value.$func$);
        return [syncFnId, value.$args$];
    }
    function filterEffectBackRefs(effectBackRef) {
        let effectBackRefToSerialize = null;
        if (effectBackRef) {
            for (const [effectProp, effect] of effectBackRef) {
                if (effect[2 /* EffectSubscriptionProp.BACK_REF */]) {
                    effectBackRefToSerialize ||= new Map();
                    effectBackRefToSerialize.set(effectProp, effect);
                }
            }
        }
        return effectBackRefToSerialize;
    }
    class SerializationWeakRef {
        $obj$;
        constructor($obj$) {
            this.$obj$ = $obj$;
        }
    }
    /** @internal */
    const _serializationWeakRef = (obj) => new SerializationWeakRef(obj);

    let isDomRef = (obj) => false;
    /**
     * A back reference to a previously serialized object. Before deserialization, all backrefs are
     * swapped with their original locations.
     */
    class BackRef {
        $path$;
        constructor(
        /** The path from root to the original object */
        $path$) {
            this.$path$ = $path$;
        }
    }
    const createSerializationContext = (
    /**
     * Node constructor, for instanceof checks.
     *
     * A node constructor can be null. For example on the client we can't serialize DOM nodes as
     * server will not know what to do with them.
     */
    NodeConstructor, 
    /** DomRef constructor, for instanceof checks. */
    DomRefConstructor, symbolToChunkResolver, getProp, setProp, storeProxyMap, writer) => {
        if (!writer) {
            const buffer = [];
            writer = {
                write: (text) => buffer.push(text),
                toString: () => buffer.join(''),
            };
        }
        const seenObjsMap = new Map();
        const syncFnMap = new Map();
        const syncFns = [];
        const roots = [];
        const getSeenRef = (obj) => seenObjsMap.get(obj);
        const $markSeen$ = (obj, parent, index) => {
            const ref = { $index$: index, $parent$: parent };
            seenObjsMap.set(obj, ref);
            return ref;
        };
        /**
         * Returns a path string representing the path from roots through all parents to the object.
         * Format: "3 2 0" where each number is the index within its parent, from root to leaf.
         */
        const $getObjectPath$ = (ref) => {
            // Traverse up through parent references to build a path
            const path = [];
            while (ref.$parent$) {
                path.unshift(ref.$index$);
                ref = ref.$parent$;
            }
            // Now we are at root, but it could be a backref
            path.unshift(ref.$index$);
            return path.join(' ');
        };
        const $promoteToRoot$ = (ref, index) => {
            const path = $getObjectPath$(ref);
            if (index === undefined) {
                index = roots.length;
            }
            roots[index] = new BackRef(path);
            ref.$parent$ = null;
            ref.$index$ = index;
        };
        const $addRoot$ = ((obj, returnRef) => {
            let seen = seenObjsMap.get(obj);
            let index;
            if (!seen) {
                index = roots.length;
                seen = {
                    $index$: index,
                    // TODO benchmark with and without $parent$
                    // $parent$: undefined
                };
                seenObjsMap.set(obj, seen);
                roots.push(obj);
            }
            else {
                if (seen.$parent$) {
                    $promoteToRoot$(seen);
                }
                index = seen.$index$;
            }
            return returnRef ? seen : index;
        });
        const isSsrNode = (NodeConstructor ? (obj) => obj instanceof NodeConstructor : (() => false));
        isDomRef = (DomRefConstructor ? (obj) => obj instanceof DomRefConstructor : (() => false));
        return {
            async $serialize$() {
                return await serialize(this);
            },
            $isSsrNode$: isSsrNode,
            $isDomRef$: isDomRef,
            $symbolToChunkResolver$: symbolToChunkResolver,
            getSeenRef,
            $roots$: roots,
            $markSeen$,
            $hasRootId$: (obj) => {
                const id = seenObjsMap.get(obj);
                return id && (id.$parent$ ? undefined : id.$index$);
            },
            $promoteToRoot$,
            $addRoot$,
            $syncFns$: syncFns,
            $addSyncFn$: (funcStr, argCount, fn) => {
                const isFullFn = funcStr == null;
                if (isFullFn) {
                    funcStr = fn.serialized || fn.toString();
                }
                let id = syncFnMap.get(funcStr);
                if (id === undefined) {
                    id = syncFns.length;
                    syncFnMap.set(funcStr, id);
                    if (isFullFn) {
                        syncFns.push(funcStr);
                    }
                    else {
                        let code = '(';
                        for (let i = 0; i < argCount; i++) {
                            code += (i == 0 ? 'p' : ',p') + i;
                        }
                        syncFns.push((code += ')=>' + funcStr));
                    }
                }
                return id;
            },
            $writer$: writer,
            $eventQrls$: new Set(),
            $eventNames$: new Set(),
            $resources$: new Set(),
            $renderSymbols$: new Set(),
            $storeProxyMap$: storeProxyMap,
            $getProp$: getProp,
            $setProp$: setProp,
        };
    };

    /** @internal */
    class _SharedContainer {
        $version$;
        $scheduler$;
        $storeProxyMap$;
        /// Current language locale
        $locale$;
        /// Retrieve Object from paused serialized state.
        $getObjectById$;
        $serverData$;
        $currentUniqueId$ = 0;
        $instanceHash$ = null;
        $buildBase$ = null;
        $flushEpoch$ = 0;
        constructor(journalFlush, serverData, locale) {
            this.$serverData$ = serverData;
            this.$locale$ = locale;
            this.$version$ = version;
            this.$storeProxyMap$ = new WeakMap();
            this.$getObjectById$ = (_id) => {
                throw Error('Not implemented');
            };
            const choreQueue = new ChoreArray();
            const blockedChores = new Set();
            const runningChores = new Set();
            this.$scheduler$ = createScheduler(this, journalFlush, choreQueue, blockedChores, runningChores);
        }
        trackSignalValue(signal, subscriber, property, data) {
            return trackSignalAndAssignHost(signal, subscriber, property, this, data);
        }
        serializationCtxFactory(NodeConstructor, DomRefConstructor, symbolToChunkResolver, writer) {
            return createSerializationContext(NodeConstructor, DomRefConstructor, symbolToChunkResolver, this.getHostProp.bind(this), this.setHostProp.bind(this), this.$storeProxyMap$, writer);
        }
    }

    function isAsyncGenerator(value) {
        return !!value[Symbol.asyncIterator];
    }

    const applyInlineComponent = (ssr, componentHost, inlineComponentFunction, jsx) => {
        const host = ssr.getOrCreateLastNode();
        return executeComponent(ssr, host, componentHost, inlineComponentFunction, jsx.props);
    };
    const applyQwikComponentBody = (ssr, jsx, component) => {
        const host = ssr.getOrCreateLastNode();
        const [componentQrl] = component[SERIALIZABLE_STATE];
        const srcProps = jsx.props;
        if (srcProps && srcProps.children) {
            delete srcProps.children;
        }
        host.setProp(OnRenderProp, componentQrl);
        host.setProp(ELEMENT_PROPS, srcProps);
        if (jsx.key !== null) {
            host.setProp(ELEMENT_KEY, jsx.key);
        }
        const componentChore = ssr.$scheduler$(6 /* ChoreType.COMPONENT */, host, componentQrl, srcProps);
        return getChorePromise(componentChore);
    };

    class ParentComponentData {
        $scopedStyle$;
        $componentFrame$;
        constructor($scopedStyle$, $componentFrame$) {
            this.$scopedStyle$ = $scopedStyle$;
            this.$componentFrame$ = $componentFrame$;
        }
    }
    class MaybeAsyncSignal {
    }
    /** @internal */
    async function _walkJSX(ssr, value, options) {
        const stack = [value];
        const enqueue = (value) => stack.push(value);
        const drain = async () => {
            while (stack.length) {
                const value = stack.pop();
                if (value instanceof ParentComponentData) {
                    options.currentStyleScoped = value.$scopedStyle$;
                    options.parentComponentFrame = value.$componentFrame$;
                    continue;
                }
                else if (value === MaybeAsyncSignal) {
                    // It could be an async signal, but it is not resolved yet, we need to wait for it.
                    // We could do that in the processJSXNode,
                    // but it will mean that we need to await it there, and it will return a promise.
                    // We probably want to avoid creating a promise for all jsx nodes.
                    const trackFn = stack.pop();
                    await retryOnPromise(() => stack.push(trackFn()));
                    continue;
                }
                else if (typeof value === 'function') {
                    if (value === Promise) {
                        stack.push(await stack.pop());
                        continue;
                    }
                    await value.apply(ssr);
                    continue;
                }
                processJSXNode(ssr, enqueue, value, {
                    styleScoped: options.currentStyleScoped,
                    parentComponentFrame: options.parentComponentFrame,
                });
            }
        };
        await drain();
    }
    function processJSXNode(ssr, enqueue, value, options) {
        // console.log('processJSXNode', value);
        if (value === null || value === undefined) {
            ssr.textNode('');
        }
        else if (typeof value === 'boolean') {
            ssr.textNode('');
        }
        else if (typeof value === 'number') {
            ssr.textNode(String(value));
        }
        else if (typeof value === 'string') {
            ssr.textNode(value);
        }
        else if (typeof value === 'object') {
            if (Array.isArray(value)) {
                for (let i = value.length - 1; i >= 0; i--) {
                    enqueue(value[i]);
                }
            }
            else if (isSignal(value)) {
                ssr.openFragment(build.isDev ? [DEBUG_TYPE, "S" /* VirtualType.WrappedSignal */] : EMPTY_ARRAY);
                const signalNode = ssr.getOrCreateLastNode();
                const unwrappedSignal = value instanceof WrappedSignalImpl ? value.$unwrapIfSignal$() : value;
                enqueue(ssr.closeFragment);
                enqueue(() => trackSignalAndAssignHost(unwrappedSignal, signalNode, "." /* EffectProperty.VNODE */, ssr));
                enqueue(MaybeAsyncSignal);
            }
            else if (isPromise(value)) {
                ssr.openFragment(build.isDev ? [DEBUG_TYPE, "A" /* VirtualType.Awaited */] : EMPTY_ARRAY);
                enqueue(ssr.closeFragment);
                enqueue(value);
                enqueue(Promise);
                enqueue(() => ssr.commentNode(FLUSH_COMMENT));
            }
            else if (isAsyncGenerator(value)) {
                enqueue(async () => {
                    for await (const chunk of value) {
                        await _walkJSX(ssr, chunk, {
                            currentStyleScoped: options.styleScoped,
                            parentComponentFrame: options.parentComponentFrame,
                        });
                        ssr.commentNode(FLUSH_COMMENT);
                    }
                });
            }
            else {
                const jsx = value;
                const type = jsx.type;
                // Below, JSXChildren allows functions and regexes, but we assume the dev only uses those as appropriate.
                if (typeof type === 'string') {
                    appendClassIfScopedStyleExists(jsx, options.styleScoped);
                    let qwikInspectorAttrValue = null;
                    if (build.isDev && jsx.dev && jsx.type !== 'head') {
                        qwikInspectorAttrValue = getFileLocationFromJsx(jsx.dev);
                        if (qInspector) {
                            appendQwikInspectorAttribute(jsx, qwikInspectorAttrValue);
                        }
                    }
                    const innerHTML = ssr.openElement(type, varPropsToSsrAttrs(jsx.varProps, jsx.constProps, {
                        serializationCtx: ssr.serializationCtx,
                        styleScopedId: options.styleScoped,
                        key: jsx.key,
                        toSort: jsx.toSort,
                    }), constPropsToSsrAttrs(jsx.constProps, jsx.varProps, {
                        serializationCtx: ssr.serializationCtx,
                        styleScopedId: options.styleScoped,
                    }), qwikInspectorAttrValue);
                    if (innerHTML) {
                        ssr.htmlNode(innerHTML);
                    }
                    enqueue(ssr.closeElement);
                    if (type === 'head') {
                        ssr.emitQwikLoaderAtTopIfNeeded();
                        ssr.emitPreloaderPre();
                        enqueue(ssr.additionalHeadNodes);
                    }
                    else if (type === 'body') {
                        enqueue(ssr.additionalBodyNodes);
                    }
                    else if (!ssr.isHtml && !ssr._didAddQwikLoader) {
                        ssr.emitQwikLoaderAtTopIfNeeded();
                        ssr.emitPreloaderPre();
                        ssr._didAddQwikLoader = true;
                    }
                    const children = jsx.children;
                    children != null && enqueue(children);
                }
                else if (isFunction(type)) {
                    if (type === Fragment) {
                        let attrs = jsx.key != null ? [ELEMENT_KEY, jsx.key] : EMPTY_ARRAY;
                        if (build.isDev) {
                            attrs = [DEBUG_TYPE, "F" /* VirtualType.Fragment */, ...attrs]; // Add debug info.
                        }
                        ssr.openFragment(attrs);
                        enqueue(ssr.closeFragment);
                        // In theory we could get functions or regexes, but we assume all is well
                        const children = jsx.children;
                        children != null && enqueue(children);
                    }
                    else if (type === Slot) {
                        const componentFrame = options.parentComponentFrame || ssr.unclaimedProjectionComponentFrameQueue.shift();
                        if (componentFrame) {
                            const compId = componentFrame.componentNode.id || '';
                            const projectionAttrs = build.isDev ? [DEBUG_TYPE, "P" /* VirtualType.Projection */] : [];
                            projectionAttrs.push(QSlotParent, compId);
                            ssr.openProjection(projectionAttrs);
                            const host = componentFrame.componentNode;
                            const node = ssr.getOrCreateLastNode();
                            const slotName = getSlotName(host, jsx, ssr);
                            projectionAttrs.push(QSlot, slotName);
                            enqueue(new ParentComponentData(options.styleScoped, options.parentComponentFrame));
                            enqueue(ssr.closeProjection);
                            const slotDefaultChildren = jsx.children || null;
                            const slotChildren = componentFrame.consumeChildrenForSlot(node, slotName) || slotDefaultChildren;
                            if (slotDefaultChildren && slotChildren !== slotDefaultChildren) {
                                ssr.addUnclaimedProjection(componentFrame, QDefaultSlot, slotDefaultChildren);
                            }
                            enqueue(slotChildren);
                            enqueue(new ParentComponentData(componentFrame.projectionScopedStyle, componentFrame.projectionComponentFrame));
                        }
                        else {
                            // Even thought we are not projecting we still need to leave a marker for the slot.
                            ssr.openFragment(build.isDev ? [DEBUG_TYPE, "P" /* VirtualType.Projection */] : EMPTY_ARRAY);
                            ssr.closeFragment();
                        }
                    }
                    else if (type === SSRComment) {
                        ssr.commentNode(directGetPropsProxyProp(jsx, 'data') || '');
                    }
                    else if (type === SSRStream) {
                        ssr.commentNode(FLUSH_COMMENT);
                        const generator = jsx.children;
                        let value;
                        if (isFunction(generator)) {
                            value = generator({
                                async write(chunk) {
                                    await _walkJSX(ssr, chunk, {
                                        currentStyleScoped: options.styleScoped,
                                        parentComponentFrame: options.parentComponentFrame,
                                    });
                                    ssr.commentNode(FLUSH_COMMENT);
                                },
                            });
                        }
                        else {
                            value = generator;
                        }
                        enqueue(value);
                        isPromise(value) && enqueue(Promise);
                    }
                    else if (type === SSRRaw) {
                        ssr.htmlNode(directGetPropsProxyProp(jsx, 'data'));
                    }
                    else if (isQwikComponent(type)) {
                        // prod: use new instance of an array for props, we always modify props for a component
                        ssr.openComponent(build.isDev ? [DEBUG_TYPE, "C" /* VirtualType.Component */] : []);
                        const host = ssr.getOrCreateLastNode();
                        const componentFrame = ssr.getParentComponentFrame();
                        componentFrame.distributeChildrenIntoSlots(jsx.children, options.styleScoped, options.parentComponentFrame);
                        const jsxOutput = applyQwikComponentBody(ssr, jsx, type);
                        const compStyleComponentId = addComponentStylePrefix(host.getProp(QScopedStyle));
                        enqueue(new ParentComponentData(options.styleScoped, options.parentComponentFrame));
                        enqueue(ssr.closeComponent);
                        enqueue(jsxOutput);
                        isPromise(jsxOutput) && enqueue(Promise);
                        enqueue(new ParentComponentData(compStyleComponentId, componentFrame));
                    }
                    else {
                        const inlineComponentProps = [ELEMENT_KEY, jsx.key];
                        ssr.openFragment(build.isDev
                            ? [DEBUG_TYPE, "I" /* VirtualType.InlineComponent */, ...inlineComponentProps]
                            : inlineComponentProps);
                        enqueue(ssr.closeFragment);
                        const component = ssr.getComponentFrame(0);
                        const jsxOutput = applyInlineComponent(ssr, component && component.componentNode, type, jsx);
                        enqueue(jsxOutput);
                        isPromise(jsxOutput) && enqueue(Promise);
                    }
                }
            }
        }
    }
    function varPropsToSsrAttrs(varProps, constProps, options) {
        return toSsrAttrs(varProps, options);
    }
    function constPropsToSsrAttrs(constProps, varProps, options) {
        return toSsrAttrs(constProps, options);
    }
    function toSsrAttrs(record, options) {
        if (record == null) {
            return null;
        }
        const ssrAttrs = [];
        const handleProp = (key, value) => {
            if (value == null) {
                return;
            }
            if (isHtmlAttributeAnEventName(key)) {
                const eventValue = setEvent(options.serializationCtx, key, value);
                if (eventValue) {
                    ssrAttrs.push(key, eventValue);
                }
                return;
            }
            if (isSignal(value)) {
                // write signal as is. We will track this signal inside `writeAttrs`
                if (isClassAttr(key)) {
                    // additionally append styleScopedId for class attr
                    ssrAttrs.push(key, [value, options.styleScopedId]);
                }
                else {
                    ssrAttrs.push(key, value);
                }
                return;
            }
            if (isPreventDefault(key)) {
                addPreventDefaultEventToSerializationContext(options.serializationCtx, key);
            }
            value = serializeAttribute(key, value, options.styleScopedId);
            ssrAttrs.push(key, value);
        };
        if (options.toSort) {
            const keys = Object.keys(record).sort();
            for (const key of keys) {
                handleProp(key, record[key]);
            }
        }
        else {
            for (const key in record) {
                handleProp(key, record[key]);
            }
        }
        if (options.key != null) {
            ssrAttrs.push(ELEMENT_KEY, options.key);
        }
        return ssrAttrs;
    }
    function setEvent(serializationCtx, key, rawValue) {
        let value = null;
        const qrls = rawValue;
        const appendToValue = (valueToAppend) => {
            value = (value == null ? '' : value + '\n') + valueToAppend;
        };
        const getQrlString = (qrl) => {
            /**
             * If there are captures we need to schedule so everything is executed in the right order + qrls
             * are resolved.
             *
             * For internal qrls (starting with `_`) we assume that they do the right thing.
             */
            if (!qrl.$symbol$.startsWith('_') && (qrl.$captureRef$ || qrl.$capture$)) {
                qrl = createQRL(null, '_run', _run, null, null, [qrl]);
            }
            return qrlToString(serializationCtx, qrl);
        };
        if (Array.isArray(qrls)) {
            for (let i = 0; i <= qrls.length; i++) {
                const qrl = qrls[i];
                if (isQrl(qrl)) {
                    appendToValue(getQrlString(qrl));
                    addQwikEventToSerializationContext(serializationCtx, key, qrl);
                }
                else if (qrl != null) {
                    // nested arrays etc.
                    const nestedValue = setEvent(serializationCtx, key, qrl);
                    if (nestedValue) {
                        appendToValue(nestedValue);
                    }
                }
            }
        }
        else if (isQrl(qrls)) {
            value = getQrlString(qrls);
            addQwikEventToSerializationContext(serializationCtx, key, qrls);
        }
        return value;
    }
    function addQwikEventToSerializationContext(serializationCtx, key, qrl) {
        // TODO extract window/document too so qwikloader can precisely listen
        const data = getEventDataFromHtmlAttribute(key);
        if (data) {
            const eventName = data[1];
            serializationCtx.$eventNames$.add(eventName);
            serializationCtx.$eventQrls$.add(qrl);
        }
    }
    function addPreventDefaultEventToSerializationContext(serializationCtx, key) {
        // skip first 15 chars, this is length of the `preventdefault:`
        const eventName = key.substring(15);
        if (eventName) {
            serializationCtx.$eventNames$.add(eventName);
        }
    }
    function getSlotName(host, jsx, ssr) {
        const constProps = jsx.constProps;
        if (constProps && typeof constProps == 'object' && 'name' in constProps) {
            const constValue = constProps.name;
            if (constValue instanceof WrappedSignalImpl) {
                return trackSignalAndAssignHost(constValue, host, ":" /* EffectProperty.COMPONENT */, ssr);
            }
        }
        return directGetPropsProxyProp(jsx, 'name') || QDefaultSlot;
    }
    function appendQwikInspectorAttribute(jsx, qwikInspectorAttrValue) {
        if (qwikInspectorAttrValue && (!jsx.constProps || !(qwikInspectorAttr in jsx.constProps))) {
            (jsx.constProps ||= {})[qwikInspectorAttr] = qwikInspectorAttrValue;
        }
    }
    // append class attribute if styleScopedId exists and there is no class attribute
    function appendClassIfScopedStyleExists(jsx, styleScoped) {
        const classAttributeExists = directGetPropsProxyProp(jsx, 'class') != null;
        if (!classAttributeExists && styleScoped) {
            if (!jsx.constProps) {
                jsx.constProps = {};
            }
            jsx.constProps['class'] = '';
        }
    }

    const inflate = (container, target, typeId, data) => {
        if (typeId === 0 /* TypeIds.Plain */) {
            // Already processed
            return;
        }
        // Restore the complex data, special case for Array
        if (typeId !== 4 /* TypeIds.Array */ && Array.isArray(data)) {
            data = _eagerDeserializeArray(container, data);
        }
        switch (typeId) {
            case 4 /* TypeIds.Array */:
                // Arrays are special, we need to fill the array in place
                _eagerDeserializeArray(container, data, target);
                break;
            case 5 /* TypeIds.Object */:
                if (data === 0) {
                    // Special case, was an empty object
                    break;
                }
                for (let i = 0; i < data.length; i += 2) {
                    const key = data[i];
                    const value = data[i + 1];
                    target[key] = value;
                }
                break;
            case 19 /* TypeIds.QRL */:
            case 20 /* TypeIds.PreloadQRL */:
                _inflateQRL(container, target);
                if (typeId === 20 /* TypeIds.PreloadQRL */) {
                    target.resolve();
                }
                break;
            case 21 /* TypeIds.Task */:
                const task = target;
                const v = data;
                task.$qrl$ = v[0];
                task.$flags$ = v[1];
                task.$index$ = v[2];
                task.$el$ = v[3];
                task[_EFFECT_BACK_REF] = v[4];
                task.$state$ = v[5];
                break;
            case 22 /* TypeIds.Resource */:
                const [resolved, result, effects] = data;
                const resource = target;
                if (resolved) {
                    resource.value = Promise.resolve(result);
                    resource._resolved = result;
                    resource._state = 'resolved';
                }
                else {
                    resource.value = Promise.reject(result);
                    resource._error = result;
                    resource._state = 'rejected';
                }
                getStoreHandler(target).$effects$ = effects;
                break;
            case 23 /* TypeIds.Component */:
                target[SERIALIZABLE_STATE][0] = data[0];
                break;
            case 29 /* TypeIds.Store */: {
                // Inflate the store target
                const store = unwrapStore(target);
                const storeTarget = pendingStoreTargets.get(store);
                if (storeTarget) {
                    pendingStoreTargets.delete(store);
                    inflate(container, store, storeTarget.t, storeTarget.v);
                }
                /**
                 * Note that we don't do anything with the innerstores we added during serialization, because
                 * they are already inflated in the deserialize of the data, above.
                 */
                const [, flags, effects] = data;
                const storeHandler = getStoreHandler(target);
                storeHandler.$flags$ = flags;
                storeHandler.$effects$ = effects;
                break;
            }
            case 24 /* TypeIds.Signal */: {
                const signal = target;
                const d = data;
                signal.$untrackedValue$ = d[0];
                signal.$effects$ = new Set(d.slice(1));
                break;
            }
            case 25 /* TypeIds.WrappedSignal */: {
                const signal = target;
                const d = data;
                signal.$func$ = container.getSyncFn(d[0]);
                signal.$args$ = d[1];
                signal[_EFFECT_BACK_REF] = d[2];
                signal.$untrackedValue$ = NEEDS_COMPUTATION;
                signal.$flags$ = d[3];
                signal.$flags$ |= 1 /* SignalFlags.INVALID */;
                signal.$hostElement$ = d[4];
                signal.$effects$ = new Set(d.slice(5));
                inflateWrappedSignalValue(signal);
                break;
            }
            case 27 /* TypeIds.AsyncComputedSignal */: {
                const asyncComputed = target;
                const d = data;
                asyncComputed.$computeQrl$ = d[0];
                asyncComputed.$effects$ = new Set(d[1]);
                asyncComputed.$loadingEffects$ = new Set(d[2]);
                asyncComputed.$errorEffects$ = new Set(d[3]);
                asyncComputed.$untrackedLoading$ = d[4];
                asyncComputed.$untrackedError$ = d[5] || null;
                const hasValue = d.length > 6;
                if (hasValue) {
                    asyncComputed.$untrackedValue$ = d[6];
                }
                asyncComputed.$flags$ |= 1 /* SignalFlags.INVALID */;
                break;
            }
            // Inflating a SerializerSignal is the same as inflating a ComputedSignal
            case 28 /* TypeIds.SerializerSignal */:
            case 26 /* TypeIds.ComputedSignal */: {
                const computed = target;
                const d = data;
                computed.$computeQrl$ = d[0];
                computed.$effects$ = new Set(d[1]);
                const hasValue = d.length > 2;
                if (hasValue) {
                    computed.$untrackedValue$ = d[2];
                    // The serialized signal is always invalid so it can recreate the custom object
                    if (typeId === 28 /* TypeIds.SerializerSignal */) {
                        computed.$flags$ |= 1 /* SignalFlags.INVALID */;
                    }
                }
                else {
                    computed.$flags$ |= 1 /* SignalFlags.INVALID */;
                    /**
                     * If we try to compute value and the qrl is not resolved, then system throws an error with
                     * qrl promise. To prevent that we should early resolve computed qrl while computed
                     * deserialization. This also prevents anything from firing while computed qrls load,
                     * because of scheduler
                     */
                    // try to download qrl in this tick
                    computed.$computeQrl$.resolve();
                    container.$scheduler$(1 /* ChoreType.QRL_RESOLVE */, null, computed.$computeQrl$);
                }
                break;
            }
            case 14 /* TypeIds.Error */: {
                const d = data;
                target.message = d[0];
                for (let i = 1; i < d.length; i += 2) {
                    target[d[i]] = d[i + 1];
                }
                break;
            }
            case 30 /* TypeIds.FormData */: {
                const formData = target;
                const d = data;
                for (let i = 0; i < d.length; i++) {
                    formData.append(d[i++], d[i]);
                }
                break;
            }
            case 31 /* TypeIds.JSXNode */: {
                const jsx = target;
                const [type, key, varProps, constProps, children, toSort] = data;
                jsx.type = type;
                jsx.key = key;
                jsx.varProps = varProps;
                jsx.constProps = constProps || null;
                jsx.children = children;
                jsx.toSort = !!toSort;
                break;
            }
            case 16 /* TypeIds.Set */: {
                const set = target;
                const d = data;
                for (let i = 0; i < d.length; i++) {
                    set.add(d[i]);
                }
                break;
            }
            case 17 /* TypeIds.Map */: {
                const map = target;
                const d = data;
                for (let i = 0; i < d.length; i++) {
                    map.set(d[i++], d[i]);
                }
                break;
            }
            case 15 /* TypeIds.Promise */: {
                const promise = target;
                const [resolved, result] = data;
                const [resolve, reject] = resolvers.get(promise);
                if (resolved) {
                    resolve(result);
                }
                else {
                    reject(result);
                }
                break;
            }
            case 18 /* TypeIds.Uint8Array */:
                const bytes = target;
                const buf = atob(data);
                let i = 0;
                for (const s of buf) {
                    bytes[i++] = s.charCodeAt(0);
                }
                break;
            case 32 /* TypeIds.PropsProxy */:
                const propsProxy = target;
                const d = data;
                let owner = d[0];
                if (owner === _UNINITIALIZED) {
                    owner = new JSXNodeImpl(Fragment, d[1], d[2]);
                    owner._proxy = propsProxy;
                }
                propsProxy[_OWNER] = owner;
                break;
            case 33 /* TypeIds.SubscriptionData */: {
                const effectData = target;
                effectData.data.$scopedStyleIdPrefix$ = data[0];
                effectData.data.$isConst$ = data[1];
                break;
            }
            default:
                throw qError(16 /* QError.serializeErrorNotImplemented */, [typeId]);
        }
    }; /**
     * Restores an array eagerly. If you need it lazily, use `deserializeData(container, TypeIds.Array,
     * array)` instead
     */
    const _eagerDeserializeArray = (container, data, output = Array(data.length / 2)) => {
        for (let i = 0; i < data.length; i += 2) {
            output[i / 2] = deserializeData(container, data[i], data[i + 1]);
        }
        return output;
    };
    function _inflateQRL(container, qrl) {
        if (qrl.$captureRef$) {
            // early return if capture references are already set and qrl is already inflated
            return qrl;
        }
        const captureIds = qrl.$capture$;
        qrl.$captureRef$ = captureIds ? captureIds.map((id) => container.$getObjectById$(id)) : null;
        // clear serialized capture references
        qrl.$capture$ = null;
        if (container.element) {
            qrl.$setContainer$(container.element);
        }
        return qrl;
    }
    function deserializeData(container, typeId, value) {
        if (typeId === 0 /* TypeIds.Plain */) {
            return value;
        }
        const propValue = allocate(container, typeId, value);
        if (needsInflation(typeId)) {
            inflate(container, propValue, typeId, value);
        }
        return propValue;
    }
    function inflateWrappedSignalValue(signal) {
        if (signal.$hostElement$ !== null && vnode_isVNode(signal.$hostElement$)) {
            const hostVNode = signal.$hostElement$;
            const effects = signal.$effects$;
            let hasAttrValue = false;
            if (effects) {
                // Find string keys (attribute names) in the effect back refs
                for (const [_, key] of effects) {
                    if (isString(key)) {
                        // This is an attribute name, try to read its value
                        const attrValue = hostVNode.getAttr(key);
                        if (attrValue !== null) {
                            signal.$untrackedValue$ = attrValue;
                            hasAttrValue = true;
                            break; // Take first non-null attribute value
                        }
                    }
                }
            }
            if (!hasAttrValue) {
                // If no attribute value found, check if this is a text content signal
                const firstChild = vnode_getFirstChild(hostVNode);
                if (firstChild &&
                    hostVNode.firstChild === hostVNode.lastChild &&
                    vnode_isTextVNode(firstChild)) {
                    signal.$untrackedValue$ = vnode_getText(firstChild);
                }
            }
        }
    }

    /** Arrays/Objects are special-cased so their identifiers is a single digit. */
    const needsInflation = (typeId) => typeId >= 14 /* TypeIds.Error */ || typeId === 4 /* TypeIds.Array */ || typeId === 5 /* TypeIds.Object */;
    const deserializedProxyMap = new WeakMap();
    const isDeserializerProxy = (value) => {
        return isObject(value) && SERIALIZER_PROXY_UNWRAP in value;
    };
    const SERIALIZER_PROXY_UNWRAP = Symbol('UNWRAP');
    /** Call this on the serialized root state */
    const wrapDeserializerProxy = (container, data) => {
        if (!Array.isArray(data) || // must be an array
            vnode_isVNode(data) || // and not a VNode or Slot
            isDeserializerProxy(data) // and not already wrapped
        ) {
            return data;
        }
        let proxy = deserializedProxyMap.get(data);
        if (!proxy) {
            const target = Array(data.length / 2).fill(undefined);
            proxy = new Proxy(target, new DeserializationHandler(container, data));
            deserializedProxyMap.set(data, proxy);
        }
        return proxy;
    };
    class DeserializationHandler {
        $container$;
        $data$;
        $length$;
        constructor($container$, $data$) {
            this.$container$ = $container$;
            this.$data$ = $data$;
            this.$length$ = this.$data$.length / 2;
        }
        get(target, property, receiver) {
            if (property === SERIALIZER_PROXY_UNWRAP) {
                // Note that this will only be partially filled in
                return target;
            }
            const i = typeof property === 'number'
                ? property
                : typeof property === 'string'
                    ? parseInt(property, 10)
                    : NaN;
            if (Number.isNaN(i) || i < 0 || i >= this.$length$) {
                return Reflect.get(target, property, receiver);
            }
            // The serialized data is an array with 2 values for each item
            const idx = i * 2;
            const typeId = this.$data$[idx];
            const value = this.$data$[idx + 1];
            if (typeId === 0 /* TypeIds.Plain */) {
                // The value is already cached
                return value;
            }
            const container = this.$container$;
            const propValue = allocate(container, typeId, value);
            Reflect.set(target, property, propValue);
            this.$data$[idx] = 0 /* TypeIds.Plain */;
            this.$data$[idx + 1] = propValue;
            /** We stored the reference, so now we can inflate, allowing cycles */
            if (needsInflation(typeId)) {
                inflate(container, propValue, typeId, value);
            }
            return propValue;
        }
        has(target, property) {
            if (property === SERIALIZER_PROXY_UNWRAP) {
                return true;
            }
            return Object.prototype.hasOwnProperty.call(target, property);
        }
        set(target, property, value, receiver) {
            if (property === SERIALIZER_PROXY_UNWRAP) {
                return false;
            }
            const out = Reflect.set(target, property, value, receiver);
            const i = typeof property === 'number' ? property : parseInt(property, 10);
            if (Number.isNaN(i) || i < 0 || i >= this.$data$.length / 2) {
                return out;
            }
            const idx = i * 2;
            this.$data$[idx] = 0 /* TypeIds.Plain */;
            this.$data$[idx + 1] = value;
            return true;
        }
    }

    // NOTE: we want to move this function to qwikloader, and therefore this function should not have any external dependencies
    /**
     * Process the VNodeData script tags and store the VNodeData in the VNodeDataMap.
     *
     * The end result of this function is that each DOM element has the associated `VNodeData` attached
     * to it, to be used later `VNode` materialization. The "attachment" is done through the
     * `VNodeDataMap`.
     *
     * Run this function on startup to process the `<script type="qwik/vnode">` tags. The data in the
     * tags needs to be parsed and attached to the DOM elements. (We do this through `VNodeDataMap`)
     * `VNodeDataMap` is then used to lazily materialize the VNodes.
     *
     * Only one invocation of this function is needed per document/browser session.
     *
     * Below is an example of the kinds of constructs which need to be handled when dealing with
     * VNodeData deserialization.
     *
     * ```
     * <html q:container="paused">
     *   <body>
     *     <div q:container="paused">
     *       <script type="qwik/vnode">...</script>
     *     </div>
     *     <div q:container="html">...</div>
     *     before
     *     <!--q:container=ABC-->
     *     ...
     *     <!--/q:container-->
     *     after
     *     <!--q:ignore=FOO-->
     *     ...
     *        <!--q:container-island=BAR-->
     *        <div>some interactive island</div>
     *        <!--/q:container-island-->
     *     ...
     *     <!--/q:ignore-->
     *     <textarea q:container="text">...</textarea>
     *     <script type="qwik/vnode">...</script>
     *   </body>
     * </html>
     * ```
     *
     * Each `qwik/vnode` script assumes that the elements are numbered in depth first order. For this
     * reason, whenever the `processVNodeData` comes across a `q:container` it must ignore its
     * children.
     *
     * IMPLEMENTATION:
     *
     * - Stack to keep track of the current `q:container` being processed.
     * - Attach all `qwik/vnode` scripts (not the data contain within them) to the `q:container` element.
     * - Walk the tree and process each `q:container` element.
     */
    function processVNodeData(document) {
        const Q_CONTAINER = 'q:container';
        const Q_CONTAINER_END = '/' + Q_CONTAINER;
        const Q_PROPS_SEPARATOR = ':';
        const Q_SHADOW_ROOT = 'q:shadowroot';
        const Q_IGNORE = 'q:ignore';
        const Q_IGNORE_END = '/' + Q_IGNORE;
        const Q_CONTAINER_ISLAND = 'q:container-island';
        const Q_CONTAINER_ISLAND_END = '/' + Q_CONTAINER_ISLAND;
        const qDocument = document;
        const vNodeDataMap = qDocument.qVNodeData || (qDocument.qVNodeData = new WeakMap());
        const prototype = document.body;
        const getter = (prototype, name) => {
            let getter;
            while (prototype && !(getter = Object.getOwnPropertyDescriptor(prototype, name)?.get)) {
                prototype = Object.getPrototypeOf(prototype);
            }
            return (getter ||
                function () {
                    return this[name];
                });
        };
        const getAttribute = prototype.getAttribute;
        const hasAttribute = prototype.hasAttribute;
        const getNodeType = getter(prototype, 'nodeType');
        // Process all of the `qwik/vnode` script tags by attaching them to the corresponding containers.
        const attachVnodeDataAndRefs = (element) => {
            Array.from(element.querySelectorAll('script[type="qwik/vnode"]')).forEach((script) => {
                script.setAttribute('type', 'x-qwik/vnode');
                const qContainerElement = script.closest('[q\\:container]');
                qContainerElement.qVnodeData = script.textContent;
                qContainerElement.qVNodeRefs = new Map();
            });
            element.querySelectorAll('[q\\:shadowroot]').forEach((parent) => {
                const shadowRoot = parent.shadowRoot;
                shadowRoot && attachVnodeDataAndRefs(shadowRoot);
            });
        };
        attachVnodeDataAndRefs(document);
        /**
         * Looks up which type of node this is in a monomorphic way which should be faster.
         *
         * See: https://mhevery.github.io/perf-tests/DOM-megamorphic.html
         */
        const getFastNodeType = (node) => {
            const nodeType = getNodeType.call(node);
            if (nodeType === 1 /* Node.ELEMENT_NODE */) {
                const qContainer = getAttribute.call(node, Q_CONTAINER);
                if (qContainer === null) {
                    if (hasAttribute.call(node, Q_SHADOW_ROOT)) {
                        return 6 /* NodeType.ELEMENT_SHADOW_ROOT_WRAPPER */;
                    }
                    const isQElement = hasAttribute.call(node, Q_PROPS_SEPARATOR);
                    return isQElement ? 2 /* NodeType.ELEMENT */ : 0 /* NodeType.OTHER */;
                }
                else {
                    return 3 /* NodeType.ELEMENT_CONTAINER */;
                }
            }
            else if (nodeType === 8 /* Node.COMMENT_NODE */) {
                const nodeValue = node.nodeValue || ''; // nodeValue is monomorphic so it does not need fast path
                if (nodeValue.startsWith(Q_CONTAINER_ISLAND)) {
                    return 65 /* NodeType.COMMENT_ISLAND_START */;
                }
                else if (nodeValue.startsWith(Q_IGNORE)) {
                    return 16 /* NodeType.COMMENT_IGNORE_START */;
                }
                else if (nodeValue.startsWith(Q_CONTAINER)) {
                    return 9 /* NodeType.COMMENT_SKIP_START */;
                }
                else if (nodeValue.startsWith(Q_CONTAINER_ISLAND_END)) {
                    return 64 /* NodeType.COMMENT_ISLAND_END */;
                }
                else if (nodeValue.startsWith(Q_IGNORE_END)) {
                    return 32 /* NodeType.COMMENT_IGNORE_END */;
                }
                else if (nodeValue.startsWith(Q_CONTAINER_END)) {
                    return 8 /* NodeType.COMMENT_SKIP_END */;
                }
            }
            return 0 /* NodeType.OTHER */;
        };
        const isSeparator = (ch) => 
        /* `!` */ VNodeDataSeparator.ADVANCE_1 <= ch && ch <= VNodeDataSeparator.ADVANCE_8192; /* `.` */
        /**
         * Given the `vData` string, `start` index, and `end` index, find the end of the VNodeData
         * section.
         */
        const findVDataSectionEnd = (vData, start, end) => {
            let depth = 0;
            while (true) {
                // look for the end of VNodeData
                if (start < end) {
                    const ch = vData.charCodeAt(start);
                    if (depth === 0 && isSeparator(ch)) {
                        break;
                    }
                    else {
                        if (ch === VNodeDataChar.OPEN) {
                            depth++;
                        }
                        else if (ch === VNodeDataChar.CLOSE) {
                            depth--;
                        }
                        start++;
                    }
                }
                else {
                    break;
                }
            }
            return start;
        };
        const nextSibling = (node) => {
            // eslint-disable-next-line no-empty
            while (node && (node = node.nextSibling) && getFastNodeType(node) === 0 /* NodeType.OTHER */) { }
            return node;
        };
        /**
         * Process the container
         *
         * @param walker TreeWalker
         * @param containerNode The root of container element
         * @param exitNode The node which represents the last node and we should exit.
         * @param qVNodeRefs Place to store the VNodeRefs
         */
        const walkContainer = (walker, containerNode, node, exitNode, vData, qVNodeRefs, prefix) => {
            const vData_length = vData.length;
            /// Stores the current element index as the TreeWalker traverses the DOM.
            let elementIdx = 0;
            /// Stores the current VNode index as derived from the VNodeData script tag.
            let vNodeElementIndex = -1;
            let vData_start = 0;
            let vData_end = 0;
            let ch = 0;
            let needsToStoreRef = -1;
            let nextNode = null;
            /** Computes number of elements which need to be skipped to get to the next VNodeData section. */
            const howManyElementsToSkip = () => {
                let elementsToSkip = 0;
                while (isSeparator((ch = vData.charCodeAt(vData_start)))) {
                    // Keep consuming the separators and incrementing the vNodeIndex
                    // console.log('ADVANCE', vNodeElementIndex, ch, ch - 33);
                    elementsToSkip += 1 << (ch - VNodeDataSeparator.ADVANCE_1);
                    vData_start++;
                    if (vData_start >= vData_length) {
                        // we reached the end of the vNodeData stop.
                        break;
                    }
                }
                return elementsToSkip;
            };
            do {
                if (node === exitNode) {
                    return;
                }
                nextNode = null;
                const nodeType = node == containerNode ? 2 /* NodeType.ELEMENT */ : getFastNodeType(node);
                if (nodeType === 3 /* NodeType.ELEMENT_CONTAINER */) {
                    // If we are in a container, we need to skip the children.
                    const container = node;
                    let cursor = node;
                    while (cursor && !(nextNode = nextSibling(cursor))) {
                        cursor = cursor.parentNode;
                    }
                    // console.log('EXIT', nextNode?.outerHTML);
                    walkContainer(walker, container, node, nextNode, container.qVnodeData || '', container.qVNodeRefs);
                }
                else if (nodeType === 16 /* NodeType.COMMENT_IGNORE_START */) {
                    let islandNode = node;
                    do {
                        islandNode = walker.nextNode();
                        if (!islandNode) {
                            throw new Error(`Island inside <!--${node?.nodeValue}--> not found!`);
                        }
                    } while (getFastNodeType(islandNode) !== 65 /* NodeType.COMMENT_ISLAND_START */);
                    nextNode = null;
                }
                else if (nodeType === 64 /* NodeType.COMMENT_ISLAND_END */) {
                    nextNode = node;
                    do {
                        nextNode = walker.nextNode();
                        if (!nextNode) {
                            throw new Error(`Ignore block not closed!`);
                        }
                    } while (getFastNodeType(nextNode) !== 32 /* NodeType.COMMENT_IGNORE_END */);
                    nextNode = null;
                }
                else if (nodeType === 9 /* NodeType.COMMENT_SKIP_START */) {
                    // If we are in a container, we need to skip the children.
                    nextNode = node;
                    do {
                        nextNode = nextSibling(nextNode);
                        if (!nextNode) {
                            throw new Error(`<!--${node?.nodeValue}--> not closed!`);
                        }
                    } while (getFastNodeType(nextNode) !== 8 /* NodeType.COMMENT_SKIP_END */);
                    // console.log('EXIT', nextNode?.outerHTML);
                    walkContainer(walker, node, node, nextNode, '', null);
                }
                else if (nodeType === 6 /* NodeType.ELEMENT_SHADOW_ROOT_WRAPPER */) {
                    // If we are in a shadow root, we need to get the shadow root element.
                    nextNode = nextSibling(node);
                    const shadowRootContainer = node;
                    const shadowRoot = shadowRootContainer?.shadowRoot;
                    if (shadowRoot) {
                        walkContainer(
                        // we need to create a new walker for the shadow root
                        document.createTreeWalker(shadowRoot, 0x1 /* NodeFilter.SHOW_ELEMENT  */ | 0x80 /*  NodeFilter.SHOW_COMMENT */), null, shadowRoot, null, '', null);
                    }
                }
                if ((nodeType & 2 /* NodeType.ELEMENT */) === 2 /* NodeType.ELEMENT */) {
                    if (vNodeElementIndex < elementIdx) {
                        // VNodeData needs to catch up with the elementIdx
                        if (vNodeElementIndex === -1) {
                            vNodeElementIndex = 0;
                        }
                        vData_start = vData_end;
                        if (vData_start < vData_length) {
                            vNodeElementIndex += howManyElementsToSkip();
                            const shouldStoreRef = ch === VNodeDataSeparator.REFERENCE;
                            if (shouldStoreRef) {
                                // if we need to store the ref handle it here.
                                needsToStoreRef = vNodeElementIndex;
                                vData_start++;
                                if (vData_start < vData_length) {
                                    ch = vData.charCodeAt(vData_end);
                                }
                                else {
                                    // assume separator on end.
                                    ch = VNodeDataSeparator.ADVANCE_1;
                                }
                            }
                            vData_end = findVDataSectionEnd(vData, vData_start, vData_length);
                        }
                        else {
                            vNodeElementIndex = Number.MAX_SAFE_INTEGER;
                        }
                    }
                    // console.log(
                    //   prefix,
                    //   'ELEMENT',
                    //   nodeType,
                    //   elementIdx,
                    //   vNodeElementIndex,
                    //   (node as any).outerHTML,
                    //   elementIdx === vNodeElementIndex ? vData.substring(vData_start, vData_end) : ''
                    // );
                    if (elementIdx === vNodeElementIndex) {
                        if (needsToStoreRef === elementIdx) {
                            qVNodeRefs.set(elementIdx, node);
                        }
                        const instructions = vData.substring(vData_start, vData_end);
                        vNodeDataMap.set(node, instructions);
                    }
                    elementIdx++;
                }
            } while ((node = nextNode || walker.nextNode()));
        };
        // Walk the tree and process each `q:container` element.
        const walker = document.createTreeWalker(document, 0x1 /* NodeFilter.SHOW_ELEMENT  */ | 0x80 /*  NodeFilter.SHOW_COMMENT */);
        walkContainer(walker, null, walker.firstChild(), null, '', null);
    }

    /** @file Public APIs for the SSR */
    /** @public */
    function getDomContainer(element) {
        const qContainerElement = _getQContainerElement(element);
        if (!qContainerElement) {
            throw qError(24 /* QError.containerNotFound */);
        }
        return getDomContainerFromQContainerElement(qContainerElement);
    }
    function getDomContainerFromQContainerElement(qContainerElement) {
        const qElement = qContainerElement;
        let container = qElement.qContainer;
        if (!container) {
            container = new DomContainer(qElement);
        }
        return container;
    }
    /** @internal */
    function _getQContainerElement(element) {
        const qContainerElement = vnode_isVNode(element)
            ? vnode_getDomParent(element, true)
            : element;
        return qContainerElement.closest(QContainerSelector);
    }
    const isDomContainer = (container) => {
        return container instanceof DomContainer;
    };
    /** @internal */
    class DomContainer extends _SharedContainer {
        element;
        qContainer;
        qManifestHash;
        rootVNode;
        document;
        $journal$;
        $rawStateData$;
        $storeProxyMap$ = new WeakMap();
        $qFuncs$;
        $instanceHash$;
        $forwardRefs$ = null;
        vNodeLocate = (id) => vnode_locate(this.rootVNode, id);
        $stateData$;
        $styleIds$ = null;
        constructor(element) {
            super(() => {
                this.$flushEpoch$++;
                vnode_applyJournal(this.$journal$);
            }, {}, element.getAttribute(QLocaleAttr));
            this.qContainer = element.getAttribute(QContainerAttr);
            if (!this.qContainer) {
                throw qError(25 /* QError.elementWithoutContainer */);
            }
            this.$journal$ = [
                3 /* VNodeJournalOpCode.HoistStyles */,
                element.ownerDocument,
            ];
            this.document = element.ownerDocument;
            this.element = element;
            this.$buildBase$ = element.getAttribute(QBaseAttr);
            this.$instanceHash$ = element.getAttribute(QInstanceAttr);
            this.qManifestHash = element.getAttribute(QManifestHashAttr);
            this.rootVNode = vnode_newUnMaterializedElement(this.element);
            this.$rawStateData$ = [];
            this.$stateData$ = [];
            const document = this.element.ownerDocument;
            if (!document.qVNodeData) {
                processVNodeData(document);
            }
            this.$qFuncs$ = getQFuncs(document, this.$instanceHash$) || EMPTY_ARRAY;
            this.$setServerData$();
            element.setAttribute(QContainerAttr, "resumed" /* QContainerValue.RESUMED */);
            element.qContainer = this;
            const qwikStates = element.querySelectorAll('script[type="qwik/state"]');
            if (qwikStates.length !== 0) {
                const lastState = qwikStates[qwikStates.length - 1];
                this.$rawStateData$ = JSON.parse(lastState.textContent);
                preprocessState(this.$rawStateData$, this);
                this.$stateData$ = wrapDeserializerProxy(this, this.$rawStateData$);
            }
        }
        $setRawState$(id, vParent) {
            this.$stateData$[id] = vParent;
        }
        parseQRL(qrl) {
            return _inflateQRL(this, parseQRL(qrl));
        }
        handleError(err, host) {
            if (qDev && host) {
                if (typeof document !== 'undefined') {
                    const vHost = host;
                    const journal = [];
                    const vHostParent = vHost.parent;
                    const vHostNextSibling = vHost.nextSibling;
                    const vErrorDiv = vnode_createErrorDiv(document, vHost, err, journal);
                    // If the host is an element node, we need to insert the error div into its parent.
                    const insertHost = vnode_isElementVNode(vHost) ? vHostParent || vHost : vHost;
                    // If the host is different then we need to insert errored-host in the same position as the host.
                    const insertBefore = insertHost === vHost ? null : vHostNextSibling;
                    vnode_insertBefore(journal, insertHost, vErrorDiv, insertBefore);
                    vnode_applyJournal(journal);
                }
                if (err && err instanceof Error) {
                    if (!('hostElement' in err)) {
                        err['hostElement'] = String(host);
                    }
                }
                if (!isRecoverable(err)) {
                    throw err;
                }
            }
            const errorStore = host && this.resolveContext(host, ERROR_CONTEXT);
            if (!errorStore) {
                throw err;
            }
            errorStore.error = err;
        }
        setContext(host, context, value) {
            let ctx = this.getHostProp(host, QCtxAttr);
            if (ctx == null) {
                this.setHostProp(host, QCtxAttr, (ctx = []));
            }
            mapArray_set(ctx, context.id, value, 0, true);
        }
        resolveContext(host, contextId) {
            while (host) {
                const ctx = this.getHostProp(host, QCtxAttr);
                if (ctx != null && mapArray_has(ctx, contextId.id, 0)) {
                    return mapArray_get(ctx, contextId.id, 0);
                }
                host = this.getParentHost(host);
            }
            return undefined;
        }
        getParentHost(host) {
            let vNode = host.parent;
            while (vNode) {
                if (vnode_isVirtualVNode(vNode)) {
                    if (vNode.getProp(OnRenderProp, null) !== null) {
                        return vNode;
                    }
                    vNode =
                        vNode.parent ||
                            // If virtual node, than it could be a slot so we need to read its parent.
                            vNode.slotParent;
                }
                else {
                    vNode = vNode.parent;
                }
            }
            return null;
        }
        setHostProp(host, name, value) {
            const vNode = host;
            vNode.setProp(name, value);
        }
        getHostProp(host, name) {
            const vNode = host;
            let getObjectById = null;
            switch (name) {
                case ELEMENT_SEQ:
                case ELEMENT_PROPS:
                case OnRenderProp:
                case QCtxAttr:
                case QBackRefs:
                    getObjectById = this.$getObjectById$;
                    break;
                case ELEMENT_SEQ_IDX:
                case USE_ON_LOCAL_SEQ_IDX:
                    getObjectById = parseInt;
                    break;
            }
            return vNode.getProp(name, getObjectById);
        }
        ensureProjectionResolved(vNode) {
            if ((vNode.flags & 16 /* VNodeFlags.Resolved */) === 0) {
                vNode.flags |= 16 /* VNodeFlags.Resolved */;
                const props = vnode_getProps(vNode);
                for (let i = 0; i < props.length; i = i + 2) {
                    const prop = props[i];
                    if (isSlotProp(prop)) {
                        const value = props[i + 1];
                        if (typeof value == 'string') {
                            const projection = this.vNodeLocate(value);
                            props[i + 1] = projection;
                        }
                    }
                }
            }
        }
        $getObjectById$ = (id) => {
            return getObjectById(id, this.$stateData$);
        };
        getSyncFn(id) {
            const fn = this.$qFuncs$[id];
            assertTrue(typeof fn === 'function', 'Invalid reference: ' + id);
            return fn;
        }
        $appendStyle$(content, styleId, host, scoped) {
            if (scoped) {
                const scopedStyleIdsString = this.getHostProp(host, QScopedStyle);
                const scopedStyleIds = new Set(convertScopedStyleIdsToArray(scopedStyleIdsString));
                scopedStyleIds.add(styleId);
                this.setHostProp(host, QScopedStyle, convertStyleIdsToString(scopedStyleIds));
            }
            if (this.$styleIds$ == null) {
                this.$styleIds$ = new Set();
                this.element.querySelectorAll(QStyleSelector).forEach((style) => {
                    this.$styleIds$.add(style.getAttribute(QStyle));
                });
            }
            if (!this.$styleIds$.has(styleId)) {
                this.$styleIds$.add(styleId);
                const styleElement = this.document.createElement('style');
                styleElement.setAttribute(QStyle, styleId);
                styleElement.textContent = content;
                this.$journal$.push(6 /* VNodeJournalOpCode.Insert */, this.document.head, null, styleElement);
            }
        }
        // TODO: should be moved to the Qwik Router?
        /** Set the server data for the Qwik Router. */
        $setServerData$() {
            const containerAttributes = {};
            const attrs = this.element.attributes;
            if (attrs) {
                for (let index = 0; index < attrs.length; index++) {
                    const attr = attrs[index];
                    if (attr.name === Q_PROPS_SEPARATOR) {
                        continue;
                    }
                    containerAttributes[attr.name] = attr.value;
                }
            }
            this.$serverData$ = { containerAttributes };
        }
    }

    const throwIfQRLNotResolved = (qrl) => {
        const resolved = qrl.resolved;
        if (!resolved) {
            // When we are creating a signal using a use method, we need to ensure
            // that the computation can be lazy and therefore we need to unsure
            // that the QRL is resolved.
            // When we re-create the signal from serialization (we don't create the signal
            // using useMethod) it is OK to not resolve it until the graph is marked as dirty.
            throw qrl.resolve();
        }
    };
    /** @public */
    const isSignal = (value) => {
        return value instanceof SignalImpl;
    };
    const ensureContainsSubscription = (array, effectSubscription) => {
        !array.has(effectSubscription) && array.add(effectSubscription);
    };
    /** Ensure the item is in back refs set */
    const ensureContainsBackRef = (array, value) => {
        array[2 /* EffectSubscriptionProp.BACK_REF */] ||= new Set();
        !array[2 /* EffectSubscriptionProp.BACK_REF */].has(value) &&
            array[2 /* EffectSubscriptionProp.BACK_REF */].add(value);
    };
    const addQrlToSerializationCtx = (effectSubscriber, container) => {
        if (!!container && !isDomContainer(container)) {
            const effect = effectSubscriber[0 /* EffectSubscriptionProp.CONSUMER */];
            const property = effectSubscriber[1 /* EffectSubscriptionProp.PROPERTY */];
            let qrl = null;
            if (isTask(effect)) {
                qrl = effect.$qrl$;
            }
            else if (effect instanceof ComputedSignalImpl) {
                qrl = effect.$computeQrl$;
            }
            else if (property === ":" /* EffectProperty.COMPONENT */) {
                qrl = container.getHostProp(effect, OnRenderProp);
            }
            if (qrl) {
                container.serializationCtx.$eventQrls$.add(qrl);
            }
        }
    };
    const scheduleEffects = (container, signal, effects) => {
        const isBrowser = !isServerPlatform();
        if (effects) {
            const scheduleEffect = (effectSubscription) => {
                const consumer = effectSubscription[0 /* EffectSubscriptionProp.CONSUMER */];
                const property = effectSubscription[1 /* EffectSubscriptionProp.PROPERTY */];
                assertDefined(container, 'Container must be defined.');
                if (isTask(consumer)) {
                    consumer.$flags$ |= 8 /* TaskFlags.DIRTY */;
                    let choreType = 3 /* ChoreType.TASK */;
                    if (consumer.$flags$ & 1 /* TaskFlags.VISIBLE_TASK */) {
                        choreType = 16 /* ChoreType.VISIBLE */;
                    }
                    container.$scheduler$(choreType, consumer);
                }
                else if (consumer instanceof SignalImpl) {
                    // we don't schedule ComputedSignal/DerivedSignal directly, instead we invalidate it and
                    // and schedule the signals effects (recursively)
                    if (consumer instanceof ComputedSignalImpl) {
                        // Ensure that the computed signal's QRL is resolved.
                        // If not resolved schedule it to be resolved.
                        if (!consumer.$computeQrl$.resolved) {
                            container.$scheduler$(1 /* ChoreType.QRL_RESOLVE */, null, consumer.$computeQrl$);
                        }
                    }
                    consumer.invalidate();
                }
                else if (property === ":" /* EffectProperty.COMPONENT */) {
                    const host = consumer;
                    const qrl = container.getHostProp(host, OnRenderProp);
                    assertDefined(qrl, 'Component must have QRL');
                    const props = container.getHostProp(host, ELEMENT_PROPS);
                    container.$scheduler$(6 /* ChoreType.COMPONENT */, host, qrl, props);
                }
                else if (property === "." /* EffectProperty.VNODE */) {
                    if (isBrowser) {
                        const host = consumer;
                        container.$scheduler$(4 /* ChoreType.NODE_DIFF */, host, host, signal);
                    }
                }
                else {
                    const host = consumer;
                    const effectData = effectSubscription[3 /* EffectSubscriptionProp.DATA */];
                    if (effectData instanceof SubscriptionData) {
                        const data = effectData.data;
                        const payload = {
                            ...data,
                            $value$: signal,
                        };
                        container.$scheduler$(5 /* ChoreType.NODE_PROP */, host, property, payload);
                    }
                }
            };
            for (const effect of effects) {
                scheduleEffect(effect);
            }
        }
    };
    /** @internal */
    const isSerializerObj = (obj) => {
        return isObject(obj) && typeof obj[SerializerSymbol] === 'function';
    };
    const getComputedSignalFlags = (serializationStrategy) => {
        let flags = 1 /* SignalFlags.INVALID */;
        switch (serializationStrategy) {
            // TODO: implement this in the future
            // case 'auto':
            //   flags |= ComputedSignalFlags.SERIALIZATION_STRATEGY_AUTO;
            //   break;
            case 'never':
                flags |= 16 /* SerializationSignalFlags.SERIALIZATION_STRATEGY_NEVER */;
                break;
            case 'always':
                flags |= 32 /* SerializationSignalFlags.SERIALIZATION_STRATEGY_ALWAYS */;
                break;
        }
        return flags;
    };

    const stringifyPath = [];
    function qwikDebugToString(value) {
        if (value === null) {
            return 'null';
        }
        else if (value === undefined) {
            return 'undefined';
        }
        else if (typeof value === 'string') {
            return '"' + value + '"';
        }
        else if (typeof value === 'number' || typeof value === 'boolean') {
            return String(value);
        }
        else if (isTask(value)) {
            return `Task(${qwikDebugToString(value.$qrl$)})`;
        }
        else if (isQrl(value)) {
            return `Qrl(${value.$symbol$})`;
        }
        else if (typeof value === 'object' || typeof value === 'function') {
            if (stringifyPath.includes(value)) {
                return '*';
            }
            try {
                stringifyPath.push(value);
                if (Array.isArray(value)) {
                    if (vnode_isVNode(value)) {
                        return '(' + value.getProp(DEBUG_TYPE, null) + ')';
                    }
                    else {
                        return value.map(qwikDebugToString);
                    }
                }
                else if (isSignal(value)) {
                    if (value instanceof WrappedSignalImpl) {
                        return 'WrappedSignal';
                    }
                    else if (value instanceof ComputedSignalImpl) {
                        return 'ComputedSignal';
                    }
                    else {
                        return 'Signal';
                    }
                }
                else if (isStore(value)) {
                    return 'Store';
                }
                else if (isJSXNode(value)) {
                    return jsxToString(value);
                }
                else if (vnode_isVNode(value)) {
                    return '(' + value.getProp(DEBUG_TYPE, null) + ')';
                }
            }
            finally {
                stringifyPath.pop();
            }
        }
        return value;
    }
    const pad = (text, prefix) => {
        return String(text)
            .split('\n')
            .map((line, idx) => (idx ? prefix : '') + line)
            .join('\n');
    };
    const jsxToString = (value) => {
        if (isJSXNode(value)) {
            let str = '<' + value.type;
            if (value.props) {
                for (const [key, val] of Object.entries(value.props)) {
                    str += ' ' + key + '=' + qwikDebugToString(val);
                }
                const children = value.children;
                if (children != null) {
                    str += '>';
                    if (Array.isArray(children)) {
                        children.forEach((child) => {
                            str += jsxToString(child);
                        });
                    }
                    else {
                        str += jsxToString(children);
                    }
                    str += '</' + value.type + '>';
                }
                else {
                    str += '/>';
                }
            }
            return str;
        }
        else {
            return String(value);
        }
    };

    const getStoreHandler = (value) => {
        return value[STORE_HANDLER];
    };
    const getStoreTarget = (value) => {
        return value?.[STORE_TARGET] || null;
    };
    /**
     * Force a store to recompute and schedule effects.
     *
     * @public
     */
    const forceStoreEffects = (value, prop) => {
        const handler = getStoreHandler(value);
        if (handler) {
            handler.force(prop);
        }
    };
    /**
     * @returns True if the store has effects for the given prop
     * @internal
     */
    const _hasStoreEffects = (value, prop) => {
        const handler = getStoreHandler(value);
        if (handler) {
            return (handler.$effects$?.get(prop)?.size ?? 0) > 0;
        }
        return false;
    };
    /**
     * Get the original object that was wrapped by the store. Useful if you want to clone a store
     * (structuredClone, IndexedDB,...)
     *
     * @public
     */
    const unwrapStore = (value) => {
        return getStoreTarget(value) || value;
    };
    /** @internal */
    const isStore = (value) => {
        return STORE_TARGET in value;
    };
    function createStore(container, obj, flags) {
        return new Proxy(obj, new StoreHandler(flags, container || null));
    }
    const getOrCreateStore = (obj, flags, container) => {
        if (isSerializableObject(obj) && container) {
            let store = container.$storeProxyMap$.get(obj);
            if (!store) {
                store = createStore(container, obj, flags);
                container.$storeProxyMap$.set(obj, store);
            }
            return store;
        }
        return obj;
    };
    class StoreHandler {
        $flags$;
        $container$;
        $effects$ = null;
        constructor($flags$, $container$) {
            this.$flags$ = $flags$;
            this.$container$ = $container$;
        }
        toString() {
            return '[Store]';
        }
        force(prop) {
            const target = getStoreTarget(this);
            this.$container$?.$scheduler$(7 /* ChoreType.RECOMPUTE_AND_SCHEDULE_EFFECTS */, null, this, getEffects(target, prop, this.$effects$));
        }
        get(target, prop) {
            // TODO(perf): handle better `slice` calls
            if (typeof prop === 'symbol') {
                if (prop === STORE_TARGET) {
                    return target;
                }
                if (prop === STORE_HANDLER) {
                    return this;
                }
                return target[prop];
            }
            const ctx = tryGetInvokeContext();
            const value = target[prop];
            if (ctx) {
                if (this.$container$ === null) {
                    if (!ctx.$container$) {
                        return value;
                    }
                    // Grab the container now we have access to it
                    this.$container$ = ctx.$container$;
                }
                else {
                    assertTrue(!ctx.$container$ || ctx.$container$ === this.$container$, 'Do not use signals across containers');
                }
                const effectSubscriber = ctx.$effectSubscriber$;
                if (effectSubscriber) {
                    addStoreEffect(target, Array.isArray(target) ? STORE_ALL_PROPS : prop, this, effectSubscriber);
                }
            }
            if (prop === 'toString' && value === Object.prototype.toString) {
                return this.toString;
            }
            const flags = this.$flags$;
            if (flags & 1 /* StoreFlags.RECURSIVE */ &&
                isObject(value) &&
                !Object.isFrozen(value) &&
                !isStore(value) &&
                !Object.isFrozen(target)) {
                return getOrCreateStore(value, this.$flags$, this.$container$);
            }
            return value;
        }
        /** In the case of oldValue and value are the same, the effects are not triggered. */
        set(target, prop, value) {
            if (typeof prop === 'symbol') {
                target[prop] = value;
                return true;
            }
            const newValue = this.$flags$ & 1 /* StoreFlags.RECURSIVE */ ? unwrapStore(value) : value;
            if (prop in target) {
                const oldValue = target[prop];
                if (newValue !== oldValue) {
                    setNewValueAndTriggerEffects(prop, newValue, target, this);
                }
            }
            else {
                setNewValueAndTriggerEffects(prop, newValue, target, this);
            }
            return true;
        }
        deleteProperty(target, prop) {
            if (typeof prop != 'string' || !delete target[prop]) {
                return false;
            }
            if (!Array.isArray(target)) {
                // If the target is an array, we don't need to trigger effects.
                // Changing the length property will trigger effects.
                this.$container$?.$scheduler$(7 /* ChoreType.RECOMPUTE_AND_SCHEDULE_EFFECTS */, null, this, getEffects(target, prop, this.$effects$));
            }
            return true;
        }
        has(target, prop) {
            if (prop === STORE_TARGET) {
                return true;
            }
            if (typeof prop === 'string') {
                const ctx = tryGetInvokeContext();
                if (ctx) {
                    const effectSubscriber = ctx.$effectSubscriber$;
                    if (effectSubscriber) {
                        addStoreEffect(target, Array.isArray(target) ? STORE_ALL_PROPS : prop, this, effectSubscriber);
                    }
                }
            }
            return Object.prototype.hasOwnProperty.call(target, prop);
        }
        ownKeys(target) {
            const ctx = tryGetInvokeContext();
            const effectSubscriber = ctx?.$effectSubscriber$;
            if (effectSubscriber) {
                addStoreEffect(target, STORE_ALL_PROPS, this, effectSubscriber);
            }
            return Reflect.ownKeys(target);
        }
        getOwnPropertyDescriptor(target, prop) {
            const descriptor = Reflect.getOwnPropertyDescriptor(target, prop);
            if (Array.isArray(target) || typeof prop === 'symbol') {
                return descriptor;
            }
            if (descriptor && !descriptor.configurable) {
                return descriptor;
            }
            return {
                enumerable: true,
                configurable: true,
            };
        }
    }
    function addStoreEffect(target, prop, store, effectSubscription) {
        const effectsMap = (store.$effects$ ||= new Map());
        let effects = effectsMap.get(prop);
        if (!effects) {
            effects = new Set();
            effectsMap.set(prop, effects);
        }
        // Let's make sure that we have a reference to this effect.
        // Adding reference is essentially adding a subscription, so if the signal
        // changes we know who to notify.
        ensureContainsSubscription(effects, effectSubscription);
        // But when effect is scheduled in needs to be able to know which signals
        // to unsubscribe from. So we need to store the reference from the effect back
        // to this signal.
        ensureContainsBackRef(effectSubscription, target);
        addQrlToSerializationCtx(effectSubscription, store.$container$);
    }
    function setNewValueAndTriggerEffects(prop, value, target, currentStore) {
        target[prop] = value;
        const effects = getEffects(target, prop, currentStore.$effects$);
        if (effects) {
            currentStore.$container$?.$scheduler$(7 /* ChoreType.RECOMPUTE_AND_SCHEDULE_EFFECTS */, null, currentStore, effects);
        }
    }
    function getEffects(target, prop, storeEffects) {
        let effectsToTrigger;
        if (storeEffects) {
            if (Array.isArray(target)) {
                for (const effects of storeEffects.values()) {
                    effectsToTrigger ||= new Set();
                    for (const effect of effects) {
                        effectsToTrigger.add(effect);
                    }
                }
            }
            else {
                effectsToTrigger = storeEffects.get(prop);
            }
        }
        const storeArrayValue = storeEffects?.get(STORE_ALL_PROPS);
        if (storeArrayValue) {
            effectsToTrigger ||= new Set();
            for (const effect of storeArrayValue) {
                effectsToTrigger.add(effect);
            }
        }
        return effectsToTrigger || null;
    }

    const canSerialize = (value, seen = new WeakSet()) => {
        if (value == null ||
            typeof value === 'string' ||
            typeof value === 'number' ||
            typeof value === 'boolean' ||
            typeof value === 'bigint') {
            return true;
        }
        else if (typeof value === 'object') {
            if (seen.has(value)) {
                return true;
            }
            seen.add(value);
            const proto = Object.getPrototypeOf(value);
            if (isStore(value)) {
                value = getStoreTarget(value);
            }
            if (proto == Object.prototype) {
                for (const key in value) {
                    // if the value is a props proxy, then sometimes we could create a component-level subscription,
                    // so we should call untrack here to avoid tracking the value
                    if (!canSerialize(untrack(() => value[key]), seen)) {
                        return false;
                    }
                }
                return true;
            }
            else if (proto == Array.prototype) {
                for (let i = 0; i < value.length; i++) {
                    if (!canSerialize(value[i], seen)) {
                        return false;
                    }
                }
                return true;
            }
            else if (isTask(value)) {
                return true;
            }
            else if (isPropsProxy(value)) {
                return true;
            }
            else if (isPromise(value)) {
                return true;
            }
            else if (isJSXNode(value)) {
                return true;
            }
            else if (value instanceof Error) {
                return true;
            }
            else if (value instanceof URL) {
                return true;
            }
            else if (value instanceof Date) {
                return true;
            }
            else if (value instanceof RegExp) {
                return true;
            }
            else if (value instanceof URLSearchParams) {
                return true;
            }
            else if (value instanceof FormData) {
                return true;
            }
            else if (value instanceof Set) {
                return true;
            }
            else if (value instanceof Map) {
                return true;
            }
            else if (value instanceof Uint8Array) {
                return true;
            }
            else if (value instanceof SubscriptionData) {
                return true;
            }
            else if (isDomRef?.(value)) {
                return true;
            }
        }
        else if (typeof value === 'function') {
            if (isQrl(value) || isQwikComponent(value) || value === Slot || value === Fragment) {
                return true;
            }
        }
        else if (value === _UNINITIALIZED || value === NEEDS_COMPUTATION || value === STORE_ALL_PROPS) {
            return true;
        }
        return false;
    };

    const circularProofJson = (obj, indent) => {
        const seen = new WeakSet();
        return JSON.stringify(obj, (_, value) => {
            if (isObject(value)) {
                if (seen.has(value)) {
                    return `[Circular ${value.constructor.name}]`;
                }
                seen.add(value);
            }
            return value;
        }, indent);
    };
    const printRaw = (value, prefix) => {
        let result = vnode_isVNode(value)
            ? vnode_toString.call(value, 1, '', true).replaceAll(/\n.*/gm, '')
            : typeof value === 'function'
                ? String(value)
                : circularProofJson(value, 2);
        if (result.length > 500) {
            result = result.slice(0, 500) + '"...';
        }
        result = result.replace(/\n/g, '\n' + prefix);
        return result.includes('\n') ? (result = `\n${prefix}${result}`) : result;
    };
    let hasRaw = false;
    /** @internal */
    const _dumpState = (state, color = false, prefix = '', limit = 20) => {
        const RED = color ? '\x1b[31m' : '';
        const RESET = color ? '\x1b[0m' : '';
        const isRoot = prefix === '';
        const out = [];
        for (let i = 0; i < state.length; i++) {
            if (limit && i > 2 * limit) {
                out.push('...');
                break;
            }
            const key = state[i];
            let value = state[++i];
            if (key === 0 /* TypeIds.Plain */) {
                const isRaw = typeof value !== 'number' && typeof value !== 'string';
                if (isRaw) {
                    hasRaw = true;
                }
                const type = `{${isObject(value) ? value.constructor.name : typeof value}}`;
                out.push(`${RED}${type}${RESET} ${printRaw(value, `${prefix}  `)}`);
            }
            else {
                if (key === 3 /* TypeIds.Constant */) {
                    value = constantToName(value);
                }
                else if (typeof value === 'string') {
                    value = JSON.stringify(value);
                    if (value.length > 120) {
                        value = value.slice(0, 120) + '"...';
                    }
                }
                else if (key === 13 /* TypeIds.ForwardRefs */) {
                    value = '[' + `\n${prefix}  ${value.join(`\n${prefix}  `)}\n${prefix}]`;
                }
                else if (Array.isArray(value)) {
                    value = value.length ? `[\n${_dumpState(value, color, `${prefix}  `)}\n${prefix}]` : '[]';
                }
                out.push(`${RED}${typeIdToName(key)}${RESET} ${value}`);
            }
        }
        const result = out.map((v, i) => `${prefix}${isRoot ? `${i} ` : ''}${v}`).join('\n');
        if (isRoot) {
            const count = hasRaw ? '' : `(${JSON.stringify(state).length} chars)`;
            hasRaw = false;
            return `\n${result}\n${count}`;
        }
        return result;
    };
    const typeIdToName = (code) => {
        return _typeIdNames[code] || `Unknown(${code})`;
    };
    const constantToName = (code) => {
        return _constantNames[code] || `Unknown(${code})`;
    };

    /**
     * Preprocess the state data to:
     *
     * - Replace RootRef with the actual object
     * - Create a map for forward refs
     * - Create an array of indexes for initial QRLs
     *
     * Before:
     *
     * ```
     * 0 Object [
     *   String "foo"
     *   Object [
     *     String "shared"
     *     Number 1
     *   ]
     * ]
     * 1 Object [
     *   String "bar"
     *   RootRef 2
     * ]
     * 2 RootRef "0 1"
     * (59 chars)
     * ```
     *
     * After:
     *
     * ```
     * 0 Object [
     *   String "foo"
     *   RootRef 2
     * ]
     * 1 Object [
     *   String "bar"
     *   RootRef 2
     * ]
     * 2 Object [
     *   String "shared"
     *   Number 1
     * ]
     * (55 chars)
     * ```
     *
     * @param data - The state data to preprocess
     * @returns The preprocessed state data
     * @internal
     */
    function preprocessState(data, container) {
        const isRootDeepRef = (type, value) => {
            return type === 1 /* TypeIds.RootRef */ && typeof value === 'string';
        };
        const isForwardRefsMap = (type) => {
            return type === 13 /* TypeIds.ForwardRefs */;
        };
        const isPreloadQrlType = (type) => {
            return type === 20 /* TypeIds.PreloadQRL */;
        };
        const processRootRef = (index) => {
            const rootRefPath = data[index + 1].split(' ');
            let object = data;
            let objectType = 1 /* TypeIds.RootRef */;
            let typeIndex = 0;
            let valueIndex = 0;
            let parent = null;
            for (let i = 0; i < rootRefPath.length; i++) {
                parent = object;
                typeIndex = parseInt(rootRefPath[i], 10) * 2;
                valueIndex = typeIndex + 1;
                objectType = object[typeIndex];
                object = object[valueIndex];
                if (objectType === 1 /* TypeIds.RootRef */) {
                    const rootRef = object;
                    const rootRefTypeIndex = rootRef * 2;
                    objectType = data[rootRefTypeIndex];
                    object = data[rootRefTypeIndex + 1];
                }
            }
            if (parent) {
                parent[typeIndex] = 1 /* TypeIds.RootRef */;
                parent[valueIndex] = index / 2;
            }
            data[index] = objectType;
            data[index + 1] = object;
        };
        const toPreload = build.isServer ? undefined : [];
        for (let i = 0; i < data.length; i += 2) {
            if (isRootDeepRef(data[i], data[i + 1])) {
                processRootRef(i);
            }
            else if (isForwardRefsMap(data[i])) {
                container.$forwardRefs$ = data[i + 1];
            }
            else if (!build.isServer && isPreloadQrlType(data[i])) {
                // preload QRLs are always serialized as strings with chunk and symbol ids
                const qrl = data[i + 1];
                const chunkIdx = Number(qrl.split(' ')[0]);
                toPreload.push(chunkIdx);
            }
        }
        /**
         * Preloads QRLs that are defined in the state data as `PreloadQRL`.
         *
         * This is done because when computed and custom serializer QRLs are called they need QRL to work.
         * If the QRL is not resolved at this point, it will be resolved by throwing a promise and
         * rerunning the whole wrapping function again. We want to avoid that, because it means that the
         * function can execute twice.
         *
         * ```ts
         * useVisibleTask$(() => {
         *   runHeavyLogic(); // This will be called again if the QRL of `computedOrCustomSerializer` is not resolved.
         *   console.log(computedOrCustomSerializer.value); // Throw a promise if QRL not resolved and execute visible task again.
         * });
         * ```
         */
        if (!build.isServer) {
            for (const idx of toPreload) {
                // we preload the chunk instead of the symbol so it also works in dev
                const chunkType = data[idx * 2];
                let chunk;
                if (chunkType === 0 /* TypeIds.Plain */) {
                    chunk = data[idx * 2 + 1];
                }
                else if (chunkType === 1 /* TypeIds.RootRef */) {
                    const refIdx = data[idx * 2 + 1];
                    chunk = data[refIdx * 2 + 1];
                }
                else {
                    continue;
                }
                preloader.p(chunk, 0.3);
            }
        }
    }

    /**
     * Serialize data to string using SerializationContext.
     *
     * @param data - Data to serialize
     * @internal
     */
    async function _serialize(data) {
        const serializationContext = createSerializationContext(null, null, () => '', () => '', () => { }, new WeakMap());
        for (const root of data) {
            serializationContext.$addRoot$(root);
        }
        await serializationContext.$serialize$();
        return serializationContext.$writer$.toString();
    }
    /**
     * Deserialize data from string to an array of objects.
     *
     * @param rawStateData - Data to deserialize
     * @param element - Container element
     * @internal
     */
    function _deserialize(rawStateData, element) {
        if (rawStateData == null) {
            return [];
        }
        const stateData = JSON.parse(rawStateData);
        if (!Array.isArray(stateData)) {
            return [];
        }
        let container;
        if (isNode(element) && isElement$1(element)) {
            container = _createDeserializeContainer(stateData, element);
        }
        else {
            container = _createDeserializeContainer(stateData);
        }
        const output = [];
        for (let i = 0; i < stateData.length; i += 2) {
            output[i / 2] = deserializeData(container, stateData[i], stateData[i + 1]);
        }
        return output;
    }
    function getObjectById(id, stateData) {
        if (typeof id === 'string') {
            id = parseInt(id, 10);
        }
        assertTrue(id < stateData.length, `Invalid reference ${id} >= ${stateData.length}`);
        return stateData[id];
    }
    function _createDeserializeContainer(stateData, element) {
        // eslint-disable-next-line prefer-const
        let state;
        const container = {
            $getObjectById$: (id) => getObjectById(id, state),
            getSyncFn: (_) => {
                const fn = () => { };
                return fn;
            },
            $storeProxyMap$: new WeakMap(),
            element: null,
            $forwardRefs$: null,
            $scheduler$: null,
        };
        preprocessState(stateData, container);
        state = wrapDeserializerProxy(container, stateData);
        container.$state$ = state;
        if (element) {
            container.element = element;
        }
        return container;
    }

    /** @internal */
    const verifySerializable = (value, preMessage) => {
        const seen = new WeakSet();
        return untrack(() => _verifySerializable(value, seen, '_', preMessage));
    };
    const _verifySerializable = (value, seen, ctx, preMessage) => {
        const unwrapped = unwrapStore(value);
        if (unwrapped == null) {
            return value;
        }
        if (shouldSerialize(unwrapped)) {
            if (typeof unwrapped === 'object') {
                if (seen.has(unwrapped)) {
                    return value;
                }
                seen.add(unwrapped);
            }
            if (isSignal(unwrapped)) {
                return value;
            }
            if (canSerialize(unwrapped)) {
                return value;
            }
            const typeObj = typeof unwrapped;
            switch (typeObj) {
                case 'object':
                    if (isPromise(unwrapped)) {
                        return value;
                    }
                    if (isNode(unwrapped)) {
                        return value;
                    }
                    if (isArray(unwrapped)) {
                        let expectIndex = 0;
                        // Make sure the array has no holes
                        unwrapped.forEach((v, i) => {
                            if (i !== expectIndex) {
                                throw qError(3 /* QError.verifySerializable */, [unwrapped]);
                            }
                            _verifySerializable(v, seen, ctx + '[' + i + ']');
                            expectIndex = i + 1;
                        });
                        return value;
                    }
                    if (isSerializableObject(unwrapped)) {
                        for (const [key, item] of Object.entries(unwrapped)) {
                            _verifySerializable(item, seen, ctx + '.' + key);
                        }
                        return value;
                    }
                    break;
            }
            let message;
            if (preMessage) {
                message = preMessage;
            }
            else {
                message = 'Value cannot be serialized';
            }
            if (ctx !== '_') {
                message += ` in ${ctx},`;
            }
            if (typeObj === 'object') {
                message += ` because it's an instance of "${value?.constructor.name}". You might need to use 'noSerialize()' or use an object literal instead. Check out https://qwik.dev/docs/advanced/dollar/`;
            }
            else if (typeObj === 'function') {
                const fnName = value.name;
                message += ` because it's a function named "${fnName}". You might need to convert it to a QRL using $(fn):\n\nconst ${fnName} = $(${String(value)});\n\nPlease check out https://qwik.dev/docs/advanced/qrl/ for more information.`;
            }
            throw qError(3 /* QError.verifySerializable */, [message]);
        }
        return value;
    };
    const noSerializeSet = /*#__PURE__*/ new WeakSet();
    const shouldSerialize = (obj) => {
        if (isObject(obj) || isFunction(obj)) {
            return !noSerializeSet.has(obj) && !(NoSerializeSymbol in obj);
        }
        return true;
    };
    const fastSkipSerialize = (obj) => {
        return (!!obj &&
            (isObject(obj) || typeof obj === 'function') &&
            (NoSerializeSymbol in obj || noSerializeSet.has(obj)));
    };
    // <docs markdown="../../readme.md#noSerialize">
    // !!DO NOT EDIT THIS COMMENT DIRECTLY!!!
    // (edit ../../readme.md#noSerialize instead and run `pnpm docs.sync`)
    /**
     * Marks a property on a store as non-serializable.
     *
     * At times it is necessary to store values on a store that are non-serializable. Normally this is a
     * runtime error as Store wants to eagerly report when a non-serializable property is assigned to
     * it.
     *
     * You can use `noSerialize()` to mark a value as non-serializable. The value is persisted in the
     * Store but does not survive serialization. The implication is that when your application is
     * resumed, the value of this object will be `undefined`. You will be responsible for recovering
     * from this.
     *
     * See: [noSerialize Tutorial](http://qwik.dev/tutorial/store/no-serialize)
     *
     * @public
     */
    // </docs>
    const noSerialize = (input) => {
        // only add supported values to the noSerializeSet, prevent console errors
        if ((isObject(input) && input !== null) || typeof input === 'function') {
            noSerializeSet.add(input);
        }
        return input;
    };
    /**
     * If an object has this property, it will not be serialized. Use this on prototypes to avoid having
     * to call `noSerialize()` on every object.
     *
     * @public
     */
    const NoSerializeSymbol = Symbol('noSerialize');
    /**
     * If an object has this property as a function, it will be called with the object and should return
     * a serializable value.
     *
     * This can be used to clean up, integrate with other libraries, etc.
     *
     * The type your object should conform to is:
     *
     * ```ts
     * {
     *   [SerializerSymbol]: (this: YourType, toSerialize: YourType) => YourSerializableType;
     * }
     * ```
     *
     * @public
     */
    const SerializerSymbol = Symbol('serialize');

    // keep these imports above the rest to prevent circular dep issues
    const resolvedSymbol = Symbol('resolved');
    const createQRL = (chunk, symbol, symbolRef, symbolFn, capture, captureRef) => {
        if (qDev && qSerialize) {
            if (captureRef) {
                for (const item of captureRef) {
                    verifySerializable(item, 'Captured variable in the closure can not be serialized');
                }
            }
        }
        let _containerEl;
        const qrl = async function (...args) {
            const boundedFn = bindFnToContext.call(this, tryGetInvokeContext());
            const result = await boundedFn(...args);
            return result;
        };
        const setContainer = (el) => {
            if (!_containerEl) {
                _containerEl = el;
            }
            return _containerEl;
        };
        function bindFnToContext(currentCtx, beforeFn) {
            // Note that we bind the current `this`
            const bound = (...args) => {
                if (!qrl.resolved) {
                    return qrl.resolve().then((fn) => {
                        if (!isFunction(fn)) {
                            throw qError(5 /* QError.qrlIsNotFunction */);
                        }
                        return bound(...args);
                    });
                }
                if (beforeFn && beforeFn() === false) {
                    return;
                }
                const context = createOrReuseInvocationContext(currentCtx);
                const prevQrl = context.$qrl$;
                const prevEvent = context.$event$;
                // Note that we set the qrl here instead of in wrapFn because
                // it is possible we're called on a copied qrl
                context.$qrl$ = qrl;
                context.$event$ ||= this;
                try {
                    return invoke.call(this, context, symbolRef, ...args);
                }
                finally {
                    context.$qrl$ = prevQrl;
                    context.$event$ = prevEvent;
                }
            };
            return bound;
        }
        // Wrap functions to provide their lexical scope
        const wrapFn = (fn) => {
            if (typeof fn !== 'function' || (!capture?.length && !captureRef?.length)) {
                return fn;
            }
            return function (...args) {
                let context = tryGetInvokeContext();
                // use the given qrl if it is the right one
                if (context) {
                    // TODO check if this is necessary in production
                    if (context.$qrl$?.$symbol$ === qrl.$symbol$) {
                        return fn.apply(this, args);
                    }
                    const prevQrl = context.$qrl$;
                    context.$qrl$ = qrl;
                    try {
                        return fn.apply(this, args);
                    }
                    finally {
                        context.$qrl$ = prevQrl;
                    }
                }
                context = newInvokeContext();
                context.$qrl$ = qrl;
                context.$event$ = this;
                return invoke.call(this, context, fn, ...args);
            };
        };
        // Retrieve memoized result from symbolFn
        if (symbolFn && resolvedSymbol in symbolFn) {
            symbolRef = symbolFn[resolvedSymbol];
        }
        const resolve = symbolRef
            ? async () => symbolRef
            : async (containerEl) => {
                if (symbolRef !== null) {
                    // Resolving (Promise) or already resolved (value)
                    return symbolRef;
                }
                if (containerEl) {
                    setContainer(containerEl);
                }
                if (chunk === '') {
                    // Sync QRL
                    assertDefined(_containerEl, 'Sync QRL must have container element');
                    const hash = _containerEl.getAttribute(QInstanceAttr);
                    const doc = _containerEl.ownerDocument;
                    const qFuncs = getQFuncs(doc, hash);
                    // No need to wrap, syncQRLs can't have captured scope
                    return (qrl.resolved = symbolRef = qFuncs[Number(symbol)]);
                }
                if (build.isBrowser && chunk) {
                    /** We run the QRL, so now the probability of the chunk is 100% */
                    preloader.p(chunk, 1);
                }
                const start = now();
                const ctx = tryGetInvokeContext();
                if (symbolFn !== null) {
                    symbolRef = symbolFn().then((module) => {
                        const resolved = wrapFn((symbolRef = module[symbol]));
                        // We memoize the result on the symbolFn
                        symbolFn[resolvedSymbol] = resolved;
                        qrl.resolved = resolved;
                        return resolved;
                    });
                }
                else {
                    // TODO cache the imported symbol but watch out for dev mode
                    const imported = getPlatform().importSymbol(_containerEl, chunk, symbol);
                    symbolRef = maybeThen(imported, (ref) => (qrl.resolved = wrapFn((symbolRef = ref))));
                }
                if (isPromise(symbolRef)) {
                    symbolRef.then(() => emitUsedSymbol(symbol, ctx?.$element$, start), (err) => {
                        console.error(`qrl ${symbol} failed to load`, err);
                        // We shouldn't cache rejections, we can try again later
                        symbolRef = null;
                    });
                }
                return symbolRef;
            };
        const createOrReuseInvocationContext = (invoke) => {
            if (invoke == null) {
                return newInvokeContext();
            }
            else if (isArray(invoke)) {
                return newInvokeContextFromTuple(invoke);
            }
            else {
                return invoke;
            }
        };
        const hash = getSymbolHash(symbol);
        Object.assign(qrl, {
            getSymbol: () => symbol,
            getHash: () => hash,
            // captureRef is replaced during deserialization
            getCaptured: () => qrl.$captureRef$,
            resolve,
            $setContainer$: setContainer,
            $chunk$: chunk,
            $symbol$: symbol,
            $hash$: hash,
            getFn: bindFnToContext,
            $capture$: capture,
            $captureRef$: captureRef,
            dev: null,
            resolved: undefined,
        });
        if (symbolRef) {
            // Unwrap any promises
            symbolRef = maybeThen(symbolRef, (resolved) => (qrl.resolved = wrapFn((symbolRef = resolved))));
        }
        if (qDev) {
            seal(qrl);
        }
        if (build.isBrowser && symbol) {
            /**
             * Preloading the symbol instead of the chunk allows us to get probabilities for the bundle
             * based on its contents.
             */
            preloader.p(symbol, 0.8);
        }
        return qrl;
    };
    const EMITTED = /*#__PURE__*/ new Set();
    const emitUsedSymbol = (symbol, element, reqTime) => {
        if (!EMITTED.has(symbol)) {
            EMITTED.add(symbol);
            emitEvent('qsymbol', {
                symbol,
                element,
                reqTime,
            });
        }
    };
    const emitEvent = (eventName, detail) => {
        if (!qTest && !isServerPlatform() && typeof document === 'object') {
            document.dispatchEvent(new CustomEvent(eventName, {
                bubbles: false,
                detail,
            }));
        }
    };
    const now = () => {
        if (qTest || isServerPlatform()) {
            return 0;
        }
        if (typeof performance === 'object') {
            return performance.now();
        }
        return 0;
    };

    let runtimeSymbolId = 0;
    // <docs markdown="../../readme.md#$">
    // !!DO NOT EDIT THIS COMMENT DIRECTLY!!!
    // (edit ../../readme.md#$ instead and run `pnpm docs.sync`)
    /**
     * Qwik Optimizer marker function.
     *
     * Use `$(...)` to tell Qwik Optimizer to extract the expression in `$(...)` into a lazy-loadable
     * resource referenced by `QRL`.
     *
     * @param expression - Expression which should be lazy loaded
     * @public
     * @see `implicit$FirstArg` for additional `____$(...)` rules.
     *
     * In this example, `$(...)` is used to capture the callback function of `onmousemove` into a
     * lazy-loadable reference. This allows the code to refer to the function without actually
     * loading the function. In this example, the callback function does not get loaded until
     * `mousemove` event fires.
     *
     * ```tsx
     * useOnDocument(
     *   'mousemove',
     *   $((event) => console.log('mousemove', event))
     * );
     * ```
     *
     * In this code, the Qwik Optimizer detects `$(...)` and transforms the code into:
     *
     * ```tsx
     * // FILE: <current file>
     * useOnDocument('mousemove', qrl('./chunk-abc.js', 'onMousemove'));
     *
     * // FILE: chunk-abc.js
     * export const onMousemove = () => console.log('mousemove');
     * ```
     *
     * ## Special Rules
     *
     * The Qwik Optimizer places special rules on functions that can be lazy-loaded.
     *
     * 1. The expression of the `$(expression)` function must be importable by the system.
     * (expression shows up in `import` or has `export`)
     * 2. If inlined function, then all lexically captured values must be:
     *    - importable (vars show up in `import`s or `export`s)
     *    - const (The capturing process differs from JS capturing in that writing to captured
     * variables does not update them, and therefore writes are forbidden. The best practice is that
     * all captured variables are constants.)
     *    - Must be runtime serializable.
     *
     * ```tsx
     *
     * import { createContextId, useContext, useContextProvider } from './use/use-context';
     * import { Resource } from './use/use-resource';
     * import { useResource$ } from './use/use-resource-dollar';
     * import { useSignal } from './use/use-signal';
     *
     * export const greet = () => console.log('greet');
     * function topLevelFn() {}
     *
     * function myCode() {
     *   const store = useStore({});
     *   function localFn() {}
     *   // Valid Examples
     *   $(greet); // greet is importable
     *   $(() => greet()); // greet is importable;
     *   $(() => console.log(store)); // store is serializable.
     *
     *   // Compile time errors
     *   $(topLevelFn); // ERROR: `topLevelFn` not importable
     *   $(() => topLevelFn()); // ERROR: `topLevelFn` not importable
     *
     *   // Runtime errors
     *   $(localFn); // ERROR: `localFn` fails serialization
     *   $(() => localFn()); // ERROR: `localFn` fails serialization
     * }
     *
     * ```
     */
    // </docs>
    const $ = (expression) => {
        if (!qRuntimeQrl && qDev) {
            throw new Error('Optimizer should replace all usages of $() with some special syntax. If you need to create a QRL manually, use inlinedQrl() instead.');
        }
        return createQRL(null, 's' + runtimeSymbolId++, expression, null, null, null);
    };
    /** @private Use To avoid optimizer replacement */
    const dollar = $;
    /** @internal */
    const eventQrl = (qrl) => {
        return qrl;
    };
    /**
     * Extract function into a synchronously loadable QRL.
     *
     * NOTE: Synchronous QRLs functions can't close over any variables, including exports.
     *
     * @param fn - Function to extract.
     * @returns
     * @public
     */
    const sync$ = (fn) => {
        if (!qRuntimeQrl && qDev) {
            throw new Error('Optimizer should replace all usages of sync$() with some special syntax. If you need to create a QRL manually, use inlinedSyncQrl() instead.');
        }
        if (qDev) {
            // To make sure that in dev mode we don't accidentally capture context in `sync$()` we serialize and deserialize the function.
            // eslint-disable-next-line no-new-func
            fn = new Function('return ' + fn.toString())();
        }
        return createQRL('', SYNC_QRL, fn, null, null, null);
    };
    /**
     * Extract function into a synchronously loadable QRL.
     *
     * NOTE: Synchronous QRLs functions can't close over any variables, including exports.
     *
     * @param fn - Extracted function
     * @param serializedFn - Serialized function in string form.
     * @returns
     * @internal
     */
    const _qrlSync = function (fn, serializedFn) {
        if (serializedFn === undefined) {
            serializedFn = fn.toString();
        }
        fn.serialized = serializedFn;
        return createQRL('', SYNC_QRL, fn, null, null, null);
    };

    /** @internal */
    const componentQrl = (componentQrl) => {
        // Return a QComponent Factory function.
        function QwikComponent(props, key, flags = 0) {
            assertQrl(componentQrl);
            assertNumber(flags, 'The Qwik Component was not invoked correctly');
            const hash = qTest ? 'sX' : componentQrl.$hash$.slice(0, 4);
            const finalKey = hash + ':' + (key ? key : '');
            const InnerCmp = () => { };
            InnerCmp[SERIALIZABLE_STATE] = [componentQrl];
            return _jsxSplit(InnerCmp, props, null, props.children, flags, finalKey);
        }
        QwikComponent[SERIALIZABLE_STATE] = [componentQrl];
        return QwikComponent;
    };
    const SERIALIZABLE_STATE = Symbol('serializable-data');
    const isQwikComponent = (component) => {
        return typeof component == 'function' && component[SERIALIZABLE_STATE] !== undefined;
    };
    // <docs markdown="../readme.md#component">
    // !!DO NOT EDIT THIS COMMENT DIRECTLY!!!
    // (edit ../readme.md#component instead and run `pnpm docs.sync`)
    /**
     * Declare a Qwik component that can be used to create UI.
     *
     * Use `component$` to declare a Qwik component. A Qwik component is a special kind of component
     * that allows the Qwik framework to lazy load and execute the component independently of other Qwik
     * components as well as lazy load the component's life-cycle hooks and event handlers.
     *
     * Side note: You can also declare regular (standard JSX) components that will have standard
     * synchronous behavior.
     *
     * Qwik component is a facade that describes how the component should be used without forcing the
     * implementation of the component to be eagerly loaded. A minimum Qwik definition consists of:
     *
     * ### Example
     *
     * An example showing how to create a counter component:
     *
     * ```tsx
     * export interface CounterProps {
     *   initialValue?: number;
     *   step?: number;
     * }
     * export const Counter = component$((props: CounterProps) => {
     *   const state = useStore({ count: props.initialValue || 0 });
     *   return (
     *     <div>
     *       <span>{state.count}</span>
     *       <button onClick$={() => (state.count += props.step || 1)}>+</button>
     *     </div>
     *   );
     * });
     * ```
     *
     * - `component$` is how a component gets declared.
     * - `{ value?: number; step?: number }` declares the public (props) interface of the component.
     * - `{ count: number }` declares the private (state) interface of the component.
     *
     * The above can then be used like so:
     *
     * ```tsx
     * export const OtherComponent = component$(() => {
     *   return <Counter initialValue={100} />;
     * });
     * ```
     *
     * See also: `component`, `useCleanup`, `onResume`, `onPause`, `useOn`, `useOnDocument`,
     * `useOnWindow`, `useStyles`
     *
     * @public
     */
    // </docs>
    const component$ = (onMount) => {
        return componentQrl(dollar(onMount));
    };

    /** @public */
    const event$ = implicit$FirstArg(eventQrl);

    /**
     * Render JSX.
     *
     * Use this method to render JSX. This function does reconciling which means it always tries to
     * reuse what is already in the DOM (rather then destroy and recreate content.) It returns a cleanup
     * function you could use for cleaning up subscriptions.
     *
     * @param parent - Element which will act as a parent to `jsxNode`. When possible the rendering will
     *   try to reuse existing nodes.
     * @param jsxNode - JSX to render
     * @returns An object containing a cleanup function.
     * @public
     */
    const render = async (parent, jsxNode, opts = {}) => {
        if (isDocument(parent)) {
            let child = parent.firstChild;
            while (child && !isElement$1(child)) {
                child = child.nextSibling;
            }
            parent = child;
        }
        if (qDev && parent.hasAttribute(QContainerAttr)) {
            throw qError(4 /* QError.cannotRenderOverExistingContainer */, [parent]);
        }
        parent.setAttribute(QContainerAttr, "resumed" /* QContainerValue.RESUMED */);
        const container = getDomContainer(parent);
        container.$serverData$ = opts.serverData || {};
        const host = container.rootVNode;
        container.$scheduler$(4 /* ChoreType.NODE_DIFF */, host, host, jsxNode);
        await container.$scheduler$(255 /* ChoreType.WAIT_FOR_QUEUE */).$returnValue$;
        return {
            cleanup: () => {
                cleanup(container, container.rootVNode);
            },
        };
    };

    // <docs markdown="../readme.md#useStore">
    // !!DO NOT EDIT THIS COMMENT DIRECTLY!!!
    // (edit ../readme.md#useStore instead and run `pnpm docs.sync`)
    /**
     * Creates an object that Qwik can track across serializations.
     *
     * Use `useStore` to create a state for your application. The returned object is a proxy that has a
     * unique ID. The ID of the object is used in the `QRL`s to refer to the store.
     *
     * ### Example
     *
     * Example showing how `useStore` is used in Counter example to keep track of the count.
     *
     * ```tsx
     * const Stores = component$(() => {
     *   const counter = useCounter(1);
     *
     *   // Reactivity happens even for nested objects and arrays
     *   const userData = useStore({
     *     name: 'Manu',
     *     address: {
     *       address: '',
     *       city: '',
     *     },
     *     orgs: [],
     *   });
     *
     *   // useStore() can also accept a function to calculate the initial value
     *   const state = useStore(() => {
     *     return {
     *       value: expensiveInitialValue(),
     *     };
     *   });
     *
     *   return (
     *     <div>
     *       <div>Counter: {counter.value}</div>
     *       <Child userData={userData} state={state} />
     *     </div>
     *   );
     * });
     *
     * function useCounter(step: number) {
     *   // Multiple stores can be created in custom hooks for convenience and composability
     *   const counterStore = useStore({
     *     value: 0,
     *   });
     *   useVisibleTask$(() => {
     *     // Only runs in the client
     *     const timer = setInterval(() => {
     *       counterStore.value += step;
     *     }, 500);
     *     return () => {
     *       clearInterval(timer);
     *     };
     *   });
     *   return counterStore;
     * }
     * ```
     *
     * @public
     */
    // </docs>
    const useStore = (initialState, opts) => {
        const { val, set, iCtx } = useSequentialScope();
        if (val != null) {
            return val;
        }
        const value = isFunction(initialState) ? invoke(undefined, initialState) : initialState;
        if (opts?.reactive === false) {
            set(value);
            return value;
        }
        else {
            const containerState = iCtx.$container$;
            const recursive = opts?.deep ?? true;
            const flags = recursive ? 1 /* StoreFlags.RECURSIVE */ : 0 /* StoreFlags.NONE */;
            const newStore = getOrCreateStore(value, flags, containerState);
            set(newStore);
            return newStore;
        }
    };

    const intToStr = (nu) => {
        return nu.toString(36);
    };
    const getNextUniqueIndex = (container) => {
        return intToStr(container.$currentUniqueId$++);
    };

    /** @public */
    const useId = () => {
        const { val, set, iCtx } = useSequentialScope();
        if (val != null) {
            return val;
        }
        const containerBase = iCtx.$container$.$buildBase$ || '';
        const base = containerBase ? hashCode(containerBase).substring(0, 3) : '';
        const componentQrl = iCtx.$container$.getHostProp(iCtx.$hostElement$, OnRenderProp);
        const hash = componentQrl?.getHash().substring(0, 3) || '';
        const counter = getNextUniqueIndex(iCtx.$container$) || '';
        let id = `${base}${hash}${counter}`;
        let firstChar = id.charCodeAt(0);
        // convert first char to letter if starts with a number, because CSS does not allow class names to start with a number
        if (firstChar >= 48 /* 0 */ && firstChar <= 57 /* 9 */) {
            // 48 is char code for '0', 65 is char code for 'A'
            // 65 - 48 = 17, so we add 17 to the char code of the first char to convert it to a letter
            firstChar += 17;
            id = String.fromCharCode(firstChar) + id.substring(1);
        }
        return set(id);
    };

    /** @public */
    function useServerData(key, defaultValue) {
        const ctx = tryGetInvokeContext();
        return ctx?.$container$?.$serverData$[key] ?? defaultValue;
    }

    /* eslint-disable no-console */
    const STYLE_CACHE = /*#__PURE__*/ new Map();
    const getScopedStyles = (css, scopeId) => {
        if (qDev) {
            return scopeStylesheet(css, scopeId);
        }
        let styleCss = STYLE_CACHE.get(scopeId);
        if (!styleCss) {
            STYLE_CACHE.set(scopeId, (styleCss = scopeStylesheet(css, scopeId)));
        }
        return styleCss;
    };
    const scopeStylesheet = (css, scopeId) => {
        const end = css.length;
        const out = [];
        const stack = [];
        let idx = 0;
        let lastIdx = idx;
        let mode = rule;
        let lastCh = 0;
        while (idx < end) {
            const chIdx = idx;
            let ch = css.charCodeAt(idx++);
            if (ch === BACKSLASH) {
                idx++;
                ch = A; // Pretend it's a letter
            }
            const arcs = STATE_MACHINE[mode];
            for (let i = 0; i < arcs.length; i++) {
                const arc = arcs[i];
                const [expectLastCh, expectCh, newMode] = arc;
                if (expectLastCh === lastCh ||
                    expectLastCh === ANY ||
                    (expectLastCh === IDENT && isIdent(lastCh)) ||
                    (expectLastCh === WHITESPACE && isWhiteSpace(lastCh))) {
                    if (expectCh === ch ||
                        expectCh === ANY ||
                        (expectCh === IDENT && isIdent(ch)) ||
                        (expectCh === NOT_IDENT && !isIdent(ch) && ch !== DOT) ||
                        (expectCh === WHITESPACE && isWhiteSpace(ch))) {
                        if (arc.length == 3 || lookAhead(arc)) {
                            if (arc.length > 3) {
                                // If matched on lookAhead than we we have to update current `ch`
                                ch = css.charCodeAt(idx - 1);
                            }
                            // We found a match!
                            if (newMode === EXIT || newMode == EXIT_INSERT_SCOPE) {
                                if (newMode === EXIT_INSERT_SCOPE) {
                                    if (mode === starSelector && !shouldNotInsertScoping()) {
                                        // Replace `*` with the scoping elementClassIdSelector.
                                        if (isChainedSelector(ch)) {
                                            // *foo
                                            flush(idx - 2);
                                        }
                                        else {
                                            // * (by itself)
                                            insertScopingSelector(idx - 2);
                                        }
                                        lastIdx++;
                                    }
                                    else {
                                        if (!isChainedSelector(ch)) {
                                            // We are exiting one of the Selector so we may need to
                                            const offset = expectCh == NOT_IDENT ? 1 : expectCh == CLOSE_PARENTHESIS ? 2 : 0;
                                            insertScopingSelector(idx - offset);
                                        }
                                    }
                                }
                                if (expectCh === NOT_IDENT) {
                                    // NOT_IDENT is not a real character more like lack of what we expected.
                                    // if pseudoGlobal we need to give it a chance to exit as well.
                                    // For this reason we need to reparse the last character again.
                                    idx--;
                                    ch = lastCh;
                                }
                                do {
                                    mode = stack.pop() || rule;
                                    if (mode === pseudoGlobal) {
                                        // Skip over the `)` in `:global(...)`.
                                        flush(idx - 1);
                                        lastIdx++;
                                    }
                                } while (isSelfClosingRule(mode));
                            }
                            else {
                                stack.push(mode);
                                if (mode === pseudoGlobal && newMode === rule) {
                                    flush(idx - 8); // `:global(`.length
                                    lastIdx = idx; // skip over ":global("
                                }
                                else if (newMode === pseudoElement) {
                                    // We are entering pseudoElement `::foo`; insert scoping in front of it.
                                    insertScopingSelector(chIdx);
                                }
                                mode = newMode;
                            }
                            break; // get out of the for loop as we found a match
                        }
                    }
                }
            }
            lastCh = ch;
        }
        flush(idx);
        return out.join('');
        function flush(idx) {
            out.push(css.substring(lastIdx, idx));
            lastIdx = idx;
        }
        function insertScopingSelector(idx) {
            if (mode === pseudoGlobal || shouldNotInsertScoping()) {
                return;
            }
            flush(idx);
            out.push('.', ComponentStylesPrefixContent, scopeId);
        }
        function lookAhead(arc) {
            let prefix = 0; // Ignore vendor prefixes such as `-webkit-`.
            if (css.charCodeAt(idx) === DASH) {
                for (let i = 1; i < 10; i++) {
                    // give up after 10 characters
                    if (css.charCodeAt(idx + i) === DASH) {
                        prefix = i + 1;
                        break;
                    }
                }
            }
            words: for (let arcIndx = 3; arcIndx < arc.length; arcIndx++) {
                const txt = arc[arcIndx];
                for (let i = 0; i < txt.length; i++) {
                    if ((css.charCodeAt(idx + i + prefix) | LOWERCASE) !== txt.charCodeAt(i)) {
                        continue words;
                    }
                }
                // we found a match;
                idx += txt.length + prefix;
                return true;
            }
            return false;
        }
        function shouldNotInsertScoping() {
            return stack.indexOf(pseudoGlobal) !== -1 || stack.indexOf(atRuleSelector) !== -1;
        }
    };
    const isIdent = (ch) => {
        return ((ch >= _0 && ch <= _9) ||
            (ch >= A && ch <= Z) ||
            (ch >= a && ch <= z) ||
            ch >= 0x80 ||
            ch === UNDERSCORE ||
            ch === DASH);
    };
    const isChainedSelector = (ch) => {
        return ch === COLON || ch === DOT || ch === OPEN_BRACKET || ch === HASH || isIdent(ch);
    };
    const isSelfClosingRule = (mode) => {
        return (mode === atRuleBlock || mode === atRuleSelector || mode === atRuleInert || mode === pseudoGlobal);
    };
    const isWhiteSpace = (ch) => {
        return ch === SPACE || ch === TAB || ch === NEWLINE || ch === CARRIAGE_RETURN;
    };
    const rule = 0; // top level initial space.
    const elementClassIdSelector = 1; // .elementClassIdSelector {}
    const starSelector = 2; // * {}
    const pseudoClassWithSelector = 3; // :pseudoClass(elementClassIdSelector) {}
    const pseudoClass = 4; // :pseudoClass {}
    const pseudoGlobal = 5; // :global(elementClassIdSelector)
    const pseudoElement = 6; // ::pseudoElement {}
    const attrSelector = 7; // [attr] {}
    const inertParenthesis = 8; // (ignored)
    const inertBlock = 9; // {ignored}
    const atRuleSelector = 10; // @keyframe elementClassIdSelector {}
    const atRuleBlock = 11; // @media {elementClassIdSelector {}}
    const atRuleInert = 12; // @atRule something;
    const body = 13; // .elementClassIdSelector {body}
    const stringSingle = 14; // 'text'
    const stringDouble = 15; // 'text'
    const commentMultiline = 16; // /* ... */
    // NOT REAL MODES
    const EXIT = 17; // Exit the mode
    const EXIT_INSERT_SCOPE = 18; // Exit the mode INSERT SCOPE
    const ANY = 0;
    const IDENT = 1;
    const NOT_IDENT = 2;
    const WHITESPACE = 3;
    const TAB = 9; // `\t`.charCodeAt(0);
    const NEWLINE = 10; // `\n`.charCodeAt(0);
    const CARRIAGE_RETURN = 13; // `\r`.charCodeAt(0);
    const SPACE = 32; // ` `.charCodeAt(0);
    const DOUBLE_QUOTE = 34; // `"`.charCodeAt(0);
    const HASH = 35; // `#`.charCodeAt(0);
    const SINGLE_QUOTE = 39; // `'`.charCodeAt(0);
    const OPEN_PARENTHESIS = 40; // `(`.charCodeAt(0);
    const CLOSE_PARENTHESIS = 41; // `)`.charCodeAt(0);
    const STAR = 42; // `*`.charCodeAt(0);
    // const COMMA = 44; // `,`.charCodeAt(0);
    const DASH = 45; // `-`.charCodeAt(0);
    const DOT = 46; // `.`.charCodeAt(0);
    const FORWARD_SLASH = 47; // `/`.charCodeAt(0);
    const _0 = 48; // `0`.charCodeAt(0);
    const _9 = 57; // `9`.charCodeAt(0);
    const COLON = 58; // `:`.charCodeAt(0);
    const SEMICOLON = 59; // `;`.charCodeAt(0);
    // const LESS_THAN = 60; // `<`.charCodeAt(0);
    const AT = 64; // `@`.charCodeAt(0);
    const A = 65; // `A`.charCodeAt(0);
    const Z = 90; // `Z`.charCodeAt(0);
    const OPEN_BRACKET = 91; // `[`.charCodeAt(0);
    const CLOSE_BRACKET = 93; // `]`.charCodeAt(0);
    const BACKSLASH = 92; // `\\`.charCodeAt(0);
    const UNDERSCORE = 95; // `_`.charCodeAt(0);
    const LOWERCASE = 0x20; // `a`.charCodeAt(0);
    const a = 97; // `a`.charCodeAt(0);
    // const d = 100; // `d`.charCodeAt(0);
    // const g = 103; // 'g'.charCodeAt(0);
    // const h = 104; // `h`.charCodeAt(0);
    // const i = 105; // `i`.charCodeAt(0);
    // const l = 108; // `l`.charCodeAt(0);
    // const t = 116; // `t`.charCodeAt(0);
    const z = 122; // `z`.charCodeAt(0);
    const OPEN_BRACE = 123; // `{`.charCodeAt(0);
    const CLOSE_BRACE = 125; // `}`.charCodeAt(0);
    const STRINGS_COMMENTS = /*__PURE__*/ (() => [
        [ANY, SINGLE_QUOTE, stringSingle],
        [ANY, DOUBLE_QUOTE, stringDouble],
        [ANY, FORWARD_SLASH, commentMultiline, '*'],
    ])();
    const STATE_MACHINE = /*__PURE__*/ (() => [
        [
            /// rule
            [ANY, STAR, starSelector],
            [ANY, OPEN_BRACKET, attrSelector],
            [ANY, COLON, pseudoElement, ':', 'before', 'after', 'first-letter', 'first-line'],
            [ANY, COLON, pseudoGlobal, 'global'],
            [
                ANY,
                COLON,
                pseudoClassWithSelector,
                'has',
                'host-context',
                'not',
                'where',
                'is',
                'matches',
                'any',
            ],
            [ANY, COLON, pseudoClass],
            [ANY, IDENT, elementClassIdSelector],
            [ANY, DOT, elementClassIdSelector],
            [ANY, HASH, elementClassIdSelector],
            [ANY, AT, atRuleSelector, 'keyframe'],
            [ANY, AT, atRuleBlock, 'media', 'supports', 'container'],
            [ANY, AT, atRuleInert],
            [ANY, OPEN_BRACE, body],
            [FORWARD_SLASH, STAR, commentMultiline],
            [ANY, SEMICOLON, EXIT],
            [ANY, CLOSE_BRACE, EXIT],
            [ANY, CLOSE_PARENTHESIS, EXIT],
            ...STRINGS_COMMENTS,
        ],
        [
            /// elementClassIdSelector
            [ANY, NOT_IDENT, EXIT_INSERT_SCOPE],
        ],
        [
            /// starSelector
            [ANY, NOT_IDENT, EXIT_INSERT_SCOPE],
        ],
        [
            /// pseudoClassWithSelector
            [ANY, OPEN_PARENTHESIS, rule],
            [ANY, NOT_IDENT, EXIT_INSERT_SCOPE],
        ],
        [
            /// pseudoClass
            [ANY, OPEN_PARENTHESIS, inertParenthesis],
            [ANY, NOT_IDENT, EXIT_INSERT_SCOPE],
        ],
        [
            /// pseudoGlobal
            [ANY, OPEN_PARENTHESIS, rule],
            [ANY, NOT_IDENT, EXIT],
        ],
        [
            /// pseudoElement
            [ANY, NOT_IDENT, EXIT],
        ],
        [
            /// attrSelector
            [ANY, CLOSE_BRACKET, EXIT_INSERT_SCOPE],
            [ANY, SINGLE_QUOTE, stringSingle],
            [ANY, DOUBLE_QUOTE, stringDouble],
        ],
        [
            /// inertParenthesis
            [ANY, CLOSE_PARENTHESIS, EXIT],
            ...STRINGS_COMMENTS,
        ],
        [
            /// inertBlock
            [ANY, CLOSE_BRACE, EXIT],
            ...STRINGS_COMMENTS,
        ],
        [
            /// atRuleSelector
            [ANY, CLOSE_BRACE, EXIT],
            [WHITESPACE, IDENT, elementClassIdSelector],
            [ANY, COLON, pseudoGlobal, 'global'],
            [ANY, OPEN_BRACE, body],
            ...STRINGS_COMMENTS,
        ],
        [
            /// atRuleBlock
            [ANY, OPEN_BRACE, rule],
            [ANY, SEMICOLON, EXIT],
            ...STRINGS_COMMENTS,
        ],
        [
            /// atRuleInert
            [ANY, SEMICOLON, EXIT],
            [ANY, OPEN_BRACE, inertBlock],
            ...STRINGS_COMMENTS,
        ],
        [
            /// body
            [ANY, CLOSE_BRACE, EXIT],
            [ANY, OPEN_BRACE, body],
            [ANY, OPEN_PARENTHESIS, inertParenthesis],
            ...STRINGS_COMMENTS,
        ],
        [
            /// stringSingle
            [ANY, SINGLE_QUOTE, EXIT],
        ],
        [
            /// stringDouble
            [ANY, DOUBLE_QUOTE, EXIT],
        ],
        [
            /// commentMultiline
            [STAR, FORWARD_SLASH, EXIT],
        ],
    ])();

    /** @internal */
    const useStylesQrl = (styles) => {
        return {
            styleId: _useStyles(styles, (str) => str, false),
        };
    };
    // <docs markdown="../readme.md#useStyles">
    // !!DO NOT EDIT THIS COMMENT DIRECTLY!!!
    // (edit ../readme.md#useStyles instead and run `pnpm docs.sync`)
    /**
     * A lazy-loadable reference to a component's styles.
     *
     * Component styles allow Qwik to lazy load the style information for the component only when
     * needed. (And avoid double loading it in case of SSR hydration.)
     *
     * ```tsx
     * import styles from './code-block.css?inline';
     *
     * export const CmpStyles = component$(() => {
     *   useStyles$(styles);
     *
     *   return <div>Some text</div>;
     * });
     * ```
     *
     * @public
     * @see `useStylesScoped`
     */
    // </docs>
    const useStyles$ = /*#__PURE__*/ implicit$FirstArg(useStylesQrl);
    /** @internal */
    const useStylesScopedQrl = (styles) => {
        return {
            scopeId: ComponentStylesPrefixContent + _useStyles(styles, getScopedStyles, true),
        };
    };
    // <docs markdown="../readme.md#useStylesScoped">
    // !!DO NOT EDIT THIS COMMENT DIRECTLY!!!
    // (edit ../readme.md#useStylesScoped instead and run `pnpm docs.sync`)
    /**
     * A lazy-loadable reference to a component's styles, that is scoped to the component.
     *
     * Component styles allow Qwik to lazy load the style information for the component only when
     * needed. (And avoid double loading it in case of SSR hydration.)
     *
     * ```tsx
     * import scoped from './code-block.css?inline';
     *
     * export const CmpScopedStyles = component$(() => {
     *   useStylesScoped$(scoped);
     *
     *   return <div>Some text</div>;
     * });
     * ```
     *
     * @public
     * @see `useStyles`
     */
    // </docs>
    const useStylesScoped$ = /*#__PURE__*/ implicit$FirstArg(useStylesScopedQrl);
    const _useStyles = (styleQrl, transform, scoped) => {
        assertQrl(styleQrl);
        const { val, set, iCtx, i } = useSequentialScope();
        if (val) {
            return val;
        }
        const styleId = styleKey(styleQrl, i);
        const host = iCtx.$hostElement$;
        set(styleId);
        if (styleQrl.resolved) {
            iCtx.$container$.$appendStyle$(transform(styleQrl.resolved, styleId), styleId, host, scoped);
        }
        else {
            throw styleQrl
                .resolve()
                .then((val) => iCtx.$container$.$appendStyle$(transform(val, styleId), styleId, host, scoped));
        }
        return styleId;
    };

    // <docs markdown="../readme.md#useOn">
    // !!DO NOT EDIT THIS COMMENT DIRECTLY!!!
    // (edit ../readme.md#useOn instead and run `pnpm docs.sync`)
    /**
     * Register a listener on the current component's host element.
     *
     * Used to programmatically add event listeners. Useful from custom `use*` methods, which do not
     * have access to the JSX. Otherwise, it's adding a JSX listener in the `<div>` is a better idea.
     *
     * Events are case sensitive.
     *
     * @public
     * @see `useOn`, `useOnWindow`, `useOnDocument`.
     */
    // </docs>
    const useOn = (event, eventQrl) => {
        _useOn("on:" /* EventNameHtmlScope.on */, event, eventQrl);
    };
    // <docs markdown="../readme.md#useOnDocument">
    // !!DO NOT EDIT THIS COMMENT DIRECTLY!!!
    // (edit ../readme.md#useOnDocument instead and run `pnpm docs.sync`)
    /**
     * Register a listener on `document`.
     *
     * Used to programmatically add event listeners. Useful from custom `use*` methods, which do not
     * have access to the JSX.
     *
     * Events are case sensitive.
     *
     * @public
     * @see `useOn`, `useOnWindow`, `useOnDocument`.
     *
     * ```tsx
     * function useScroll() {
     *   useOnDocument(
     *     'scroll',
     *     $((event) => {
     *       console.log('body scrolled', event);
     *     })
     *   );
     * }
     *
     * const Cmp = component$(() => {
     *   useScroll();
     *   return <div>Profit!</div>;
     * });
     * ```
     */
    // </docs>
    const useOnDocument = (event, eventQrl) => {
        _useOn("on-document:" /* EventNameHtmlScope.document */, event, eventQrl);
    };
    // <docs markdown="../readme.md#useOnWindow">
    // !!DO NOT EDIT THIS COMMENT DIRECTLY!!!
    // (edit ../readme.md#useOnWindow instead and run `pnpm docs.sync`)
    /**
     * Register a listener on `window`.
     *
     * Used to programmatically add event listeners. Useful from custom `use*` methods, which do not
     * have access to the JSX.
     *
     * Events are case sensitive.
     *
     * @public
     * @see `useOn`, `useOnWindow`, `useOnDocument`.
     *
     * ```tsx
     * function useAnalytics() {
     *   useOnWindow(
     *     'popstate',
     *     $((event) => {
     *       console.log('navigation happened', event);
     *       // report to analytics
     *     })
     *   );
     * }
     *
     * const Cmp = component$(() => {
     *   useAnalytics();
     *   return <div>Profit!</div>;
     * });
     * ```
     */
    // </docs>
    const useOnWindow = (event, eventQrl) => {
        _useOn("on-window:" /* EventNameHtmlScope.window */, event, eventQrl);
    };
    const _useOn = (prefix, eventName, eventQrl) => {
        const { isAdded, addEvent } = useOnEventsSequentialScope();
        if (isAdded) {
            return;
        }
        if (eventQrl) {
            if (Array.isArray(eventName)) {
                for (const event of eventName) {
                    addEvent(prefix + fromCamelToKebabCase(event), eventQrl);
                }
            }
            else {
                addEvent(prefix + fromCamelToKebabCase(eventName), eventQrl);
            }
        }
    };
    /**
     * This hook is like the `useSequentialScope` but it is specifically for `useOn`. This is needed
     * because we want to execute the `useOn` hooks only once and store the event listeners on the host
     * element. From Qwik V2 the component is rerunning when the promise is thrown, so we need to make
     * sure that the event listeners are not added multiple times.
     *
     * - The event listeners are stored in the `USE_ON_LOCAL` property.
     * - The `USE_ON_LOCAL_SEQ_IDX` is used to keep track of the index of the hook that calls this.
     * - The `USE_ON_LOCAL_FLAGS` is used to keep track of whether the event listener has been added or
     *   not.
     */
    const useOnEventsSequentialScope = () => {
        const iCtx = useInvokeContext();
        const hostElement = iCtx.$hostElement$;
        const host = hostElement;
        let onMap = iCtx.$container$.getHostProp(host, USE_ON_LOCAL);
        if (onMap === null) {
            onMap = {};
            iCtx.$container$.setHostProp(host, USE_ON_LOCAL, onMap);
        }
        let seqIdx = iCtx.$container$.getHostProp(host, USE_ON_LOCAL_SEQ_IDX);
        if (seqIdx === null) {
            seqIdx = 0;
        }
        iCtx.$container$.setHostProp(host, USE_ON_LOCAL_SEQ_IDX, seqIdx + 1);
        let addedFlags = iCtx.$container$.getHostProp(host, USE_ON_LOCAL_FLAGS);
        if (addedFlags === null) {
            addedFlags = [];
            iCtx.$container$.setHostProp(host, USE_ON_LOCAL_FLAGS, addedFlags);
        }
        while (addedFlags.length <= seqIdx) {
            addedFlags.push(false);
        }
        const addEvent = (eventName, eventQrl) => {
            addedFlags[seqIdx] = true;
            let events = onMap[eventName];
            if (!events) {
                onMap[eventName] = events = [];
            }
            events.push(eventQrl);
        };
        return {
            isAdded: addedFlags[seqIdx],
            addEvent,
        };
    };

    /** @public */
    const useSignal = (initialState) => {
        return useConstant(() => {
            const value = isFunction(initialState) && !isQwikComponent(initialState)
                ? invoke(undefined, initialState)
                : initialState;
            return createSignal(value);
        });
    };
    /**
     * Stores a value which is retained for the lifetime of the component. Subsequent calls to
     * `useConstant` will always return the first value given.
     *
     * If the value is a function, the function is invoked once to calculate the actual value.
     *
     * @public
     */
    const useConstant = (value) => {
        const { val, set } = useSequentialScope();
        if (val != null) {
            return val;
        }
        // Note: We are not using `invoke` here because we don't want to clear the context
        value = isFunction(value) && !isQwikComponent(value) ? value() : value;
        return set(value);
    };

    const useComputedCommon = (qrl, createFn, options) => {
        const { val, set } = useSequentialScope();
        if (val) {
            return val;
        }
        assertQrl(qrl);
        const signal = createFn(qrl, options);
        set(signal);
        // Note that we first save the signal
        // and then we throw to load the qrl
        // This is why we can't use useConstant, we need to keep using the same qrl object
        throwIfQRLNotResolved(qrl);
        return signal;
    };
    /** @internal */
    const useComputedQrl = (qrl, options) => {
        return useComputedCommon(qrl, createComputedSignal, options);
    };
    /**
     * Creates a computed signal which is calculated from the given function. A computed signal is a
     * signal which is calculated from other signals. When the signals change, the computed signal is
     * recalculated, and if the result changed, all tasks which are tracking the signal will be re-run
     * and all components that read the signal will be re-rendered.
     *
     * The function must be synchronous and must not have any side effects.
     *
     * @public
     */
    const useComputed$ = implicit$FirstArg(useComputedQrl);

    /** @internal */
    const useSerializerQrl = (qrl) => useComputedCommon(qrl, createSerializerSignal);
    /**
     * Creates a signal which holds a custom serializable value. It requires that the value implements
     * the `CustomSerializable` type, which means having a function under the `[SerializeSymbol]`
     * property that returns a serializable value when called.
     *
     * The `fn` you pass is called with the result of the serialization (in the browser, only when the
     * value is needed), or `undefined` when not yet initialized. If you refer to other signals, `fn`
     * will be called when those change just like computed signals, and then the argument will be the
     * previous output, not the serialized result.
     *
     * This is useful when using third party libraries that use custom objects that are not
     * serializable.
     *
     * Note that the `fn` is called lazily, so it won't impact container resume.
     *
     * @example
     *
     * ```tsx
     * class MyCustomSerializable {
     *   constructor(public n: number) {}
     *   inc() {
     *     this.n++;
     *   }
     * }
     * const Cmp = component$(() => {
     *   const custom = useSerializer$({
     *     deserialize: (data) => new MyCustomSerializable(data),
     *     serialize: (data) => data.n,
     *     initial: 2,
     *   });
     *   return <div onClick$={() => custom.value.inc()}>{custom.value.n}</div>;
     * });
     * ```
     *
     * @example
     *
     * When using a Signal as the data to create the object, you need to pass the configuration as a
     * function, and you can then also provide the `update` function to update the object when the
     * signal changes.
     *
     * By returning an object from `update`, you signal that the listeners have to be notified. You can
     * mutate the current object but you should return it so that it will trigger listeners.
     *
     * ```tsx
     * const Cmp = component$(() => {
     *   const n = useSignal(2);
     *   const custom = useSerializer$(() =>
     *     ({
     *       deserialize: () => new MyCustomSerializable(n.value),
     *       update: (current) => {
     *         current.n = n.value;
     *         return current;
     *       }
     *     })
     *   );
     *   return <div onClick$={() => n.value++}>{custom.value.n}</div>;
     * });
     * ```
     *
     * @public
     */
    const useSerializer$ = implicit$FirstArg(useSerializerQrl);

    /** @internal */
    const useVisibleTaskQrl = (qrl, opts) => {
        const { val, set, i, iCtx } = useSequentialScope();
        const eagerness = opts?.strategy ?? 'intersection-observer';
        if (val) {
            if (isServerPlatform()) {
                useRunTask(val, eagerness);
            }
            return;
        }
        assertQrl(qrl);
        const task = new Task(1 /* TaskFlags.VISIBLE_TASK */, i, iCtx.$hostElement$, qrl, undefined, null);
        set(task);
        useRunTask(task, eagerness);
        if (!isServerPlatform()) {
            qrl.resolve(iCtx.$element$);
            iCtx.$container$.$scheduler$(16 /* ChoreType.VISIBLE */, task);
        }
    };
    const useRunTask = (task, eagerness) => {
        if (eagerness === 'intersection-observer') {
            useOn('qvisible', getTaskHandlerQrl(task));
        }
        else if (eagerness === 'document-ready') {
            useOnDocument('qinit', getTaskHandlerQrl(task));
        }
        else if (eagerness === 'document-idle') {
            useOnDocument('qidle', getTaskHandlerQrl(task));
        }
    };
    const getTaskHandlerQrl = (task) => {
        return createQRL(null, '_task', scheduleTask, null, null, [task]);
    };

    // <docs markdown="../readme.md#useResource">
    // !!DO NOT EDIT THIS COMMENT DIRECTLY!!!
    // (edit ../readme.md#useResource instead and run `pnpm docs.sync`)
    /**
     * This method works like an async memoized function that runs whenever some tracked value changes
     * and returns some data.
     *
     * `useResource` however returns immediate a `ResourceReturn` object that contains the data and a
     * state that indicates if the data is available or not.
     *
     * The status can be one of the following:
     *
     * - `pending` - the data is not yet available.
     * - `resolved` - the data is available.
     * - `rejected` - the data is not available due to an error or timeout.
     *
     * Be careful when using a `try/catch` statement in `useResource$`. If you catch the error and don't
     * re-throw it (or a new Error), the resource status will never be `rejected`.
     *
     * ### Example
     *
     * Example showing how `useResource` to perform a fetch to request the weather, whenever the input
     * city name changes.
     *
     * ```tsx
     * const Cmp = component$(() => {
     *   const cityS = useSignal('');
     *
     *   const weatherResource = useResource$(async ({ track, cleanup }) => {
     *     const cityName = track(cityS);
     *     const abortController = new AbortController();
     *     cleanup(() => abortController.abort('cleanup'));
     *     const res = await fetch(`http://weatherdata.com?city=${cityName}`, {
     *       signal: abortController.signal,
     *     });
     *     const data = await res.json();
     *     return data as { temp: number };
     *   });
     *
     *   return (
     *     <div>
     *       <input name="city" bind:value={cityS} />
     *       <Resource
     *         value={weatherResource}
     *         onResolved={(weather) => {
     *           return <div>Temperature: {weather.temp}</div>;
     *         }}
     *       />
     *     </div>
     *   );
     * });
     * ```
     *
     * @public
     * @see Resource
     * @see ResourceReturn
     */
    // </docs>
    const useResource$ = (generatorFn, opts) => {
        return useResourceQrl(dollar(generatorFn), opts);
    };

    // <docs markdown="../readme.md#useTask">
    // !!DO NOT EDIT THIS COMMENT DIRECTLY!!!
    // (edit ../readme.md#useTask instead and run `pnpm docs.sync`)
    /**
     * Reruns the `taskFn` when the observed inputs change.
     *
     * Use `useTask` to observe changes on a set of inputs, and then re-execute the `taskFn` when those
     * inputs change.
     *
     * The `taskFn` only executes if the observed inputs change. To observe the inputs, use the `obs`
     * function to wrap property reads. This creates subscriptions that will trigger the `taskFn` to
     * rerun.
     *
     * @param task - Function which should be re-executed when changes to the inputs are detected
     * @public
     *
     * ### Example
     *
     * The `useTask` function is used to observe the `store.count` property. Any changes to the
     * `store.count` cause the `taskFn` to execute which in turn updates the `store.doubleCount` to
     * the double of `store.count`.
     *
     * ```tsx
     * const Cmp = component$(() => {
     *   const store = useStore({
     *     count: 0,
     *     doubleCount: 0,
     *     debounced: 0,
     *   });
     *
     *   // Double count task
     *   useTask$(({ track }) => {
     *     const count = track(() => store.count);
     *     store.doubleCount = 2 * count;
     *   });
     *
     *   // Debouncer task
     *   useTask$(({ track }) => {
     *     const doubleCount = track(() => store.doubleCount);
     *     const timer = setTimeout(() => {
     *       store.debounced = doubleCount;
     *     }, 2000);
     *     return () => {
     *       clearTimeout(timer);
     *     };
     *   });
     *   return (
     *     <div>
     *       <div>
     *         {store.count} / {store.doubleCount}
     *       </div>
     *       <div>{store.debounced}</div>
     *     </div>
     *   );
     * });
     * ```
     *
     * @public
     * @see `Tracker`
     */
    // </docs>
    // We need to cast to help out the api extractor
    const useTask$ = /*#__PURE__*/ implicit$FirstArg(useTaskQrl);

    // <docs markdown="../readme.md#useVisibleTask">
    // !!DO NOT EDIT THIS COMMENT DIRECTLY!!!
    // (edit ../readme.md#useVisibleTask instead and run `pnpm docs.sync`)
    /**
     * ```tsx
     * const Timer = component$(() => {
     *   const store = useStore({
     *     count: 0,
     *   });
     *
     *   useVisibleTask$(() => {
     *     // Only runs in the client
     *     const timer = setInterval(() => {
     *       store.count++;
     *     }, 500);
     *     return () => {
     *       clearInterval(timer);
     *     };
     *   });
     *
     *   return <div>{store.count}</div>;
     * });
     * ```
     *
     * @public
     */
    // </docs>
    // We need to cast to help out the api extractor
    const useVisibleTask$ = /*#__PURE__*/ implicit$FirstArg(useVisibleTaskQrl);

    /** @internal */
    const useAsyncComputedQrl = (qrl, options) => {
        return useComputedCommon(qrl, createAsyncComputedSignal, options);
    };
    /**
     * Creates a computed signal which is calculated from the given function. A computed signal is a
     * signal which is calculated from other signals. When the signals change, the computed signal is
     * recalculated, and if the result changed, all tasks which are tracking the signal will be re-run
     * and all components that read the signal will be re-rendered.
     *
     * The function must be synchronous and must not have any side effects.
     *
     * @public
     */
    const useAsyncComputed$ = implicit$FirstArg(useAsyncComputedQrl);

    /** @public */
    const useErrorBoundary = () => {
        const error = useStore({ error: undefined });
        useContextProvider(ERROR_CONTEXT, error);
        return error;
    };

    // keep this import from core/build so the cjs build works
    /**
     * @deprecated This is no longer needed as the preloading happens automatically in qrl-class.ts.
     *   Leave this in your app for a while so it uninstalls existing service workers, but don't use it
     *   for new projects.
     * @alpha
     */
    const PrefetchServiceWorker = (opts) => {
        const isTest = undefined.TEST;
        if (build.isDev && !isTest) {
            const props = {
                dangerouslySetInnerHTML: '<!-- PrefetchServiceWorker is disabled in dev mode. -->',
            };
            return _jsxSorted('script', null, props, null, 0, 'prefetch-service-worker');
        }
        // if an MFE app has a custom BASE_URL then this will be the correct value
        // if you're not using MFE from another codebase then you want to override this value to your custom setup
        const baseUrl = globalThis.BASE_URL||"/" || '/';
        const resolvedOpts = {
            path: 'qwik-prefetch-service-worker.js',
            ...opts,
        };
        if (opts?.path?.startsWith?.('/')) {
            // allow different path and base
            resolvedOpts.path = opts.path;
        }
        else {
            // baseUrl: '/'
            // path: 'qwik-prefetch-service-worker.js'
            // the file 'qwik-prefetch-service-worker.js' is not located in /build/
            resolvedOpts.path = baseUrl + resolvedOpts.path;
        }
        let code = PREFETCH_CODE.replace('"_URL_"', JSON.stringify(resolvedOpts.path.split('/').pop()));
        if (!build.isDev) {
            // consecutive spaces are indentation
            code = code.replaceAll(/\s\s+/gm, '');
        }
        const props = {
            dangerouslySetInnerHTML: [
                '(' + code + ')(',
                [
                    'navigator.serviceWorker', // Service worker container
                ].join(','),
                ');',
            ].join(''),
            nonce: resolvedOpts.nonce,
        };
        return _jsxSorted('script', null, props, null, 0, 'prefetch-service-worker');
    };
    const PREFETCH_CODE = /*#__PURE__*/ ((c // Service worker container
    ) => {
        if ('getRegistrations' in c) {
            c.getRegistrations().then((registrations) => {
                registrations.forEach((registration) => {
                    if (registration.active) {
                        if (registration.active.scriptURL.endsWith('_URL_')) {
                            registration.unregister().catch(console.error);
                        }
                    }
                });
            });
        }
        if ('caches' in window) {
            caches
                .keys()
                .then((names) => {
                const cacheName = names.find((name) => name.startsWith('QwikBundles'));
                if (cacheName) {
                    caches.delete(cacheName).catch(console.error);
                }
            })
                .catch(console.error);
        }
    }).toString();
    /**
     * @deprecated This is no longer needed as the preloading happens automatically in qrl-class. You
     *   can remove this component from your app.
     * @alpha
     */
    const PrefetchGraph = (_opts = {}) => null;

    //////////////////////////////////////////////////////////////////////////////////////////
    // Protect against duplicate imports
    //////////////////////////////////////////////////////////////////////////////////////////
    if (globalThis.__qwik) {
        console.error(`==============================================\n` +
            `Qwik version ${globalThis.__qwik} already imported while importing ${version}.\n` +
            `This can lead to issues due to duplicated shared structures.\n` +
            `Verify that the Qwik libraries you're using are in "resolve.noExternal[]" and in "optimizeDeps.exclude".\n` +
            `==============================================\n`);
    }
    globalThis.__qwik = version;
    if (undefined) {
        undefined.dispose(() => {
            globalThis.__qwik = undefined;
        });
    }

    Object.defineProperty(exports, "isBrowser", {
        enumerable: true,
        get: function () { return build.isBrowser; }
    });
    Object.defineProperty(exports, "isDev", {
        enumerable: true,
        get: function () { return build.isDev; }
    });
    Object.defineProperty(exports, "isServer", {
        enumerable: true,
        get: function () { return build.isServer; }
    });
    exports.$ = $;
    exports.Fragment = Fragment;
    exports.NoSerializeSymbol = NoSerializeSymbol;
    exports.PrefetchGraph = PrefetchGraph;
    exports.PrefetchServiceWorker = PrefetchServiceWorker;
    exports.RenderOnce = RenderOnce;
    exports.Resource = Resource;
    exports.SSRComment = SSRComment;
    exports.SSRRaw = SSRRaw;
    exports.SSRStream = SSRStream;
    exports.SSRStreamBlock = SSRStreamBlock;
    exports.SerializerSymbol = SerializerSymbol;
    exports.SkipRender = SkipRender;
    exports.Slot = Slot;
    exports._CONST_PROPS = _CONST_PROPS;
    exports._DomContainer = DomContainer;
    exports._EFFECT_BACK_REF = _EFFECT_BACK_REF;
    exports._EMPTY_ARRAY = EMPTY_ARRAY;
    exports._IMMUTABLE = _IMMUTABLE;
    exports._SharedContainer = _SharedContainer;
    exports._SubscriptionData = SubscriptionData;
    exports._UNINITIALIZED = _UNINITIALIZED;
    exports._VAR_PROPS = _VAR_PROPS;
    exports._chk = _chk;
    exports._deserialize = _deserialize;
    exports._dumpState = _dumpState;
    exports._fnSignal = _fnSignal;
    exports._getConstProps = _getConstProps;
    exports._getContextContainer = _getContextContainer;
    exports._getContextElement = _getContextElement;
    exports._getContextEvent = _getContextEvent;
    exports._getDomContainer = getDomContainer;
    exports._getQContainerElement = _getQContainerElement;
    exports._getVarProps = _getVarProps;
    exports._hasStoreEffects = _hasStoreEffects;
    exports._isJSXNode = isJSXNode;
    exports._isStore = isStore;
    exports._isStringifiable = isStringifiable;
    exports._isTask = isTask;
    exports._jsxBranch = _jsxBranch;
    exports._jsxC = _jsxC;
    exports._jsxQ = _jsxQ;
    exports._jsxS = _jsxS;
    exports._jsxSorted = _jsxSorted;
    exports._jsxSplit = _jsxSplit;
    exports._mapApp_findIndx = mapApp_findIndx;
    exports._mapArray_get = mapArray_get;
    exports._mapArray_set = mapArray_set;
    exports._noopQrl = _noopQrl;
    exports._noopQrlDEV = _noopQrlDEV;
    exports._preprocessState = preprocessState;
    exports._qrlSync = _qrlSync;
    exports._regSymbol = _regSymbol;
    exports._resolveContextWithoutSequentialScope = _resolveContextWithoutSequentialScope;
    exports._restProps = _restProps;
    exports._run = _run;
    exports._serialize = _serialize;
    exports._task = scheduleTask;
    exports._val = _val;
    exports._verifySerializable = verifySerializable;
    exports._vnode_ensureElementInflated = vnode_ensureElementInflated;
    exports._vnode_getAttrKeys = vnode_getAttrKeys;
    exports._vnode_getFirstChild = vnode_getFirstChild;
    exports._vnode_getProps = vnode_getProps;
    exports._vnode_isMaterialized = vnode_isMaterialized;
    exports._vnode_isTextVNode = vnode_isTextVNode;
    exports._vnode_isVirtualVNode = vnode_isVirtualVNode;
    exports._vnode_toString = vnode_toString;
    exports._waitUntilRendered = _waitUntilRendered;
    exports._walkJSX = _walkJSX;
    exports._wrapProp = _wrapProp;
    exports._wrapSignal = _wrapSignal;
    exports.component$ = component$;
    exports.componentQrl = componentQrl;
    exports.createAsyncComputed$ = createAsyncComputed$;
    exports.createAsyncComputedQrl = createAsyncComputedSignal;
    exports.createComputed$ = createComputed$;
    exports.createComputedQrl = createComputedSignal;
    exports.createContextId = createContextId;
    exports.createElement = h;
    exports.createSerializer$ = createSerializer$;
    exports.createSerializerQrl = createSerializerSignal;
    exports.createSignal = createSignal;
    exports.event$ = event$;
    exports.eventQrl = eventQrl;
    exports.forceStoreEffects = forceStoreEffects;
    exports.getDomContainer = getDomContainer;
    exports.getLocale = getLocale;
    exports.getPlatform = getPlatform;
    exports.h = h;
    exports.implicit$FirstArg = implicit$FirstArg;
    exports.inlinedQrl = inlinedQrl;
    exports.inlinedQrlDEV = inlinedQrlDEV;
    exports.isSignal = isSignal;
    exports.jsx = jsx;
    exports.jsxDEV = jsxDEV;
    exports.jsxs = jsxs;
    exports.noSerialize = noSerialize;
    exports.qrl = qrl;
    exports.qrlDEV = qrlDEV;
    exports.render = render;
    exports.setPlatform = setPlatform;
    exports.sync$ = sync$;
    exports.untrack = untrack;
    exports.unwrapStore = unwrapStore;
    exports.useAsyncComputed$ = useAsyncComputed$;
    exports.useAsyncComputedQrl = useAsyncComputedQrl;
    exports.useComputed$ = useComputed$;
    exports.useComputedQrl = useComputedQrl;
    exports.useConstant = useConstant;
    exports.useContext = useContext;
    exports.useContextProvider = useContextProvider;
    exports.useErrorBoundary = useErrorBoundary;
    exports.useId = useId;
    exports.useLexicalScope = useLexicalScope;
    exports.useOn = useOn;
    exports.useOnDocument = useOnDocument;
    exports.useOnWindow = useOnWindow;
    exports.useResource$ = useResource$;
    exports.useResourceQrl = useResourceQrl;
    exports.useSerializer$ = useSerializer$;
    exports.useSerializerQrl = useSerializerQrl;
    exports.useServerData = useServerData;
    exports.useSignal = useSignal;
    exports.useStore = useStore;
    exports.useStyles$ = useStyles$;
    exports.useStylesQrl = useStylesQrl;
    exports.useStylesScoped$ = useStylesScoped$;
    exports.useStylesScopedQrl = useStylesScopedQrl;
    exports.useTask$ = useTask$;
    exports.useTaskQrl = useTaskQrl;
    exports.useVisibleTask$ = useVisibleTask$;
    exports.useVisibleTaskQrl = useVisibleTaskQrl;
    exports.version = version;
    exports.withLocale = withLocale;

}));
//# sourceMappingURL=core.cjs.map
