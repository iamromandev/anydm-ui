/**
 * @license
 * @qwik.dev/core 2.0.0-beta.13-dev+cb19ff7
 * Copyright QwikDev. All Rights Reserved.
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/QwikDev/qwik/blob/main/LICENSE
 */
!function(global, factory) {
    "object" == typeof exports && "undefined" != typeof module ? factory(exports, require("@qwik.dev/core/build"), require("@qwik.dev/core/preloader")) : "function" == typeof define && define.amd ? define([ "exports", "@qwik.dev/core/build", "@qwik.dev/core/preloader" ], factory) : factory((global = "undefined" != typeof globalThis ? globalThis : global || self).qwikCore = {}, global.qwikBuild, global.qwikPreloader);
}(this, function(exports, build, preloader) {
    "use strict";
    const version = "2.0.0-beta.13-dev+cb19ff7";
    const qDev = !1;
    const seal = () => {
        qDev;
    };
    const throwErrorAndStop = (message, ...optionalParams) => {
        throw createAndLogError(!1, message, ...optionalParams);
    };
    const logWarn = () => {
        qDev;
    };
    const createAndLogError = (asyncThrow, message, ...optionalParams) => {
        const err = message instanceof Error ? message : new Error(message);
        return console.error("%cQWIK ERROR", "", err.message, ...optionalParams, err.stack), 
        asyncThrow && setTimeout(() => {
            throw err;
        }, 0), err;
    };
    const isSerializableObject = v => {
        const proto = Object.getPrototypeOf(v);
        return proto === Object.prototype || proto === Array.prototype || null === proto;
    };
    const isObject = v => "object" == typeof v && null !== v;
    const isArray = v => Array.isArray(v);
    const isString = v => "string" == typeof v;
    const isFunction = v => "function" == typeof v;
    const qError = (code, errorMessageArgs = []) => {
        const text = (code => `Code(Q${code}) https://github.com/QwikDev/qwik/blob/main/packages/qwik/src/core/error/error.ts#L${8 + code}`)(code, ...errorMessageArgs);
        return ((message, ...optionalParams) => createAndLogError(qDev, message, ...optionalParams))(text, ...errorMessageArgs);
    };
    const isSyncQrl = value => isQrl(value) && "<sync>" == value.$symbol$;
    const isQrl = value => "function" == typeof value && "function" == typeof value.getSymbol;
    function assertQrl(qrl) {
        if (build.isDev && !isQrl(qrl)) {
            throw new Error("Not a QRL");
        }
    }
    const getSymbolHash = symbolName => {
        const index = symbolName.lastIndexOf("_");
        return index > -1 ? symbolName.slice(index + 1) : symbolName;
    };
    const QSlot = "q:slot";
    const QSlotS = "q:s";
    const getQFuncs = (document, hash) => document["qFuncs_" + hash] || [];
    const HTML_NS = "http://www.w3.org/1999/xhtml";
    const SVG_NS = "http://www.w3.org/2000/svg";
    const MATH_NS = "http://www.w3.org/1998/Math/MathML";
    const createPlatform = () => ({
        isServer: build.isServer,
        importSymbol(containerEl, url, symbolName) {
            if (build.isServer) {
                const hash = getSymbolHash(symbolName);
                const regSym = globalThis.__qwik_reg_symbols?.get(hash);
                if (regSym) {
                    return regSym;
                }
            }
            if (!url) {
                throw qError(14, [ symbolName ]);
            }
            if (!containerEl) {
                throw qError(13, [ url, symbolName ]);
            }
            const urlDoc = toUrl(containerEl.ownerDocument, containerEl, url).toString();
            const urlCopy = new URL(urlDoc);
            urlCopy.hash = "";
            return import(urlCopy.href).then(mod => mod[symbolName]);
        },
        raf: fn => new Promise(resolve => {
            requestAnimationFrame(() => {
                resolve(fn());
            });
        }),
        chunkForSymbol: (symbolName, chunk) => [ symbolName, chunk ?? "_" ]
    });
    const toUrl = (doc, containerEl, url) => {
        const baseURI = doc.baseURI;
        const base = new URL(containerEl.getAttribute("q:base") ?? baseURI, baseURI);
        return new URL(url, base);
    };
    let _platform = /*#__PURE__ */ createPlatform();
    const getPlatform = () => _platform;
    const isServerPlatform = () => _platform.isServer;
    const isNode = value => value && "number" == typeof value.nodeType;
    const isElement$1 = value => 1 === value.nodeType;
    const isPromise = value => !!value && "object" == typeof value && "function" == typeof value.then;
    const safeCall = (call, thenFn, rejectFn) => {
        try {
            const result = call();
            return isPromise(result) ? result.then(thenFn, rejectFn) : thenFn(result);
        } catch (e) {
            return rejectFn(e);
        }
    };
    const maybeThen = (valueOrPromise, thenFn) => isPromise(valueOrPromise) ? valueOrPromise.then(thenFn, shouldNotError) : thenFn(valueOrPromise);
    const shouldNotError = reason => {
        throwErrorAndStop(reason);
    };
    const delay = timeout => new Promise(resolve => {
        setTimeout(resolve, timeout);
    });
    function retryOnPromise(fn, retryCount = 0) {
        const retryOrThrow = e => {
            if (isPromise(e) && retryCount < 100) {
                return e.then(retryOnPromise.bind(null, fn, retryCount++));
            }
            throw e;
        };
        try {
            const result = fn();
            return isPromise(result) ? result.catch(e => retryOrThrow(e)) : result;
        } catch (e) {
            if (build.isDev && build.isServer && e instanceof ReferenceError && e.message.includes("window")) {
                throw e.message = 'It seems like you forgot to add "if (isBrowser) {...}" here:' + e.message, 
                e;
            }
            return retryOrThrow(e);
        }
    }
    function assertDefined() {
        qDev;
    }
    function assertEqual() {
        qDev;
    }
    function assertTrue() {
        qDev;
    }
    function assertFalse() {
        qDev;
    }
    let _locale;
    let localAsyncStore;
    build.isServer && import("node:async_hooks").then(module => {
        localAsyncStore = new module.AsyncLocalStorage;
    }).catch(() => {});
    const VirtualTypeName = {
        V: "Virtual",
        F: "Fragment",
        S: "Signal",
        A: "Awaited",
        C: "Component",
        I: "InlineComponent",
        P: "Projection"
    };
    const VNodeDataSeparator_REFERENCE = 126, VNodeDataSeparator_ADVANCE_1 = 33, VNodeDataSeparator_ADVANCE_8192 = 46;
    const VNodeDataChar_OPEN = 123, VNodeDataChar_CLOSE = 125, VNodeDataChar_SCOPED_STYLE = 59, VNodeDataChar_RENDER_FN = 60, VNodeDataChar_ID = 61, VNodeDataChar_PROPS = 62, VNodeDataChar_SLOT_PARENT = 63, VNodeDataChar_KEY = 64, VNodeDataChar_SEQ = 91, VNodeDataChar_CONTEXT = 93, VNodeDataChar_SEQ_IDX = 94, VNodeDataChar_BACK_REFS = 96, VNodeDataChar_SEPARATOR = 124, VNodeDataChar_SLOT = 126;
    const mapApp_findIndx = (array, key, start) => {
        assertTrue();
        let bottom = start >> 1;
        let top = array.length - 2 >> 1;
        for (;bottom <= top; ) {
            const mid = bottom + (top - bottom >> 1);
            const midKey = array[mid << 1];
            if (midKey === key) {
                return mid << 1;
            }
            midKey < key ? bottom = mid + 1 : top = mid - 1;
        }
        return ~(bottom << 1);
    };
    const mapArray_set = (array, key, value, start, allowNullValue = !1) => {
        const indx = mapApp_findIndx(array, key, start);
        indx >= 0 ? null != value || allowNullValue ? array[indx + 1] = value : array.splice(indx, 2) : (null != value || allowNullValue) && array.splice(-1 ^ indx, 0, key, value);
    };
    const mapArray_get = (array, key, start) => {
        const indx = mapApp_findIndx(array, key, start);
        return indx >= 0 ? array[indx + 1] : null;
    };
    const mapArray_has = (array, key, start) => mapApp_findIndx(array, key, start) >= 0;
    const isForeignObjectElement = elementName => build.isDev ? "foreignobject" === elementName.toLowerCase() : "foreignObject" === elementName;
    function cloneDomTreeWithNamespace(element, elementName, namespace, deep = !1) {
        const newElement = element.ownerDocument.createElementNS(namespace, elementName);
        for (const attr of element.attributes) {
            ":" !== attr.name && newElement.setAttribute(attr.name, attr.value);
        }
        if (deep) {
            for (const child of element.childNodes) {
                const nodeType = child.nodeType;
                3 === nodeType ? newElement.appendChild(child.cloneNode()) : 1 === nodeType && newElement.appendChild(cloneDomTreeWithNamespace(child, child.localName, namespace, deep));
            }
        }
        return newElement;
    }
    function vnode_cloneElementWithNamespace(elementVNode, parentVNode, namespace, namespaceFlag) {
        ensureElementVNode(elementVNode);
        let vCursor = elementVNode;
        let vParent = null;
        let rootElement = null;
        let parentElement = null;
        for (;vCursor; ) {
            let childElement = null;
            let newChildElement = null;
            if (vnode_isElementVNode(vCursor)) {
                childElement = vCursor.element;
                const childElementTag = vnode_getElementName(vCursor);
                const vCursorParent = vCursor.parent;
                const vCursorDomParent = null == rootElement ? parentVNode : vCursorParent && vnode_getDomParentVNode(vCursorParent);
                if (vCursorDomParent) {
                    const namespaceData = getNewElementNamespaceData(vCursorDomParent, vnode_getElementName(vCursor));
                    namespace = namespaceData.elementNamespace, namespaceFlag = namespaceData.elementNamespaceFlag;
                }
                const vFirstChild = vnode_getFirstChild(vCursor);
                if (newChildElement = cloneDomTreeWithNamespace(childElement, childElementTag, namespace, !vFirstChild), 
                childElement.remove(), null == rootElement && (rootElement = newChildElement), parentElement && parentElement.appendChild(newChildElement), 
                vCursor.element = newChildElement, vCursor.flags &= -193, vCursor.flags |= namespaceFlag, 
                vFirstChild) {
                    vCursor = vFirstChild, parentElement = newChildElement;
                    continue;
                }
                if (shouldIgnoreChildren(childElement)) {
                    const container = getDomContainerFromQContainerElement(childElement);
                    if (container) {
                        const innerContainerFirstVNode = vnode_getFirstChild(container.rootVNode);
                        if (innerContainerFirstVNode) {
                            vCursor = innerContainerFirstVNode, parentElement = newChildElement;
                            continue;
                        }
                    }
                }
            }
            if (vCursor === elementVNode) {
                return rootElement;
            }
            const vNextSibling = vCursor.nextSibling;
            if (vNextSibling) {
                vCursor = vNextSibling;
            } else {
                for (vParent = vCursor.parent; vParent; ) {
                    if (vParent === elementVNode) {
                        return rootElement;
                    }
                    const vNextParentSibling = vParent.nextSibling;
                    if (vNextParentSibling) {
                        return vCursor = vNextParentSibling, rootElement;
                    }
                    vParent = vParent.parent;
                }
                if (null == vParent) {
                    return rootElement;
                }
            }
        }
        return rootElement;
    }
    function isSvg(tagOrVNode) {
        return "string" == typeof tagOrVNode ? "svg" === (elementName = tagOrVNode) || isForeignObjectElement(elementName) : !!(64 & tagOrVNode.flags);
        var elementName;
    }
    function getNewElementNamespaceData(domParentVNode, tagOrVNode) {
        const parentIsDefaultNamespace = !domParentVNode || !(!vnode_getElementName(domParentVNode) || (vnode = domParentVNode, 
        192 & vnode.flags));
        var vnode;
        const parentIsForeignObject = !parentIsDefaultNamespace && isForeignObjectElement(vnode_getElementName(domParentVNode));
        let elementNamespace = HTML_NS;
        let elementNamespaceFlag = 0;
        const isElementVNodeOrString = "string" == typeof tagOrVNode || vnode_isElementVNode(tagOrVNode);
        if (isElementVNodeOrString && isSvg(tagOrVNode)) {
            elementNamespace = SVG_NS, elementNamespaceFlag = 64;
        } else if (isElementVNodeOrString && function(tagOrVNode) {
            return "string" == typeof tagOrVNode ? "math" === tagOrVNode : !!(128 & tagOrVNode.flags);
        }(tagOrVNode)) {
            elementNamespace = MATH_NS, elementNamespaceFlag = 128;
        } else if (domParentVNode && !parentIsForeignObject && !parentIsDefaultNamespace) {
            elementNamespace = !!(64 & domParentVNode.flags) ? SVG_NS : !!(128 & domParentVNode.flags) ? MATH_NS : HTML_NS, 
            elementNamespaceFlag = 192 & domParentVNode.flags;
        }
        return {
            elementNamespace,
            elementNamespaceFlag
        };
    }
    const NEEDS_COMPUTATION = Symbol("invalid");
    const _EFFECT_BACK_REF = Symbol("backRef");
    const STORE_TARGET = Symbol("store.target");
    const STORE_HANDLER = Symbol("store.handler");
    const STORE_ALL_PROPS = Symbol("store.all");
    class SignalImpl {
        $untrackedValue$;
        $effects$=null;
        $container$=null;
        $wrappedSignal$=null;
        constructor(container, value) {
            this.$container$ = container, this.$untrackedValue$ = value;
        }
        force() {
            this.$container$?.$scheduler$(7, null, this, this.$effects$);
        }
        get untrackedValue() {
            return this.$untrackedValue$;
        }
        set untrackedValue(value) {
            this.$untrackedValue$ = value;
        }
        get value() {
            return setupSignalValueAccess(this, () => this.$effects$ ||= new Set, () => this.untrackedValue);
        }
        set value(value) {
            value !== this.$untrackedValue$ && (this.$untrackedValue$ = value, this.$container$?.$scheduler$(7, null, this, this.$effects$));
        }
        valueOf() {
            qDev;
        }
        toString() {
            return build.isDev ? `[${this.constructor.name}${1 & this.$flags$ ? " INVALID" : ""} ${String(this.$untrackedValue$)}]` + (Array.from(this.$effects$ || []).map(e => "\n -> " + pad(qwikDebugToString(e[0]), "    ")).join("\n") || "") : this.constructor.name;
        }
        toJSON() {
            return {
                value: this.$untrackedValue$
            };
        }
    }
    const setupSignalValueAccess = (target, effectsFn, returnValueFn) => {
        const ctx = tryGetInvokeContext();
        if (ctx) {
            if (null === target.$container$) {
                if (!ctx.$container$) {
                    return returnValueFn();
                }
                target.$container$ = ctx.$container$;
            } else {
                assertTrue();
            }
            const effectSubscriber = ctx.$effectSubscriber$;
            effectSubscriber && ((signal, effectSubscriber, effects) => {
                ensureContainsSubscription(effects, effectSubscriber), ensureContainsBackRef(effectSubscriber, signal), 
                addQrlToSerializationCtx(effectSubscriber, signal.$container$);
            })(target, effectSubscriber, effectsFn());
        }
        return returnValueFn();
    };
    const _CONST_PROPS = Symbol("CONST");
    const _VAR_PROPS = Symbol("VAR");
    const _OWNER = Symbol("OWNER");
    const _IMMUTABLE = Symbol("IMMUTABLE");
    const _UNINITIALIZED = Symbol("UNINITIALIZED");
    const isHtmlAttributeAnEventName = name => name.startsWith("on:") || name.startsWith("on-window:") || name.startsWith("on-document:");
    function jsxEventToHtmlAttribute(jsxEvent) {
        if (jsxEvent.endsWith("$")) {
            const [prefix, idx] = function(eventName) {
                let prefix = "on:";
                let idx = -1;
                eventName.startsWith("on") ? (prefix = "on:", idx = 2) : eventName.startsWith("window:on") ? (prefix = "on-window:", 
                idx = 9) : eventName.startsWith("document:on") && (prefix = "on-document:", idx = 11);
                return [ prefix, idx ];
            }(jsxEvent);
            if (-1 !== idx) {
                const name = jsxEvent.slice(idx, -1);
                return "DOMContentLoaded" === name ? prefix + "-d-o-m-content-loaded" : function(event, prefix) {
                    const eventName = fromCamelToKebabCase(event);
                    return prefix + eventName;
                }("-" === name.charAt(0) ? name.slice(1) : name.toLowerCase(), prefix);
            }
        }
        return null;
    }
    function isPreventDefault(key) {
        return key.startsWith("preventdefault:");
    }
    const fromCamelToKebabCase = text => text.replace(/([A-Z-])/g, a => "-" + a.toLowerCase());
    const getEventDataFromHtmlAttribute = htmlKey => htmlKey.startsWith("on:") ? [ "", htmlKey.substring(3) ] : htmlKey.startsWith("on-window:") ? [ "window", htmlKey.substring(10) ] : [ "document", htmlKey.substring(12) ];
    const EMPTY_ARRAY = [];
    const EMPTY_OBJ = {};
    function createPropsProxy(owner) {
        return new Proxy({}, new PropsProxyHandler(owner));
    }
    Object.freeze(EMPTY_ARRAY), Object.freeze(EMPTY_OBJ);
    class PropsProxyHandler {
        owner;
        constructor(owner) {
            this.owner = owner;
        }
        get(_, prop) {
            if (prop === _CONST_PROPS) {
                return this.owner.constProps;
            }
            if (prop === _VAR_PROPS) {
                return this.owner.varProps;
            }
            if (prop === _OWNER) {
                return this.owner;
            }
            let value;
            if ("children" === prop) {
                value = this.owner.children;
            } else {
                if ("string" == typeof prop && "string" == typeof this.owner.type) {
                    const attr = jsxEventToHtmlAttribute(prop);
                    attr && (prop = attr);
                }
                value = directGetPropsProxyProp(this.owner, prop);
            }
            return value instanceof WrappedSignalImpl && 4 & value.$flags$ ? value.value : value;
        }
        set(_, prop, value) {
            if (prop === _OWNER) {
                this.owner = value;
            } else if ("children" === prop) {
                this.owner.children = value;
            } else {
                if ("string" == typeof prop && "string" == typeof this.owner.type) {
                    const attr = jsxEventToHtmlAttribute(prop);
                    attr && (prop = attr);
                }
                this.owner.constProps && prop in this.owner.constProps ? (this.owner.constProps[prop] = void 0, 
                prop in this.owner.varProps || (this.owner.toSort = !0), this.owner.varProps[prop] = value) : (this.owner.varProps === EMPTY_OBJ ? this.owner.varProps = {} : prop in this.owner.varProps || (this.owner.toSort = !0), 
                this.owner.varProps[prop] = value);
            }
            return !0;
        }
        deleteProperty(_, prop) {
            let didDelete = delete this.owner.varProps[prop];
            return this.owner.constProps && (didDelete = delete this.owner.constProps[prop] || didDelete), 
            null != this.owner.children && "children" === prop && (this.owner.children = null, 
            didDelete = !0), didDelete;
        }
        has(_, prop) {
            if ("children" === prop) {
                return null != this.owner.children;
            }
            if (prop === _CONST_PROPS || prop === _VAR_PROPS) {
                return !0;
            }
            if ("string" == typeof prop && "string" == typeof this.owner.type) {
                const attr = jsxEventToHtmlAttribute(prop);
                attr && (prop = attr);
            }
            return prop in this.owner.varProps || !!this.owner.constProps && prop in this.owner.constProps;
        }
        getOwnPropertyDescriptor(_, p) {
            return {
                configurable: !0,
                enumerable: !0,
                value: "children" === p ? this.owner.children : this.owner.constProps && p in this.owner.constProps ? this.owner.constProps[p] : this.owner.varProps[p]
            };
        }
        ownKeys() {
            const out = Object.keys(this.owner.varProps);
            if (null != this.owner.children && out.push("children"), this.owner.constProps) {
                for (const key in this.owner.constProps) {
                    -1 === out.indexOf(key) && out.push(key);
                }
            }
            return out;
        }
    }
    const directGetPropsProxyProp = (jsx, prop) => jsx.constProps && prop in jsx.constProps ? jsx.constProps[prop] : jsx.varProps[prop];
    const isPropsProxy = obj => obj && _VAR_PROPS in obj;
    function getSubscriber(effect, prop, data) {
        effect[_EFFECT_BACK_REF] || (build.isServer && isSsrNode(effect) ? effect.setProp("q:brefs", new Map) : effect[_EFFECT_BACK_REF] = new Map);
        const subMap = effect[_EFFECT_BACK_REF];
        let sub = subMap.get(prop);
        return sub || (sub = [ effect, prop ], subMap.set(prop, sub)), data && (sub[3] = data), 
        sub;
    }
    function isSsrNode(value) {
        return "__brand__" in value && "SsrNode" === value.__brand__;
    }
    const trackFn = (target, container) => (obj, prop) => {
        const ctx = newInvokeContext();
        return ctx.$effectSubscriber$ = getSubscriber(target, ":"), ctx.$container$ = container || void 0, 
        invoke(ctx, () => {
            if (isFunction(obj)) {
                return obj();
            }
            if (prop) {
                return obj[prop];
            }
            if (isSignal(obj)) {
                return obj.value;
            }
            if (isObject(obj) && isStore(obj)) {
                return addStoreEffect(getStoreTarget(obj), STORE_ALL_PROPS, getStoreHandler(obj), ctx.$effectSubscriber$), 
                obj;
            }
            throw qError(2);
        });
    };
    const cleanupFn = (target, handleError) => {
        let cleanupFns = null;
        return [ fn => {
            "function" == typeof fn && (cleanupFns || (cleanupFns = [], target.$destroy$ = noSerialize(() => {
                target.$destroy$ = null, cleanupFns.forEach(fn => {
                    try {
                        fn();
                    } catch (err) {
                        handleError(err);
                    }
                });
            })), cleanupFns.push(fn));
        }, cleanupFns ?? [] ];
    };
    class ComputedSignalImpl extends SignalImpl {
        $computeQrl$;
        $flags$;
        [_EFFECT_BACK_REF]=null;
        constructor(container, fn, flags = 33) {
            super(container, NEEDS_COMPUTATION), this.$computeQrl$ = fn, this.$flags$ = flags;
        }
        invalidate() {
            this.$flags$ |= 1, this.$container$?.$scheduler$(7, null, this, this.$effects$);
        }
        force() {
            this.$flags$ |= 2, super.force();
        }
        get untrackedValue() {
            return this.$computeIfNeeded$(), assertFalse(), this.$untrackedValue$;
        }
        $computeIfNeeded$() {
            if (!(1 & this.$flags$)) {
                return;
            }
            const computeQrl = this.$computeQrl$;
            throwIfQRLNotResolved(computeQrl);
            const ctx = tryGetInvokeContext();
            const previousEffectSubscription = ctx?.$effectSubscriber$;
            ctx && (ctx.$effectSubscriber$ = getSubscriber(this, "."));
            try {
                const untrackedValue = computeQrl.getFn(ctx)();
                if (isPromise(untrackedValue)) {
                    throw qError(29, [ computeQrl.dev ? computeQrl.dev.file : "", computeQrl.$hash$ ]);
                }
                this.$flags$ &= -2;
                untrackedValue !== this.$untrackedValue$ && (this.$untrackedValue$ !== NEEDS_COMPUTATION && (this.$flags$ |= 2), 
                this.$untrackedValue$ = untrackedValue);
            } finally {
                ctx && (ctx.$effectSubscriber$ = previousEffectSubscription);
            }
        }
        set value(_) {
            throw qError(30);
        }
        get value() {
            return super.value;
        }
    }
    class AsyncComputedSignalImpl extends ComputedSignalImpl {
        $untrackedLoading$=!1;
        $untrackedError$=null;
        $loadingEffects$=null;
        $errorEffects$=null;
        $destroy$;
        $promiseValue$=NEEDS_COMPUTATION;
        [_EFFECT_BACK_REF]=null;
        constructor(container, fn, flags = 1) {
            super(container, fn, flags);
        }
        get loading() {
            return setupSignalValueAccess(this, () => this.$loadingEffects$ ||= new Set, () => this.untrackedLoading);
        }
        set untrackedLoading(value) {
            value !== this.$untrackedLoading$ && (this.$untrackedLoading$ = value, this.$container$?.$scheduler$(7, null, this, this.$loadingEffects$));
        }
        get untrackedLoading() {
            return this.$untrackedLoading$;
        }
        get error() {
            return setupSignalValueAccess(this, () => this.$errorEffects$ ||= new Set, () => this.untrackedError);
        }
        set untrackedError(value) {
            value !== this.$untrackedError$ && (this.$untrackedError$ = value, this.$container$?.$scheduler$(7, null, this, this.$errorEffects$));
        }
        get untrackedError() {
            return this.$untrackedError$;
        }
        invalidate() {
            super.invalidate(), this.$promiseValue$ = NEEDS_COMPUTATION;
        }
        async resolve() {
            return await retryOnPromise(() => this.$computeIfNeeded$()), this.$untrackedValue$;
        }
        $computeIfNeeded$() {
            if (!(1 & this.$flags$)) {
                return;
            }
            const [cleanup] = cleanupFn(this, err => this.$container$?.handleError(err, null));
            const untrackedValue = this.$promiseValue$ === NEEDS_COMPUTATION ? this.$computeQrl$.getFn()({
                track: trackFn(this, this.$container$),
                cleanup
            }) : this.$promiseValue$;
            if (isPromise(untrackedValue)) {
                throw this.untrackedLoading = !0, this.untrackedError = null, untrackedValue.then(promiseValue => {
                    this.$promiseValue$ = promiseValue, this.untrackedLoading = !1, this.untrackedError = null;
                }).catch(err => {
                    this.$promiseValue$ = err, this.untrackedLoading = !1, this.untrackedError = err;
                });
            }
            this.$promiseValue$ = NEEDS_COMPUTATION, this.$flags$ &= -2;
            const didChange = untrackedValue !== this.$untrackedValue$;
            return didChange && (this.$flags$ |= 2, this.$untrackedValue$ = untrackedValue), 
            didChange;
        }
    }
    const implicit$FirstArg = fn => function(first, ...rest) {
        return fn.call(null, dollar(first), ...rest);
    };
    class SerializerSignalImpl extends ComputedSignalImpl {
        constructor(container, argQrl) {
            super(container, argQrl, 33);
        }
        $didInitialize$=!1;
        $computeIfNeeded$() {
            if (!(1 & this.$flags$)) {
                return;
            }
            throwIfQRLNotResolved(this.$computeQrl$);
            let arg = this.$computeQrl$.resolved;
            "function" == typeof arg && (arg = arg());
            const {deserialize, initial} = arg;
            const update = arg.update;
            const currentValue = this.$untrackedValue$ === NEEDS_COMPUTATION ? initial : this.$untrackedValue$;
            const untrackedValue = trackSignal(() => this.$didInitialize$ ? update?.(currentValue) || currentValue : deserialize(currentValue), this, ".", this.$container$);
            const didChange = this.$didInitialize$ && "undefined" !== untrackedValue || untrackedValue !== this.$untrackedValue$;
            this.$flags$ &= -2, this.$didInitialize$ = !0, didChange && (this.$flags$ |= 2, 
            this.$untrackedValue$ = untrackedValue);
        }
    }
    const createComputedSignal = (qrl, options) => new ComputedSignalImpl(options?.container || null, qrl, getComputedSignalFlags(options?.serializationStrategy || "always"));
    const createAsyncComputedSignal = (qrl, options) => new AsyncComputedSignalImpl(options?.container || null, qrl, getComputedSignalFlags(options?.serializationStrategy || "never"));
    const createSerializerSignal = arg => new SerializerSignalImpl(null, arg);
    const createSignal = value => new SignalImpl(null, value);
    const createComputed$ = /*#__PURE__*/ implicit$FirstArg(createComputedSignal);
    const createAsyncComputed$ = /*#__PURE__*/ implicit$FirstArg(createAsyncComputedSignal);
    const createSerializer$ = implicit$FirstArg(createSerializerSignal);
    const getValueProp = p0 => p0.value;
    const getProp = (p0, p1) => p0[p1];
    const getWrapped = args => 1 === args.length ? isSignal(args[0]) ? args[0].$wrappedSignal$ ||= new WrappedSignalImpl(null, getValueProp, args, null) : isStore(args[0]) ? new WrappedSignalImpl(null, getValueProp, args, null) : args[0].value : new WrappedSignalImpl(null, getProp, args, null);
    const _wrapProp = (...args) => {
        const obj = args[0];
        const prop = args.length < 2 ? "value" : args[1];
        if (!isObject(obj)) {
            return obj[prop];
        }
        if (isSignal(obj)) {
            return obj instanceof AsyncComputedSignalImpl || assertEqual(), obj instanceof WrappedSignalImpl && 4 & obj.$flags$ ? obj : getWrapped(args);
        }
        if (isPropsProxy(obj)) {
            const constProps = obj[_CONST_PROPS];
            if (constProps && prop in constProps) {
                return constProps[prop];
            }
        } else {
            const target = getStoreTarget(obj);
            if (target) {
                const value = target[prop];
                return isSignal(value) ? value : getWrapped(args);
            }
        }
        return obj[prop];
    };
    class WrappedSignalImpl extends SignalImpl {
        $args$;
        $func$;
        $funcStr$;
        $flags$;
        $hostElement$=null;
        [_EFFECT_BACK_REF]=null;
        constructor(container, fn, args, fnStr, flags = 5) {
            super(container, NEEDS_COMPUTATION), this.$args$ = args, this.$func$ = fn, this.$funcStr$ = fnStr, 
            this.$flags$ = flags;
        }
        invalidate() {
            this.$flags$ |= 1;
            try {
                this.$computeIfNeeded$();
            } catch (_) {
                this.$container$?.$scheduler$(7, this.$hostElement$, this, this.$effects$);
            }
            2 & this.$flags$ && (this.$flags$ &= -3, scheduleEffects(this.$container$, this, this.$effects$));
        }
        force() {
            this.$flags$ |= 2, this.$container$?.$scheduler$(7, this.$hostElement$, this, this.$effects$);
        }
        get untrackedValue() {
            return this.$computeIfNeeded$(), assertFalse(), this.$untrackedValue$;
        }
        $computeIfNeeded$() {
            if (!(1 & this.$flags$)) {
                return;
            }
            const untrackedValue = trackSignal(() => this.$func$(...this.$args$), this, ".", this.$container$);
            this.$flags$ &= -3;
            untrackedValue !== this.$untrackedValue$ && (this.$flags$ |= 2, this.$untrackedValue$ = untrackedValue);
        }
        $unwrapIfSignal$() {
            return this.$func$ === getValueProp && isSignal(this.$args$[0]) ? this.$args$[0] : this;
        }
        set value(_) {
            throw qError(31);
        }
        get value() {
            return super.value;
        }
    }
    let BackRef$1 = class {
        [_EFFECT_BACK_REF]=null;
    };
    function clearAllEffects(container, consumer) {
        vnode_isVNode(consumer) && vnode_isElementVNode(consumer) && ensureMaterialized(consumer);
        const effects = consumer[_EFFECT_BACK_REF];
        if (effects) {
            for (const [, effect] of effects) {
                clearEffectSubscription(container, effect);
            }
        }
    }
    function clearEffectSubscription(container, effect) {
        const backRefs = effect[2];
        if (backRefs) {
            for (const producer of backRefs) {
                if (producer instanceof SignalImpl) {
                    clearSignal(container, producer, effect);
                } else if (producer instanceof AsyncComputedSignalImpl) {
                    clearAsyncComputedSignal(producer, effect);
                } else if (container.$storeProxyMap$.has(producer)) {
                    const target = container.$storeProxyMap$.get(producer);
                    clearStore(getStoreHandler(target), effect);
                }
            }
        }
    }
    function clearSignal(container, producer, effect) {
        const effects = producer.$effects$;
        effects && effects.has(effect) && effects.delete(effect), producer instanceof WrappedSignalImpl && (producer.$hostElement$ = null, 
        clearAllEffects(container, producer));
    }
    function clearAsyncComputedSignal(producer, effect) {
        const effects = producer.$effects$;
        effects && effects.has(effect) && effects.delete(effect);
        const pendingEffects = producer.$loadingEffects$;
        pendingEffects && pendingEffects.has(effect) && pendingEffects.delete(effect);
    }
    function clearStore(producer, effect) {
        const effects = producer?.$effects$;
        if (effects) {
            for (const propEffects of effects.values()) {
                propEffects.has(effect) && propEffects.delete(effect);
            }
        }
    }
    class VNode extends BackRef$1 {
        flags;
        parent;
        previousSibling;
        nextSibling;
        props=null;
        slotParent=null;
        chores=null;
        blockedChores=null;
        constructor(flags, parent, previousSibling, nextSibling) {
            super(), this.flags = flags, this.parent = parent, this.previousSibling = previousSibling, 
            this.nextSibling = nextSibling;
        }
        getProp(key, getObject) {
            const type = this.flags;
            if (3 & type) {
                1 & type && vnode_ensureElementInflated(this), this.props ||= [];
                const idx = mapApp_findIndx(this.props, key, 0);
                if (idx >= 0) {
                    let value = this.props[idx + 1];
                    return "string" == typeof value && getObject && (this.props[idx + 1] = value = getObject(value)), 
                    value;
                }
            }
            return null;
        }
        setProp(key, value) {
            this.props ||= [];
            const idx = mapApp_findIndx(this.props, key, 0);
            idx >= 0 ? this.props[idx + 1] = value : null != value && this.props.splice(-1 ^ idx, 0, key, value);
        }
        getAttr(key) {
            return 3 & this.flags ? (vnode_ensureElementInflated(this), this.props ||= [], mapArray_get(this.props, key, 0)) : null;
        }
        setAttr(key, value, journal) {
            if (3 & this.flags) {
                vnode_ensureElementInflated(this), this.props ||= [];
                const idx = mapApp_findIndx(this.props, key, 0);
                idx >= 0 ? (this.props[idx + 1] != value && this instanceof ElementVNode && journal && journal.push(2, this.element, key, value), 
                null == value ? this.props.splice(idx, 2) : this.props[idx + 1] = value) : null != value && (this.props.splice(-1 ^ idx, 0, key, value), 
                this instanceof ElementVNode && journal && journal.push(2, this.element, key, value));
            }
        }
        toString() {
            return build.isDev ? vnode_toString.call(this) : String(this);
        }
    }
    class TextVNode extends VNode {
        textNode;
        text;
        constructor(flags, parent, previousSibling, nextSibling, textNode, text) {
            super(flags, parent, previousSibling, nextSibling), this.textNode = textNode, this.text = text;
        }
    }
    class VirtualVNode extends VNode {
        firstChild;
        lastChild;
        constructor(flags, parent, previousSibling, nextSibling, firstChild, lastChild) {
            super(flags, parent, previousSibling, nextSibling), this.firstChild = firstChild, 
            this.lastChild = lastChild;
        }
    }
    class ElementVNode extends VNode {
        firstChild;
        lastChild;
        element;
        elementName;
        constructor(flags, parent, previousSibling, nextSibling, firstChild, lastChild, element, elementName) {
            super(flags, parent, previousSibling, nextSibling), this.firstChild = firstChild, 
            this.lastChild = lastChild, this.element = element, this.elementName = elementName;
        }
    }
    const vnode_newElement = (element, elementName) => {
        assertEqual(fastNodeType(element));
        const vnode = new ElementVNode(-247, null, null, null, null, null, element, elementName);
        return assertTrue(vnode_isElementVNode(vnode)), assertFalse(vnode_isTextVNode(vnode)), 
        assertFalse(vnode_isVirtualVNode(vnode)), element.vNode = vnode, vnode;
    };
    const vnode_newUnMaterializedElement = element => {
        assertEqual(fastNodeType(element));
        const vnode = new ElementVNode(-255, null, null, null, void 0, void 0, element, void 0);
        return assertTrue(vnode_isElementVNode(vnode)), assertFalse(vnode_isTextVNode(vnode)), 
        assertFalse(vnode_isVirtualVNode(vnode)), element.vNode = vnode, vnode;
    };
    const vnode_newText = (textNode, textContent) => {
        const vnode = new TextVNode(-244, null, null, null, textNode, textContent);
        return assertEqual(fastNodeType(textNode)), assertFalse(vnode_isElementVNode(vnode)), 
        assertTrue(vnode_isTextVNode(vnode)), assertFalse(vnode_isVirtualVNode(vnode)), 
        vnode;
    };
    const vnode_newVirtual = () => {
        const vnode = new VirtualVNode(-254, null, null, null, null, null);
        return assertFalse(vnode_isElementVNode(vnode)), assertFalse(vnode_isTextVNode(vnode)), 
        assertTrue(vnode_isVirtualVNode(vnode)), vnode;
    };
    const vnode_isVNode = vNode => vNode instanceof VNode;
    const vnode_isElementVNode = vNode => {
        assertDefined();
        return !(1 & ~vNode.flags);
    };
    const vnode_isElementOrTextVNode = vNode => {
        assertDefined();
        return !!(5 & vNode.flags);
    };
    const vnode_isMaterialized = vNode => {
        assertDefined();
        return !(1 & ~vNode.flags) && void 0 !== vNode.firstChild && void 0 !== vNode.lastChild;
    };
    const vnode_isTextVNode = vNode => {
        assertDefined();
        return !(4 & ~vNode.flags);
    };
    const vnode_isVirtualVNode = vNode => {
        assertDefined();
        return !(2 & ~vNode.flags);
    };
    const vnode_isProjection = vNode => {
        assertDefined();
        return !(2 & ~vNode.flags) && null !== vNode.getProp(QSlot, null);
    };
    const ensureElementVNode = vNode => (assertTrue(vnode_isElementVNode(vNode), vnode_getNodeTypeName(vNode)), 
    vNode);
    const vnode_getNodeTypeName = vNode => {
        if (vNode) {
            switch (7 & vNode.flags) {
              case 1:
                return "Element";

              case 2:
                return "Virtual";

              case 4:
                return "Text";
            }
        }
        return "<unknown>";
    };
    const vnode_ensureElementInflated = vnode => {
        if (1 == (15 & vnode.flags)) {
            const elementVNode = vnode;
            elementVNode.flags ^= 8;
            const element = elementVNode.element;
            const attributes = element.attributes;
            for (let idx = 0; idx < attributes.length; idx++) {
                const attr = attributes[idx];
                const key = attr.name;
                if (":" === key || !key) {
                    break;
                }
                if (key.startsWith("q:container")) {
                    const props = vnode_getProps(elementVNode);
                    "html" === attr.value ? mapArray_set(props, "dangerouslySetInnerHTML", element.innerHTML, 0) : "text" === attr.value && "value" in element && mapArray_set(props, "value", element.value, 0);
                } else if (!key.startsWith("on:")) {
                    const value = attr.value;
                    const props = vnode_getProps(elementVNode);
                    mapArray_set(props, key, value, 0);
                }
            }
        }
    };
    function vnode_walkVNode(vNode, callback) {
        let vCursor = vNode;
        if (vnode_isTextVNode(vNode)) {
            return;
        }
        let vParent = null;
        for (;;) {
            if (callback?.(vCursor, vParent)) {
                return;
            }
            const vFirstChild = vnode_getFirstChild(vCursor);
            if (vFirstChild) {
                vCursor = vFirstChild;
                continue;
            }
            if (vCursor === vNode) {
                return;
            }
            const vNextSibling = vCursor.nextSibling;
            if (vNextSibling) {
                vCursor = vNextSibling;
            } else {
                for (vParent = vCursor.parent; vParent; ) {
                    if (vParent === vNode) {
                        return;
                    }
                    const vNextParentSibling = vParent.nextSibling;
                    if (vNextParentSibling) {
                        vCursor = vNextParentSibling;
                        break;
                    }
                    vParent = vParent.parent;
                }
                if (null == vParent) {
                    return;
                }
            }
        }
    }
    function vnode_getDOMChildNodes(journal, root, isVNode = !1, childNodes = []) {
        if (vnode_isElementOrTextVNode(root)) {
            return vnode_isTextVNode(root) && vnode_ensureTextInflated(journal, root), childNodes.push(isVNode ? root : vnode_getNode(root)), 
            childNodes;
        }
        let vNode = vnode_getFirstChild(root);
        for (;vNode; ) {
            vnode_isElementVNode(vNode) ? childNodes.push(isVNode ? vNode : vnode_getNode(vNode)) : vnode_isTextVNode(vNode) ? (vnode_ensureTextInflated(journal, vNode), 
            childNodes.push(isVNode ? vNode : vnode_getNode(vNode))) : vnode_getDOMChildNodes(journal, vNode, !!isVNode, childNodes), 
            vNode = vNode.nextSibling;
        }
        return childNodes;
    }
    const vnode_getDomSibling = (vNode, nextDirection, descend) => {
        const childProp = nextDirection ? "firstChild" : "lastChild";
        const siblingProp = nextDirection ? "nextSibling" : "previousSibling";
        let cursor = vNode;
        for (;descend && cursor && vnode_isVirtualVNode(cursor); ) {
            const child = cursor[childProp];
            if (!child) {
                break;
            }
            if (5 & child.flags) {
                return child;
            }
            cursor = child;
        }
        for (;cursor; ) {
            let sibling = cursor[siblingProp];
            if (sibling && 5 & sibling.flags) {
                return sibling;
            }
            if (!sibling) {
                let virtual = cursor.parent;
                if (virtual && !vnode_isVirtualVNode(virtual)) {
                    return null;
                }
                for (;virtual && !(sibling = virtual[siblingProp]); ) {
                    if (virtual = virtual.parent, virtual && !vnode_isVirtualVNode(virtual)) {
                        return null;
                    }
                }
                if (!sibling) {
                    return null;
                }
                if (vnode_isTextVNode(sibling) && virtual && vnode_isElementVNode(virtual)) {
                    return null;
                }
            }
            for (;sibling; ) {
                if (cursor = sibling, 5 & cursor.flags && vnode_getNode(cursor)) {
                    return cursor;
                }
                sibling = cursor[childProp];
            }
        }
        return null;
    };
    const vnode_ensureTextInflated = (journal, vnode) => {
        const textVNode = (assertTrue(vnode_isTextVNode(vNode = vnode), vnode_getNodeTypeName(vNode)), 
        vNode);
        var vNode;
        if (!(8 & textVNode.flags)) {
            const parentNode = vnode_getDomParent(vnode);
            assertDefined();
            const sharedTextNode = textVNode.textNode;
            const doc = parentNode.ownerDocument;
            let cursor = vnode_getDomSibling(vnode, !1, !0);
            const node = vnode_getDomSibling(vnode, !0, !0);
            const insertBeforeNode = sharedTextNode || (node instanceof ElementVNode ? node.element : node?.textNode) || null;
            let lastPreviousTextNode = insertBeforeNode;
            for (;cursor && vnode_isTextVNode(cursor); ) {
                if (!(8 & cursor.flags)) {
                    const textNode = doc.createTextNode(cursor.text);
                    journal.push(6, parentNode, lastPreviousTextNode, textNode), lastPreviousTextNode = textNode, 
                    cursor.textNode = textNode, cursor.flags |= 8;
                }
                cursor = vnode_getDomSibling(cursor, !1, !0);
            }
            for (cursor = vnode; cursor && vnode_isTextVNode(cursor); ) {
                const next = vnode_getDomSibling(cursor, !0, !0);
                const isLastNode = !next || !vnode_isTextVNode(next);
                if (!(8 & cursor.flags)) {
                    if (isLastNode && sharedTextNode) {
                        journal.push(1, sharedTextNode, cursor.text);
                    } else {
                        const textNode = doc.createTextNode(cursor.text);
                        journal.push(6, parentNode, insertBeforeNode, textNode), cursor.textNode = textNode;
                    }
                    cursor.flags |= 8;
                }
                cursor = next;
            }
        }
    };
    const vnode_locate = (rootVNode, id) => {
        ensureElementVNode(rootVNode);
        let vNode = rootVNode;
        const containerElement = rootVNode.element;
        const {qVNodeRefs} = containerElement;
        let elementOffset = -1;
        let refElement;
        if ("string" == typeof id) {
            assertDefined(), elementOffset = parseInt(id), refElement = qVNodeRefs.get(elementOffset);
        } else {
            refElement = id;
            const vNode = refElement.vNode;
            if (vNode) {
                return vNode;
            }
        }
        if (assertDefined(), vnode_isVNode(refElement)) {
            vNode = refElement;
        } else {
            assertTrue(containerElement.contains(refElement));
            let parent = refElement;
            const elementPath = [ refElement ];
            for (;parent && parent !== containerElement && !parent.vNode; ) {
                parent = parent.parentElement, elementPath.push(parent);
            }
            parent.vNode && (vNode = parent.vNode);
            for (let i = elementPath.length - 2; i >= 0; i--) {
                vNode = vnode_getVNodeForChildNode(vNode, elementPath[i]);
            }
            -1 != elementOffset && (refElement.vNode = vNode, qVNodeRefs.set(elementOffset, vNode));
        }
        if ("string" == typeof id) {
            const idLength = id.length;
            let idx = indexOfAlphanumeric(id, idLength);
            let childIdx = 0;
            for (;idx < idLength; ) {
                const ch = id.charCodeAt(idx);
                childIdx *= 26, ch >= 97 ? childIdx += ch - 97 : (childIdx += ch - 65, vNode = vnode_getChildWithIdx(vNode, childIdx), 
                childIdx = 0), idx++;
            }
        }
        return vNode;
    };
    const vnode_getChildWithIdx = (vNode, childIdx) => {
        let child = vnode_getFirstChild(vNode);
        for (assertDefined(); child.flags >>> 8 !== childIdx; ) {
            child = child.nextSibling, assertDefined();
        }
        return child;
    };
    const vNodeStack = [];
    const vnode_getVNodeForChildNode = (vNode, childElement) => {
        ensureElementVNode(vNode);
        let child = vnode_getFirstChild(vNode);
        for (assertDefined(); child && (!(child instanceof ElementVNode) || child.element !== childElement); ) {
            if (vnode_isVirtualVNode(child)) {
                const next = child.nextSibling;
                const firstChild = vnode_getFirstChild(child);
                firstChild ? (next && vNodeStack.push(next), child = firstChild) : child = next || (vNodeStack.length ? vNodeStack.pop() : null);
            } else {
                const next = child.nextSibling;
                child = next || (next || vNodeStack.pop());
            }
            assertDefined();
        }
        for (;vNodeStack.length; ) {
            vNodeStack.pop();
        }
        return ensureElementVNode(child), assertEqual(), child;
    };
    const indexOfAlphanumeric = (id, length) => {
        let idx = 0;
        for (;idx < length; ) {
            if (!(id.charCodeAt(idx) <= 57)) {
                return idx;
            }
            idx++;
        }
        return length;
    };
    const parseBoolean = value => "false" !== value && Boolean(value);
    const isBooleanAttr = (element, key) => ("allowfullscreen" == key || "async" == key || "autofocus" == key || "autoplay" == key || "checked" == key || "controls" == key || "default" == key || "defer" == key || "disabled" == key || "formnovalidate" == key || "inert" == key || "ismap" == key || "itemscope" == key || "loop" == key || "multiple" == key || "muted" == key || "nomodule" == key || "novalidate" == key || "open" == key || "playsinline" == key || "readonly" == key || "required" == key || "reversed" == key || "selected" == key) && key in element;
    const vnode_applyJournal = journal => {
        let idx = 0;
        const length = journal.length;
        for (;idx < length; ) {
            switch (journal[idx++]) {
              case 1:
                journal[idx++].nodeValue = journal[idx++];
                break;

              case 2:
                const element = journal[idx++];
                let key = journal[idx++];
                "className" === key && (key = "class");
                const value = journal[idx++];
                isBooleanAttr(element, key) ? element[key] = parseBoolean(value) : "value" === key && key in element ? element.value = String(value) : "dangerouslySetInnerHTML" === key ? (element.innerHTML = value, 
                element.setAttribute("q:container", "html")) : null == value || !1 === value ? element.removeAttribute(key) : element.setAttribute(key, String(value));
                break;

              case 3:
                const document = journal[idx++];
                const head = document.head;
                const styles = document.querySelectorAll("style[q\\:style],style[q\\:sstyle]");
                for (let i = 0; i < styles.length; i++) {
                    head.appendChild(styles[i]);
                }
                break;

              case 4:
                const removeParent = journal[idx++];
                let nodeToRemove;
                for (;idx < length && "number" != typeof (nodeToRemove = journal[idx]); ) {
                    removeParent.removeChild(nodeToRemove), idx++;
                }
                break;

              case 5:
                const removeAllParent = journal[idx++];
                removeAllParent.replaceChildren ? removeAllParent.replaceChildren() : removeAllParent.textContent = "";
                break;

              case 6:
                const insertParent = journal[idx++];
                const insertBefore = journal[idx++];
                let newChild;
                for (;idx < length && "number" != typeof (newChild = journal[idx]); ) {
                    insertParent.insertBefore(newChild, insertBefore), idx++;
                }
            }
        }
        journal.length = 0;
    };
    const vnode_insertBefore = (journal, parent, newChild, insertBefore) => {
        var vNode;
        vNode = parent, assertDefined(), assertTrue(vnode_getNodeTypeName(vNode)), vnode_isElementVNode(parent) && ensureMaterialized(parent);
        const newChildCurrentParent = newChild.parent;
        if (newChild === insertBefore) {
            if (newChildCurrentParent) {
                return;
            }
            insertBefore = null;
        }
        const domParentVNode = vnode_getDomParentVNode(parent, !1);
        const parentNode = domParentVNode && domParentVNode.element;
        let domChildren = null;
        domParentVNode && (domChildren = function(journal, domParentVNode, newChild) {
            const {elementNamespace, elementNamespaceFlag} = getNewElementNamespaceData(domParentVNode, newChild);
            let domChildren = [];
            if (elementNamespace === HTML_NS) {
                domChildren = vnode_getDOMChildNodes(journal, newChild);
            } else {
                const children = vnode_getDOMChildNodes(journal, newChild, !0);
                for (let i = 0; i < children.length; i++) {
                    const childVNode = children[i];
                    if (vnode_isTextVNode(childVNode)) {
                        domChildren.push(childVNode.textNode);
                        continue;
                    }
                    if ((192 & childVNode.flags) == (192 & domParentVNode.flags)) {
                        domChildren.push(childVNode.element);
                        continue;
                    }
                    const newChildElement = vnode_cloneElementWithNamespace(childVNode, domParentVNode, elementNamespace, elementNamespaceFlag);
                    newChildElement && domChildren.push(newChildElement);
                }
            }
            return domChildren;
        }(journal, domParentVNode, newChild)), newChildCurrentParent && (newChild.previousSibling || newChild.nextSibling || newChildCurrentParent !== parent) && vnode_remove(journal, newChildCurrentParent, newChild, !1);
        const parentIsDeleted = 32 & parent.flags;
        if (!parentIsDeleted) {
            let adjustedInsertBefore = null;
            null == insertBefore ? vnode_isVirtualVNode(parent) && (adjustedInsertBefore = vnode_getDomSibling(parent, !0, !1)) : adjustedInsertBefore = vnode_isVirtualVNode(insertBefore) ? vnode_getDomSibling(insertBefore, !0, !0) : insertBefore, 
            adjustedInsertBefore && ((journal, vNode) => {
                vnode_isTextVNode(vNode) && vnode_ensureTextInflated(journal, vNode);
            })(journal, adjustedInsertBefore), domChildren && domChildren.length && journal.push(6, parentNode, vnode_getNode(adjustedInsertBefore), ...domChildren);
        }
        const vNext = insertBefore;
        const vPrevious = vNext ? vNext.previousSibling : parent.lastChild;
        vNext ? vNext.previousSibling = newChild : parent.lastChild = newChild, vPrevious ? vPrevious.nextSibling = newChild : parent.firstChild = newChild, 
        newChild.previousSibling = vPrevious, newChild.nextSibling = vNext, newChild.parent = parent, 
        parentIsDeleted && (newChild.flags |= 32);
    };
    const vnode_getDomParent = (vnode, includeProjection = !0) => (vnode = vnode_getDomParentVNode(vnode, includeProjection)) && vnode.element;
    const vnode_getDomParentVNode = (vnode, includeProjection = !0) => {
        for (;vnode && !vnode_isElementVNode(vnode); ) {
            vnode = vnode.parent || (includeProjection ? vnode.slotParent : null);
        }
        return vnode;
    };
    const vnode_remove = (journal, vParent, vToRemove, removeDOM) => {
        if (assertEqual(), vnode_isTextVNode(vToRemove) && vnode_ensureTextInflated(journal, vToRemove), 
        removeDOM) {
            const domParent = vnode_getDomParent(vParent, !1);
            if (vParent.getAttr("dangerouslySetInnerHTML")) {
                return;
            }
            const children = vnode_getDOMChildNodes(journal, vToRemove);
            domParent && children.length && journal.push(4, domParent, ...children);
        }
        const vPrevious = vToRemove.previousSibling;
        const vNext = vToRemove.nextSibling;
        vPrevious ? vPrevious.nextSibling = vNext : vParent.firstChild = vNext, vNext ? vNext.previousSibling = vPrevious : vParent.lastChild = vPrevious, 
        vToRemove.previousSibling = null, vToRemove.nextSibling = null;
    };
    const vnode_getElementName = vnode => {
        const elementVNode = ensureElementVNode(vnode);
        let elementName = elementVNode.elementName;
        if (void 0 === elementName) {
            const element = elementVNode.element;
            const nodeName = fastNodeName(element).toLowerCase();
            elementName = elementVNode.elementName = nodeName, elementVNode.flags |= (element => {
                switch (fastNamespaceURI(element)) {
                  case SVG_NS:
                    return 64;

                  case MATH_NS:
                    return 128;

                  default:
                    return 0;
                }
            })(element);
        }
        return elementName;
    };
    const vnode_getText = textVNode => {
        let text = textVNode.text;
        return void 0 === text && (text = textVNode.text = textVNode.textNode.nodeValue), 
        text;
    };
    const vnode_getFirstChild = vnode => {
        if (vnode_isTextVNode(vnode)) {
            return null;
        }
        let vFirstChild = vnode.firstChild;
        return void 0 === vFirstChild && (vFirstChild = ensureMaterialized(vnode)), vFirstChild;
    };
    const materialize = (vNode, element, firstChild, vNodeData) => {
        if (vNodeData) {
            if (vNodeData.charCodeAt(0) === VNodeDataChar_SEPARATOR) {
                const elementVNodeDataStartIdx = 1;
                let elementVNodeDataEndIdx = 1;
                for (;vNodeData.charCodeAt(elementVNodeDataEndIdx) !== VNodeDataChar_SEPARATOR; ) {
                    elementVNodeDataEndIdx++;
                }
                const elementVNodeData = vNodeData.substring(elementVNodeDataStartIdx, elementVNodeDataEndIdx);
                vNodeData = vNodeData.substring(elementVNodeDataEndIdx + 1);
                const vFirstChild = materializeFromDOM(vNode, firstChild, elementVNodeData);
                if (!vNodeData) {
                    return vFirstChild;
                }
            }
            return function(vParent, vData, element, child) {
                let idx = 0;
                let vFirst = null;
                let vLast = null;
                let previousTextNode = null;
                const addVNode = node => {
                    node.flags = 255 & node.flags | idx << 8, idx++, vLast && (vLast.nextSibling = node), 
                    node.previousSibling = vLast, node.parent = vParent, vFirst || (vParent.firstChild = vFirst = node), 
                    vLast = node;
                };
                let textIdx = 0;
                let combinedText = null;
                let container = null;
                const shouldSkipNode = node => {
                    const nodeIsElement = isElement(node);
                    return !nodeIsElement || nodeIsElement && shouldSkipElement(node);
                };
                return processVNodeData$1(vData, (peek, consumeValue, consume, getChar, nextToConsumeIdx) => {
                    if (isNumber(peek())) {
                        for (;shouldSkipNode(child); ) {
                            if (!(child = fastNextSibling(child))) {
                                throw qError(27, [ vData, peek(), nextToConsumeIdx ]);
                            }
                        }
                        combinedText = null, previousTextNode = null;
                        let value = 0;
                        for (;isNumber(peek()); ) {
                            value *= 10, value += consume() - 48;
                        }
                        for (;value--; ) {
                            addVNode(vnode_newUnMaterializedElement(child)), child = fastNextSibling(child);
                        }
                    } else if (peek() === VNodeDataChar_SCOPED_STYLE) {
                        vParent.setAttr("q:sstyle", consumeValue(), null);
                    } else if (peek() === VNodeDataChar_RENDER_FN) {
                        vParent.setAttr("q:renderFn", consumeValue(), null);
                    } else if (peek() === VNodeDataChar_ID) {
                        container || (container = getDomContainer(element));
                        const id = consumeValue();
                        container.$setRawState$(parseInt(id), vParent), build.isDev && vParent.setAttr("q:id", id, null);
                    } else if (peek() === VNodeDataChar_PROPS) {
                        vParent.setAttr("q:props", consumeValue(), null);
                    } else if (peek() === VNodeDataChar_KEY) {
                        let value;
                        getChar(nextToConsumeIdx + 1) === VNodeDataChar_SEPARATOR ? (consume(), value = decodeURI(consumeValue()), 
                        consume()) : value = consumeValue(), vParent.setAttr("q:key", value, null);
                    } else if (peek() === VNodeDataChar_SEQ) {
                        vParent.setAttr("q:seq", consumeValue(), null);
                    } else if (peek() === VNodeDataChar_SEQ_IDX) {
                        vParent.setAttr("q:seqIdx", consumeValue(), null);
                    } else if (peek() === VNodeDataChar_BACK_REFS) {
                        container || (container = getDomContainer(element)), setEffectBackRefFromVNodeData(vParent, consumeValue(), container);
                    } else if (peek() === VNodeDataChar_SLOT_PARENT) {
                        container || (container = getDomContainer(element)), vParent.slotParent = vnode_locate(container.rootVNode, consumeValue());
                    } else if (peek() === VNodeDataChar_CONTEXT) {
                        vParent.setAttr("q:ctx", consumeValue(), null);
                    } else if (peek() === VNodeDataChar_OPEN) {
                        consume(), addVNode(vnode_newVirtual()), stack.push(vParent, vFirst, vLast, previousTextNode, idx), 
                        idx = 0, vParent = vLast, vFirst = vLast = null;
                    } else if (peek() === VNodeDataChar_SEPARATOR) {
                        const key = consumeValue();
                        const value = consumeValue();
                        vParent.setAttr(key, value, null);
                    } else if (peek() === VNodeDataChar_CLOSE) {
                        consume(), vParent.lastChild = vLast, idx = stack.pop(), previousTextNode = stack.pop(), 
                        vLast = stack.pop(), vFirst = stack.pop(), vParent = stack.pop();
                    } else if (peek() === VNodeDataChar_SLOT) {
                        vParent.setAttr(QSlot, consumeValue(), null);
                    } else {
                        for (;isElement(child) && shouldSkipElement(child); ) {
                            child = fastNextSibling(child);
                        }
                        const textNode = child && 3 === fastNodeType(child) ? child : null;
                        null === combinedText && (combinedText = textNode ? textNode.nodeValue : null, textIdx = 0);
                        let length = 0;
                        for (;isLowercase(peek()); ) {
                            length += consume() - 97, length *= 26;
                        }
                        length += consume() - 65;
                        const text = null === combinedText ? "" : combinedText.substring(textIdx, textIdx + length);
                        addVNode(previousTextNode = ((previousTextNode, sharedTextNode, textContent) => {
                            sharedTextNode && assertEqual(fastNodeType(sharedTextNode));
                            const vnode = new TextVNode(-252, null, previousTextNode, null, sharedTextNode, textContent);
                            return assertFalse(vnode_isElementVNode(vnode)), assertTrue(vnode_isTextVNode(vnode)), 
                            assertFalse(vnode_isVirtualVNode(vnode)), vnode;
                        })(previousTextNode, textNode, text)), textIdx += length;
                    }
                }), vParent.lastChild = vLast, vFirst;
            }(vNode, vNodeData, element, firstChild);
        }
        return materializeFromDOM(vNode, firstChild);
    };
    const ensureMaterialized = vnode => {
        const vParent = ensureElementVNode(vnode);
        let vFirstChild = vParent.firstChild;
        if (void 0 === vFirstChild) {
            vFirstChild = vParent.parent && shouldIgnoreChildren(vParent.element) ? vParent.firstChild = vParent.lastChild = null : (vNode => {
                const element = vNode.element;
                const firstChild = fastFirstChild(element);
                const vNodeData = element.ownerDocument?.qVNodeData?.get(element);
                return materialize(vNode, element, firstChild, vNodeData);
            })(vParent);
        }
        return assertTrue(), assertTrue(), vFirstChild;
    };
    let _fastHasAttribute = null;
    const shouldIgnoreChildren = node => (_fastHasAttribute || (_fastHasAttribute = node.hasAttribute), 
    _fastHasAttribute.call(node, "q:container"));
    let _fastNodeType = null;
    const fastNodeType = node => (_fastNodeType || (_fastNodeType = fastGetter(node, "nodeType")), 
    _fastNodeType.call(node));
    const fastIsTextOrElement = node => {
        const type = fastNodeType(node);
        return 3 === type || 1 === type;
    };
    let _fastNextSibling = null;
    const fastNextSibling = node => {
        for (_fastNextSibling || (_fastNextSibling = fastGetter(node, "nextSibling")), _fastFirstChild || (_fastFirstChild = fastGetter(node, "firstChild")); node; ) {
            if (null !== (node = _fastNextSibling.call(node))) {
                const type = fastNodeType(node);
                if (3 === type || 1 === type) {
                    break;
                }
                if (8 === type) {
                    const nodeValue = node.nodeValue;
                    if (nodeValue?.startsWith("q:ignore")) {
                        return getNodeAfterCommentNode(node, "q:container-island", _fastNextSibling, _fastFirstChild);
                    }
                    if (node.nodeValue?.startsWith("/q:container-island")) {
                        return getNodeAfterCommentNode(node, "/q:ignore", _fastNextSibling, _fastFirstChild);
                    }
                    if (nodeValue?.startsWith("q:container")) {
                        for (;node && (node = _fastNextSibling.call(node)) && (8 !== fastNodeType(node) || !node.nodeValue?.startsWith("/q:container")); ) {}
                    }
                }
            }
        }
        return node;
    };
    function getNodeAfterCommentNode(node, commentValue, nextSibling, firstChild) {
        for (;node; ) {
            if (node.nodeValue?.startsWith(commentValue)) {
                return node = nextSibling.call(node) || null;
            }
            let nextNode = firstChild.call(node);
            nextNode || (nextNode = nextSibling.call(node)), nextNode || (nextNode = fastParentNode(node), 
            nextNode && (nextNode = nextSibling.call(nextNode))), node = nextNode;
        }
        return null;
    }
    let _fastParentNode = null;
    const fastParentNode = node => (_fastParentNode || (_fastParentNode = fastGetter(node, "parentNode")), 
    _fastParentNode.call(node));
    let _fastFirstChild = null;
    const fastFirstChild = node => {
        for (_fastFirstChild || (_fastFirstChild = fastGetter(node, "firstChild")), node = node && _fastFirstChild.call(node); node && !fastIsTextOrElement(node); ) {
            node = fastNextSibling(node);
        }
        return node;
    };
    let _fastNamespaceURI = null;
    const fastNamespaceURI = element => (_fastNamespaceURI || (_fastNamespaceURI = fastGetter(element, "namespaceURI")), 
    _fastNamespaceURI.call(element));
    let _fastNodeName = null;
    const fastNodeName = element => (_fastNodeName || (_fastNodeName = fastGetter(element, "nodeName")), 
    _fastNodeName.call(element));
    const fastGetter = (prototype, name) => {
        let getter;
        for (;prototype && !(getter = Object.getOwnPropertyDescriptor(prototype, name)?.get); ) {
            prototype = Object.getPrototypeOf(prototype);
        }
        return getter || function() {
            return this[name];
        };
    };
    const hasQStyleAttribute = element => "STYLE" === element.nodeName && (element.hasAttribute("q:sstyle") || element.hasAttribute("q:style"));
    const hasPropsSeparator = element => element.hasAttribute(":");
    const materializeFromDOM = (vParent, firstChild, vData) => {
        let vFirstChild = null;
        const skipElements = () => {
            for (;isElement(child) && shouldSkipElement(child); ) {
                child = fastNextSibling(child);
            }
        };
        let child = firstChild;
        skipElements();
        let vChild = null;
        for (;child; ) {
            const nodeType = fastNodeType(child);
            let vNextChild = null;
            3 === nodeType ? vNextChild = vnode_newText(child, child.textContent ?? void 0) : 1 === nodeType && (vNextChild = vnode_newUnMaterializedElement(child)), 
            vNextChild && (vNextChild.parent = vParent, vChild && (vChild.nextSibling = vNextChild), 
            vNextChild.previousSibling = vChild, vChild = vNextChild), vFirstChild || (vParent.firstChild = vFirstChild = vChild), 
            child = fastNextSibling(child), skipElements();
        }
        if (vParent.lastChild = vChild || null, vParent.firstChild = vFirstChild, vData) {
            let container = null;
            processVNodeData$1(vData, (peek, consumeValue) => {
                if (peek() === VNodeDataChar_ID) {
                    container || (container = getDomContainer(vParent.element));
                    const id = consumeValue();
                    container.$setRawState$(parseInt(id), vParent), build.isDev && vParent.setAttr("q:id", id, null);
                } else {
                    peek() === VNodeDataChar_BACK_REFS ? (container || (container = getDomContainer(vParent.element)), 
                    setEffectBackRefFromVNodeData(vParent, consumeValue(), container)) : consumeValue();
                }
            });
        }
        return vFirstChild;
    };
    function setEffectBackRefFromVNodeData(vParent, value, container) {
        if (vParent[_EFFECT_BACK_REF]) {
            ((map1, map2) => {
                for (const [k, v] of map2) {
                    map1.set(k, v);
                }
            })(vParent[_EFFECT_BACK_REF], container.$getObjectById$(value));
        } else {
            Object.defineProperty(vParent, _EFFECT_BACK_REF, {
                get() {
                    const subMap = container.$getObjectById$(value);
                    return vParent[_EFFECT_BACK_REF] = subMap, subMap;
                },
                set(value) {
                    Object.defineProperty(vParent, _EFFECT_BACK_REF, {
                        value,
                        writable: !0,
                        enumerable: !0,
                        configurable: !0
                    });
                },
                enumerable: !0,
                configurable: !0
            });
        }
    }
    const processVNodeData$1 = (vData, callback) => {
        let nextToConsumeIdx = 0;
        let ch = 0;
        let peekCh = 0;
        const getChar = idx => idx < vData.length ? vData.charCodeAt(idx) : 0;
        const peek = () => 0 !== peekCh ? peekCh : peekCh = getChar(nextToConsumeIdx);
        const consume = () => (ch = peek(), peekCh = 0, nextToConsumeIdx++, ch);
        const consumeValue = () => {
            consume();
            const start = nextToConsumeIdx;
            for (;peek() <= 58 && 0 !== peekCh || 95 === peekCh || peekCh >= 65 && peekCh <= 90 || peekCh >= 97 && peekCh <= 122; ) {
                consume();
            }
            return vData.substring(start, nextToConsumeIdx);
        };
        for (;0 !== peek(); ) {
            callback(peek, consumeValue, consume, getChar, nextToConsumeIdx);
        }
    };
    const vnode_getAttrKeys = vnode => {
        if (3 & vnode.flags) {
            vnode_ensureElementInflated(vnode);
            const keys = [];
            const props = vnode_getProps(vnode);
            for (let i = 0; i < props.length; i += 2) {
                const key = props[i];
                key.startsWith(":") || keys.push(key);
            }
            return keys;
        }
        return [];
    };
    const vnode_getProps = vnode => (vnode.props ||= [], vnode.props);
    const vnode_getProjectionParentOrParent = vnode => vnode.parent || vnode.slotParent;
    const vnode_getNode = vnode => null === vnode || vnode_isVirtualVNode(vnode) ? null : vnode_isElementVNode(vnode) ? vnode.element : (assertTrue(vnode_isTextVNode(vnode)), 
    vnode.textNode);
    function vnode_toString(depth = 20, offset = "", materialize = !1, siblings = !1, colorize = !0) {
        let vnode = this;
        if (0 === depth) {
            return "...";
        }
        if (null === vnode) {
            return "null";
        }
        if (void 0 === vnode) {
            return "undefined";
        }
        const strings = [];
        do {
            if (vnode_isTextVNode(vnode)) {
                strings.push(qwikDebugToString(vnode_getText(vnode)));
            } else if (vnode_isVirtualVNode(vnode)) {
                const attrs = [ "[" + String(vnode.flags >>> 8) + "]" ];
                vnode_getAttrKeys(vnode).forEach(key => {
                    if ("q:type" !== key) {
                        const value = vnode.getAttr(key);
                        attrs.push(" " + key + "=" + qwikDebugToString(value));
                    }
                });
                const name = (colorize ? "[34m" : "") + (VirtualTypeName[vnode.getAttr("q:type") || "V"] || VirtualTypeName.V) + (colorize ? "[0m" : "");
                strings.push("<" + name + attrs.join("") + ">");
                const child = vnode_getFirstChild(vnode);
                child && strings.push("  " + vnode_toString.call(child, depth - 1, offset + "  ", !0, !0, colorize)), 
                strings.push("</" + name + ">");
            } else if (vnode_isElementVNode(vnode)) {
                const tag = vnode_getElementName(vnode);
                const attrs = [];
                const keys = vnode_getAttrKeys(vnode);
                keys.forEach(key => {
                    const value = vnode.getAttr(key);
                    attrs.push(" " + key + "=" + qwikDebugToString(value));
                });
                const node = vnode_getNode(vnode);
                if (node) {
                    const vnodeData = node.ownerDocument.qVNodeData?.get(node);
                    vnodeData && attrs.push(" q:vnodeData=" + qwikDebugToString(vnodeData));
                }
                const domAttrs = node.attributes;
                for (let i = 0; i < domAttrs.length; i++) {
                    const attr = domAttrs[i];
                    -1 === keys.indexOf(attr.name) && attrs.push(" " + attr.name + (attr.value ? "=" + qwikDebugToString(attr.value) : ""));
                }
                if (strings.push("<" + tag + attrs.join("") + ">"), vnode_isMaterialized(vnode) || materialize) {
                    const child = vnode_getFirstChild(vnode);
                    child && strings.push("  " + vnode_toString.call(child, depth - 1, offset + "  ", !0, !0, colorize));
                } else {
                    strings.push("  \x3c!-- not materialized --!>");
                }
                strings.push("</" + tag + ">");
            }
            vnode = siblings && vnode.nextSibling || null;
        } while (vnode);
        return strings.join("\n" + offset);
    }
    const isNumber = ch => 48 <= ch && ch <= 57;
    const isLowercase = ch => 97 <= ch && ch <= 122;
    function shouldSkipElement(element) {
        return !hasPropsSeparator(element) || hasQStyleAttribute(element);
    }
    const stack = [];
    const isElement = node => node && "object" == typeof node && 1 === fastNodeType(node);
    let _context;
    const tryGetInvokeContext = () => {
        if (!_context) {
            const context = "undefined" != typeof document && document && document.__q_context__;
            if (!context) {
                return;
            }
            return isArray(context) ? document.__q_context__ = newInvokeContextFromTuple(context) : context;
        }
        return _context;
    };
    const getInvokeContext = () => {
        const ctx = tryGetInvokeContext();
        if (!ctx) {
            throw qError(9);
        }
        return ctx;
    };
    const useInvokeContext = () => {
        const ctx = tryGetInvokeContext();
        if (!ctx || "qRender" !== ctx.$event$) {
            throw qError(10);
        }
        return assertDefined(), assertDefined(), ctx;
    };
    function useBindInvokeContext(fn) {
        if (null == fn) {
            return fn;
        }
        const ctx = getInvokeContext();
        return function(...args) {
            return invokeApply.call(this, ctx, fn, args);
        };
    }
    function invoke(context, fn, ...args) {
        return invokeApply.call(this, context, fn, args);
    }
    function invokeApply(context, fn, args) {
        const previousContext = _context;
        let returnValue;
        try {
            _context = context, returnValue = fn.apply(this, args);
        } finally {
            _context = previousContext;
        }
        return returnValue;
    }
    const newInvokeContextFromTuple = ([element, event, url]) => {
        const domContainer = getDomContainer(element);
        const hostElement = vnode_locate(domContainer.rootVNode, element);
        const locale = domContainer.$locale$;
        return locale && function(locale) {
            localAsyncStore ? localAsyncStore.enterWith(locale) : _locale = locale;
        }(locale), newInvokeContext(locale, hostElement, element, event, url);
    };
    const newInvokeContext = (locale, hostElement, element, event, url) => {
        const ctx = {
            $url$: url,
            $hostElement$: hostElement,
            $element$: element,
            $event$: event,
            $qrl$: void 0,
            $effectSubscriber$: void 0,
            $locale$: locale || (event && isObject(event) && "locale" in event ? event.locale : void 0),
            $container$: void 0
        };
        return seal(), ctx;
    };
    const untrack = fn => {
        if (!_context) {
            return fn();
        }
        {
            const sub = _context.$effectSubscriber$;
            try {
                return _context.$effectSubscriber$ = void 0, fn();
            } finally {
                _context.$effectSubscriber$ = sub;
            }
        }
    };
    const trackInvocation = /*#__PURE__*/ newInvokeContext(void 0, void 0, void 0, "qRender");
    const trackSignal = (fn, subscriber, property, container, data) => {
        const previousSubscriber = trackInvocation.$effectSubscriber$;
        const previousContainer = trackInvocation.$container$;
        try {
            return trackInvocation.$effectSubscriber$ = getSubscriber(subscriber, property, data), 
            trackInvocation.$container$ = container, invoke(trackInvocation, fn);
        } finally {
            trackInvocation.$effectSubscriber$ = previousSubscriber, trackInvocation.$container$ = previousContainer;
        }
    };
    const trackSignalAndAssignHost = (value, host, property, container, data) => (value instanceof WrappedSignalImpl && value.$hostElement$ !== host && host && (value.$hostElement$ = host), 
    trackSignal(() => value.value, host, property, container, data));
    const useSequentialScope = () => {
        const iCtx = useInvokeContext();
        const host = iCtx.$hostElement$;
        let seq = iCtx.$container$.getHostProp(host, "q:seq");
        null === seq && (seq = [], iCtx.$container$.setHostProp(host, "q:seq", seq));
        let seqIdx = iCtx.$container$.getHostProp(host, "q:seqIdx");
        for (null === seqIdx && (seqIdx = 0), iCtx.$container$.setHostProp(host, "q:seqIdx", seqIdx + 1); seq.length <= seqIdx; ) {
            seq.push(void 0);
        }
        return {
            val: seq[seqIdx],
            set: value => seq[seqIdx] = value,
            i: seqIdx,
            iCtx
        };
    };
    const createContextId = name => (assertTrue(/^[\w/.-]+$/.test(name)), /*#__PURE__*/ Object.freeze({
        id: fromCamelToKebabCase(name)
    }));
    const useContextProvider = (context, newValue) => {
        const {val, set, iCtx} = useSequentialScope();
        void 0 === val && (iCtx.$container$.setContext(iCtx.$hostElement$, context, newValue), 
        set(1));
    };
    const ERROR_CONTEXT = /*#__PURE__*/ createContextId("qk-error");
    class SubscriptionData {
        data;
        constructor(data) {
            this.data = data;
        }
    }
    const useLexicalScope = () => {
        const context = getInvokeContext();
        let qrl = context.$qrl$;
        if (qrl) {
            assertQrl(qrl), assertDefined();
        } else {
            const el = context.$element$;
            assertDefined();
            const containerElement = _getQContainerElement(el);
            assertDefined();
            qrl = getDomContainer(containerElement).parseQRL(decodeURIComponent(String(context.$url$)));
        }
        return qrl.$captureRef$;
    };
    const _val = (_, element) => {
        const [signal] = useLexicalScope();
        signal.value = "number" === element.type ? element.valueAsNumber : element.value;
    };
    const _chk = (_, element) => {
        const [signal] = useLexicalScope();
        signal.value = element.checked;
    };
    class JSXNodeImpl {
        type;
        toSort;
        key;
        varProps;
        constProps;
        children;
        dev;
        _proxy=null;
        constructor(type, varProps, constProps, children, key, toSort, dev) {
            if (this.type = type, this.toSort = !!toSort, this.key = null == key ? null : String(key), 
            this.varProps = !varProps || isEmpty(varProps) ? EMPTY_OBJ : varProps, this.constProps = !constProps || isEmpty(constProps) ? null : constProps, 
            this.children = children, "string" == typeof type) {
                for (const k in this.constProps) {
                    const attr = jsxEventToHtmlAttribute(k);
                    attr && (mergeHandlers(this.constProps, attr, this.constProps[k]), delete this.constProps[k]);
                }
                for (const k in this.varProps) {
                    const attr = jsxEventToHtmlAttribute(k);
                    attr && (constProps && k in constProps || (toSort = mergeHandlers(this.varProps, attr, this.varProps[k]) || toSort), 
                    delete this.varProps[k]);
                }
                "bind:checked" in this.varProps ? toSort = handleBindProp(this.varProps, "bind:checked") || toSort : "bind:value" in this.varProps ? toSort = handleBindProp(this.varProps, "bind:value") || toSort : this.constProps && ("bind:checked" in this.constProps ? handleBindProp(this.constProps, "bind:checked") : "bind:value" in this.constProps && handleBindProp(this.constProps, "bind:value")), 
                "className" in this.varProps && (this.varProps.class = this.varProps.className, 
                this.varProps.className = void 0, toSort = !0), this.constProps && "className" in this.constProps && (this.constProps.class = this.constProps.className, 
                this.constProps.className = void 0);
            }
            seal();
        }
        get props() {
            return this._proxy ||= createPropsProxy(this);
        }
    }
    const mergeHandlers = (obj, event, handler) => {
        let current = obj[event];
        if (!current) {
            return obj[event] = handler, !0;
        }
        Array.isArray(current) ? current.push(handler) : current = obj[event] = [ current, handler ];
    };
    const isJSXNode = n => n instanceof JSXNodeImpl;
    const isEmpty = obj => {
        for (const prop in obj) {
            if (void 0 !== obj[prop]) {
                return !1;
            }
        }
        return !0;
    };
    const handleBindProp = (props, prop) => {
        const value = props[prop];
        if (props[prop] = void 0, value) {
            return "bind:checked" === prop ? (props.checked = value, props["on:input"] = createQRL(null, "_chk", _chk, null, null, [ value ])) : (props.value = value, 
            props["on:input"] = createQRL(null, "_val", _val, null, null, [ value ])), !0;
        }
    };
    const _jsxSorted = (type, varProps, constProps, children, flags, key, dev) => untrack(() => new JSXNodeImpl(type, varProps, constProps, children, key, !1, dev));
    const _jsxSplit = (type, varProps, constProps, children, flags, key, dev) => untrack(() => {
        if (varProps) {
            for (const k in varProps) {
                "children" === k ? (children ||= varProps.children, varProps.children = void 0) : "key" === k ? (key ||= varProps.key, 
                varProps.key = void 0) : constProps && k in constProps && (varProps[k] = void 0);
            }
        }
        return new JSXNodeImpl(type, varProps, constProps, children, key, !0, dev);
    });
    const Virtual = props => props.children;
    const jsx = (type, props, key, _isStatic, dev) => _jsxSplit(type, props, null, null, 0, key, dev);
    const jsxDEV = jsx;
    const jsxs = jsx;
    function h(type, props, ...children) {
        const normalizedProps = {
            children: arguments.length > 2 ? children.flat(100) : null
        };
        let key = null;
        for (const i in props) {
            "key" == i ? key = props[i] : normalizedProps[i] = props[i];
        }
        return "string" == typeof type && !key && "dangerouslySetInnerHTML" in normalizedProps && (key = "innerhtml"), 
        _jsxSplit(type, props, null, normalizedProps.children, 0, key);
    }
    const Fragment = props => props.children;
    const RenderOnce = (props, key) => new JSXNodeImpl(Virtual, null, null, props.children, key);
    const useTaskQrl = qrl => {
        const {val, set, iCtx, i} = useSequentialScope();
        if (val) {
            return;
        }
        assertQrl(qrl), set(1);
        const task = new Task(10, i, iCtx.$hostElement$, qrl, void 0, null);
        set(task);
        const result = runTask(task, iCtx.$container$, iCtx.$hostElement$);
        if (isPromise(result)) {
            throw result;
        }
    };
    const runTask = (task, container, host) => {
        task.$flags$ &= -9, cleanupTask(task);
        const iCtx = newInvokeContext(container.$locale$, host, void 0, "qTask");
        iCtx.$container$ = container;
        const taskFn = task.$qrl$.getFn(iCtx, () => clearAllEffects(container, task));
        const track = trackFn(task, container);
        const [cleanup] = cleanupFn(task, reason => container.handleError(reason, host));
        const taskApi = {
            track,
            cleanup
        };
        return safeCall(() => taskFn(taskApi), cleanup, err => {
            if (isPromise(err)) {
                return err.then(() => runTask(task, container, host));
            }
            throw err;
        });
    };
    const cleanupTask = task => {
        const destroy = task.$destroy$;
        if (destroy) {
            task.$destroy$ = null;
            try {
                destroy();
            } catch (err) {
                ((message, ...optionalParams) => {
                    createAndLogError(!1, message, ...optionalParams);
                })(err);
            }
        }
    };
    class Task extends BackRef$1 {
        $flags$;
        $index$;
        $el$;
        $qrl$;
        $state$;
        $destroy$;
        constructor($flags$, $index$, $el$, $qrl$, $state$, $destroy$) {
            super(), this.$flags$ = $flags$, this.$index$ = $index$, this.$el$ = $el$, this.$qrl$ = $qrl$, 
            this.$state$ = $state$, this.$destroy$ = $destroy$;
        }
    }
    const isTask = value => value instanceof Task;
    const scheduleTask = (_event, element) => {
        const [task] = useLexicalScope();
        const type = 1 & task.$flags$ ? 16 : 3;
        getDomContainer(element).$scheduler$(type, task);
    };
    const useResourceQrl = (qrl, opts) => {
        const {val, set, i, iCtx} = useSequentialScope();
        if (null != val) {
            return val;
        }
        assertQrl(qrl);
        const container = iCtx.$container$;
        const resource = createResourceReturn(container, opts);
        const el = iCtx.$hostElement$;
        const task = new Task(12, i, el, qrl, resource, null);
        return set(resource), runResource(task, container, el), resource;
    };
    const createResourceReturn = (container, opts, initialPromise) => {
        const result = (opts => ({
            __brand: "resource",
            value: void 0,
            loading: !isServerPlatform(),
            _resolved: void 0,
            _error: void 0,
            _state: "pending",
            _timeout: opts?.timeout ?? -1,
            _cache: 0
        }))(opts);
        return result.value = initialPromise, createStore(container, result, 1);
    };
    const isResourceReturn = obj => isObject(obj) && "resource" === (getStoreTarget(obj) || obj).__brand;
    const runResource = (task, container, host) => {
        task.$flags$ &= -9, cleanupTask(task);
        const iCtx = newInvokeContext(container.$locale$, host, void 0, "qResource");
        iCtx.$container$ = container;
        const taskFn = task.$qrl$.getFn(iCtx, () => clearAllEffects(container, task));
        const resource = task.$state$;
        assertDefined();
        const track = trackFn(task, container);
        const [cleanup, cleanups] = cleanupFn(task, reason => container.handleError(reason, host));
        const resourceTarget = unwrapStore(resource);
        const opts = {
            track,
            cleanup,
            cache(policy) {
                let milliseconds = 0;
                milliseconds = "immutable" === policy ? 1 / 0 : policy, resource._cache = milliseconds;
            },
            previous: resourceTarget._resolved
        };
        let resolve;
        let reject;
        let done = !1;
        const setState = (resolved, value) => !done && (done = !0, resolved ? (done = !0, 
        resourceTarget.loading = !1, resourceTarget._state = "resolved", resourceTarget._resolved = value, 
        resourceTarget._error = void 0, resolve(value)) : (done = !0, resourceTarget.loading = !1, 
        resourceTarget._state = "rejected", resourceTarget._error = value, reject(value)), 
        isServerPlatform() || forceStoreEffects(resource, "_state"), !0);
        cleanups.push(() => {
            if (!0 === untrack(() => resource.loading)) {
                const value = untrack(() => resource._resolved);
                setState(!0, value);
            }
        }), invoke(iCtx, () => {
            resource._state = "pending", resource.loading = !isServerPlatform(), resource.value = new Promise((r, re) => {
                resolve = r, reject = re;
            });
        });
        const promise = safeCall(() => taskFn(opts), value => {
            setState(!0, value);
        }, err => {
            if (isPromise(err)) {
                return err.then(() => runResource(task, container, host));
            }
            setState(!1, err);
        });
        const timeout = resourceTarget._timeout;
        return timeout > 0 ? Promise.race([ promise, delay(timeout).then(() => {
            setState(!1, new Error("timeout")) && cleanupTask(task);
        }) ]) : promise;
    };
    const Slot = props => _jsxSorted(Virtual, null, {
        [QSlotS]: ""
    }, props.children, 0, props.name ?? "");
    const _constants = [ void 0, null, !0, !1, "", EMPTY_ARRAY, EMPTY_OBJ, NEEDS_COMPUTATION, STORE_ALL_PROPS, _UNINITIALIZED, Slot, Fragment, NaN, 1 / 0, -1 / 0, Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER - 1, Number.MIN_SAFE_INTEGER ];
    const _constantNames = [ "undefined", "null", "true", "false", "''", "EMPTY_ARRAY", "EMPTY_OBJ", "NEEDS_COMPUTATION", "STORE_ALL_PROPS", "_UNINITIALIZED", "Slot", "Fragment", "NaN", "Infinity", "-Infinity", "MAX_SAFE_INTEGER", "MAX_SAFE_INTEGER-1", "MIN_SAFE_INTEGER" ];
    const _typeIdNames = [ "Plain", "RootRef", "ForwardRef", "Constant", "Array", "Object", "URL", "Date", "Regex", "VNode", "RefVNode", "BigInt", "URLSearchParams", "ForwardRefs", "Error", "Promise", "Set", "Map", "Uint8Array", "QRL", "PreloadQRL", "Task", "Resource", "Component", "Signal", "WrappedSignal", "ComputedSignal", "AsyncComputedSignal", "SerializerSignal", "Store", "FormData", "JSXNode", "PropsProxy", "SubscriptionData" ];
    function qrlToString(serializationContext, value, raw) {
        let symbol = value.$symbol$;
        let chunk = value.$chunk$;
        const platform = getPlatform();
        if (platform) {
            const result = platform.chunkForSymbol(symbol, chunk, value.dev?.file);
            result && (chunk = result[1], symbol = result[0]);
        }
        if (isSyncQrl(value)) {
            chunk = "", symbol = String(serializationContext.$addSyncFn$(null, 0, value.resolved));
        } else {
            if (chunk || (chunk = serializationContext.$symbolToChunkResolver$(value.$hash$)), 
            build.isDev) {
                (globalThis.__qrl_back_channel__ ||= new Map).set(value.$symbol$, value.resolved), 
                chunk || (chunk = QRL_RUNTIME_CHUNK);
            }
            if (!chunk) {
                throw qError(14, [ value.$symbol$ ]);
            }
            chunk.startsWith("./") && (chunk = chunk.slice(2));
        }
        if (!value.$capture$ && Array.isArray(value.$captureRef$) && value.$captureRef$.length > 0 && (value.$capture$ = value.$captureRef$.map(ref => `${serializationContext.$addRoot$(ref)}`)), 
        raw) {
            return [ chunk, symbol, value.$capture$ ];
        }
        let qrlStringInline = `${chunk}#${symbol}`;
        return value.$capture$ && value.$capture$.length > 0 && (qrlStringInline += `[${value.$capture$.join(" ")}]`), 
        qrlStringInline;
    }
    function createQRLWithBackChannel(chunk, symbol, captureIds) {
        let qrlRef = null;
        if (build.isDev && chunk === QRL_RUNTIME_CHUNK) {
            const backChannel = globalThis.__qrl_back_channel__;
            assertDefined(), qrlRef = backChannel.get(symbol);
        }
        return createQRL(chunk, symbol, qrlRef, null, captureIds, null);
    }
    const QRL_RUNTIME_CHUNK = "mock-chunk";
    const resolvers = new WeakMap;
    const pendingStoreTargets = new Map;
    const allocate = (container, typeId, value) => {
        switch (typeId) {
          case 0:
          case 13:
            return value;

          case 1:
            return container.$getObjectById$(value);

          case 2:
            if (!container.$forwardRefs$) {
                return _UNINITIALIZED;
            }
            const rootRef = container.$forwardRefs$[value];
            return -1 === rootRef || void 0 === rootRef ? _UNINITIALIZED : container.$getObjectById$(rootRef);

          case 3:
            return _constants[value];

          case 4:
            return Array(value.length / 2);

          case 5:
            return {};

          case 19:
          case 20:
            if ("string" == typeof value) {
                const data = value.split(" ").map(Number);
                return createQRLWithBackChannel(container.$getObjectById$(data[0]), container.$getObjectById$(data[1]), data.length > 2 ? data.slice(2) : null);
            }
            return createQRLWithBackChannel("", String(value));

          case 21:
            return new Task(-1, -1, null, null, null, null);

          case 22:
            {
                const res = createResourceReturn(container, void 0, void 0);
                return res.loading = !1, res;
            }

          case 6:
            return new URL(value);

          case 7:
            return new Date(value);

          case 8:
            const idx = value.lastIndexOf("/");
            return new RegExp(value.slice(1, idx), value.slice(idx + 1));

          case 14:
            return new Error;

          case 23:
            return componentQrl(null);

          case 24:
            return new SignalImpl(container, 0);

          case 25:
            return new WrappedSignalImpl(container, null, null, null);

          case 26:
            return new ComputedSignalImpl(container, null);

          case 27:
            return new AsyncComputedSignalImpl(container, null);

          case 28:
            return new SerializerSignalImpl(container, null);

          case 29:
            {
                const data = value;
                const t = data[0];
                const v = data[1];
                const storeValue = allocate(container, t, v);
                const store = getOrCreateStore(storeValue, 0, container);
                return needsInflation(t) && pendingStoreTargets.set(storeValue, {
                    t,
                    v
                }), data[0] = 0, data[1] = storeValue, store;
            }

          case 12:
            return new URLSearchParams(value);

          case 30:
            return new FormData;

          case 31:
            return new JSXNodeImpl(null);

          case 11:
            return BigInt(value);

          case 16:
            return new Set;

          case 17:
            return new Map;

          case 15:
            let resolve;
            let reject;
            const promise = new Promise((res, rej) => {
                resolve = res, reject = rej;
            });
            return resolvers.set(promise, [ resolve, reject ]), promise.catch(() => {}), promise;

          case 18:
            const encodedLength = value.length;
            const rest = 3 & encodedLength;
            return new Uint8Array(3 * (encodedLength >>> 2) + (rest ? rest - 1 : 0));

          case 32:
            return createPropsProxy(null);

          case 9:
            return retrieveVNodeOrDocument(container, value);

          case 10:
            const vNode = retrieveVNodeOrDocument(container, value);
            if (vnode_isVNode(vNode)) {
                return ensureMaterialized(vNode), vnode_getNode(vNode);
            }
            throw qError(17, [ typeof vNode ]);

          case 33:
            return new SubscriptionData({});

          default:
            throw qError(18, [ typeId ]);
        }
    };
    function retrieveVNodeOrDocument(container, value) {
        return value ? container.rootVNode ? vnode_locate(container.rootVNode, value) : void 0 : container.element?.ownerDocument;
    }
    const EXTRACT_IMPORT_PATH = /\(\s*(['"])([^\1]+)\1\s*\)/;
    const EXTRACT_SELF_IMPORT = /Promise\s*\.\s*resolve/;
    const EXTRACT_FILE_NAME = /[\\/(]([\w\d.\-_]+\.(js|ts)x?):/;
    const qrl = (chunkOrFn, symbol, lexicalScopeCapture = EMPTY_ARRAY, stackOffset = 0) => {
        let chunk = null;
        let symbolFn = null;
        if (isFunction(chunkOrFn)) {
            symbolFn = chunkOrFn;
            {
                let match;
                const srcCode = String(chunkOrFn);
                if ((match = srcCode.match(EXTRACT_IMPORT_PATH)) && match[2]) {
                    chunk = match[2];
                } else {
                    if (!(match = srcCode.match(EXTRACT_SELF_IMPORT))) {
                        throw qError(6, [ srcCode ]);
                    }
                    {
                        const ref = "QWIK-SELF";
                        const frames = new Error(ref).stack.split("\n");
                        const start = frames.findIndex(f => f.includes(ref));
                        match = frames[start + 2 + stackOffset].match(EXTRACT_FILE_NAME), chunk = match ? match[1] : "main";
                    }
                }
            }
        } else {
            if (!isString(chunkOrFn)) {
                throw qError(7, [ chunkOrFn ]);
            }
            chunk = chunkOrFn;
        }
        return createQRL(chunk, symbol, null, symbolFn, null, lexicalScopeCapture);
    };
    const inlinedQrl = (symbol, symbolName, lexicalScopeCapture = EMPTY_ARRAY) => createQRL(null, symbolName, symbol, null, null, lexicalScopeCapture);
    const _noopQrl = (symbolName, lexicalScopeCapture = EMPTY_ARRAY) => createQRL(null, symbolName, null, null, null, lexicalScopeCapture);
    const executeComponent = (container, renderHost, subscriptionHost, componentQRL, props) => {
        const iCtx = newInvokeContext(container.$locale$, subscriptionHost || void 0, void 0, "qRender");
        let componentFn;
        subscriptionHost && (iCtx.$effectSubscriber$ = getSubscriber(subscriptionHost, ":"), 
        iCtx.$container$ = container), container.ensureProjectionResolved(renderHost);
        let isInlineComponent = !1;
        if (null === componentQRL && (componentQRL = container.getHostProp(renderHost, "q:renderFn"), 
        assertDefined()), isQrl(componentQRL)) {
            "children" in (props = props || container.getHostProp(renderHost, "q:props") || EMPTY_OBJ) && delete props.children, 
            componentFn = componentQRL.getFn(iCtx);
        } else if (isQwikComponent(componentQRL)) {
            const qComponentFn = componentQRL;
            componentFn = () => invokeApply(iCtx, qComponentFn, [ props || EMPTY_OBJ, null, 0 ]);
        } else {
            isInlineComponent = !0;
            const inlineComponent = componentQRL;
            componentFn = () => invokeApply(iCtx, inlineComponent, [ props || EMPTY_OBJ ]);
        }
        const executeComponentWithPromiseExceptionRetry = (retryCount = 0) => safeCall(() => (isInlineComponent || (container.setHostProp(renderHost, "q:seqIdx", null), 
        container.setHostProp(renderHost, ":onIdx", null)), retryCount > 0 && vnode_isVNode(renderHost) && clearAllEffects(container, renderHost), 
        componentFn(props)), jsx => {
            const useOnEvents = container.getHostProp(renderHost, ":on");
            return useOnEvents ? function(jsx, useOnEvents) {
                const jsxElement = findFirstElementNode(jsx);
                let jsxResult = jsx;
                const qVisibleEvent = "on:qvisible";
                return maybeThen(jsxElement, jsxElement => {
                    const isHeadless = !jsxElement;
                    let placeholderElement = null;
                    for (const key in useOnEvents) {
                        if (Object.prototype.hasOwnProperty.call(useOnEvents, key)) {
                            let targetElement = jsxElement;
                            let eventKey = key;
                            if (isHeadless) {
                                if (key !== qVisibleEvent && !key.startsWith("on-document:") && !key.startsWith("on-window:")) {
                                    build.isDev && logWarn('You are trying to add an event "' + key + '" using `useOn` hook, but a node to which you can add an event is not found. Please make sure that the component has a valid element node. ');
                                    continue;
                                }
                                if (!placeholderElement) {
                                    const [createdElement, newJsx] = injectPlaceholderElement(jsxResult);
                                    jsxResult = newJsx, placeholderElement = createdElement;
                                }
                                targetElement = placeholderElement;
                            }
                            targetElement && ("script" === targetElement.type && key === qVisibleEvent && (eventKey = "on-document:qinit", 
                            build.isDev && logWarn('You are trying to add an event "' + key + '" using the `useVisibleTask$` hook with the "intersection-observer" strategy, but a node to which you can add an event is not found. Using "document-ready" or "document-idle" instead.')), 
                            addUseOnEvent(targetElement, eventKey, useOnEvents[key]));
                        }
                    }
                    return jsxResult;
                });
            }(jsx, useOnEvents) : jsx;
        }, err => {
            if (isPromise(err) && retryCount < 100) {
                return err.then(() => executeComponentWithPromiseExceptionRetry(++retryCount));
            }
            if (retryCount >= 100) {
                throw new Error("Max retry count of component execution reached");
            }
            throw err;
        });
        return executeComponentWithPromiseExceptionRetry();
    };
    function addUseOnEvent(jsxElement, key, value) {
        const props = jsxElement.constProps ||= {};
        const propValue = props[key];
        null == propValue ? props[key] = value : Array.isArray(propValue) ? propValue.push(...value) : props[key] = [ propValue, ...value ];
        jsxElement.varProps[key] && (Array.isArray(propValue) ? propValue.push(...props[key]) : jsxElement.varProps[key] = [ propValue, ...value ], 
        props[key] = void 0);
    }
    function findFirstElementNode(jsx) {
        const queue = [ jsx ];
        for (;queue.length; ) {
            const jsx = queue.shift();
            if (isJSXNode(jsx)) {
                if ("string" == typeof jsx.type) {
                    return jsx;
                }
                queue.push(jsx.children);
            } else if (isArray(jsx)) {
                queue.push(...jsx);
            } else {
                if (isPromise(jsx)) {
                    return maybeThen(jsx, jsx => findFirstElementNode(jsx));
                }
                if (isSignal(jsx)) {
                    return findFirstElementNode(untrack(() => jsx.value));
                }
            }
        }
        return null;
    }
    function injectPlaceholderElement(jsx) {
        if (isJSXNode(jsx)) {
            const placeholder = createPlaceholderScriptNode();
            return jsx.type === Fragment || isQwikComponent(jsx.type) ? (null == jsx.children ? jsx.children = placeholder : isArray(jsx.children) ? jsx.children.push(placeholder) : jsx.children = [ jsx.children, placeholder ], 
            [ placeholder, jsx ]) : [ placeholder, _jsxSorted(Fragment, null, null, [ jsx, placeholder ], 0, null) ];
        }
        if ("object" != typeof (v = jsx) && "function" != typeof v && null != v) {
            const placeholder = createPlaceholderScriptNode();
            return [ placeholder, _jsxSorted(Fragment, null, null, [ jsx, placeholder ], 0, null) ];
        }
        var v;
        if (isArray(jsx) && jsx.length > 0) {
            const [createdElement, _] = injectPlaceholderElement(jsx[0]);
            return [ createdElement, jsx ];
        }
        return [ null, jsx ];
    }
    function createPlaceholderScriptNode() {
        return new JSXNodeImpl("script", null, {
            hidden: ""
        });
    }
    const SkipRender = Symbol("skip render");
    const SSRRaw = () => null;
    const SSRComment = () => null;
    const SSRStream = (props, key) => jsx(RenderOnce, {
        children: jsx(InternalSSRStream, props)
    }, key);
    const InternalSSRStream = () => null;
    function escapeHTML(html) {
        let escapedHTML = "";
        const length = html.length;
        let idx = 0;
        let lastIdx = idx;
        for (;idx < length; idx++) {
            const ch = html.charCodeAt(idx);
            if (60 === ch) {
                escapedHTML += html.substring(lastIdx, idx) + "&lt;";
            } else if (62 === ch) {
                escapedHTML += html.substring(lastIdx, idx) + "&gt;";
            } else if (38 === ch) {
                escapedHTML += html.substring(lastIdx, idx) + "&amp;";
            } else if (34 === ch) {
                escapedHTML += html.substring(lastIdx, idx) + "&quot;";
            } else {
                if (39 !== ch) {
                    continue;
                }
                escapedHTML += html.substring(lastIdx, idx) + "&#39;";
            }
            lastIdx = idx + 1;
        }
        return 0 === lastIdx ? html : escapedHTML + html.substring(lastIdx);
    }
    function getFileLocationFromJsx(jsxDev) {
        if (!jsxDev) {
            return null;
        }
        const sanitizedFileName = jsxDev.fileName?.replace(/\\/g, "/");
        return sanitizedFileName ? `${sanitizedFileName}:${jsxDev.lineNumber}:${jsxDev.columnNumber}` : null;
    }
    function isSlotProp(prop) {
        return !prop.startsWith("q:") && !prop.startsWith(":");
    }
    const styleContent = styleId => "" + styleId;
    function hasClassAttr(props) {
        return "class" in props || "className" in props;
    }
    function isClassAttr(key) {
        return "class" === key || "className" === key;
    }
    const addComponentStylePrefix = styleId => {
        if (styleId) {
            let idx = 0;
            do {
                styleId = styleId.substring(0, idx) + styleContent(styleId.substring(idx));
            } while (0 !== (idx = styleId.indexOf(" ", idx) + 1));
        }
        return styleId || null;
    };
    const unitlessNumbers = new Set([ "animationIterationCount", "aspectRatio", "borderImageOutset", "borderImageSlice", "borderImageWidth", "boxFlex", "boxFlexGroup", "boxOrdinalGroup", "columnCount", "columns", "flex", "flexGrow", "flexShrink", "gridArea", "gridRow", "gridRowEnd", "gridRowStart", "gridColumn", "gridColumnEnd", "gridColumnStart", "fontWeight", "lineClamp", "lineHeight", "opacity", "order", "orphans", "scale", "tabSize", "widows", "zIndex", "zoom", "MozAnimationIterationCount", "MozBoxFlex", "msFlex", "msFlexPositive", "WebkitAnimationIterationCount", "WebkitBoxFlex", "WebkitBoxOrdinalGroup", "WebkitColumnCount", "WebkitColumns", "WebkitFlex", "WebkitFlexGrow", "WebkitFlexShrink", "WebkitLineClamp" ]);
    const hashCode = (text, hash = 0) => {
        for (let i = 0; i < text.length; i++) {
            hash = (hash << 5) - hash + text.charCodeAt(i), hash |= 0;
        }
        return Number(Math.abs(hash)).toString(36);
    };
    const serializeClass = obj => {
        if (!obj) {
            return "";
        }
        if (isString(obj)) {
            return obj.trim();
        }
        const classes = [];
        if (isArray(obj)) {
            for (const o of obj) {
                const classList = serializeClass(o);
                classList && classes.push(classList);
            }
        } else {
            for (const [key, value] of Object.entries(obj)) {
                value && classes.push(key.trim());
            }
        }
        return classes.join(" ");
    };
    const fromCamelToKebabCaseWithDash = text => text.replace(/([A-Z])/g, "-$1").toLowerCase();
    function serializeAttribute(key, value, styleScopedId) {
        if (isClassAttr(key)) {
            const serializedClass = serializeClass(value);
            value = styleScopedId ? styleScopedId + (serializedClass.length ? " " + serializedClass : serializedClass) : serializedClass;
        } else {
            "style" === key ? value = (obj => {
                if (null == obj) {
                    return "";
                }
                if ("object" == typeof obj) {
                    if (isArray(obj)) {
                        throw qError(0, [ obj, "style" ]);
                    }
                    {
                        const chunks = [];
                        for (const key in obj) {
                            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                                const value = obj[key];
                                null != value && "function" != typeof value && (key.startsWith("--") ? chunks.push(key + ":" + value) : chunks.push(fromCamelToKebabCaseWithDash(key) + ":" + setValueForStyle(key, value)));
                            }
                        }
                        return chunks.join(";");
                    }
                }
                return String(obj);
            })(value) : !function(key) {
                return prop = key, prop.startsWith("aria-") || [ "spellcheck", "draggable", "contenteditable" ].includes(key);
                var prop;
            }(key) && "number" != typeof value ? !1 === value || null == value ? value = null : !0 === value && isPreventDefault(key) && (value = "") : value = (value => null != value ? String(value) : null)(value);
        }
        return value;
    }
    const setValueForStyle = (styleName, value) => "number" != typeof value || 0 === value || unitlessNumbers.has(styleName) ? value : value + "px";
    const vnode_diff = (container, jsxNode, vStartNode, scopedStyleIdPrefix) => {
        let journal = container.$journal$;
        const stack = [];
        const asyncQueue = [];
        let vParent = null;
        let vCurrent = null;
        let vNewNode = null;
        let vSiblings = null;
        let vSiblingsArray = null;
        let vSideBuffer = null;
        let jsxChildren = null;
        let jsxValue = null;
        let jsxIdx = 0;
        let jsxCount = 0;
        let shouldAdvance = !0;
        const CONST_SUBSCRIPTION_DATA = new SubscriptionData({
            $scopedStyleIdPrefix$: scopedStyleIdPrefix,
            $isConst$: !0
        });
        const NON_CONST_SUBSCRIPTION_DATA = new SubscriptionData({
            $scopedStyleIdPrefix$: scopedStyleIdPrefix,
            $isConst$: !1
        });
        return diff(jsxNode, vStartNode), function drainAsyncQueue() {
            for (;asyncQueue.length; ) {
                const jsxNode = asyncQueue.shift();
                const vHostNode = asyncQueue.shift();
                if (isPromise(jsxNode)) {
                    return jsxNode.then(jsxNode => (diff(jsxNode, vHostNode), drainAsyncQueue())).catch(e => (container.handleError(e, vHostNode), 
                    drainAsyncQueue()));
                }
                diff(jsxNode, vHostNode);
            }
        }();
        function diff(jsxNode, vStartNode) {
            if (assertFalse(vnode_isVNode(jsxNode)), assertTrue(vnode_isVNode(vStartNode)), 
            vParent = vStartNode, vNewNode = null, vCurrent = vnode_getFirstChild(vStartNode), 
            stackPush(jsxNode, !0), !(32 & vParent.flags)) {
                for (;stack.length; ) {
                    for (;jsxIdx < jsxCount; ) {
                        if (assertFalse(), "string" == typeof jsxValue) {
                            expectText(jsxValue);
                        } else if ("number" == typeof jsxValue) {
                            expectText(String(jsxValue));
                        } else if (jsxValue && "object" == typeof jsxValue) {
                            if (Array.isArray(jsxValue)) {
                                descend(jsxValue, !1);
                            } else if (isSignal(jsxValue)) {
                                expectVirtual("S", null);
                                const unwrappedSignal = jsxValue instanceof WrappedSignalImpl ? jsxValue.$unwrapIfSignal$() : jsxValue;
                                const currentSignal = vCurrent?.[_EFFECT_BACK_REF]?.get(".")?.[0];
                                if (currentSignal !== unwrappedSignal) {
                                    const vHost = vNewNode || vCurrent;
                                    descend(resolveSignalAndDescend(() => trackSignalAndAssignHost(unwrappedSignal, vHost, ".", container)), !0);
                                }
                            } else if (isPromise(jsxValue)) {
                                expectVirtual("A", null), asyncQueue.push(jsxValue, vNewNode || vCurrent);
                            } else if (isJSXNode(jsxValue)) {
                                const type = jsxValue.type;
                                "string" == typeof type ? (expectNoMoreTextNodes(), expectElement(jsxValue, type), 
                                descend(jsxValue.children, !0)) : "function" == typeof type && (type === Fragment ? (expectNoMoreTextNodes(), 
                                expectVirtual("F", jsxValue.key), descend(jsxValue.children, !0)) : type === Slot ? (expectNoMoreTextNodes(), 
                                expectSlot() || descend(jsxValue.children, !0)) : type === Projection ? (expectProjection(), 
                                descend(jsxValue.children, !0, !1)) : type === SSRComment || type === SSRRaw ? expectNoMore() : (expectNoMoreTextNodes(), 
                                expectComponent(type)));
                            }
                        } else {
                            jsxValue === SkipRender ? journal = [] : expectText("");
                        }
                        advance();
                    }
                    expectNoMore(), cleanupSideBuffer(), ascend();
                }
            }
        }
        function resolveSignalAndDescend(fn) {
            try {
                return fn();
            } catch (e) {
                if (isPromise(e)) {
                    const retryPromise = e.then(() => retryOnPromise(fn));
                    return asyncQueue.push(retryPromise, vNewNode || vCurrent), null;
                }
                throw e;
            }
        }
        function advance() {
            if (shouldAdvance) {
                if (jsxIdx++, jsxIdx < jsxCount) {
                    jsxValue = jsxChildren[jsxIdx];
                } else if (!1 === stack[stack.length - 1]) {
                    return ascend();
                }
                null !== vNewNode ? vNewNode = null : advanceToNextSibling();
            } else {
                shouldAdvance = !0;
            }
        }
        function peekNextSibling() {
            return vCurrent ? vCurrent.nextSibling : null;
        }
        function advanceToNextSibling() {
            vCurrent = peekNextSibling();
        }
        function descend(children, descendVNode, shouldExpectNoChildren = !0) {
            shouldExpectNoChildren && (null == children || descendVNode && isArray(children) && 0 === children.length) ? function() {
                const vFirstChild = vCurrent && vnode_getFirstChild(vCurrent);
                if (null !== vFirstChild) {
                    let vChild = vFirstChild;
                    for (;vChild; ) {
                        cleanup(container, vChild), vChild = vChild.nextSibling;
                    }
                    ((journal, vParent, vDelete) => {
                        assertDefined();
                        const parent = vnode_getDomParent(vParent);
                        if (parent) {
                            if (vnode_isElementVNode(vParent)) {
                                journal.push(5, parent);
                            } else {
                                const children = vnode_getDOMChildNodes(journal, vParent);
                                children.length && journal.push(4, parent, ...children);
                            }
                        }
                        const vPrevious = vDelete.previousSibling;
                        vPrevious ? vPrevious.nextSibling = null : vParent.firstChild = null, vParent.lastChild = vPrevious;
                    })(journal, vCurrent, vFirstChild);
                }
            }() : (stackPush(children, descendVNode), descendVNode && (assertDefined(), vSideBuffer = null, 
            vSiblings = null, vSiblingsArray = null, vParent = vNewNode || vCurrent, vCurrent = vnode_getFirstChild(vParent), 
            vNewNode = null), shouldAdvance = !1);
        }
        function ascend() {
            stack.pop() && (vSideBuffer = stack.pop(), vSiblings = stack.pop(), vSiblingsArray = stack.pop(), 
            vNewNode = stack.pop(), vCurrent = stack.pop(), vParent = stack.pop()), jsxValue = stack.pop(), 
            jsxCount = stack.pop(), jsxIdx = stack.pop(), jsxChildren = stack.pop(), advance();
        }
        function stackPush(children, descendVNode) {
            stack.push(jsxChildren, jsxIdx, jsxCount, jsxValue), descendVNode && stack.push(vParent, vCurrent, vNewNode, vSiblingsArray, vSiblings, vSideBuffer), 
            stack.push(descendVNode), Array.isArray(children) ? (jsxIdx = 0, jsxCount = children.length, 
            jsxChildren = children, jsxValue = jsxCount > 0 ? children[0] : null) : void 0 === children ? (jsxIdx = 0, 
            jsxValue = null, jsxChildren = null, jsxCount = 0) : (jsxIdx = 0, jsxValue = children, 
            jsxChildren = null, jsxCount = 1);
        }
        function getInsertBefore() {
            return vNewNode ? vCurrent : peekNextSibling();
        }
        function expectProjection() {
            const slotName = jsxValue.key;
            vCurrent = vParent.getProp(slotName, id => vnode_locate(container.rootVNode, id)), 
            vCurrent = vCurrent && 32 & vCurrent.flags ? null : vCurrent, null == vCurrent && (vNewNode = vnode_newVirtual(), 
            build.isDev && vNewNode.setProp("q:type", "P"), build.isDev && vNewNode.setProp("q:code", "expectProjection"), 
            vNewNode.setProp(QSlot, slotName), vNewNode.slotParent = vParent, vParent.setProp(slotName, vNewNode));
        }
        function expectSlot() {
            const vHost = (vHost => {
                let projectionDepth = 1;
                for (;projectionDepth--; ) {
                    for (;vHost && (!vnode_isVirtualVNode(vHost) || null === vHost.getProp("q:renderFn", null)); ) {
                        const qSlotParent = vHost.slotParent;
                        const vProjectionParent = vnode_isVirtualVNode(vHost) && qSlotParent;
                        vProjectionParent && projectionDepth++, vHost = vProjectionParent || vHost.parent;
                    }
                    projectionDepth > 0 && (vHost = vHost.parent);
                }
                return vHost;
            })(vParent);
            const slotNameKey = function(vHost) {
                const jsxNode = jsxValue;
                const constProps = jsxNode.constProps;
                if (constProps && "object" == typeof constProps && "name" in constProps) {
                    const constValue = constProps.name;
                    if (vHost && constValue instanceof WrappedSignalImpl) {
                        return trackSignalAndAssignHost(constValue, vHost, ":", container);
                    }
                }
                return directGetPropsProxyProp(jsxNode, "name") || "";
            }(vHost);
            const vProjectedNode = vHost ? vHost.getProp(slotNameKey, null) : null;
            return null == vProjectedNode ? (vnode_insertBefore(journal, vParent, vNewNode = vnode_newVirtual(), vCurrent && getInsertBefore()), 
            vNewNode.setProp(QSlot, slotNameKey), vHost && vHost.setProp(slotNameKey, vNewNode), 
            build.isDev && vNewNode.setProp("q:type", "P"), build.isDev && vNewNode.setProp("q:code", "expectSlot" + count++), 
            !1) : (vProjectedNode === vCurrent || (vnode_insertBefore(journal, vParent, vNewNode = vProjectedNode, vCurrent && getInsertBefore()), 
            vNewNode.setProp(QSlot, slotNameKey), vHost && vHost.setProp(slotNameKey, vNewNode), 
            build.isDev && vNewNode.setProp("q:type", "P"), build.isDev && vNewNode.setProp("q:code", "expectSlot" + count++)), 
            !0);
        }
        function cleanupSideBuffer() {
            if (vSideBuffer) {
                for (const vNode of vSideBuffer.values()) {
                    32 & vNode.flags || (cleanup(container, vNode), vnode_remove(journal, vParent, vNode, !0));
                }
                vSideBuffer.clear(), vSideBuffer = null;
            }
            vCurrent = null;
        }
        function expectNoMore() {
            if (assertFalse(), null !== vCurrent) {
                for (;vCurrent; ) {
                    const toRemove = vCurrent;
                    advanceToNextSibling(), vParent === toRemove.parent && (cleanup(container, toRemove), 
                    vnode_remove(journal, vParent, toRemove, !0));
                }
            }
        }
        function expectNoMoreTextNodes() {
            for (;null !== vCurrent && vnode_isTextVNode(vCurrent); ) {
                cleanup(container, vCurrent);
                const toRemove = vCurrent;
                advanceToNextSibling(), vnode_remove(journal, vParent, toRemove, !0);
            }
        }
        function createNewElement(jsx, elementName, currentFile) {
            const element = function(elementName) {
                const domParentVNode = vnode_getDomParentVNode(vParent);
                const {elementNamespace, elementNamespaceFlag} = getNewElementNamespaceData(domParentVNode, elementName);
                const element = container.document.createElementNS(elementNamespace, elementName);
                return vNewNode = vnode_newElement(element, elementName), vNewNode.flags |= elementNamespaceFlag, 
                element;
            }(elementName);
            function setAttribute(key, value, vHost) {
                if (null != (value = serializeAttribute(key, value, scopedStyleIdPrefix))) {
                    if (64 & vHost.flags) {
                        const namespace = function(attributeName) {
                            switch (attributeName) {
                              case "xlink:href":
                              case "xlink:actuate":
                              case "xlink:arcrole":
                              case "xlink:role":
                              case "xlink:show":
                              case "xlink:title":
                              case "xlink:type":
                                return "http://www.w3.org/1999/xlink";

                              case "xml:base":
                              case "xml:lang":
                              case "xml:space":
                                return "http://www.w3.org/XML/1998/namespace";

                              default:
                                return null;
                            }
                        }(key);
                        if (namespace) {
                            return void element.setAttributeNS(namespace, key, String(value));
                        }
                    }
                    element.setAttribute(key, String(value));
                }
            }
            const {constProps} = jsx;
            let needsQDispatchEventPatch = !1;
            if (constProps) {
                for (const key in constProps) {
                    let value = constProps[key];
                    if (isHtmlAttributeAnEventName(key)) {
                        const data = getEventDataFromHtmlAttribute(key);
                        if (data) {
                            const scope = data[0];
                            const eventName = data[1];
                            eventName && (vNewNode.setProp(HANDLER_PREFIX + ":" + scope + ":" + eventName, value), 
                            scope && vNewNode.setAttr(key, "", journal), registerQwikLoaderEvent(eventName));
                        }
                        needsQDispatchEventPatch = !0;
                        continue;
                    }
                    if ("ref" === key) {
                        if (isSignal(value)) {
                            value.value = element;
                            continue;
                        }
                        if ("function" == typeof value) {
                            value(element);
                            continue;
                        }
                        if (null == value) {
                            continue;
                        }
                        throw qError(15, [ currentFile ]);
                    }
                    if (isSignal(value)) {
                        const vHost = vNewNode;
                        const signal = value;
                        value = retryOnPromise(() => trackSignalAndAssignHost(signal, vHost, key, container, CONST_SUBSCRIPTION_DATA));
                    }
                    if (isPromise(value)) {
                        const vHost = vNewNode;
                        value.then(resolvedValue => setAttribute(key, resolvedValue, vHost));
                        continue;
                    }
                    if ("dangerouslySetInnerHTML" !== key) {
                        if ("textarea" !== elementName || "value" !== key) {
                            setAttribute(key, value, vNewNode);
                        } else {
                            if (value && "string" != typeof value) {
                                if (build.isDev) {
                                    throw qError(23, [ currentFile, value ]);
                                }
                                continue;
                            }
                            element.value = escapeHTML(value || "");
                        }
                    } else {
                        value && (element.innerHTML = String(value), element.setAttribute("q:container", "html"));
                    }
                }
            }
            const key = jsx.key;
            if (key && vNewNode.setProp("q:key", key), scopedStyleIdPrefix) {
                hasClassAttr(jsx.varProps) || jsx.constProps && hasClassAttr(jsx.constProps) || element.setAttribute("class", scopedStyleIdPrefix);
            }
            return vnode_insertBefore(journal, vParent, vNewNode, vCurrent), needsQDispatchEventPatch;
        }
        function expectElement(jsx, elementName) {
            const isSameElementName = vCurrent && vnode_isElementVNode(vCurrent) && elementName === vnode_getElementName(vCurrent);
            const jsxKey = jsx.key;
            let needsQDispatchEventPatch = !1;
            const currentKey = getKey(vCurrent);
            if (isSameElementName && jsxKey === currentKey) {
                deleteFromSideBuffer(elementName, jsxKey);
            } else {
                const sideBufferKey = getSideBufferKey(elementName, jsxKey);
                moveOrCreateKeyedNode(elementName, jsxKey, sideBufferKey, vParent, () => needsQDispatchEventPatch = createNewElement(jsx, elementName));
            }
            const jsxAttrs = [];
            const props = jsx.varProps;
            if (jsx.toSort) {
                const keys = Object.keys(props).sort();
                for (const key of keys) {
                    const value = props[key];
                    null != value && jsxAttrs.push(key, value);
                }
            } else {
                for (const key in props) {
                    const value = props[key];
                    null != value && jsxAttrs.push(key, value);
                }
            }
            null !== jsxKey && mapArray_set(jsxAttrs, "q:key", jsxKey, 0);
            const vNode = vNewNode || vCurrent;
            const element = vNode.element;
            element.vNode || (element.vNode = vNode), needsQDispatchEventPatch = function(vnode, srcAttrs, currentFile) {
                vnode_ensureElementInflated(vnode);
                const dstAttrs = vnode_getProps(vnode);
                let srcIdx = 0;
                let dstIdx = 0;
                let patchEventDispatch = !1;
                const setAttribute = (key, value, vHost) => {
                    vHost.setAttr(key, null !== value ? serializeAttribute(key, value, scopedStyleIdPrefix) : null, journal);
                };
                const record = (key, value) => {
                    if (key.startsWith(":")) {
                        return void vnode.setProp(key, value);
                    }
                    if ("ref" === key) {
                        const element = vnode.element;
                        if (isSignal(value)) {
                            return void (value.value = element);
                        }
                        if ("function" == typeof value) {
                            return void value(element);
                        }
                        throw qError(15, [ currentFile ]);
                    }
                    const currentEffect = vnode[_EFFECT_BACK_REF]?.get(key);
                    if (isSignal(value)) {
                        const unwrappedSignal = value instanceof WrappedSignalImpl ? value.$unwrapIfSignal$() : value;
                        const currentSignal = currentEffect?.[0];
                        if (currentSignal === unwrappedSignal) {
                            return;
                        }
                        currentEffect && clearEffectSubscription(container, currentEffect);
                        const vHost = vnode;
                        value = retryOnPromise(() => trackSignalAndAssignHost(unwrappedSignal, vHost, key, container, NON_CONST_SUBSCRIPTION_DATA));
                    } else {
                        currentEffect && clearEffectSubscription(container, currentEffect);
                    }
                    if (isPromise(value)) {
                        const vHost = vnode;
                        return void value.then(resolvedValue => setAttribute(key, resolvedValue, vHost));
                    }
                    setAttribute(key, value, vnode);
                };
                const recordJsxEvent = (key, value) => {
                    const data = getEventDataFromHtmlAttribute(key);
                    if (data) {
                        const [scope, eventName] = data;
                        record(":" + scope + ":" + eventName, value), registerQwikLoaderEvent(eventName), 
                        patchEventDispatch = !0;
                    }
                };
                for (;srcIdx < srcAttrs.length || dstIdx < dstAttrs.length; ) {
                    const srcKey = srcIdx < srcAttrs.length ? srcAttrs[srcIdx] : void 0;
                    const dstKey = dstIdx < dstAttrs.length ? dstAttrs[dstIdx] : void 0;
                    if (dstKey?.startsWith(HANDLER_PREFIX) || dstKey?.startsWith("q:")) {
                        dstIdx += 2;
                    } else if (void 0 === srcKey) {
                        isHtmlAttributeAnEventName(dstKey) ? dstIdx += 2 : record(dstKey, null);
                    } else if (void 0 === dstKey) {
                        const srcValue = srcAttrs[srcIdx + 1];
                        isHtmlAttributeAnEventName(srcKey) ? recordJsxEvent(srcKey, srcValue) : record(srcKey, srcValue), 
                        srcIdx += 2, dstIdx += 2;
                    } else if (srcKey === dstKey) {
                        const srcValue = srcAttrs[srcIdx + 1];
                        const dstValue = dstAttrs[dstIdx + 1];
                        const isEventHandler = isHtmlAttributeAnEventName(srcKey);
                        srcValue !== dstValue ? isEventHandler ? recordJsxEvent(srcKey, srcValue) : record(srcKey, srcValue) : isEventHandler && !vnode.element.qDispatchEvent && recordJsxEvent(srcKey, srcValue), 
                        srcIdx += 2, dstIdx += 2;
                    } else if (srcKey < dstKey) {
                        const srcValue = srcAttrs[srcIdx + 1];
                        isHtmlAttributeAnEventName(srcKey) ? recordJsxEvent(srcKey, srcValue) : record(srcKey, srcValue), 
                        srcIdx += 2, dstIdx += 2;
                    } else {
                        isHtmlAttributeAnEventName(dstKey) ? dstIdx += 2 : record(dstKey, null);
                    }
                }
                return patchEventDispatch;
            }(vNode, jsxAttrs, build.isDev && getFileLocationFromJsx(jsx.dev) || null) || needsQDispatchEventPatch, 
            needsQDispatchEventPatch && (element.qDispatchEvent || (element.qDispatchEvent = (event, scope) => {
                const eventName = fromCamelToKebabCase(event.type);
                const eventProp = ":" + scope.substring(1) + ":" + eventName;
                const qrls = [ vNode.getProp(eventProp, null), vNode.getProp(HANDLER_PREFIX + eventProp, null) ];
                let returnValue = !1;
                return qrls.flat(2).forEach(qrl => {
                    if (qrl) {
                        if (isSyncQrl(qrl)) {
                            qrl(event, element);
                        } else {
                            const value = container.$scheduler$(2, vNode, qrl, [ event, element ]);
                            returnValue = returnValue || !0 === value;
                        }
                    }
                }), returnValue;
            }));
        }
        function registerQwikLoaderEvent(eventName) {
            const window = container.document.defaultView;
            window && (window.qwikevents ||= []).push(eventName);
        }
        function retrieveChildWithKey(nodeName, key) {
            let vNodeWithKey = null;
            if (null === vSiblings) {
                vSiblings = new Map, vSiblingsArray = [];
                let vNode = vCurrent;
                for (;vNode; ) {
                    const name = vnode_isElementVNode(vNode) ? vnode_getElementName(vNode) : null;
                    const vKey = getKey(vNode) || getComponentHash(vNode, container.$getObjectById$);
                    null === vNodeWithKey && vKey == key && name == nodeName ? vNodeWithKey = vNode : null === vKey ? vSiblingsArray.push(name, vNode) : vSiblings.set(getSideBufferKey(name, vKey), vNode), 
                    vNode = vNode.nextSibling;
                }
            } else if (null === key) {
                for (let i = 0; i < vSiblingsArray.length; i += 2) {
                    if (vSiblingsArray[i] === nodeName) {
                        vNodeWithKey = vSiblingsArray[i + 1], vSiblingsArray.splice(i, 2);
                        break;
                    }
                }
            } else {
                const siblingsKey = getSideBufferKey(nodeName, key);
                vSiblings.has(siblingsKey) && (vNodeWithKey = vSiblings.get(siblingsKey), vSiblings.delete(siblingsKey));
            }
            return function(targetNode) {
                if (!targetNode) {
                    if (vCurrent) {
                        const name = vnode_isElementVNode(vCurrent) ? vnode_getElementName(vCurrent) : null;
                        const vKey = getKey(vCurrent) || getComponentHash(vCurrent, container.$getObjectById$);
                        if (null != vKey) {
                            const sideBufferKey = getSideBufferKey(name, vKey);
                            vSideBuffer ||= new Map, vSideBuffer.set(sideBufferKey, vCurrent), vSiblings?.delete(sideBufferKey);
                        }
                    }
                    return;
                }
                let vNode = vCurrent;
                for (;vNode && vNode !== targetNode; ) {
                    const name = vnode_isElementVNode(vNode) ? vnode_getElementName(vNode) : null;
                    const vKey = getKey(vNode) || getComponentHash(vNode, container.$getObjectById$);
                    if (null != vKey) {
                        const sideBufferKey = getSideBufferKey(name, vKey);
                        vSideBuffer ||= new Map, vSideBuffer.set(sideBufferKey, vNode), vSiblings?.delete(sideBufferKey);
                    }
                    vNode = vNode.nextSibling;
                }
            }(vNodeWithKey), vNodeWithKey;
        }
        function getSideBufferKey(nodeName, key) {
            return null == key ? null : nodeName ? nodeName + ":" + key : key;
        }
        function deleteFromSideBuffer(nodeName, key) {
            const sbKey = getSideBufferKey(nodeName, key);
            return !(!sbKey || !vSideBuffer?.has(sbKey)) && (vSideBuffer.delete(sbKey), !0);
        }
        function moveOrCreateKeyedNode(nodeName, lookupKey, sideBufferKey, parentForInsert, createNew, addCurrentToSideBufferOnSideInsert) {
            if (vNewNode = retrieveChildWithKey(nodeName, lookupKey), vNewNode) {
                return vCurrent = vNewNode, void (vNewNode = null);
            }
            if (null != sideBufferKey) {
                const buffered = vSideBuffer?.get(sideBufferKey) || null;
                if (buffered) {
                    if (vSideBuffer.delete(sideBufferKey), addCurrentToSideBufferOnSideInsert && vCurrent) {
                        const currentKey = getKey(vCurrent) || getComponentHash(vCurrent, container.$getObjectById$);
                        if (null != currentKey) {
                            const currentSideKey = getSideBufferKey(vnode_isElementVNode(vCurrent) ? vnode_getElementName(vCurrent) : null, currentKey);
                            null != currentSideKey && (vSideBuffer ||= new Map, vSideBuffer.set(currentSideKey, vCurrent));
                        }
                    }
                    return vnode_insertBefore(journal, parentForInsert, buffered, vCurrent), vCurrent = buffered, 
                    void (vNewNode = null);
                }
            }
            return createNew();
        }
        function expectVirtual(type, jsxKey) {
            const checkKey = "F" === type;
            const currentKey = getKey(vCurrent);
            if (vCurrent && vnode_isVirtualVNode(vCurrent) && currentKey === jsxKey && (!checkKey || !!jsxKey)) {
                return void deleteFromSideBuffer(null, currentKey);
            }
            const createNew = () => {
                vnode_insertBefore(journal, vParent, vNewNode = vnode_newVirtual(), vCurrent && getInsertBefore()), 
                vNewNode.setProp("q:key", jsxKey), build.isDev && vNewNode.setProp("q:type", type);
            };
            null !== jsxKey ? moveOrCreateKeyedNode(null, jsxKey, getSideBufferKey(null, jsxKey), vParent, createNew, !0) : createNew();
        }
        function expectComponent(component) {
            const componentMeta = component[SERIALIZABLE_STATE];
            let host = vNewNode || vCurrent;
            const jsxNode = jsxValue;
            if (componentMeta) {
                const jsxProps = jsxNode.props;
                let shouldRender = !1;
                const [componentQRL] = componentMeta;
                const componentHash = componentQRL.$hash$;
                const vNodeComponentHash = getComponentHash(host, container.$getObjectById$);
                const lookupKey = jsxNode.key || componentHash;
                if (lookupKey === (getKey(host) || vNodeComponentHash)) {
                    componentHash === vNodeComponentHash && jsxNode.key ? deleteFromSideBuffer(null, lookupKey) : (insertNewComponent(host, componentQRL, jsxProps), 
                    host = vNewNode, shouldRender = !0);
                } else {
                    moveOrCreateKeyedNode(null, lookupKey, lookupKey, vParent, () => {
                        insertNewComponent(host, componentQRL, jsxProps), shouldRender = !0;
                    }), host = vNewNode || vCurrent;
                }
                if (host) {
                    let vNodeProps = host.getProp("q:props", container.$getObjectById$);
                    let propsAreDifferent = !1;
                    shouldRender || (propsAreDifferent = propsDiffer(jsxProps[_CONST_PROPS], vNodeProps?.[_CONST_PROPS]) || propsDiffer(jsxProps[_VAR_PROPS], vNodeProps?.[_VAR_PROPS]), 
                    shouldRender = shouldRender || propsAreDifferent), shouldRender && (propsAreDifferent && (vNodeProps ? (vNodeProps[_CONST_PROPS] = jsxProps[_CONST_PROPS], 
                    vNodeProps[_VAR_PROPS] = jsxProps[_VAR_PROPS], vNodeProps[_OWNER] = jsxProps[_OWNER]) : jsxProps && (host.setProp("q:props", jsxProps), 
                    vNodeProps = jsxProps)), host.setProp("q:renderFn", componentQRL), host.flags &= -33, 
                    container.$scheduler$(6, host, componentQRL, vNodeProps));
                }
                !function(children, host) {
                    const projectionChildren = Array.isArray(children) ? children : [ children ];
                    const createProjectionJSXNode = slotName => new JSXNodeImpl(Projection, null, null, [], slotName);
                    const projections = [];
                    if (host) {
                        const props = vnode_getProps(host);
                        for (let i = 0; i < props.length; i += 2) {
                            const prop = props[i];
                            if (isSlotProp(prop)) {
                                const slotName = prop;
                                projections.push(slotName), projections.push(createProjectionJSXNode(slotName));
                            }
                        }
                    }
                    if (0 !== projections.length || null != children) {
                        for (let i = 0; i < projectionChildren.length; i++) {
                            const child = projectionChildren[i];
                            const slotName = String(isJSXNode(child) && directGetPropsProxyProp(child, QSlot) || "");
                            const idx = mapApp_findIndx(projections, slotName, 0);
                            let jsxBucket;
                            idx >= 0 ? jsxBucket = projections[idx + 1] : projections.splice(~idx, 0, slotName, jsxBucket = createProjectionJSXNode(slotName)), 
                            !1 === child || jsxBucket.children.push(child);
                        }
                        for (let i = projections.length - 2; i >= 0; i -= 2) {
                            projections.splice(i, 1);
                        }
                        descend(projections, !0);
                    }
                }(jsxNode.children, host);
            } else {
                const lookupKey = jsxNode.key;
                const lookupKeysAreEqual = lookupKey === getKey(host);
                const vNodeComponentHash = getComponentHash(host, container.$getObjectById$);
                if (host && !(null == vNodeComponentHash) || null == lookupKey) {
                    insertNewInlineComponent(), host = vNewNode;
                } else if (lookupKeysAreEqual) {
                    deleteFromSideBuffer(null, lookupKey);
                } else {
                    moveOrCreateKeyedNode(null, lookupKey, lookupKey, vParent, () => {
                        insertNewInlineComponent();
                    }), host = vNewNode || vCurrent;
                }
                if (host) {
                    let componentHost = host;
                    for (;componentHost && (!vnode_isVirtualVNode(componentHost) || null === componentHost.getProp("q:renderFn", null)); ) {
                        componentHost = componentHost.parent;
                    }
                    const jsxOutput = executeComponent(container, host, componentHost || container.rootVNode, component, jsxNode.props);
                    asyncQueue.push(jsxOutput, host);
                }
            }
        }
        function insertNewComponent(host, componentQRL, jsxProps) {
            host && clearAllEffects(container, host), vnode_insertBefore(journal, vParent, vNewNode = vnode_newVirtual(), vCurrent && getInsertBefore());
            const jsxNode = jsxValue;
            build.isDev && vNewNode.setProp("q:type", "C"), container.setHostProp(vNewNode, "q:renderFn", componentQRL), 
            container.setHostProp(vNewNode, "q:props", jsxProps), container.setHostProp(vNewNode, "q:key", jsxNode.key);
        }
        function insertNewInlineComponent() {
            vnode_insertBefore(journal, vParent, vNewNode = vnode_newVirtual(), vCurrent && getInsertBefore());
            const jsxNode = jsxValue;
            build.isDev && vNewNode.setProp("q:type", "I"), vNewNode.setProp("q:props", jsxNode.props), 
            jsxNode.key && vNewNode.setProp("q:key", jsxNode.key);
        }
        function expectText(text) {
            if (null !== vCurrent) {
                if (3 === (vnode => {
                    const type = vnode.flags;
                    if (1 & type) {
                        return 1;
                    }
                    if (2 & type) {
                        return 11;
                    }
                    if (4 & type) {
                        return 3;
                    }
                    throw qError(26, [ type ]);
                })(vCurrent)) {
                    return text !== vnode_getText(vCurrent) ? void ((journal, textVNode, text) => {
                        vnode_ensureTextInflated(journal, textVNode), journal.push(1, textVNode.textNode, textVNode.text = text);
                    })(journal, vCurrent, text) : void 0;
                }
            }
            vnode_insertBefore(journal, vParent, vNewNode = vnode_newText(container.document.createTextNode(text), text), vCurrent);
        }
    };
    function getKey(vNode) {
        return null == vNode ? null : vNode.getProp("q:key", null);
    }
    function getComponentHash(vNode, getObject) {
        if (null == vNode) {
            return null;
        }
        const qrl = vNode.getProp("q:renderFn", getObject);
        return qrl ? qrl.$hash$ : null;
    }
    function Projection() {}
    function propsDiffer(src, dst) {
        const srcEmpty = isPropsEmpty(src);
        const dstEmpty = isPropsEmpty(dst);
        if (srcEmpty && dstEmpty) {
            return !1;
        }
        if (srcEmpty || dstEmpty) {
            return !0;
        }
        const srcKeys = Object.keys(src);
        const dstKeys = Object.keys(dst);
        let srcLen = srcKeys.length;
        let dstLen = dstKeys.length;
        if ("children" in src && srcLen--, "q:brefs" in src && srcLen--, "children" in dst && dstLen--, 
        "q:brefs" in dst && dstLen--, srcLen !== dstLen) {
            return !0;
        }
        for (const key of srcKeys) {
            if ("children" !== key && "q:brefs" !== key && (!Object.prototype.hasOwnProperty.call(dst, key) || src[key] !== dst[key])) {
                return !0;
            }
        }
        return !1;
    }
    function isPropsEmpty(props) {
        return !props || 0 === Object.keys(props).length;
    }
    function cleanup(container, vNode) {
        let vCursor = vNode;
        if (vnode_isTextVNode(vNode)) {
            return void markVNodeAsDeleted(vCursor);
        }
        let vParent = null;
        for (;;) {
            const type = vCursor.flags;
            if (3 & type) {
                if (clearAllEffects(container, vCursor), markVNodeAsDeleted(vCursor), 2 & type) {
                    const seq = container.getHostProp(vCursor, "q:seq");
                    if (seq) {
                        for (let i = 0; i < seq.length; i++) {
                            const obj = seq[i];
                            if (isTask(obj)) {
                                const task = obj;
                                clearAllEffects(container, task), 1 & task.$flags$ ? container.$scheduler$(32, task) : cleanupTask(task);
                            }
                        }
                    }
                }
                if (2 & type && null !== vCursor.getProp("q:renderFn", null)) {
                    const attrs = vnode_getProps(vCursor);
                    for (let i = 0; i < attrs.length; i += 2) {
                        if (isSlotProp(attrs[i])) {
                            const value = attrs[i + 1];
                            if (value) {
                                attrs[i + 1] = null;
                                const projection = "string" == typeof value ? vnode_locate(container.rootVNode, value) : value;
                                let projectionChild = vnode_getFirstChild(projection);
                                for (;projectionChild; ) {
                                    cleanup(container, projectionChild), projectionChild = projectionChild.nextSibling;
                                }
                                cleanupStaleUnclaimedProjection(container.$journal$, projection);
                            }
                        }
                    }
                }
                if (vnode_isProjection(vCursor)) {
                    if (vCursor === vNode) {
                        const vFirstChild = vnode_getFirstChild(vCursor);
                        if (vFirstChild) {
                            return void vnode_walkVNode(vFirstChild, () => {});
                        }
                    }
                } else {
                    const vFirstChild = vnode_getFirstChild(vCursor);
                    if (vFirstChild) {
                        vCursor = vFirstChild;
                        continue;
                    }
                }
            } else {
                4 & type && markVNodeAsDeleted(vCursor);
            }
            if (vCursor === vNode) {
                return;
            }
            const vNextSibling = vCursor.nextSibling;
            if (vNextSibling) {
                vCursor = vNextSibling;
            } else {
                for (vParent = vCursor.parent; vParent; ) {
                    if (vParent === vNode) {
                        return;
                    }
                    const vNextParentSibling = vParent.nextSibling;
                    if (vNextParentSibling) {
                        vCursor = vNextParentSibling;
                        break;
                    }
                    vParent = vParent.parent;
                }
                if (null == vParent) {
                    return;
                }
            }
        }
    }
    function cleanupStaleUnclaimedProjection(journal, projection) {
        const projectionParent = projection.parent;
        if (projectionParent) {
            1 & projectionParent.flags && "q:template" === vnode_getElementName(projectionParent) && vnode_remove(journal, projectionParent, projection, !0);
        }
    }
    function markVNodeAsDeleted(vCursor) {
        vCursor.flags |= 32;
    }
    const HANDLER_PREFIX = ":";
    let count = 0;
    const VISIBLE_BLOCKING_RULES = [ {
        blockedType: 16,
        blockingType: 4,
        match: (blocked, blocking) => isDescendant(blocked, blocking) || isDescendant(blocking, blocked)
    }, {
        blockedType: 16,
        blockingType: 6,
        match: (blocked, blocking) => isDescendant(blocked, blocking) || isDescendant(blocking, blocked)
    } ];
    const BLOCKING_RULES = [ {
        blockedType: 2,
        blockingType: 1,
        match: (blocked, blocking) => {
            const blockedQrl = blocked.$target$;
            const blockingQrl = blocking.$target$;
            return isSameHost(blocked, blocking) && isSameQrl(blockedQrl, blockingQrl);
        }
    }, {
        blockedType: 3,
        blockingType: 1,
        match: (blocked, blocking) => {
            const blockedTask = blocked.$payload$;
            const blockingQrl = blocking.$target$;
            return isSameHost(blocked, blocking) && isSameQrl(blockedTask.$qrl$, blockingQrl);
        }
    }, {
        blockedType: 16,
        blockingType: 1,
        match: (blocked, blocking) => {
            const blockedTask = blocked.$payload$;
            const blockingQrl = blocking.$target$;
            return isSameHost(blocked, blocking) && isSameQrl(blockedTask.$qrl$, blockingQrl);
        }
    }, {
        blockedType: 4,
        blockingType: 6,
        match: (blocked, blocking) => blocked.$host$ === blocking.$host$
    }, {
        blockedType: 5,
        blockingType: 6,
        match: (blocked, blocking) => blocked.$host$ === blocking.$host$
    }, ...VISIBLE_BLOCKING_RULES, {
        blockedType: 3,
        blockingType: 3,
        match: (blocked, blocking, container) => {
            if (blocked.$host$ !== blocking.$host$) {
                return !1;
            }
            const blockedIdx = blocked.$idx$;
            if ("number" != typeof blockedIdx || blockedIdx <= 0) {
                return !1;
            }
            const previousTask = function(host, currentTaskIdx, container) {
                const elementSeq = container.getHostProp(host, "q:seq");
                if (!elementSeq || elementSeq.length <= currentTaskIdx) {
                    return null;
                }
                for (let i = currentTaskIdx - 1; i >= 0; i--) {
                    const candidate = elementSeq[i];
                    if (candidate instanceof Task && 2 & candidate.$flags$) {
                        return candidate;
                    }
                }
                return null;
            }(blocked.$host$, blockedIdx, container);
            return previousTask === blocking.$payload$;
        }
    } ];
    function isDescendant(descendantChore, ancestorChore) {
        const descendantHost = descendantChore.$host$;
        const ancestorHost = ancestorChore.$host$;
        return !(!vnode_isVNode(descendantHost) || !vnode_isVNode(ancestorHost)) && ((vnode, ancestor) => {
            let parent = vnode_getProjectionParentOrParent(vnode);
            for (;parent; ) {
                if (parent === ancestor) {
                    return !0;
                }
                parent = vnode_getProjectionParentOrParent(parent);
            }
            return !1;
        })(descendantHost, ancestorHost);
    }
    function isSameHost(a, b) {
        return a.$host$ === b.$host$;
    }
    function isSameQrl(a, b) {
        return a.$symbol$ === b.$symbol$;
    }
    function findAncestorBlockingChore(chore, type) {
        const host = chore.$host$;
        if (!vnode_isVNode(host)) {
            return null;
        }
        const isNormalQueue = 0 === type;
        let current = host;
        for (current = vnode_getProjectionParentOrParent(current); current; ) {
            const blockingChores = isNormalQueue ? current.chores : current.blockedChores;
            if (blockingChores) {
                for (const blockingChore of blockingChores) {
                    if (blockingChore.$type$ < 16 && 3 !== blockingChore.$type$ && 1 !== blockingChore.$type$ && 2 !== blockingChore.$type$) {
                        return blockingChore;
                    }
                }
            }
            current = vnode_getProjectionParentOrParent(current);
        }
        return null;
    }
    function findBlockingChore(chore, choreQueue, blockedChores, runningChores, container) {
        const blockingChoreInChoreQueue = findAncestorBlockingChore(chore, 0);
        if (blockingChoreInChoreQueue) {
            return blockingChoreInChoreQueue;
        }
        const blockingChoreInBlockedChores = findAncestorBlockingChore(chore, 1);
        if (blockingChoreInBlockedChores) {
            return blockingChoreInBlockedChores;
        }
        for (const rule of BLOCKING_RULES) {
            if (chore.$type$ === rule.blockedType) {
                for (const candidate of choreQueue) {
                    if (candidate.$type$ === rule.blockingType && rule.match(chore, candidate, container)) {
                        return candidate;
                    }
                }
                for (const candidate of blockedChores) {
                    if (candidate.$type$ === rule.blockingType && rule.match(chore, candidate, container)) {
                        return candidate;
                    }
                }
                for (const candidate of runningChores) {
                    if (candidate.$type$ === rule.blockingType && rule.match(chore, candidate, container)) {
                        return candidate;
                    }
                }
            }
        }
        return null;
    }
    function findBlockingChoreForVisible(chore, runningChores, container) {
        for (const rule of VISIBLE_BLOCKING_RULES) {
            if (chore.$type$ === rule.blockedType) {
                for (const candidate of runningChores) {
                    if (candidate.$type$ === rule.blockingType && rule.match(chore, candidate, container)) {
                        return candidate;
                    }
                }
            }
        }
        return null;
    }
    const aVNodePath = [];
    const bVNodePath = [];
    const aSsrNodePath = [];
    const bSsrNodePath = [];
    class ChoreArray extends Array {
        add(value) {
            const idx = function(sortedArray, value) {
                let bottom = 0;
                let top = sortedArray.length;
                for (;bottom < top; ) {
                    const middle = bottom + (top - bottom >> 1);
                    const comp = choreComparator(value, sortedArray[middle]);
                    if (comp < 0) {
                        top = middle;
                    } else {
                        if (!(comp > 0)) {
                            return middle;
                        }
                        bottom = middle + 1;
                    }
                }
                return ~bottom;
            }(this, value);
            if (idx < 0) {
                return this.splice(~idx, 0, value), idx;
            }
            const existing = this[idx];
            return existing.$payload$ !== value.$payload$ && (existing.$payload$ = value.$payload$), 
            idx;
        }
        delete(value) {
            const idx = this.indexOf(value);
            return idx >= 0 && this.splice(idx, 1), idx;
        }
    }
    function choreComparator(a, b) {
        const macroTypeDiff = (240 & a.$type$) - (240 & b.$type$);
        if (0 !== macroTypeDiff) {
            return macroTypeDiff;
        }
        const aHost = a.$host$;
        const bHost = b.$host$;
        if (aHost !== bHost && null !== aHost && null !== bHost) {
            if (vnode_isVNode(aHost) && vnode_isVNode(bHost)) {
                const hostDiff = ((a, b) => {
                    if (a === b) {
                        return 0;
                    }
                    let aDepth = -1;
                    let bDepth = -1;
                    for (;a; ) {
                        a = (aVNodePath[++aDepth] = a).parent || a.slotParent;
                    }
                    for (;b; ) {
                        b = (bVNodePath[++bDepth] = b).parent || b.slotParent;
                    }
                    for (;aDepth >= 0 && bDepth >= 0; ) {
                        if ((a = aVNodePath[aDepth]) !== (b = bVNodePath[bDepth])) {
                            let cursor = b;
                            do {
                                if (cursor = cursor.nextSibling, cursor === a) {
                                    return 1;
                                }
                            } while (cursor);
                            cursor = b;
                            do {
                                if (cursor = cursor.previousSibling, cursor === a) {
                                    return -1;
                                }
                            } while (cursor);
                            return b.slotParent ? -1 : 1;
                        }
                        aDepth--, bDepth--;
                    }
                    return aDepth < bDepth ? -1 : 1;
                })(aHost, bHost);
                if (0 !== hostDiff) {
                    return hostDiff;
                }
            } else {
                assertFalse(vnode_isVNode(aHost)), assertFalse(vnode_isVNode(bHost));
                const hostDiff = ((a, b) => {
                    if (a === b) {
                        return 0;
                    }
                    let aDepth = -1;
                    let bDepth = -1;
                    for (;a; ) {
                        a = (aSsrNodePath[++aDepth] = a).parentComponent;
                    }
                    for (;b; ) {
                        b = (bSsrNodePath[++bDepth] = b).parentComponent;
                    }
                    for (;aDepth >= 0 && bDepth >= 0; ) {
                        if ((a = aSsrNodePath[aDepth]) !== (b = bSsrNodePath[bDepth])) {
                            return 1;
                        }
                        aDepth--, bDepth--;
                    }
                    return aDepth < bDepth ? -1 : 1;
                })(aHost, bHost);
                if (0 !== hostDiff) {
                    return hostDiff;
                }
            }
        }
        const microTypeDiff = (15 & a.$type$) - (15 & b.$type$);
        if (0 !== microTypeDiff) {
            return microTypeDiff;
        }
        const idxDiff = toNumber(a.$idx$) - toNumber(b.$idx$);
        return 0 !== idxDiff ? idxDiff : a.$target$ !== b.$target$ ? isQrl(a.$target$) && isQrl(b.$target$) && a.$target$.$hash$ === b.$target$.$hash$ ? 0 : 1 : 7 === a.$type$ && 7 === b.$type$ && (a.$target$ instanceof StoreHandler && b.$target$ instanceof StoreHandler || a.$target$ instanceof AsyncComputedSignalImpl && b.$target$ instanceof AsyncComputedSignalImpl) && a.$payload$ !== b.$payload$ ? 1 : 0;
    }
    function toNumber(value) {
        return "number" == typeof value ? value : -1;
    }
    var ChoreState;
    !function(ChoreState) {
        ChoreState[ChoreState.NONE = 0] = "NONE", ChoreState[ChoreState.RUNNING = 1] = "RUNNING", 
        ChoreState[ChoreState.FAILED = 2] = "FAILED", ChoreState[ChoreState.DONE = 3] = "DONE";
    }(ChoreState || (ChoreState = {}));
    const getChorePromise = chore => chore.$state$ === ChoreState.NONE ? chore.$returnValue$ ||= new Promise((resolve, reject) => {
        chore.$resolve$ = resolve, chore.$reject$ = reject;
    }) : chore.$returnValue$;
    const createScheduler = (container, journalFlush, choreQueue, blockedChores, runningChores) => {
        let drainChore = null;
        let drainScheduled = !1;
        let isDraining = !1;
        let isJournalFlushRunning = !1;
        let flushBudgetStart = 0;
        let currentTime = performance.now();
        const nextTick = (fn => {
            let nextTick;
            if ("function" == typeof setImmediate) {
                nextTick = () => {
                    setImmediate(fn);
                };
            } else if ("undefined" != typeof MessageChannel) {
                const channel = new MessageChannel;
                channel.port1.onmessage = () => {
                    fn();
                }, nextTick = () => {
                    channel.port2.postMessage(null);
                };
            } else {
                nextTick = () => {
                    setTimeout(fn);
                };
            }
            return nextTick;
        })(drainChoreQueue);
        let flushTimerId = null;
        function drainInNextTick() {
            drainScheduled || (drainScheduled = !0, nextTick());
        }
        const FREQUENCY_MS = Math.floor(1e3 / 60);
        return function(type, hostOrTask = null, targetOrQrl = null, payload = null) {
            if (255 === type && drainChore) {
                return drainChore;
            }
            const isTask = 3 === type || 16 === type || 32 === type;
            isTask && (hostOrTask.$flags$ |= 8);
            const chore = {
                $type$: type,
                $idx$: isTask ? hostOrTask.$index$ : "string" == typeof targetOrQrl ? targetOrQrl : 0,
                $host$: isTask ? hostOrTask.$el$ : hostOrTask,
                $target$: targetOrQrl,
                $payload$: isTask ? hostOrTask : payload,
                $state$: ChoreState.NONE,
                $blockedChores$: null,
                $startTime$: void 0,
                $endTime$: void 0,
                $resolve$: void 0,
                $reject$: void 0,
                $returnValue$: null
            };
            if (255 === type) {
                return getChorePromise(chore), drainChore = chore, drainInNextTick(), chore;
            }
            const isServer = isServerPlatform();
            const isClientOnly = 4 === type || 1 === type;
            if (isServer && isClientOnly) {
                return finishChore(chore, void 0), chore;
            }
            if (isServer && chore.$host$ && isSsrNode(chore.$host$)) {
                if (!!!(1 & chore.$host$.flags) && 5 !== chore.$type$ && 7 !== chore.$type$) {
                    const warningMessage = `A '${choreTypeToName(chore.$type$)}' chore was scheduled on a host element that has already been streamed to the client.\nThis can lead to inconsistencies between Server-Side Rendering (SSR) and Client-Side Rendering (CSR).\n\nProblematic chore:\n  - Type: ${choreTypeToName(chore.$type$)}\n  - Host: ${chore.$host$.toString()}\n  - Nearest element location: ${chore.$host$.currentFile}\n\nThis is often caused by modifying a signal in an already rendered component during SSR.`;
                    return logWarn(warningMessage), chore;
                }
            }
            if (1 !== chore.$type$ && 2 !== chore.$type$) {
                const blockingChore = findBlockingChore(chore, choreQueue, blockedChores, runningChores, container);
                if (blockingChore) {
                    return addBlockedChore(chore, blockingChore, blockedChores), chore;
                }
                const runningChore = function(chore) {
                    if (runningChores.size) {
                        for (const runningChore of runningChores) {
                            if (0 === choreComparator(chore, runningChore)) {
                                return runningChore;
                            }
                        }
                    }
                    return null;
                }(chore);
                if (runningChore) {
                    return addBlockedChore(chore, runningChore, blockedChores), chore;
                }
            }
            addChore(chore, choreQueue);
            (isServer && 6 === type || 2 === type) && !isDraining ? (drainScheduled = !0, drainChoreQueue()) : drainInNextTick();
            return chore;
        };
        function cancelFlushTimer() {
            null != flushTimerId && (clearTimeout(flushTimerId), flushTimerId = null);
        }
        function scheduleFlushTimer() {
            if (isServerPlatform()) {
                return;
            }
            if (null != flushTimerId) {
                return;
            }
            const now = performance.now();
            const delay = Math.max(0, FREQUENCY_MS - (now - flushBudgetStart));
            0 !== delay ? flushTimerId = setTimeout(() => {
                flushTimerId = null, applyJournalFlush();
            }, delay) : isDraining || applyJournalFlush();
        }
        function applyJournalFlush() {
            isJournalFlushRunning || (isJournalFlushRunning = !0, journalFlush(), isJournalFlushRunning = !1, 
            flushBudgetStart = performance.now(), cancelFlushTimer());
        }
        function shouldApplyJournalFlush(isServer) {
            return !isServer && currentTime - flushBudgetStart >= FREQUENCY_MS;
        }
        function drainChoreQueue() {
            const isServer = isServerPlatform();
            if (drainScheduled = !1, isDraining) {
                return;
            }
            if (!choreQueue.length) {
                return applyJournalFlush(), void (drainChore && !runningChores.size && (drainChore.$resolve$(null), 
                drainChore = null));
            }
            isDraining = !0, flushBudgetStart = performance.now(), cancelFlushTimer();
            const maybeFinishDrain = () => choreQueue.length ? (drainInNextTick(), !1) : drainChore && runningChores.size ? (shouldApplyJournalFlush(isServer) && applyJournalFlush(), 
            !1) : (currentChore = null, applyJournalFlush(), drainChore?.$resolve$(null), drainChore = null, 
            !0);
            const scheduleBlockedChoresAndDrainIfNeeded = chore => {
                let blockedChoresScheduled = !1;
                if (chore.$blockedChores$) {
                    for (const blockedChore of chore.$blockedChores$) {
                        const blockingChore = findBlockingChore(blockedChore, choreQueue, blockedChores, runningChores, container);
                        blockingChore ? (blockingChore.$blockedChores$ ||= new ChoreArray).add(blockedChore) : (blockedChores.delete(blockedChore), 
                        vnode_isVNode(blockedChore.$host$) && blockedChore.$host$.blockedChores?.delete(blockedChore), 
                        addChore(blockedChore, choreQueue), blockedChoresScheduled = !0);
                    }
                    chore.$blockedChores$ = null;
                }
                blockedChoresScheduled && !isDraining && drainInNextTick();
            };
            let currentChore = null;
            try {
                for (;choreQueue.length; ) {
                    currentTime = performance.now();
                    const chore = currentChore = choreQueue.shift();
                    if (chore.$state$ !== ChoreState.NONE) {
                        continue;
                    }
                    if (vNodeAlreadyDeleted(chore) && 32 !== chore.$type$) {
                        vnode_isVNode(chore.$host$) && chore.$host$.chores?.delete(chore);
                        continue;
                    }
                    if (16 === chore.$type$) {
                        applyJournalFlush();
                        const blockingChore = findBlockingChoreForVisible(chore, runningChores, container);
                        if (blockingChore && blockingChore.$state$ === ChoreState.RUNNING) {
                            addBlockedChore(chore, blockingChore, blockedChores);
                            continue;
                        }
                    }
                    chore.$startTime$ = performance.now();
                    const result = executeChore(chore, isServer);
                    if (chore.$returnValue$ = result, isPromise(result) ? (runningChores.add(chore), 
                    chore.$state$ = ChoreState.RUNNING, result.then(value => {
                        finishChore(chore, value);
                    }).catch(e => {
                        chore.$state$ === ChoreState.RUNNING ? handleError(chore, e) : console.error(e);
                    }).finally(() => {
                        runningChores.delete(chore), scheduleBlockedChoresAndDrainIfNeeded(chore);
                        let finished = !1;
                        drainChore && !runningChores.size && (finished = maybeFinishDrain()), finished || isDraining || scheduleFlushTimer();
                    })) : (finishChore(chore, result), scheduleBlockedChoresAndDrainIfNeeded(chore)), 
                    shouldApplyJournalFlush(isServer)) {
                        return applyJournalFlush(), void drainInNextTick();
                    }
                }
            } catch (e) {
                handleError(currentChore, e), scheduleBlockedChoresAndDrainIfNeeded(currentChore);
            } finally {
                isDraining = !1, maybeFinishDrain();
            }
        }
        function finishChore(chore, value) {
            chore.$endTime$ = performance.now(), chore.$state$ = ChoreState.DONE, chore.$returnValue$ = value, 
            chore.$resolve$?.(value), vnode_isVNode(chore.$host$) && chore.$host$.chores?.delete(chore);
        }
        function handleError(chore, e) {
            chore.$endTime$ = performance.now(), chore.$state$ = ChoreState.FAILED, chore.$reject$?.(e), 
            container.handleError(e, chore.$host$);
        }
        function executeChore(chore, isServer) {
            const host = chore.$host$;
            let returnValue;
            switch (chore.$type$) {
              case 6:
                returnValue = safeCall(() => executeComponent(container, host, host, chore.$target$, chore.$payload$), jsx => {
                    if (isServer) {
                        return jsx;
                    }
                    {
                        const styleScopedId = container.getHostProp(host, "q:sstyle");
                        return retryOnPromise(() => vnode_diff(container, jsx, host, addComponentStylePrefix(styleScopedId)));
                    }
                }, err => {
                    handleError(chore, err);
                });
                break;

              case 2:
                {
                    const fn = chore.$target$.getFn();
                    returnValue = retryOnPromise(() => fn(...chore.$payload$));
                }
                break;

              case 3:
              case 16:
                {
                    const payload = chore.$payload$;
                    returnValue = 4 & payload.$flags$ ? runResource(payload, container, host) : runTask(payload, container, host);
                }
                break;

              case 32:
                cleanupTask(chore.$payload$);
                break;

              case 4:
                {
                    const parentVirtualNode = chore.$target$;
                    let jsx = chore.$payload$;
                    isSignal(jsx) && (jsx = jsx.value), returnValue = retryOnPromise(() => vnode_diff(container, jsx, parentVirtualNode, null));
                }
                break;

              case 5:
                {
                    const virtualNode = chore.$host$;
                    const payload = chore.$payload$;
                    let value = payload.$value$;
                    isSignal(value) && (value = value.value);
                    const isConst = payload.$isConst$;
                    const journal = container.$journal$;
                    const property = chore.$idx$;
                    const serializedValue = serializeAttribute(property, value, payload.$scopedStyleIdPrefix$);
                    if (isServer) {
                        container.addBackpatchEntry(chore.$host$.id, property, serializedValue), returnValue = null;
                    } else {
                        if (isConst) {
                            journal.push(2, virtualNode.element, property, serializedValue);
                        } else {
                            virtualNode.setAttr(property, serializedValue, journal);
                        }
                        returnValue = void 0;
                    }
                }
                break;

              case 1:
                {
                    const target = chore.$target$;
                    returnValue = target.resolved ? null : target.resolve();
                }
                break;

              case 7:
                {
                    const target = chore.$target$;
                    const effects = chore.$payload$;
                    if (!effects?.size) {
                        break;
                    }
                    let shouldCompute = target instanceof ComputedSignalImpl || target instanceof WrappedSignalImpl;
                    if (target instanceof AsyncComputedSignalImpl && effects !== target.$effects$ && (shouldCompute = !1), 
                    shouldCompute) {
                        const ctx = newInvokeContext();
                        ctx.$container$ = container, returnValue = maybeThen(retryOnPromise(() => invoke.call(target, ctx, target.$computeIfNeeded$)), () => {
                            if (2 & target.$flags$) {
                                return target.$flags$ &= -3, retryOnPromise(() => scheduleEffects(container, target, effects));
                            }
                        });
                    } else {
                        returnValue = retryOnPromise(() => {
                            scheduleEffects(container, target, effects);
                        });
                    }
                }
            }
            return returnValue;
        }
    };
    function vNodeAlreadyDeleted(chore) {
        return !!(chore.$host$ && vnode_isVNode(chore.$host$) && 32 & chore.$host$.flags);
    }
    function addBlockedChore(blockedChore, blockingChore, blockedChores) {
        (blockingChore.$blockedChores$ ||= new ChoreArray).add(blockedChore), blockedChores.add(blockedChore), 
        vnode_isVNode(blockedChore.$host$) && (blockedChore.$host$.blockedChores ||= new ChoreArray).add(blockedChore);
    }
    function addChore(chore, choreArray) {
        choreArray.add(chore) < 0 && vnode_isVNode(chore.$host$) && (chore.$host$.chores ||= new ChoreArray).add(chore);
    }
    function choreTypeToName(type) {
        return {
            1: "Resolve QRL",
            2: "Run QRL",
            3: "Task",
            4: "Changes diffing",
            5: "Updating node property",
            6: "Component",
            7: "Signal recompute",
            16: "Visible",
            32: "Cleanup visible",
            255: "Wait for queue"
        }[type] || "Unknown: " + type;
    }
    const _run = (...args) => {
        const [runQrl] = useLexicalScope();
        const context = getInvokeContext();
        const hostElement = context.$hostElement$;
        if (!hostElement) {
            return;
        }
        const scheduler = getDomContainer(context.$element$).$scheduler$;
        if (!scheduler) {
            throw qError(1);
        }
        const chore = scheduler(2, hostElement, runQrl, args);
        return getChorePromise(chore);
    };
    async function serialize(serializationContext) {
        const {$writer$, $isSsrNode$, $isDomRef$, $storeProxyMap$, $addRoot$, $promoteToRoot$, getSeenRef, $markSeen$} = serializationContext;
        let rootIdx = 0;
        const forwardRefs = [];
        let forwardRefsId = 0;
        const promises = new Set;
        const preloadQrls = new Set;
        const s11nWeakRefs = new Map;
        let parent;
        const qrlMap = new Map;
        const outputArray = (value, keepNulls, writeFn) => {
            $writer$.write("[");
            let separator = !1;
            let length;
            if (keepNulls) {
                length = value.length;
            } else {
                for (length = value.length - 1; length >= 0 && null === value[length]; ) {
                    length--;
                }
                length++;
            }
            for (let i = 0; i < length; i++) {
                separator ? $writer$.write(",") : separator = !0, writeFn(value[i], i);
            }
            $writer$.write("]");
        };
        const output = (type, value, keepNulls) => {
            if ($writer$.write(`${type},`), "number" == typeof value) {
                $writer$.write(value.toString());
            } else if ("string" == typeof value) {
                const s = JSON.stringify(value);
                let angleBracketIdx = -1;
                let lastIdx = 0;
                for (;-1 !== (angleBracketIdx = s.indexOf("</", lastIdx)); ) {
                    $writer$.write(s.slice(lastIdx, angleBracketIdx)), $writer$.write("<\\/"), lastIdx = angleBracketIdx + 2;
                }
                $writer$.write(0 === lastIdx ? s : s.slice(lastIdx));
            } else {
                outputArray(value, keepNulls, (valueItem, idx) => {
                    writeValue(valueItem, idx);
                });
            }
        };
        const addPreloadQrl = qrl => {
            isSyncQrl(qrl) || (preloadQrls.add(qrl), serializationContext.$addRoot$(qrl));
        };
        const getSeenRefOrOutput = (value, index, keepWeak) => {
            let seen = getSeenRef(value);
            const forwardRefIdx = !keepWeak && s11nWeakRefs.get(value);
            if (!seen) {
                if (keepWeak) {
                    return !0;
                }
                if ("number" != typeof forwardRefIdx) {
                    return $markSeen$(value, parent, index);
                }
                seen = $addRoot$(value, !0);
            }
            seen.$parent$ && (parent ? $promoteToRoot$(seen) : ($promoteToRoot$(seen, index), 
            value = serializationContext.$roots$[index])), "number" == typeof forwardRefIdx && (forwardRefs[forwardRefIdx] = seen.$index$, 
            s11nWeakRefs.delete(value));
            const rootIdx = value instanceof BackRef ? value.$path$ : seen.$index$;
            if (!parent && rootIdx === index) {
                return seen;
            }
            output(1, rootIdx);
        };
        const writeValue = (value, index) => {
            if (fastSkipSerialize(value)) {
                output(3, 0);
            } else {
                switch (typeof value) {
                  case "undefined":
                    output(3, 0);
                    break;

                  case "boolean":
                    output(3, value ? 2 : 3);
                    break;

                  case "number":
                    Number.isNaN(value) ? output(3, 12) : Number.isFinite(value) ? value === Number.MAX_SAFE_INTEGER ? output(3, 15) : value === Number.MAX_SAFE_INTEGER - 1 ? output(3, 16) : value === Number.MIN_SAFE_INTEGER ? output(3, 17) : output(0, value) : output(3, value < 0 ? 14 : 13);
                    break;

                  case "string":
                    0 === value.length ? output(3, 4) : (value.length < 4 || getSeenRefOrOutput(value, index)) && output(0, value);
                    break;

                  case "bigint":
                    (value < 1e4 && value > -1e3 || getSeenRefOrOutput(value, index)) && output(11, value.toString());
                    break;

                  case "symbol":
                    value === NEEDS_COMPUTATION ? output(3, 7) : value === STORE_ALL_PROPS ? output(3, 8) : value === _UNINITIALIZED && output(3, 9);
                    break;

                  case "function":
                    if (value === Slot) {
                        output(3, 10);
                    } else if (value === Fragment) {
                        output(3, 11);
                    } else if (isQrl(value)) {
                        if (getSeenRefOrOutput(value, index)) {
                            const [chunk, symbol, captureIds] = qrlToString(serializationContext, value, !0);
                            let data;
                            let type;
                            if ("" !== chunk) {
                                data = `${$addRoot$(chunk)} ${$addRoot$(symbol)}${captureIds ? " " + captureIds.join(" ") : ""}`;
                                const existing = qrlMap.get(data);
                                if (existing) {
                                    const ref = $addRoot$(existing);
                                    return void output(1, ref);
                                }
                                qrlMap.set(data, value), type = preloadQrls.has(value) ? 20 : 19;
                            } else {
                                data = Number(symbol), type = 19;
                            }
                            output(type, data);
                        }
                    } else {
                        if (!isQwikComponent(value)) {
                            throw qError(34, [ value.toString() ]);
                        }
                        {
                            const [qrl] = value[SERIALIZABLE_STATE];
                            serializationContext.$renderSymbols$.add(qrl.$symbol$), output(23, [ qrl ]);
                        }
                    }
                    break;

                  case "object":
                    if (value === EMPTY_ARRAY) {
                        output(3, 5);
                    } else if (value === EMPTY_OBJ) {
                        output(3, 6);
                    } else if (null === value) {
                        output(3, 1);
                    } else if (value instanceof BackRef) {
                        output(1, value.$path$);
                    } else {
                        const newSeenRef = getSeenRefOrOutput(value, index);
                        if (newSeenRef) {
                            const oldParent = parent;
                            parent = newSeenRef, writeObjectValue(value), parent = oldParent;
                        }
                    }
                    break;

                  default:
                    throw qError(20, [ typeof value ]);
                }
            }
        };
        const writeObjectValue = value => {
            if (isPropsProxy(value)) {
                const owner = value[_OWNER];
                output(32, [ _serializationWeakRef(owner), owner.varProps, owner.constProps ]);
            } else if (value instanceof SubscriptionData) {
                output(33, [ value.data.$scopedStyleIdPrefix$, value.data.$isConst$ ]);
            } else if (isStore(value)) {
                if (function(value) {
                    return "__brand" in value && "resource" === value.__brand;
                }(value)) {
                    serializationContext.$resources$.add(value);
                    const forwardRefId = resolvePromise(value.value, $addRoot$, (resolved, resolvedValue) => new PromiseResult(22, resolved, resolvedValue, getStoreHandler(value).$effects$));
                    output(2, forwardRefId);
                } else {
                    const storeHandler = getStoreHandler(value);
                    const storeTarget = getStoreTarget(value);
                    const flags = storeHandler.$flags$;
                    const effects = storeHandler.$effects$;
                    const innerStores = [];
                    for (const prop in storeTarget) {
                        const innerStore = $storeProxyMap$.get(storeTarget[prop]);
                        innerStore && innerStores.push(innerStore);
                    }
                    const out = [ storeTarget, flags, effects, ...innerStores ];
                    for (;null == out[out.length - 1]; ) {
                        out.pop();
                    }
                    output(29, out);
                }
            } else if (isSerializerObj(value)) {
                const result = value[SerializerSymbol](value);
                if (isPromise(result)) {
                    const forwardRef = resolvePromise(result, $addRoot$, (resolved, resolvedValue) => new PromiseResult(28, resolved, resolvedValue, null, null));
                    output(2, forwardRef);
                } else {
                    const index = parent.$index$;
                    parent = parent.$parent$, writeValue(result, index);
                }
            } else if (function(obj) {
                const prototype = Object.getPrototypeOf(obj);
                return null == prototype || prototype === Object.prototype || prototype === Array.prototype;
            }(value)) {
                if (Array.isArray(value)) {
                    output(4, value);
                } else {
                    const out = [];
                    for (const key in value) {
                        if (Object.prototype.hasOwnProperty.call(value, key)) {
                            const subVal = value[key];
                            fastSkipSerialize(subVal) || out.push(key, subVal);
                        }
                    }
                    output(5, out.length ? out : 0);
                }
            } else if ($isDomRef$(value)) {
                value.$ssrNode$.vnodeData[0] |= 16, output(10, value.$ssrNode$.id);
            } else if (value instanceof SignalImpl) {
                if (value instanceof SerializerSignalImpl) {
                    addPreloadQrl(value.$computeQrl$);
                    const forwardRefId = resolvePromise(function(signal, value) {
                        return new Promise(resolve => {
                            signal.$computeQrl$.resolve().then(arg => {
                                let data;
                                arg.serialize ? data = arg.serialize(value) : SerializerSymbol in value && (data = value[SerializerSymbol](value)), 
                                void 0 === data && (data = NEEDS_COMPUTATION), resolve(data);
                            });
                        });
                    }(value, value.$untrackedValue$), $addRoot$, (resolved, resolvedValue) => new PromiseResult(28, resolved, resolvedValue, value.$effects$, value.$computeQrl$));
                    return void output(2, forwardRefId);
                }
                if (value instanceof WrappedSignalImpl) {
                    output(25, [ ...serializeWrappingFn(serializationContext, value), filterEffectBackRefs(value[_EFFECT_BACK_REF]), value.$flags$, value.$hostElement$, ...value.$effects$ || [] ]);
                } else if (value instanceof ComputedSignalImpl) {
                    let v = value.$untrackedValue$;
                    const shouldAlwaysSerialize = 32 & value.$flags$;
                    const shouldNeverSerialize = 16 & value.$flags$;
                    const isInvalid = 1 & value.$flags$;
                    const isSkippable = fastSkipSerialize(value.$untrackedValue$);
                    shouldAlwaysSerialize ? v = value.$untrackedValue$ : (shouldNeverSerialize || isInvalid || isSkippable) && (v = NEEDS_COMPUTATION), 
                    addPreloadQrl(value.$computeQrl$);
                    const out = [ value.$computeQrl$, value.$effects$ ];
                    const isAsync = value instanceof AsyncComputedSignalImpl;
                    isAsync && out.push(value.$loadingEffects$, value.$errorEffects$, value.$untrackedLoading$, value.$untrackedError$), 
                    v !== NEEDS_COMPUTATION && out.push(v), output(isAsync ? 27 : 26, out);
                } else {
                    output(24, [ value.$untrackedValue$, ...value.$effects$ || [] ]);
                }
            } else if (value instanceof URL) {
                output(6, value.href);
            } else if (value instanceof Date) {
                output(7, Number.isNaN(value.valueOf()) ? "" : value.valueOf());
            } else if (value instanceof RegExp) {
                output(8, value.toString());
            } else if (value instanceof Error) {
                const out = [ value.message ];
                out.push(...Object.entries(value).flat()), build.isDev && out.push("stack", value.stack), 
                output(14, out);
            } else if ($isSsrNode$(value)) {
                const rootIndex = $addRoot$(value);
                serializationContext.$setProp$(value, "q:id", String(rootIndex)), output(9, value.id);
                const vNodeData = value.vnodeData;
                if (vNodeData && (discoverValuesForVNodeData(vNodeData, vNodeDataValue => $addRoot$(vNodeDataValue)), 
                vNodeData[0] |= 16), value.children) {
                    for (const child of value.children) {
                        const childVNodeData = child.vnodeData;
                        if (childVNodeData) {
                            for (const value of childVNodeData) {
                                if (isSsrAttrs(value)) {
                                    const backRefKeyIndex = value.findIndex(v => "q:brefs" === v);
                                    -1 !== backRefKeyIndex && $addRoot$(value[backRefKeyIndex + 1]);
                                }
                            }
                            childVNodeData[0] |= 16;
                        }
                    }
                }
            } else if ("undefined" != typeof FormData && value instanceof FormData) {
                const array = [];
                value.forEach((value, key) => {
                    array.push(key, "string" == typeof value ? value : value.name);
                }), output(30, array);
            } else if (value instanceof URLSearchParams) {
                output(12, value.toString());
            } else if (value instanceof Set) {
                output(16, [ ...value.values() ]);
            } else if (value instanceof Map) {
                const combined = [];
                for (const [k, v] of value.entries()) {
                    combined.push(k, v);
                }
                output(17, combined);
            } else if (isJSXNode(value)) {
                const out = [ value.type, value.key, value.varProps, value.constProps, value.children, value.toSort || null ];
                for (;null == out[out.length - 1]; ) {
                    out.pop();
                }
                output(31, out);
            } else if (value instanceof Task) {
                const out = [ value.$qrl$, value.$flags$, value.$index$, value.$el$, value[_EFFECT_BACK_REF], value.$state$ ];
                for (;null == out[out.length - 1]; ) {
                    out.pop();
                }
                output(21, out);
            } else if (isPromise(value)) {
                const forwardRefId = resolvePromise(value, $addRoot$, (resolved, resolvedValue) => new PromiseResult(15, resolved, resolvedValue));
                output(2, forwardRefId);
            } else if (value instanceof PromiseResult) {
                if (22 === value.$type$) {
                    output(22, [ value.$resolved$, value.$value$, value.$effects$ ]);
                } else if (28 === value.$type$) {
                    if (value.$qrl$) {
                        output(28, [ value.$qrl$, value.$effects$, value.$value$ ]);
                    } else {
                        if (!value.$resolved$) {
                            throw console.error(value.$value$), qError(33);
                        }
                        {
                            const index = parent.$index$;
                            parent = parent.$parent$, writeValue(value.$value$, index);
                        }
                    }
                } else {
                    output(15, [ value.$resolved$, value.$value$ ]);
                }
            } else if (value instanceof Uint8Array) {
                let buf = "";
                for (const c of value) {
                    buf += String.fromCharCode(c);
                }
                const out = btoa(buf).replace(/=+$/, "");
                output(18, out);
            } else if (value instanceof SerializationWeakRef) {
                const obj = value.$obj$;
                if (getSeenRefOrOutput(obj, parent.$index$, !0)) {
                    let forwardRefId = s11nWeakRefs.get(obj);
                    void 0 === forwardRefId && (forwardRefId = forwardRefsId++, s11nWeakRefs.set(obj, forwardRefId), 
                    forwardRefs[forwardRefId] = -1), output(2, forwardRefId);
                }
            } else {
                if (!vnode_isVNode(value)) {
                    throw qError(20, [ typeof value ]);
                }
                output(3, 0);
            }
        };
        function resolvePromise(promise, $addRoot$, classCreator) {
            const forwardRefId = forwardRefsId++;
            return promise.then(resolvedValue => {
                promises.delete(promise), forwardRefs[forwardRefId] = $addRoot$(classCreator(!0, resolvedValue));
            }).catch(err => {
                promises.delete(promise), forwardRefs[forwardRefId] = $addRoot$(classCreator(!1, err));
            }), promises.add(promise), forwardRefId;
        }
        await (async () => {
            $writer$.write("[");
            const {$roots$} = serializationContext;
            for (;rootIdx < $roots$.length || promises.size; ) {
                0 !== rootIdx && $writer$.write(",");
                let separator = !1;
                for (;rootIdx < $roots$.length; rootIdx++) {
                    separator ? $writer$.write(",") : separator = !0, writeValue($roots$[rootIdx], rootIdx);
                }
                if (promises.size) {
                    try {
                        await Promise.race(promises);
                    } catch {}
                }
            }
            if (forwardRefs.length) {
                let lastIdx = forwardRefs.length - 1;
                for (;lastIdx >= 0 && -1 === forwardRefs[lastIdx]; ) {
                    lastIdx--;
                }
                if (lastIdx >= 0) {
                    $writer$.write(","), $writer$.write("13,");
                    const out = lastIdx === forwardRefs.length - 1 ? forwardRefs : forwardRefs.slice(0, lastIdx + 1);
                    outputArray(out, !0, value => {
                        $writer$.write(String(value));
                    });
                }
            }
            $writer$.write("]");
        })();
    }
    class PromiseResult {
        $type$;
        $resolved$;
        $value$;
        $effects$;
        $qrl$;
        constructor($type$, $resolved$, $value$, $effects$ = null, $qrl$ = null) {
            this.$type$ = $type$, this.$resolved$ = $resolved$, this.$value$ = $value$, this.$effects$ = $effects$, 
            this.$qrl$ = $qrl$;
        }
    }
    const discoverValuesForVNodeData = (vnodeData, callback) => {
        for (const value of vnodeData) {
            if (isSsrAttrs(value)) {
                for (let i = 1; i < value.length; i += 2) {
                    const attrValue = value[i];
                    null == attrValue || "string" == typeof attrValue || "q:props" === value[i - 1] && 0 === Object.keys(attrValue).length || callback(attrValue);
                }
            }
        }
    };
    const isSsrAttrs = value => Array.isArray(value) && value.length > 0;
    function serializeWrappingFn(serializationContext, value) {
        value.$funcStr$ && "{" === value.$funcStr$[0] && (value.$funcStr$ = `(${value.$funcStr$})`);
        return [ serializationContext.$addSyncFn$(value.$funcStr$, value.$args$.length, value.$func$), value.$args$ ];
    }
    function filterEffectBackRefs(effectBackRef) {
        let effectBackRefToSerialize = null;
        if (effectBackRef) {
            for (const [effectProp, effect] of effectBackRef) {
                effect[2] && (effectBackRefToSerialize ||= new Map, effectBackRefToSerialize.set(effectProp, effect));
            }
        }
        return effectBackRefToSerialize;
    }
    class SerializationWeakRef {
        $obj$;
        constructor($obj$) {
            this.$obj$ = $obj$;
        }
    }
    const _serializationWeakRef = obj => new SerializationWeakRef(obj);
    let isDomRef = () => !1;
    class BackRef {
        $path$;
        constructor($path$) {
            this.$path$ = $path$;
        }
    }
    const createSerializationContext = (NodeConstructor, DomRefConstructor, symbolToChunkResolver, getProp, setProp, storeProxyMap, writer) => {
        if (!writer) {
            const buffer = [];
            writer = {
                write: text => buffer.push(text),
                toString: () => buffer.join("")
            };
        }
        const seenObjsMap = new Map;
        const syncFnMap = new Map;
        const syncFns = [];
        const roots = [];
        const $promoteToRoot$ = (ref, index) => {
            const path = (ref => {
                const path = [];
                for (;ref.$parent$; ) {
                    path.unshift(ref.$index$), ref = ref.$parent$;
                }
                return path.unshift(ref.$index$), path.join(" ");
            })(ref);
            void 0 === index && (index = roots.length), roots[index] = new BackRef(path), ref.$parent$ = null, 
            ref.$index$ = index;
        };
        const isSsrNode = NodeConstructor ? obj => obj instanceof NodeConstructor : () => !1;
        return isDomRef = DomRefConstructor ? obj => obj instanceof DomRefConstructor : () => !1, 
        {
            async $serialize$() {
                return await serialize(this);
            },
            $isSsrNode$: isSsrNode,
            $isDomRef$: isDomRef,
            $symbolToChunkResolver$: symbolToChunkResolver,
            getSeenRef: obj => seenObjsMap.get(obj),
            $roots$: roots,
            $markSeen$: (obj, parent, index) => {
                const ref = {
                    $index$: index,
                    $parent$: parent
                };
                return seenObjsMap.set(obj, ref), ref;
            },
            $hasRootId$: obj => {
                const id = seenObjsMap.get(obj);
                return id && (id.$parent$ ? void 0 : id.$index$);
            },
            $promoteToRoot$,
            $addRoot$: (obj, returnRef) => {
                let seen = seenObjsMap.get(obj);
                let index;
                return seen ? (seen.$parent$ && $promoteToRoot$(seen), index = seen.$index$) : (index = roots.length, 
                seen = {
                    $index$: index
                }, seenObjsMap.set(obj, seen), roots.push(obj)), returnRef ? seen : index;
            },
            $syncFns$: syncFns,
            $addSyncFn$: (funcStr, argCount, fn) => {
                const isFullFn = null == funcStr;
                isFullFn && (funcStr = fn.serialized || fn.toString());
                let id = syncFnMap.get(funcStr);
                if (void 0 === id) {
                    if (id = syncFns.length, syncFnMap.set(funcStr, id), isFullFn) {
                        syncFns.push(funcStr);
                    } else {
                        let code = "(";
                        for (let i = 0; i < argCount; i++) {
                            code += (0 == i ? "p" : ",p") + i;
                        }
                        syncFns.push(code += ")=>" + funcStr);
                    }
                }
                return id;
            },
            $writer$: writer,
            $eventQrls$: new Set,
            $eventNames$: new Set,
            $resources$: new Set,
            $renderSymbols$: new Set,
            $storeProxyMap$: storeProxyMap,
            $getProp$: getProp,
            $setProp$: setProp
        };
    };
    class _SharedContainer {
        $version$;
        $scheduler$;
        $storeProxyMap$;
        $locale$;
        $getObjectById$;
        $serverData$;
        $currentUniqueId$=0;
        $instanceHash$=null;
        $buildBase$=null;
        $flushEpoch$=0;
        constructor(journalFlush, serverData, locale) {
            this.$serverData$ = serverData, this.$locale$ = locale, this.$version$ = version, 
            this.$storeProxyMap$ = new WeakMap, this.$getObjectById$ = () => {
                throw Error("Not implemented");
            };
            const choreQueue = new ChoreArray;
            const blockedChores = new Set;
            const runningChores = new Set;
            this.$scheduler$ = createScheduler(this, journalFlush, choreQueue, blockedChores, runningChores);
        }
        trackSignalValue(signal, subscriber, property, data) {
            return trackSignalAndAssignHost(signal, subscriber, property, this, data);
        }
        serializationCtxFactory(NodeConstructor, DomRefConstructor, symbolToChunkResolver, writer) {
            return createSerializationContext(NodeConstructor, DomRefConstructor, symbolToChunkResolver, this.getHostProp.bind(this), this.setHostProp.bind(this), this.$storeProxyMap$, writer);
        }
    }
    class ParentComponentData {
        $scopedStyle$;
        $componentFrame$;
        constructor($scopedStyle$, $componentFrame$) {
            this.$scopedStyle$ = $scopedStyle$, this.$componentFrame$ = $componentFrame$;
        }
    }
    class MaybeAsyncSignal {}
    async function _walkJSX(ssr, value, options) {
        const stack = [ value ];
        const enqueue = value => stack.push(value);
        await (async () => {
            for (;stack.length; ) {
                const value = stack.pop();
                if (value instanceof ParentComponentData) {
                    options.currentStyleScoped = value.$scopedStyle$, options.parentComponentFrame = value.$componentFrame$;
                } else {
                    if (value === MaybeAsyncSignal) {
                        const trackFn = stack.pop();
                        await retryOnPromise(() => stack.push(trackFn()));
                        continue;
                    }
                    if ("function" != typeof value) {
                        processJSXNode(ssr, enqueue, value, {
                            styleScoped: options.currentStyleScoped,
                            parentComponentFrame: options.parentComponentFrame
                        });
                    } else {
                        if (value === Promise) {
                            stack.push(await stack.pop());
                            continue;
                        }
                        await value.apply(ssr);
                    }
                }
            }
        })();
    }
    function processJSXNode(ssr, enqueue, value, options) {
        if (null == value) {
            ssr.textNode("");
        } else if ("boolean" == typeof value) {
            ssr.textNode("");
        } else if ("number" == typeof value) {
            ssr.textNode(String(value));
        } else if ("string" == typeof value) {
            ssr.textNode(value);
        } else if ("object" == typeof value) {
            if (Array.isArray(value)) {
                for (let i = value.length - 1; i >= 0; i--) {
                    enqueue(value[i]);
                }
            } else if (isSignal(value)) {
                ssr.openFragment(build.isDev ? [ "q:type", "S" ] : EMPTY_ARRAY);
                const signalNode = ssr.getOrCreateLastNode();
                const unwrappedSignal = value instanceof WrappedSignalImpl ? value.$unwrapIfSignal$() : value;
                enqueue(ssr.closeFragment), enqueue(() => trackSignalAndAssignHost(unwrappedSignal, signalNode, ".", ssr)), 
                enqueue(MaybeAsyncSignal);
            } else if (isPromise(value)) {
                ssr.openFragment(build.isDev ? [ "q:type", "A" ] : EMPTY_ARRAY), enqueue(ssr.closeFragment), 
                enqueue(value), enqueue(Promise), enqueue(() => ssr.commentNode("qkssr-f"));
            } else if (function(value) {
                return !!value[Symbol.asyncIterator];
            }(value)) {
                enqueue(async () => {
                    for await (const chunk of value) {
                        await _walkJSX(ssr, chunk, {
                            currentStyleScoped: options.styleScoped,
                            parentComponentFrame: options.parentComponentFrame
                        }), ssr.commentNode("qkssr-f");
                    }
                });
            } else {
                const jsx = value;
                const type = jsx.type;
                if ("string" == typeof type) {
                    !function(jsx, styleScoped) {
                        const classAttributeExists = null != directGetPropsProxyProp(jsx, "class");
                        !classAttributeExists && styleScoped && (jsx.constProps || (jsx.constProps = {}), 
                        jsx.constProps.class = "");
                    }(jsx, options.styleScoped);
                    let qwikInspectorAttrValue = null;
                    build.isDev && jsx.dev && "head" !== jsx.type && (qwikInspectorAttrValue = getFileLocationFromJsx(jsx.dev));
                    const innerHTML = ssr.openElement(type, function(varProps, constProps, options) {
                        return toSsrAttrs(varProps, options);
                    }(jsx.varProps, 0, {
                        serializationCtx: ssr.serializationCtx,
                        styleScopedId: options.styleScoped,
                        key: jsx.key,
                        toSort: jsx.toSort
                    }), function(constProps, varProps, options) {
                        return toSsrAttrs(constProps, options);
                    }(jsx.constProps, 0, {
                        serializationCtx: ssr.serializationCtx,
                        styleScopedId: options.styleScoped
                    }), qwikInspectorAttrValue);
                    innerHTML && ssr.htmlNode(innerHTML), enqueue(ssr.closeElement), "head" === type ? (ssr.emitQwikLoaderAtTopIfNeeded(), 
                    ssr.emitPreloaderPre(), enqueue(ssr.additionalHeadNodes)) : "body" === type ? enqueue(ssr.additionalBodyNodes) : ssr.isHtml || ssr._didAddQwikLoader || (ssr.emitQwikLoaderAtTopIfNeeded(), 
                    ssr.emitPreloaderPre(), ssr._didAddQwikLoader = !0);
                    const children = jsx.children;
                    null != children && enqueue(children);
                } else if (isFunction(type)) {
                    if (type === Fragment) {
                        let attrs = null != jsx.key ? [ "q:key", jsx.key ] : EMPTY_ARRAY;
                        build.isDev && (attrs = [ "q:type", "F", ...attrs ]), ssr.openFragment(attrs), enqueue(ssr.closeFragment);
                        const children = jsx.children;
                        null != children && enqueue(children);
                    } else if (type === Slot) {
                        const componentFrame = options.parentComponentFrame || ssr.unclaimedProjectionComponentFrameQueue.shift();
                        if (componentFrame) {
                            const projectionAttrs = build.isDev ? [ "q:type", "P" ] : [];
                            projectionAttrs.push("q:sparent", componentFrame.componentNode.id || ""), ssr.openProjection(projectionAttrs);
                            const host = componentFrame.componentNode;
                            const node = ssr.getOrCreateLastNode();
                            const slotName = function(host, jsx, ssr) {
                                const constProps = jsx.constProps;
                                if (constProps && "object" == typeof constProps && "name" in constProps) {
                                    const constValue = constProps.name;
                                    if (constValue instanceof WrappedSignalImpl) {
                                        return trackSignalAndAssignHost(constValue, host, ":", ssr);
                                    }
                                }
                                return directGetPropsProxyProp(jsx, "name") || "";
                            }(host, jsx, ssr);
                            projectionAttrs.push(QSlot, slotName), enqueue(new ParentComponentData(options.styleScoped, options.parentComponentFrame)), 
                            enqueue(ssr.closeProjection);
                            const slotDefaultChildren = jsx.children || null;
                            const slotChildren = componentFrame.consumeChildrenForSlot(node, slotName) || slotDefaultChildren;
                            slotDefaultChildren && slotChildren !== slotDefaultChildren && ssr.addUnclaimedProjection(componentFrame, "", slotDefaultChildren), 
                            enqueue(slotChildren), enqueue(new ParentComponentData(componentFrame.projectionScopedStyle, componentFrame.projectionComponentFrame));
                        } else {
                            ssr.openFragment(build.isDev ? [ "q:type", "P" ] : EMPTY_ARRAY), ssr.closeFragment();
                        }
                    } else if (type === SSRComment) {
                        ssr.commentNode(directGetPropsProxyProp(jsx, "data") || "");
                    } else if (type === SSRStream) {
                        ssr.commentNode("qkssr-f");
                        const generator = jsx.children;
                        let value;
                        value = isFunction(generator) ? generator({
                            async write(chunk) {
                                await _walkJSX(ssr, chunk, {
                                    currentStyleScoped: options.styleScoped,
                                    parentComponentFrame: options.parentComponentFrame
                                }), ssr.commentNode("qkssr-f");
                            }
                        }) : generator, enqueue(value), isPromise(value) && enqueue(Promise);
                    } else if (type === SSRRaw) {
                        ssr.htmlNode(directGetPropsProxyProp(jsx, "data"));
                    } else if (isQwikComponent(type)) {
                        ssr.openComponent(build.isDev ? [ "q:type", "C" ] : []);
                        const host = ssr.getOrCreateLastNode();
                        const componentFrame = ssr.getParentComponentFrame();
                        componentFrame.distributeChildrenIntoSlots(jsx.children, options.styleScoped, options.parentComponentFrame);
                        const jsxOutput = ((ssr, jsx, component) => {
                            const host = ssr.getOrCreateLastNode();
                            const [componentQrl] = component[SERIALIZABLE_STATE];
                            const srcProps = jsx.props;
                            srcProps && srcProps.children && delete srcProps.children, host.setProp("q:renderFn", componentQrl), 
                            host.setProp("q:props", srcProps), null !== jsx.key && host.setProp("q:key", jsx.key);
                            const componentChore = ssr.$scheduler$(6, host, componentQrl, srcProps);
                            return getChorePromise(componentChore);
                        })(ssr, jsx, type);
                        const compStyleComponentId = addComponentStylePrefix(host.getProp("q:sstyle"));
                        enqueue(new ParentComponentData(options.styleScoped, options.parentComponentFrame)), 
                        enqueue(ssr.closeComponent), enqueue(jsxOutput), isPromise(jsxOutput) && enqueue(Promise), 
                        enqueue(new ParentComponentData(compStyleComponentId, componentFrame));
                    } else {
                        const inlineComponentProps = [ "q:key", jsx.key ];
                        ssr.openFragment(build.isDev ? [ "q:type", "I", ...inlineComponentProps ] : inlineComponentProps), 
                        enqueue(ssr.closeFragment);
                        const component = ssr.getComponentFrame(0);
                        const jsxOutput = ((ssr, componentHost, inlineComponentFunction, jsx) => {
                            const host = ssr.getOrCreateLastNode();
                            return executeComponent(ssr, host, componentHost, inlineComponentFunction, jsx.props);
                        })(ssr, component && component.componentNode, type, jsx);
                        enqueue(jsxOutput), isPromise(jsxOutput) && enqueue(Promise);
                    }
                }
            }
        }
    }
    function toSsrAttrs(record, options) {
        if (null == record) {
            return null;
        }
        const ssrAttrs = [];
        const handleProp = (key, value) => {
            if (null != value) {
                if (isHtmlAttributeAnEventName(key)) {
                    const eventValue = setEvent(options.serializationCtx, key, value);
                    return void (eventValue && ssrAttrs.push(key, eventValue));
                }
                isSignal(value) ? isClassAttr(key) ? ssrAttrs.push(key, [ value, options.styleScopedId ]) : ssrAttrs.push(key, value) : (isPreventDefault(key) && function(serializationCtx, key) {
                    const eventName = key.substring(15);
                    eventName && serializationCtx.$eventNames$.add(eventName);
                }(options.serializationCtx, key), value = serializeAttribute(key, value, options.styleScopedId), 
                ssrAttrs.push(key, value));
            }
        };
        if (options.toSort) {
            const keys = Object.keys(record).sort();
            for (const key of keys) {
                handleProp(key, record[key]);
            }
        } else {
            for (const key in record) {
                handleProp(key, record[key]);
            }
        }
        return null != options.key && ssrAttrs.push("q:key", options.key), ssrAttrs;
    }
    function setEvent(serializationCtx, key, rawValue) {
        let value = null;
        const qrls = rawValue;
        const appendToValue = valueToAppend => {
            value = (null == value ? "" : value + "\n") + valueToAppend;
        };
        const getQrlString = qrl => (qrl.$symbol$.startsWith("_") || !qrl.$captureRef$ && !qrl.$capture$ || (qrl = createQRL(null, "_run", _run, null, null, [ qrl ])), 
        qrlToString(serializationCtx, qrl));
        if (Array.isArray(qrls)) {
            for (let i = 0; i <= qrls.length; i++) {
                const qrl = qrls[i];
                if (isQrl(qrl)) {
                    appendToValue(getQrlString(qrl)), addQwikEventToSerializationContext(serializationCtx, key, qrl);
                } else if (null != qrl) {
                    const nestedValue = setEvent(serializationCtx, key, qrl);
                    nestedValue && appendToValue(nestedValue);
                }
            }
        } else {
            isQrl(qrls) && (value = getQrlString(qrls), addQwikEventToSerializationContext(serializationCtx, key, qrls));
        }
        return value;
    }
    function addQwikEventToSerializationContext(serializationCtx, key, qrl) {
        const data = getEventDataFromHtmlAttribute(key);
        if (data) {
            serializationCtx.$eventNames$.add(data[1]), serializationCtx.$eventQrls$.add(qrl);
        }
    }
    const inflate = (container, target, typeId, data) => {
        if (0 !== typeId) {
            switch (4 !== typeId && Array.isArray(data) && (data = _eagerDeserializeArray(container, data)), 
            typeId) {
              case 4:
                _eagerDeserializeArray(container, data, target);
                break;

              case 5:
                if (0 === data) {
                    break;
                }
                for (let i = 0; i < data.length; i += 2) {
                    target[data[i]] = data[i + 1];
                }
                break;

              case 19:
              case 20:
                _inflateQRL(container, target), 20 === typeId && target.resolve();
                break;

              case 21:
                const task = target;
                const v = data;
                task.$qrl$ = v[0], task.$flags$ = v[1], task.$index$ = v[2], task.$el$ = v[3], task[_EFFECT_BACK_REF] = v[4], 
                task.$state$ = v[5];
                break;

              case 22:
                const [resolved, result, effects] = data;
                const resource = target;
                resolved ? (resource.value = Promise.resolve(result), resource._resolved = result, 
                resource._state = "resolved") : (resource.value = Promise.reject(result), resource._error = result, 
                resource._state = "rejected"), getStoreHandler(target).$effects$ = effects;
                break;

              case 23:
                target[SERIALIZABLE_STATE][0] = data[0];
                break;

              case 29:
                {
                    const store = unwrapStore(target);
                    const storeTarget = pendingStoreTargets.get(store);
                    storeTarget && (pendingStoreTargets.delete(store), inflate(container, store, storeTarget.t, storeTarget.v));
                    const [, flags, effects] = data;
                    const storeHandler = getStoreHandler(target);
                    storeHandler.$flags$ = flags, storeHandler.$effects$ = effects;
                    break;
                }

              case 24:
                {
                    const signal = target;
                    const d = data;
                    signal.$untrackedValue$ = d[0], signal.$effects$ = new Set(d.slice(1));
                    break;
                }

              case 25:
                {
                    const signal = target;
                    const d = data;
                    signal.$func$ = container.getSyncFn(d[0]), signal.$args$ = d[1], signal[_EFFECT_BACK_REF] = d[2], 
                    signal.$untrackedValue$ = NEEDS_COMPUTATION, signal.$flags$ = d[3], signal.$flags$ |= 1, 
                    signal.$hostElement$ = d[4], signal.$effects$ = new Set(d.slice(5)), function(signal) {
                        if (null !== signal.$hostElement$ && vnode_isVNode(signal.$hostElement$)) {
                            const hostVNode = signal.$hostElement$;
                            const effects = signal.$effects$;
                            let hasAttrValue = !1;
                            if (effects) {
                                for (const [_, key] of effects) {
                                    if (isString(key)) {
                                        const attrValue = hostVNode.getAttr(key);
                                        if (null !== attrValue) {
                                            signal.$untrackedValue$ = attrValue, hasAttrValue = !0;
                                            break;
                                        }
                                    }
                                }
                            }
                            if (!hasAttrValue) {
                                const firstChild = vnode_getFirstChild(hostVNode);
                                firstChild && hostVNode.firstChild === hostVNode.lastChild && vnode_isTextVNode(firstChild) && (signal.$untrackedValue$ = vnode_getText(firstChild));
                            }
                        }
                    }(signal);
                    break;
                }

              case 27:
                {
                    const asyncComputed = target;
                    const d = data;
                    asyncComputed.$computeQrl$ = d[0], asyncComputed.$effects$ = new Set(d[1]), asyncComputed.$loadingEffects$ = new Set(d[2]), 
                    asyncComputed.$errorEffects$ = new Set(d[3]), asyncComputed.$untrackedLoading$ = d[4], 
                    asyncComputed.$untrackedError$ = d[5] || null;
                    d.length > 6 && (asyncComputed.$untrackedValue$ = d[6]), asyncComputed.$flags$ |= 1;
                    break;
                }

              case 28:
              case 26:
                {
                    const computed = target;
                    const d = data;
                    computed.$computeQrl$ = d[0], computed.$effects$ = new Set(d[1]);
                    d.length > 2 ? (computed.$untrackedValue$ = d[2], 28 === typeId && (computed.$flags$ |= 1)) : (computed.$flags$ |= 1, 
                    computed.$computeQrl$.resolve(), container.$scheduler$(1, null, computed.$computeQrl$));
                    break;
                }

              case 14:
                {
                    const d = data;
                    target.message = d[0];
                    for (let i = 1; i < d.length; i += 2) {
                        target[d[i]] = d[i + 1];
                    }
                    break;
                }

              case 30:
                {
                    const formData = target;
                    const d = data;
                    for (let i = 0; i < d.length; i++) {
                        formData.append(d[i++], d[i]);
                    }
                    break;
                }

              case 31:
                {
                    const jsx = target;
                    const [type, key, varProps, constProps, children, toSort] = data;
                    jsx.type = type, jsx.key = key, jsx.varProps = varProps, jsx.constProps = constProps || null, 
                    jsx.children = children, jsx.toSort = !!toSort;
                    break;
                }

              case 16:
                {
                    const set = target;
                    const d = data;
                    for (let i = 0; i < d.length; i++) {
                        set.add(d[i]);
                    }
                    break;
                }

              case 17:
                {
                    const map = target;
                    const d = data;
                    for (let i = 0; i < d.length; i++) {
                        map.set(d[i++], d[i]);
                    }
                    break;
                }

              case 15:
                {
                    const promise = target;
                    const [resolved, result] = data;
                    const [resolve, reject] = resolvers.get(promise);
                    resolved ? resolve(result) : reject(result);
                    break;
                }

              case 18:
                const bytes = target;
                const buf = atob(data);
                let i = 0;
                for (const s of buf) {
                    bytes[i++] = s.charCodeAt(0);
                }
                break;

              case 32:
                const propsProxy = target;
                let owner = data[0];
                owner === _UNINITIALIZED && (owner = new JSXNodeImpl(Fragment, data[1], data[2]), 
                owner._proxy = propsProxy), propsProxy[_OWNER] = owner;
                break;

              case 33:
                {
                    const effectData = target;
                    effectData.data.$scopedStyleIdPrefix$ = data[0], effectData.data.$isConst$ = data[1];
                    break;
                }

              default:
                throw qError(16, [ typeId ]);
            }
        }
    };
    const _eagerDeserializeArray = (container, data, output = Array(data.length / 2)) => {
        for (let i = 0; i < data.length; i += 2) {
            output[i / 2] = deserializeData(container, data[i], data[i + 1]);
        }
        return output;
    };
    function _inflateQRL(container, qrl) {
        if (qrl.$captureRef$) {
            return qrl;
        }
        const captureIds = qrl.$capture$;
        return qrl.$captureRef$ = captureIds ? captureIds.map(id => container.$getObjectById$(id)) : null, 
        qrl.$capture$ = null, container.element && qrl.$setContainer$(container.element), 
        qrl;
    }
    function deserializeData(container, typeId, value) {
        if (0 === typeId) {
            return value;
        }
        const propValue = allocate(container, typeId, value);
        return needsInflation(typeId) && inflate(container, propValue, typeId, value), propValue;
    }
    const needsInflation = typeId => typeId >= 14 || 4 === typeId || 5 === typeId;
    const deserializedProxyMap = new WeakMap;
    const SERIALIZER_PROXY_UNWRAP = Symbol("UNWRAP");
    const wrapDeserializerProxy = (container, data) => {
        if (!Array.isArray(data) || vnode_isVNode(data) || isObject(value = data) && SERIALIZER_PROXY_UNWRAP in value) {
            return data;
        }
        var value;
        let proxy = deserializedProxyMap.get(data);
        if (!proxy) {
            const target = Array(data.length / 2).fill(void 0);
            proxy = new Proxy(target, new DeserializationHandler(container, data)), deserializedProxyMap.set(data, proxy);
        }
        return proxy;
    };
    class DeserializationHandler {
        $container$;
        $data$;
        $length$;
        constructor($container$, $data$) {
            this.$container$ = $container$, this.$data$ = $data$, this.$length$ = this.$data$.length / 2;
        }
        get(target, property, receiver) {
            if (property === SERIALIZER_PROXY_UNWRAP) {
                return target;
            }
            const i = "number" == typeof property ? property : "string" == typeof property ? parseInt(property, 10) : NaN;
            if (Number.isNaN(i) || i < 0 || i >= this.$length$) {
                return Reflect.get(target, property, receiver);
            }
            const idx = 2 * i;
            const typeId = this.$data$[idx];
            const value = this.$data$[idx + 1];
            if (0 === typeId) {
                return value;
            }
            const container = this.$container$;
            const propValue = allocate(container, typeId, value);
            return Reflect.set(target, property, propValue), this.$data$[idx] = 0, this.$data$[idx + 1] = propValue, 
            needsInflation(typeId) && inflate(container, propValue, typeId, value), propValue;
        }
        has(target, property) {
            return property === SERIALIZER_PROXY_UNWRAP || Object.prototype.hasOwnProperty.call(target, property);
        }
        set(target, property, value, receiver) {
            if (property === SERIALIZER_PROXY_UNWRAP) {
                return !1;
            }
            const out = Reflect.set(target, property, value, receiver);
            const i = "number" == typeof property ? property : parseInt(property, 10);
            if (Number.isNaN(i) || i < 0 || i >= this.$data$.length / 2) {
                return out;
            }
            const idx = 2 * i;
            return this.$data$[idx] = 0, this.$data$[idx + 1] = value, !0;
        }
    }
    function getDomContainer(element) {
        const qContainerElement = _getQContainerElement(element);
        if (!qContainerElement) {
            throw qError(24);
        }
        return getDomContainerFromQContainerElement(qContainerElement);
    }
    function getDomContainerFromQContainerElement(qContainerElement) {
        let container = qContainerElement.qContainer;
        return container || (container = new DomContainer(qContainerElement)), container;
    }
    function _getQContainerElement(element) {
        return (vnode_isVNode(element) ? vnode_getDomParent(element, !0) : element).closest("[q\\:container]:not([q\\:container=html]):not([q\\:container=text])");
    }
    class DomContainer extends _SharedContainer {
        element;
        qContainer;
        qManifestHash;
        rootVNode;
        document;
        $journal$;
        $rawStateData$;
        $storeProxyMap$=new WeakMap;
        $qFuncs$;
        $instanceHash$;
        $forwardRefs$=null;
        vNodeLocate=id => vnode_locate(this.rootVNode, id);
        $stateData$;
        $styleIds$=null;
        constructor(element) {
            if (super(() => {
                this.$flushEpoch$++, vnode_applyJournal(this.$journal$);
            }, {}, element.getAttribute("q:locale")), this.qContainer = element.getAttribute("q:container"), 
            !this.qContainer) {
                throw qError(25);
            }
            this.$journal$ = [ 3, element.ownerDocument ], this.document = element.ownerDocument, 
            this.element = element, this.$buildBase$ = element.getAttribute("q:base"), this.$instanceHash$ = element.getAttribute("q:instance"), 
            this.qManifestHash = element.getAttribute("q:manifest-hash"), this.rootVNode = vnode_newUnMaterializedElement(this.element), 
            this.$rawStateData$ = [], this.$stateData$ = [];
            const document = this.element.ownerDocument;
            document.qVNodeData || function(document) {
                const vNodeDataMap = document.qVNodeData || (document.qVNodeData = new WeakMap);
                const prototype = document.body;
                const getAttribute = prototype.getAttribute;
                const hasAttribute = prototype.hasAttribute;
                const getNodeType = ((prototype, name) => {
                    let getter;
                    for (;prototype && !(getter = Object.getOwnPropertyDescriptor(prototype, name)?.get); ) {
                        prototype = Object.getPrototypeOf(prototype);
                    }
                    return getter || function() {
                        return this[name];
                    };
                })(prototype, "nodeType");
                const attachVnodeDataAndRefs = element => {
                    Array.from(element.querySelectorAll('script[type="qwik/vnode"]')).forEach(script => {
                        script.setAttribute("type", "x-qwik/vnode");
                        const qContainerElement = script.closest("[q\\:container]");
                        qContainerElement.qVnodeData = script.textContent, qContainerElement.qVNodeRefs = new Map;
                    }), element.querySelectorAll("[q\\:shadowroot]").forEach(parent => {
                        const shadowRoot = parent.shadowRoot;
                        shadowRoot && attachVnodeDataAndRefs(shadowRoot);
                    });
                };
                attachVnodeDataAndRefs(document);
                const getFastNodeType = node => {
                    const nodeType = getNodeType.call(node);
                    if (1 === nodeType) {
                        return null === getAttribute.call(node, "q:container") ? hasAttribute.call(node, "q:shadowroot") ? 6 : hasAttribute.call(node, ":") ? 2 : 0 : 3;
                    }
                    if (8 === nodeType) {
                        const nodeValue = node.nodeValue || "";
                        if (nodeValue.startsWith("q:container-island")) {
                            return 65;
                        }
                        if (nodeValue.startsWith("q:ignore")) {
                            return 16;
                        }
                        if (nodeValue.startsWith("q:container")) {
                            return 9;
                        }
                        if (nodeValue.startsWith("/q:container-island")) {
                            return 64;
                        }
                        if (nodeValue.startsWith("/q:ignore")) {
                            return 32;
                        }
                        if (nodeValue.startsWith("/q:container")) {
                            return 8;
                        }
                    }
                    return 0;
                };
                const isSeparator = ch => VNodeDataSeparator_ADVANCE_1 <= ch && ch <= VNodeDataSeparator_ADVANCE_8192;
                const findVDataSectionEnd = (vData, start, end) => {
                    let depth = 0;
                    for (;start < end; ) {
                        const ch = vData.charCodeAt(start);
                        if (0 === depth && isSeparator(ch)) {
                            break;
                        }
                        ch === VNodeDataChar_OPEN ? depth++ : ch === VNodeDataChar_CLOSE && depth--, start++;
                    }
                    return start;
                };
                const nextSibling = node => {
                    for (;node && (node = node.nextSibling) && 0 === getFastNodeType(node); ) {}
                    return node;
                };
                const walkContainer = (walker, containerNode, node, exitNode, vData, qVNodeRefs) => {
                    const vData_length = vData.length;
                    let elementIdx = 0;
                    let vNodeElementIndex = -1;
                    let vData_start = 0;
                    let vData_end = 0;
                    let ch = 0;
                    let needsToStoreRef = -1;
                    let nextNode = null;
                    const howManyElementsToSkip = () => {
                        let elementsToSkip = 0;
                        for (;isSeparator(ch = vData.charCodeAt(vData_start)) && (elementsToSkip += 1 << ch - VNodeDataSeparator_ADVANCE_1, 
                        vData_start++, !(vData_start >= vData_length)); ) {}
                        return elementsToSkip;
                    };
                    do {
                        if (node === exitNode) {
                            return;
                        }
                        nextNode = null;
                        const nodeType = node == containerNode ? 2 : getFastNodeType(node);
                        if (3 === nodeType) {
                            const container = node;
                            let cursor = node;
                            for (;cursor && !(nextNode = nextSibling(cursor)); ) {
                                cursor = cursor.parentNode;
                            }
                            walkContainer(walker, container, node, nextNode, container.qVnodeData || "", container.qVNodeRefs);
                        } else if (16 === nodeType) {
                            let islandNode = node;
                            do {
                                if (islandNode = walker.nextNode(), !islandNode) {
                                    throw new Error(`Island inside \x3c!--${node?.nodeValue}--\x3e not found!`);
                                }
                            } while (65 !== getFastNodeType(islandNode));
                            nextNode = null;
                        } else if (64 === nodeType) {
                            nextNode = node;
                            do {
                                if (nextNode = walker.nextNode(), !nextNode) {
                                    throw new Error("Ignore block not closed!");
                                }
                            } while (32 !== getFastNodeType(nextNode));
                            nextNode = null;
                        } else if (9 === nodeType) {
                            nextNode = node;
                            do {
                                if (nextNode = nextSibling(nextNode), !nextNode) {
                                    throw new Error(`\x3c!--${node?.nodeValue}--\x3e not closed!`);
                                }
                            } while (8 !== getFastNodeType(nextNode));
                            walkContainer(walker, node, node, nextNode, "", null);
                        } else if (6 === nodeType) {
                            nextNode = nextSibling(node);
                            const shadowRootContainer = node;
                            const shadowRoot = shadowRootContainer?.shadowRoot;
                            shadowRoot && walkContainer(document.createTreeWalker(shadowRoot, 129), null, shadowRoot, null, "", null);
                        }
                        if (!(2 & ~nodeType)) {
                            if (vNodeElementIndex < elementIdx && (-1 === vNodeElementIndex && (vNodeElementIndex = 0), 
                            vData_start = vData_end, vData_start < vData_length ? (vNodeElementIndex += howManyElementsToSkip(), 
                            ch === VNodeDataSeparator_REFERENCE && (needsToStoreRef = vNodeElementIndex, vData_start++, 
                            ch = vData_start < vData_length ? vData.charCodeAt(vData_end) : VNodeDataSeparator_ADVANCE_1), 
                            vData_end = findVDataSectionEnd(vData, vData_start, vData_length)) : vNodeElementIndex = Number.MAX_SAFE_INTEGER), 
                            elementIdx === vNodeElementIndex) {
                                needsToStoreRef === elementIdx && qVNodeRefs.set(elementIdx, node);
                                const instructions = vData.substring(vData_start, vData_end);
                                vNodeDataMap.set(node, instructions);
                            }
                            elementIdx++;
                        }
                    } while (node = nextNode || walker.nextNode());
                };
                const walker = document.createTreeWalker(document, 129);
                walkContainer(walker, null, walker.firstChild(), null, "", null);
            }(document), this.$qFuncs$ = getQFuncs(document, this.$instanceHash$) || EMPTY_ARRAY, 
            this.$setServerData$(), element.setAttribute("q:container", "resumed"), element.qContainer = this;
            const qwikStates = element.querySelectorAll('script[type="qwik/state"]');
            if (0 !== qwikStates.length) {
                this.$rawStateData$ = JSON.parse(qwikStates[qwikStates.length - 1].textContent), 
                preprocessState(this.$rawStateData$, this), this.$stateData$ = wrapDeserializerProxy(this, this.$rawStateData$);
            }
        }
        $setRawState$(id, vParent) {
            this.$stateData$[id] = vParent;
        }
        parseQRL(qrl) {
            return _inflateQRL(this, function(qrl) {
                const hashIdx = qrl.indexOf("#");
                const captureStart = qrl.indexOf("[", hashIdx);
                const captureEnd = qrl.indexOf("]", captureStart);
                return createQRLWithBackChannel(qrl.slice(0, hashIdx > -1 ? hashIdx : captureStart), captureStart > -1 ? qrl.slice(hashIdx + 1, captureStart) : qrl.slice(hashIdx + 1), captureStart > -1 && captureEnd > -1 ? qrl.slice(captureStart + 1, captureEnd).split(" ").filter(v => v.length).map(s => parseInt(s, 10)) : null);
            }(qrl));
        }
        handleError(err, host) {
            const errorStore = host && this.resolveContext(host, ERROR_CONTEXT);
            if (!errorStore) {
                throw err;
            }
            errorStore.error = err;
        }
        setContext(host, context, value) {
            let ctx = this.getHostProp(host, "q:ctx");
            null == ctx && this.setHostProp(host, "q:ctx", ctx = []), mapArray_set(ctx, context.id, value, 0, !0);
        }
        resolveContext(host, contextId) {
            for (;host; ) {
                const ctx = this.getHostProp(host, "q:ctx");
                if (null != ctx && mapArray_has(ctx, contextId.id, 0)) {
                    return mapArray_get(ctx, contextId.id, 0);
                }
                host = this.getParentHost(host);
            }
        }
        getParentHost(host) {
            let vNode = host.parent;
            for (;vNode; ) {
                if (vnode_isVirtualVNode(vNode)) {
                    if (null !== vNode.getProp("q:renderFn", null)) {
                        return vNode;
                    }
                    vNode = vNode.parent || vNode.slotParent;
                } else {
                    vNode = vNode.parent;
                }
            }
            return null;
        }
        setHostProp(host, name, value) {
            host.setProp(name, value);
        }
        getHostProp(host, name) {
            const vNode = host;
            let getObjectById = null;
            switch (name) {
              case "q:seq":
              case "q:props":
              case "q:renderFn":
              case "q:ctx":
              case "q:brefs":
                getObjectById = this.$getObjectById$;
                break;

              case "q:seqIdx":
              case ":onIdx":
                getObjectById = parseInt;
            }
            return vNode.getProp(name, getObjectById);
        }
        ensureProjectionResolved(vNode) {
            if (!(16 & vNode.flags)) {
                vNode.flags |= 16;
                const props = vnode_getProps(vNode);
                for (let i = 0; i < props.length; i += 2) {
                    if (isSlotProp(props[i])) {
                        const value = props[i + 1];
                        if ("string" == typeof value) {
                            const projection = this.vNodeLocate(value);
                            props[i + 1] = projection;
                        }
                    }
                }
            }
        }
        $getObjectById$=id => getObjectById(id, this.$stateData$);
        getSyncFn(id) {
            const fn = this.$qFuncs$[id];
            return assertTrue(), fn;
        }
        $appendStyle$(content, styleId, host, scoped) {
            if (scoped) {
                const scopedStyleIdsString = this.getHostProp(host, "q:sstyle");
                const scopedStyleIds = new Set(function(scopedStyleIds) {
                    return scopedStyleIds?.split(" ") ?? null;
                }(scopedStyleIdsString));
                scopedStyleIds.add(styleId), this.setHostProp(host, "q:sstyle", function(scopedStyleIds) {
                    return Array.from(scopedStyleIds).join(" ");
                }(scopedStyleIds));
            }
            if (null == this.$styleIds$ && (this.$styleIds$ = new Set, this.element.querySelectorAll("style[q\\:style]").forEach(style => {
                this.$styleIds$.add(style.getAttribute("q:style"));
            })), !this.$styleIds$.has(styleId)) {
                this.$styleIds$.add(styleId);
                const styleElement = this.document.createElement("style");
                styleElement.setAttribute("q:style", styleId), styleElement.textContent = content, 
                this.$journal$.push(6, this.document.head, null, styleElement);
            }
        }
        $setServerData$() {
            const containerAttributes = {};
            const attrs = this.element.attributes;
            if (attrs) {
                for (let index = 0; index < attrs.length; index++) {
                    const attr = attrs[index];
                    ":" !== attr.name && (containerAttributes[attr.name] = attr.value);
                }
            }
            this.$serverData$ = {
                containerAttributes
            };
        }
    }
    const throwIfQRLNotResolved = qrl => {
        if (!qrl.resolved) {
            throw qrl.resolve();
        }
    };
    const isSignal = value => value instanceof SignalImpl;
    const ensureContainsSubscription = (array, effectSubscription) => {
        !array.has(effectSubscription) && array.add(effectSubscription);
    };
    const ensureContainsBackRef = (array, value) => {
        array[2] ||= new Set, !array[2].has(value) && array[2].add(value);
    };
    const addQrlToSerializationCtx = (effectSubscriber, container) => {
        if (container && !(container => container instanceof DomContainer)(container)) {
            const effect = effectSubscriber[0];
            const property = effectSubscriber[1];
            let qrl = null;
            isTask(effect) ? qrl = effect.$qrl$ : effect instanceof ComputedSignalImpl ? qrl = effect.$computeQrl$ : ":" === property && (qrl = container.getHostProp(effect, "q:renderFn")), 
            qrl && container.serializationCtx.$eventQrls$.add(qrl);
        }
    };
    const scheduleEffects = (container, signal, effects) => {
        const isBrowser = !isServerPlatform();
        if (effects) {
            const scheduleEffect = effectSubscription => {
                const consumer = effectSubscription[0];
                const property = effectSubscription[1];
                if (assertDefined(), isTask(consumer)) {
                    consumer.$flags$ |= 8;
                    let choreType = 3;
                    1 & consumer.$flags$ && (choreType = 16), container.$scheduler$(choreType, consumer);
                } else if (consumer instanceof SignalImpl) {
                    consumer instanceof ComputedSignalImpl && (consumer.$computeQrl$.resolved || container.$scheduler$(1, null, consumer.$computeQrl$)), 
                    consumer.invalidate();
                } else if (":" === property) {
                    const host = consumer;
                    const qrl = container.getHostProp(host, "q:renderFn");
                    assertDefined();
                    const props = container.getHostProp(host, "q:props");
                    container.$scheduler$(6, host, qrl, props);
                } else if ("." === property) {
                    if (isBrowser) {
                        container.$scheduler$(4, consumer, consumer, signal);
                    }
                } else {
                    const effectData = effectSubscription[3];
                    if (effectData instanceof SubscriptionData) {
                        const payload = {
                            ...effectData.data,
                            $value$: signal
                        };
                        container.$scheduler$(5, consumer, property, payload);
                    }
                }
            };
            for (const effect of effects) {
                scheduleEffect(effect);
            }
        }
    };
    const isSerializerObj = obj => isObject(obj) && "function" == typeof obj[SerializerSymbol];
    const getComputedSignalFlags = serializationStrategy => {
        let flags = 1;
        switch (serializationStrategy) {
          case "never":
            flags |= 16;
            break;

          case "always":
            flags |= 32;
        }
        return flags;
    };
    const stringifyPath = [];
    function qwikDebugToString(value) {
        if (null === value) {
            return "null";
        }
        if (void 0 === value) {
            return "undefined";
        }
        if ("string" == typeof value) {
            return '"' + value + '"';
        }
        if ("number" == typeof value || "boolean" == typeof value) {
            return String(value);
        }
        if (isTask(value)) {
            return `Task(${qwikDebugToString(value.$qrl$)})`;
        }
        if (isQrl(value)) {
            return `Qrl(${value.$symbol$})`;
        }
        if ("object" == typeof value || "function" == typeof value) {
            if (stringifyPath.includes(value)) {
                return "*";
            }
            try {
                if (stringifyPath.push(value), Array.isArray(value)) {
                    return vnode_isVNode(value) ? "(" + value.getProp("q:type", null) + ")" : value.map(qwikDebugToString);
                }
                if (isSignal(value)) {
                    return value instanceof WrappedSignalImpl ? "WrappedSignal" : value instanceof ComputedSignalImpl ? "ComputedSignal" : "Signal";
                }
                if (isStore(value)) {
                    return "Store";
                }
                if (isJSXNode(value)) {
                    return jsxToString(value);
                }
                if (vnode_isVNode(value)) {
                    return "(" + value.getProp("q:type", null) + ")";
                }
            } finally {
                stringifyPath.pop();
            }
        }
        return value;
    }
    const pad = (text, prefix) => String(text).split("\n").map((line, idx) => (idx ? prefix : "") + line).join("\n");
    const jsxToString = value => {
        if (isJSXNode(value)) {
            let str = "<" + value.type;
            if (value.props) {
                for (const [key, val] of Object.entries(value.props)) {
                    str += " " + key + "=" + qwikDebugToString(val);
                }
                const children = value.children;
                null != children ? (str += ">", Array.isArray(children) ? children.forEach(child => {
                    str += jsxToString(child);
                }) : str += jsxToString(children), str += "</" + value.type + ">") : str += "/>";
            }
            return str;
        }
        return String(value);
    };
    const getStoreHandler = value => value[STORE_HANDLER];
    const getStoreTarget = value => value?.[STORE_TARGET] || null;
    const forceStoreEffects = (value, prop) => {
        const handler = getStoreHandler(value);
        handler && handler.force(prop);
    };
    const unwrapStore = value => getStoreTarget(value) || value;
    const isStore = value => STORE_TARGET in value;
    function createStore(container, obj, flags) {
        return new Proxy(obj, new StoreHandler(flags, container || null));
    }
    const getOrCreateStore = (obj, flags, container) => {
        if (isSerializableObject(obj) && container) {
            let store = container.$storeProxyMap$.get(obj);
            return store || (store = createStore(container, obj, flags), container.$storeProxyMap$.set(obj, store)), 
            store;
        }
        return obj;
    };
    class StoreHandler {
        $flags$;
        $container$;
        $effects$=null;
        constructor($flags$, $container$) {
            this.$flags$ = $flags$, this.$container$ = $container$;
        }
        toString() {
            return "[Store]";
        }
        force(prop) {
            const target = getStoreTarget(this);
            this.$container$?.$scheduler$(7, null, this, getEffects(target, prop, this.$effects$));
        }
        get(target, prop) {
            if ("symbol" == typeof prop) {
                return prop === STORE_TARGET ? target : prop === STORE_HANDLER ? this : target[prop];
            }
            const ctx = tryGetInvokeContext();
            const value = target[prop];
            if (ctx) {
                if (null === this.$container$) {
                    if (!ctx.$container$) {
                        return value;
                    }
                    this.$container$ = ctx.$container$;
                } else {
                    assertTrue();
                }
                const effectSubscriber = ctx.$effectSubscriber$;
                effectSubscriber && addStoreEffect(target, Array.isArray(target) ? STORE_ALL_PROPS : prop, this, effectSubscriber);
            }
            if ("toString" === prop && value === Object.prototype.toString) {
                return this.toString;
            }
            return 1 & this.$flags$ && isObject(value) && !Object.isFrozen(value) && !isStore(value) && !Object.isFrozen(target) ? getOrCreateStore(value, this.$flags$, this.$container$) : value;
        }
        set(target, prop, value) {
            if ("symbol" == typeof prop) {
                return target[prop] = value, !0;
            }
            const newValue = 1 & this.$flags$ ? unwrapStore(value) : value;
            if (prop in target) {
                newValue !== target[prop] && setNewValueAndTriggerEffects(prop, newValue, target, this);
            } else {
                setNewValueAndTriggerEffects(prop, newValue, target, this);
            }
            return !0;
        }
        deleteProperty(target, prop) {
            return "string" == typeof prop && delete target[prop] && (Array.isArray(target) || this.$container$?.$scheduler$(7, null, this, getEffects(target, prop, this.$effects$)), 
            !0);
        }
        has(target, prop) {
            if (prop === STORE_TARGET) {
                return !0;
            }
            if ("string" == typeof prop) {
                const ctx = tryGetInvokeContext();
                if (ctx) {
                    const effectSubscriber = ctx.$effectSubscriber$;
                    effectSubscriber && addStoreEffect(target, Array.isArray(target) ? STORE_ALL_PROPS : prop, this, effectSubscriber);
                }
            }
            return Object.prototype.hasOwnProperty.call(target, prop);
        }
        ownKeys(target) {
            const ctx = tryGetInvokeContext();
            const effectSubscriber = ctx?.$effectSubscriber$;
            return effectSubscriber && addStoreEffect(target, STORE_ALL_PROPS, this, effectSubscriber), 
            Reflect.ownKeys(target);
        }
        getOwnPropertyDescriptor(target, prop) {
            const descriptor = Reflect.getOwnPropertyDescriptor(target, prop);
            return Array.isArray(target) || "symbol" == typeof prop || descriptor && !descriptor.configurable ? descriptor : {
                enumerable: !0,
                configurable: !0
            };
        }
    }
    function addStoreEffect(target, prop, store, effectSubscription) {
        const effectsMap = store.$effects$ ||= new Map;
        let effects = effectsMap.get(prop);
        effects || (effects = new Set, effectsMap.set(prop, effects)), ensureContainsSubscription(effects, effectSubscription), 
        ensureContainsBackRef(effectSubscription, target), addQrlToSerializationCtx(effectSubscription, store.$container$);
    }
    function setNewValueAndTriggerEffects(prop, value, target, currentStore) {
        target[prop] = value;
        const effects = getEffects(target, prop, currentStore.$effects$);
        effects && currentStore.$container$?.$scheduler$(7, null, currentStore, effects);
    }
    function getEffects(target, prop, storeEffects) {
        let effectsToTrigger;
        if (storeEffects) {
            if (Array.isArray(target)) {
                for (const effects of storeEffects.values()) {
                    effectsToTrigger ||= new Set;
                    for (const effect of effects) {
                        effectsToTrigger.add(effect);
                    }
                }
            } else {
                effectsToTrigger = storeEffects.get(prop);
            }
        }
        const storeArrayValue = storeEffects?.get(STORE_ALL_PROPS);
        if (storeArrayValue) {
            effectsToTrigger ||= new Set;
            for (const effect of storeArrayValue) {
                effectsToTrigger.add(effect);
            }
        }
        return effectsToTrigger || null;
    }
    const canSerialize = (value, seen = new WeakSet) => {
        if (null == value || "string" == typeof value || "number" == typeof value || "boolean" == typeof value || "bigint" == typeof value) {
            return !0;
        }
        if ("object" == typeof value) {
            if (seen.has(value)) {
                return !0;
            }
            seen.add(value);
            const proto = Object.getPrototypeOf(value);
            if (isStore(value) && (value = getStoreTarget(value)), proto == Object.prototype) {
                for (const key in value) {
                    if (!canSerialize(untrack(() => value[key]), seen)) {
                        return !1;
                    }
                }
                return !0;
            }
            if (proto == Array.prototype) {
                for (let i = 0; i < value.length; i++) {
                    if (!canSerialize(value[i], seen)) {
                        return !1;
                    }
                }
                return !0;
            }
            if (isTask(value)) {
                return !0;
            }
            if (isPropsProxy(value)) {
                return !0;
            }
            if (isPromise(value)) {
                return !0;
            }
            if (isJSXNode(value)) {
                return !0;
            }
            if (value instanceof Error) {
                return !0;
            }
            if (value instanceof URL) {
                return !0;
            }
            if (value instanceof Date) {
                return !0;
            }
            if (value instanceof RegExp) {
                return !0;
            }
            if (value instanceof URLSearchParams) {
                return !0;
            }
            if (value instanceof FormData) {
                return !0;
            }
            if (value instanceof Set) {
                return !0;
            }
            if (value instanceof Map) {
                return !0;
            }
            if (value instanceof Uint8Array) {
                return !0;
            }
            if (value instanceof SubscriptionData) {
                return !0;
            }
            if (isDomRef?.(value)) {
                return !0;
            }
        } else if ("function" == typeof value) {
            if (isQrl(value) || isQwikComponent(value) || value === Slot || value === Fragment) {
                return !0;
            }
        } else if (value === _UNINITIALIZED || value === NEEDS_COMPUTATION || value === STORE_ALL_PROPS) {
            return !0;
        }
        return !1;
    };
    const printRaw = (value, prefix) => {
        let result = vnode_isVNode(value) ? vnode_toString.call(value, 1, "", !0).replaceAll(/\n.*/gm, "") : "function" == typeof value ? String(value) : ((obj, indent) => {
            const seen = new WeakSet;
            return JSON.stringify(obj, (_, value) => {
                if (isObject(value)) {
                    if (seen.has(value)) {
                        return `[Circular ${value.constructor.name}]`;
                    }
                    seen.add(value);
                }
                return value;
            }, indent);
        })(value, 2);
        return result.length > 500 && (result = result.slice(0, 500) + '"...'), result = result.replace(/\n/g, "\n" + prefix), 
        result.includes("\n") ? result = `\n${prefix}${result}` : result;
    };
    let hasRaw = !1;
    const _dumpState = (state, color = !1, prefix = "", limit = 20) => {
        const RED = color ? "[31m" : "";
        const RESET = color ? "[0m" : "";
        const isRoot = "" === prefix;
        const out = [];
        for (let i = 0; i < state.length; i++) {
            if (limit && i > 2 * limit) {
                out.push("...");
                break;
            }
            const key = state[i];
            let value = state[++i];
            if (0 === key) {
                "number" != typeof value && "string" != typeof value && (hasRaw = !0);
                const type = `{${isObject(value) ? value.constructor.name : typeof value}}`;
                out.push(`${RED}${type}${RESET} ${printRaw(value, `${prefix}  `)}`);
            } else {
                3 === key ? value = constantToName(value) : "string" == typeof value ? (value = JSON.stringify(value), 
                value.length > 120 && (value = value.slice(0, 120) + '"...')) : 13 === key ? value = `[\n${prefix}  ${value.join(`\n${prefix}  `)}\n${prefix}]` : Array.isArray(value) && (value = value.length ? `[\n${_dumpState(value, color, `${prefix}  `)}\n${prefix}]` : "[]"), 
                out.push(`${RED}${typeIdToName(key)}${RESET} ${value}`);
            }
        }
        const result = out.map((v, i) => `${prefix}${isRoot ? `${i} ` : ""}${v}`).join("\n");
        if (isRoot) {
            const count = hasRaw ? "" : `(${JSON.stringify(state).length} chars)`;
            return hasRaw = !1, `\n${result}\n${count}`;
        }
        return result;
    };
    const typeIdToName = code => _typeIdNames[code] || `Unknown(${code})`;
    const constantToName = code => _constantNames[code] || `Unknown(${code})`;
    function preprocessState(data, container) {
        const isRootDeepRef = (type, value) => 1 === type && "string" == typeof value;
        const isForwardRefsMap = type => 13 === type;
        const isPreloadQrlType = type => 20 === type;
        const processRootRef = index => {
            const rootRefPath = data[index + 1].split(" ");
            let object = data;
            let objectType = 1;
            let typeIndex = 0;
            let valueIndex = 0;
            let parent = null;
            for (let i = 0; i < rootRefPath.length; i++) {
                if (parent = object, typeIndex = 2 * parseInt(rootRefPath[i], 10), valueIndex = typeIndex + 1, 
                objectType = object[typeIndex], object = object[valueIndex], 1 === objectType) {
                    const rootRefTypeIndex = 2 * object;
                    objectType = data[rootRefTypeIndex], object = data[rootRefTypeIndex + 1];
                }
            }
            parent && (parent[typeIndex] = 1, parent[valueIndex] = index / 2), data[index] = objectType, 
            data[index + 1] = object;
        };
        const toPreload = build.isServer ? void 0 : [];
        for (let i = 0; i < data.length; i += 2) {
            if (isRootDeepRef(data[i], data[i + 1])) {
                processRootRef(i);
            } else if (isForwardRefsMap(data[i])) {
                container.$forwardRefs$ = data[i + 1];
            } else if (!build.isServer && isPreloadQrlType(data[i])) {
                const chunkIdx = Number(data[i + 1].split(" ")[0]);
                toPreload.push(chunkIdx);
            }
        }
        if (!build.isServer) {
            for (const idx of toPreload) {
                const chunkType = data[2 * idx];
                let chunk;
                if (0 === chunkType) {
                    chunk = data[2 * idx + 1];
                } else {
                    if (1 !== chunkType) {
                        continue;
                    }
                    chunk = data[2 * data[2 * idx + 1] + 1];
                }
                preloader.p(chunk, .3);
            }
        }
    }
    function getObjectById(id, stateData) {
        return "string" == typeof id && (id = parseInt(id, 10)), assertTrue(), stateData[id];
    }
    function _createDeserializeContainer(stateData, element) {
        let state;
        const container = {
            $getObjectById$: id => getObjectById(id, state),
            getSyncFn: () => () => {},
            $storeProxyMap$: new WeakMap,
            element: null,
            $forwardRefs$: null,
            $scheduler$: null
        };
        return preprocessState(stateData, container), state = wrapDeserializerProxy(container, stateData), 
        container.$state$ = state, element && (container.element = element), container;
    }
    const verifySerializable = (value, preMessage) => {
        const seen = new WeakSet;
        return untrack(() => _verifySerializable(value, seen, "_", preMessage));
    };
    const _verifySerializable = (value, seen, ctx, preMessage) => {
        const unwrapped = unwrapStore(value);
        if (null == unwrapped) {
            return value;
        }
        if (shouldSerialize(unwrapped)) {
            if ("object" == typeof unwrapped) {
                if (seen.has(unwrapped)) {
                    return value;
                }
                seen.add(unwrapped);
            }
            if (isSignal(unwrapped)) {
                return value;
            }
            if (canSerialize(unwrapped)) {
                return value;
            }
            const typeObj = typeof unwrapped;
            if ("object" === typeObj) {
                if (isPromise(unwrapped)) {
                    return value;
                }
                if (isNode(unwrapped)) {
                    return value;
                }
                if (isArray(unwrapped)) {
                    let expectIndex = 0;
                    return unwrapped.forEach((v, i) => {
                        if (i !== expectIndex) {
                            throw qError(3, [ unwrapped ]);
                        }
                        _verifySerializable(v, seen, ctx + "[" + i + "]"), expectIndex = i + 1;
                    }), value;
                }
                if (isSerializableObject(unwrapped)) {
                    for (const [key, item] of Object.entries(unwrapped)) {
                        _verifySerializable(item, seen, ctx + "." + key);
                    }
                    return value;
                }
            }
            let message;
            if (message = preMessage || "Value cannot be serialized", "_" !== ctx && (message += ` in ${ctx},`), 
            "object" === typeObj) {
                message += ` because it's an instance of "${value?.constructor.name}". You might need to use 'noSerialize()' or use an object literal instead. Check out https://qwik.dev/docs/advanced/dollar/`;
            } else if ("function" === typeObj) {
                const fnName = value.name;
                message += ` because it's a function named "${fnName}". You might need to convert it to a QRL using $(fn):\n\nconst ${fnName} = $(${String(value)});\n\nPlease check out https://qwik.dev/docs/advanced/qrl/ for more information.`;
            }
            throw qError(3, [ message ]);
        }
        return value;
    };
    const noSerializeSet = /*#__PURE__*/ new WeakSet;
    const shouldSerialize = obj => !isObject(obj) && !isFunction(obj) || !noSerializeSet.has(obj) && !(NoSerializeSymbol in obj);
    const fastSkipSerialize = obj => !!obj && (isObject(obj) || "function" == typeof obj) && (NoSerializeSymbol in obj || noSerializeSet.has(obj));
    const noSerialize = input => ((isObject(input) && null !== input || "function" == typeof input) && noSerializeSet.add(input), 
    input);
    const NoSerializeSymbol = Symbol("noSerialize");
    const SerializerSymbol = Symbol("serialize");
    const resolvedSymbol = Symbol("resolved");
    const createQRL = (chunk, symbol, symbolRef, symbolFn, capture, captureRef) => {
        let _containerEl;
        const qrl = async function(...args) {
            const boundedFn = bindFnToContext.call(this, tryGetInvokeContext());
            return await boundedFn(...args);
        };
        const setContainer = el => (_containerEl || (_containerEl = el), _containerEl);
        function bindFnToContext(currentCtx, beforeFn) {
            const bound = (...args) => {
                if (!qrl.resolved) {
                    return qrl.resolve().then(fn => {
                        if (!isFunction(fn)) {
                            throw qError(5);
                        }
                        return bound(...args);
                    });
                }
                if (beforeFn && !1 === beforeFn()) {
                    return;
                }
                const context = createOrReuseInvocationContext(currentCtx);
                const prevQrl = context.$qrl$;
                const prevEvent = context.$event$;
                context.$qrl$ = qrl, context.$event$ ||= this;
                try {
                    return invoke.call(this, context, symbolRef, ...args);
                } finally {
                    context.$qrl$ = prevQrl, context.$event$ = prevEvent;
                }
            };
            return bound;
        }
        const wrapFn = fn => "function" != typeof fn || !capture?.length && !captureRef?.length ? fn : function(...args) {
            let context = tryGetInvokeContext();
            if (context) {
                if (context.$qrl$?.$symbol$ === qrl.$symbol$) {
                    return fn.apply(this, args);
                }
                const prevQrl = context.$qrl$;
                context.$qrl$ = qrl;
                try {
                    return fn.apply(this, args);
                } finally {
                    context.$qrl$ = prevQrl;
                }
            }
            return context = newInvokeContext(), context.$qrl$ = qrl, context.$event$ = this, 
            invoke.call(this, context, fn, ...args);
        };
        symbolFn && resolvedSymbol in symbolFn && (symbolRef = symbolFn[resolvedSymbol]);
        const resolve = symbolRef ? async () => symbolRef : async containerEl => {
            if (null !== symbolRef) {
                return symbolRef;
            }
            if (containerEl && setContainer(containerEl), "" === chunk) {
                assertDefined();
                const hash = _containerEl.getAttribute("q:instance");
                const qFuncs = getQFuncs(_containerEl.ownerDocument, hash);
                return qrl.resolved = symbolRef = qFuncs[Number(symbol)];
            }
            build.isBrowser && chunk && preloader.p(chunk, 1);
            const start = now();
            const ctx = tryGetInvokeContext();
            if (null !== symbolFn) {
                symbolRef = symbolFn().then(module => {
                    const resolved = wrapFn(symbolRef = module[symbol]);
                    return symbolFn[resolvedSymbol] = resolved, qrl.resolved = resolved, resolved;
                });
            } else {
                const imported = getPlatform().importSymbol(_containerEl, chunk, symbol);
                symbolRef = maybeThen(imported, ref => qrl.resolved = wrapFn(symbolRef = ref));
            }
            return isPromise(symbolRef) && symbolRef.then(() => emitUsedSymbol(symbol, ctx?.$element$, start), err => {
                console.error(`qrl ${symbol} failed to load`, err), symbolRef = null;
            }), symbolRef;
        };
        const createOrReuseInvocationContext = invoke => null == invoke ? newInvokeContext() : isArray(invoke) ? newInvokeContextFromTuple(invoke) : invoke;
        const hash = getSymbolHash(symbol);
        return Object.assign(qrl, {
            getSymbol: () => symbol,
            getHash: () => hash,
            getCaptured: () => qrl.$captureRef$,
            resolve,
            $setContainer$: setContainer,
            $chunk$: chunk,
            $symbol$: symbol,
            $hash$: hash,
            getFn: bindFnToContext,
            $capture$: capture,
            $captureRef$: captureRef,
            dev: null,
            resolved: void 0
        }), symbolRef && (symbolRef = maybeThen(symbolRef, resolved => qrl.resolved = wrapFn(symbolRef = resolved))), 
        build.isBrowser && symbol && preloader.p(symbol, .8), qrl;
    };
    const EMITTED = /*#__PURE__*/ new Set;
    const emitUsedSymbol = (symbol, element, reqTime) => {
        EMITTED.has(symbol) || (EMITTED.add(symbol), emitEvent("qsymbol", {
            symbol,
            element,
            reqTime
        }));
    };
    const emitEvent = (eventName, detail) => {
        isServerPlatform() || "object" != typeof document || document.dispatchEvent(new CustomEvent(eventName, {
            bubbles: !1,
            detail
        }));
    };
    const now = () => isServerPlatform() ? 0 : "object" == typeof performance ? performance.now() : 0;
    let runtimeSymbolId = 0;
    const $ = expression => createQRL(null, "s" + runtimeSymbolId++, expression, null, null, null);
    const dollar = $;
    const eventQrl = qrl => qrl;
    const componentQrl = componentQrl => {
        function QwikComponent(props, key) {
            assertQrl(componentQrl);
            const finalKey = componentQrl.$hash$.slice(0, 4) + ":" + (key || "");
            const InnerCmp = () => {};
            return InnerCmp[SERIALIZABLE_STATE] = [ componentQrl ], _jsxSplit(InnerCmp, props, null, props.children, 0, finalKey);
        }
        return QwikComponent[SERIALIZABLE_STATE] = [ componentQrl ], QwikComponent;
    };
    const SERIALIZABLE_STATE = Symbol("serializable-data");
    const isQwikComponent = component => "function" == typeof component && void 0 !== component[SERIALIZABLE_STATE];
    const event$ = implicit$FirstArg(eventQrl);
    const useStore = (initialState, opts) => {
        const {val, set, iCtx} = useSequentialScope();
        if (null != val) {
            return val;
        }
        const value = isFunction(initialState) ? invoke(void 0, initialState) : initialState;
        if (!1 === opts?.reactive) {
            return set(value), value;
        }
        {
            const containerState = iCtx.$container$;
            const newStore = getOrCreateStore(value, opts?.deep ?? !0 ? 1 : 0, containerState);
            return set(newStore), newStore;
        }
    };
    const STYLE_CACHE = /*#__PURE__*/ new Map;
    const getScopedStyles = (css, scopeId) => {
        let styleCss = STYLE_CACHE.get(scopeId);
        return styleCss || STYLE_CACHE.set(scopeId, styleCss = scopeStylesheet(css, scopeId)), 
        styleCss;
    };
    const scopeStylesheet = (css, scopeId) => {
        const end = css.length;
        const out = [];
        const stack = [];
        let idx = 0;
        let lastIdx = idx;
        let mode = rule;
        let lastCh = 0;
        for (;idx < end; ) {
            const chIdx = idx;
            let ch = css.charCodeAt(idx++);
            ch === BACKSLASH && (idx++, ch = A);
            const arcs = STATE_MACHINE[mode];
            for (let i = 0; i < arcs.length; i++) {
                const arc = arcs[i];
                const [expectLastCh, expectCh, newMode] = arc;
                if ((expectLastCh === lastCh || expectLastCh === ANY || expectLastCh === IDENT && isIdent(lastCh) || expectLastCh === WHITESPACE && isWhiteSpace(lastCh)) && (expectCh === ch || expectCh === ANY || expectCh === IDENT && isIdent(ch) || expectCh === NOT_IDENT && !isIdent(ch) && ch !== DOT || expectCh === WHITESPACE && isWhiteSpace(ch)) && (3 == arc.length || lookAhead(arc))) {
                    if (arc.length > 3 && (ch = css.charCodeAt(idx - 1)), newMode === EXIT || newMode == EXIT_INSERT_SCOPE) {
                        if (newMode === EXIT_INSERT_SCOPE) {
                            if (mode !== starSelector || shouldNotInsertScoping()) {
                                if (!isChainedSelector(ch)) {
                                    insertScopingSelector(idx - (expectCh == NOT_IDENT ? 1 : expectCh == CLOSE_PARENTHESIS ? 2 : 0));
                                }
                            } else {
                                isChainedSelector(ch) ? flush(idx - 2) : insertScopingSelector(idx - 2), lastIdx++;
                            }
                        }
                        expectCh === NOT_IDENT && (idx--, ch = lastCh);
                        do {
                            mode = stack.pop() || rule, mode === pseudoGlobal && (flush(idx - 1), lastIdx++);
                        } while (isSelfClosingRule(mode));
                    } else {
                        stack.push(mode), mode === pseudoGlobal && newMode === rule ? (flush(idx - 8), lastIdx = idx) : newMode === pseudoElement && insertScopingSelector(chIdx), 
                        mode = newMode;
                    }
                    break;
                }
            }
            lastCh = ch;
        }
        return flush(idx), out.join("");
        function flush(idx) {
            out.push(css.substring(lastIdx, idx)), lastIdx = idx;
        }
        function insertScopingSelector(idx) {
            mode === pseudoGlobal || shouldNotInsertScoping() || (flush(idx), out.push(".", "", scopeId));
        }
        function lookAhead(arc) {
            let prefix = 0;
            if (css.charCodeAt(idx) === DASH) {
                for (let i = 1; i < 10; i++) {
                    if (css.charCodeAt(idx + i) === DASH) {
                        prefix = i + 1;
                        break;
                    }
                }
            }
            words: for (let arcIndx = 3; arcIndx < arc.length; arcIndx++) {
                const txt = arc[arcIndx];
                for (let i = 0; i < txt.length; i++) {
                    if ((css.charCodeAt(idx + i + prefix) | LOWERCASE) !== txt.charCodeAt(i)) {
                        continue words;
                    }
                }
                return idx += txt.length + prefix, !0;
            }
            return !1;
        }
        function shouldNotInsertScoping() {
            return -1 !== stack.indexOf(pseudoGlobal) || -1 !== stack.indexOf(atRuleSelector);
        }
    };
    const isIdent = ch => ch >= _0 && ch <= _9 || ch >= A && ch <= Z || ch >= a && ch <= z || ch >= 128 || ch === UNDERSCORE || ch === DASH;
    const isChainedSelector = ch => ch === COLON || ch === DOT || ch === OPEN_BRACKET || ch === HASH || isIdent(ch);
    const isSelfClosingRule = mode => mode === atRuleBlock || mode === atRuleSelector || mode === atRuleInert || mode === pseudoGlobal;
    const isWhiteSpace = ch => ch === SPACE || ch === TAB || ch === NEWLINE || ch === CARRIAGE_RETURN;
    const rule = 0;
    const starSelector = 2;
    const pseudoGlobal = 5;
    const pseudoElement = 6;
    const atRuleSelector = 10;
    const atRuleBlock = 11;
    const atRuleInert = 12;
    const EXIT = 17;
    const EXIT_INSERT_SCOPE = 18;
    const ANY = 0;
    const IDENT = 1;
    const NOT_IDENT = 2;
    const WHITESPACE = 3;
    const TAB = 9;
    const NEWLINE = 10;
    const CARRIAGE_RETURN = 13;
    const SPACE = 32;
    const HASH = 35;
    const CLOSE_PARENTHESIS = 41;
    const DASH = 45;
    const DOT = 46;
    const _0 = 48;
    const _9 = 57;
    const COLON = 58;
    const A = 65;
    const Z = 90;
    const OPEN_BRACKET = 91;
    const BACKSLASH = 92;
    const UNDERSCORE = 95;
    const LOWERCASE = 32;
    const a = 97;
    const z = 122;
    const STRINGS_COMMENTS = [ [ ANY, 39, 14 ], [ ANY, 34, 15 ], [ ANY, 47, 16, "*" ] ];
    const STATE_MACHINE = [ [ [ ANY, 42, starSelector ], [ ANY, OPEN_BRACKET, 7 ], [ ANY, COLON, pseudoElement, ":", "before", "after", "first-letter", "first-line" ], [ ANY, COLON, pseudoGlobal, "global" ], [ ANY, COLON, 3, "has", "host-context", "not", "where", "is", "matches", "any" ], [ ANY, COLON, 4 ], [ ANY, IDENT, 1 ], [ ANY, DOT, 1 ], [ ANY, HASH, 1 ], [ ANY, 64, atRuleSelector, "keyframe" ], [ ANY, 64, atRuleBlock, "media", "supports", "container" ], [ ANY, 64, atRuleInert ], [ ANY, 123, 13 ], [ 47, 42, 16 ], [ ANY, 59, EXIT ], [ ANY, 125, EXIT ], [ ANY, CLOSE_PARENTHESIS, EXIT ], ...STRINGS_COMMENTS ], [ [ ANY, NOT_IDENT, EXIT_INSERT_SCOPE ] ], [ [ ANY, NOT_IDENT, EXIT_INSERT_SCOPE ] ], [ [ ANY, 40, rule ], [ ANY, NOT_IDENT, EXIT_INSERT_SCOPE ] ], [ [ ANY, 40, 8 ], [ ANY, NOT_IDENT, EXIT_INSERT_SCOPE ] ], [ [ ANY, 40, rule ], [ ANY, NOT_IDENT, EXIT ] ], [ [ ANY, NOT_IDENT, EXIT ] ], [ [ ANY, 93, EXIT_INSERT_SCOPE ], [ ANY, 39, 14 ], [ ANY, 34, 15 ] ], [ [ ANY, CLOSE_PARENTHESIS, EXIT ], ...STRINGS_COMMENTS ], [ [ ANY, 125, EXIT ], ...STRINGS_COMMENTS ], [ [ ANY, 125, EXIT ], [ WHITESPACE, IDENT, 1 ], [ ANY, COLON, pseudoGlobal, "global" ], [ ANY, 123, 13 ], ...STRINGS_COMMENTS ], [ [ ANY, 123, rule ], [ ANY, 59, EXIT ], ...STRINGS_COMMENTS ], [ [ ANY, 59, EXIT ], [ ANY, 123, 9 ], ...STRINGS_COMMENTS ], [ [ ANY, 125, EXIT ], [ ANY, 123, 13 ], [ ANY, 40, 8 ], ...STRINGS_COMMENTS ], [ [ ANY, 39, EXIT ] ], [ [ ANY, 34, EXIT ] ], [ [ 42, 47, EXIT ] ] ];
    const useStylesQrl = styles => ({
        styleId: _useStyles(styles, str => str, !1)
    });
    const useStyles$ = /*#__PURE__*/ implicit$FirstArg(useStylesQrl);
    const useStylesScopedQrl = styles => ({
        scopeId: "" + _useStyles(styles, getScopedStyles, !0)
    });
    const useStylesScoped$ = /*#__PURE__*/ implicit$FirstArg(useStylesScopedQrl);
    const _useStyles = (styleQrl, transform, scoped) => {
        assertQrl(styleQrl);
        const {val, set, iCtx, i} = useSequentialScope();
        if (val) {
            return val;
        }
        const styleId = (index = i, assertQrl(qStyles = styleQrl), `${hashCode(qStyles.$hash$)}-${index}`);
        var qStyles, index;
        const host = iCtx.$hostElement$;
        if (set(styleId), !styleQrl.resolved) {
            throw styleQrl.resolve().then(val => iCtx.$container$.$appendStyle$(transform(val, styleId), styleId, host, scoped));
        }
        return iCtx.$container$.$appendStyle$(transform(styleQrl.resolved, styleId), styleId, host, scoped), 
        styleId;
    };
    const useOn = (event, eventQrl) => {
        _useOn("on:", event, eventQrl);
    };
    const useOnDocument = (event, eventQrl) => {
        _useOn("on-document:", event, eventQrl);
    };
    const _useOn = (prefix, eventName, eventQrl) => {
        const {isAdded, addEvent} = useOnEventsSequentialScope();
        if (!isAdded && eventQrl) {
            if (Array.isArray(eventName)) {
                for (const event of eventName) {
                    addEvent(prefix + fromCamelToKebabCase(event), eventQrl);
                }
            } else {
                addEvent(prefix + fromCamelToKebabCase(eventName), eventQrl);
            }
        }
    };
    const useOnEventsSequentialScope = () => {
        const iCtx = useInvokeContext();
        const host = iCtx.$hostElement$;
        let onMap = iCtx.$container$.getHostProp(host, ":on");
        null === onMap && (onMap = {}, iCtx.$container$.setHostProp(host, ":on", onMap));
        let seqIdx = iCtx.$container$.getHostProp(host, ":onIdx");
        null === seqIdx && (seqIdx = 0), iCtx.$container$.setHostProp(host, ":onIdx", seqIdx + 1);
        let addedFlags = iCtx.$container$.getHostProp(host, ":onFlags");
        for (null === addedFlags && (addedFlags = [], iCtx.$container$.setHostProp(host, ":onFlags", addedFlags)); addedFlags.length <= seqIdx; ) {
            addedFlags.push(!1);
        }
        return {
            isAdded: addedFlags[seqIdx],
            addEvent: (eventName, eventQrl) => {
                addedFlags[seqIdx] = !0;
                let events = onMap[eventName];
                events || (onMap[eventName] = events = []), events.push(eventQrl);
            }
        };
    };
    const useConstant = value => {
        const {val, set} = useSequentialScope();
        return null != val ? val : set(value = isFunction(value) && !isQwikComponent(value) ? value() : value);
    };
    const useComputedCommon = (qrl, createFn, options) => {
        const {val, set} = useSequentialScope();
        if (val) {
            return val;
        }
        assertQrl(qrl);
        const signal = createFn(qrl, options);
        return set(signal), throwIfQRLNotResolved(qrl), signal;
    };
    const useComputedQrl = (qrl, options) => useComputedCommon(qrl, createComputedSignal, options);
    const useComputed$ = implicit$FirstArg(useComputedQrl);
    const useSerializerQrl = qrl => useComputedCommon(qrl, createSerializerSignal);
    const useSerializer$ = implicit$FirstArg(useSerializerQrl);
    const useVisibleTaskQrl = (qrl, opts) => {
        const {val, set, i, iCtx} = useSequentialScope();
        const eagerness = opts?.strategy ?? "intersection-observer";
        if (val) {
            return void (isServerPlatform() && useRunTask(val, eagerness));
        }
        assertQrl(qrl);
        const task = new Task(1, i, iCtx.$hostElement$, qrl, void 0, null);
        set(task), useRunTask(task, eagerness), isServerPlatform() || (qrl.resolve(iCtx.$element$), 
        iCtx.$container$.$scheduler$(16, task));
    };
    const useRunTask = (task, eagerness) => {
        "intersection-observer" === eagerness ? useOn("qvisible", getTaskHandlerQrl(task)) : "document-ready" === eagerness ? useOnDocument("qinit", getTaskHandlerQrl(task)) : "document-idle" === eagerness && useOnDocument("qidle", getTaskHandlerQrl(task));
    };
    const getTaskHandlerQrl = task => createQRL(null, "_task", scheduleTask, null, null, [ task ]);
    const useTask$ = /*#__PURE__*/ implicit$FirstArg(useTaskQrl);
    const useVisibleTask$ = /*#__PURE__*/ implicit$FirstArg(useVisibleTaskQrl);
    const useAsyncComputedQrl = (qrl, options) => useComputedCommon(qrl, createAsyncComputedSignal, options);
    const useAsyncComputed$ = implicit$FirstArg(useAsyncComputedQrl);
    const PREFETCH_CODE = /*#__PURE__*/ (c => {
        "getRegistrations" in c && c.getRegistrations().then(registrations => {
            registrations.forEach(registration => {
                registration.active && registration.active.scriptURL.endsWith("_URL_") && registration.unregister().catch(console.error);
            });
        }), "caches" in window && caches.keys().then(names => {
            const cacheName = names.find(name => name.startsWith("QwikBundles"));
            cacheName && caches.delete(cacheName).catch(console.error);
        }).catch(console.error);
    }).toString();
    globalThis.__qwik && console.error(`==============================================\nQwik version ${globalThis.__qwik} already imported while importing ${version}.\nThis can lead to issues due to duplicated shared structures.\nVerify that the Qwik libraries you're using are in "resolve.noExternal[]" and in "optimizeDeps.exclude".\n==============================================\n`), 
    globalThis.__qwik = version, Object.defineProperty(exports, "isBrowser", {
        enumerable: !0,
        get: function() {
            return build.isBrowser;
        }
    }), Object.defineProperty(exports, "isDev", {
        enumerable: !0,
        get: function() {
            return build.isDev;
        }
    }), Object.defineProperty(exports, "isServer", {
        enumerable: !0,
        get: function() {
            return build.isServer;
        }
    }), exports.$ = $, exports.Fragment = Fragment, exports.NoSerializeSymbol = NoSerializeSymbol, 
    exports.PrefetchGraph = () => null, exports.PrefetchServiceWorker = opts => {
        const isTest = (void 0).TEST;
        if (build.isDev && !isTest) {
            return _jsxSorted("script", null, {
                dangerouslySetInnerHTML: "\x3c!-- PrefetchServiceWorker is disabled in dev mode. --\x3e"
            }, null, 0, "prefetch-service-worker");
        }
        const baseUrl = globalThis.BASE_URL || "/";
        const resolvedOpts = {
            path: "qwik-prefetch-service-worker.js",
            ...opts
        };
        resolvedOpts.path = opts?.path?.startsWith?.("/") ? opts.path : baseUrl + resolvedOpts.path;
        let code = PREFETCH_CODE.replace('"_URL_"', JSON.stringify(resolvedOpts.path.split("/").pop()));
        build.isDev || (code = code.replaceAll(/\s\s+/gm, ""));
        const props = {
            dangerouslySetInnerHTML: [ "(" + code + ")(", [ "navigator.serviceWorker" ].join(","), ");" ].join(""),
            nonce: resolvedOpts.nonce
        };
        return _jsxSorted("script", null, props, null, 0, "prefetch-service-worker");
    }, exports.RenderOnce = RenderOnce, exports.Resource = props => _jsxSorted(Fragment, null, null, function(props) {
        const resource = props.value;
        if (isResourceReturn(resource)) {
            const state = resource._state;
            if (!isServerPlatform()) {
                if ("pending" === state && props.onPending) {
                    return Promise.resolve().then(useBindInvokeContext(props.onPending));
                }
                if ("rejected" === state && props.onRejected) {
                    return Promise.resolve(resource._error).then(useBindInvokeContext(props.onRejected));
                }
                {
                    const resolvedValue = untrack(() => resource._resolved);
                    if (void 0 !== resolvedValue) {
                        return Promise.resolve(resolvedValue).then(useBindInvokeContext(props.onResolved));
                    }
                }
            }
            return untrack(() => resource.value).then(useBindInvokeContext(props.onResolved), useBindInvokeContext(props.onRejected));
        }
        if (isPromise(resource)) {
            return resource.then(useBindInvokeContext(props.onResolved), useBindInvokeContext(props.onRejected));
        }
        if (isSignal(resource)) {
            const value = retryOnPromise(() => resource.value);
            return (isPromise(value) ? value : Promise.resolve(value)).then(useBindInvokeContext(props.onResolved));
        }
        return Promise.resolve(resource).then(useBindInvokeContext(props.onResolved));
    }(props), 0, null), exports.SSRComment = SSRComment, exports.SSRRaw = SSRRaw, exports.SSRStream = SSRStream, 
    exports.SSRStreamBlock = props => [ jsx(SSRComment, {
        data: "qkssr-pu"
    }), props.children, jsx(SSRComment, {
        data: "qkssr-po"
    }) ], exports.SerializerSymbol = SerializerSymbol, exports.SkipRender = SkipRender, 
    exports.Slot = Slot, exports._CONST_PROPS = _CONST_PROPS, exports._DomContainer = DomContainer, 
    exports._EFFECT_BACK_REF = _EFFECT_BACK_REF, exports._EMPTY_ARRAY = EMPTY_ARRAY, 
    exports._IMMUTABLE = _IMMUTABLE, exports._SharedContainer = _SharedContainer, exports._SubscriptionData = SubscriptionData, 
    exports._UNINITIALIZED = _UNINITIALIZED, exports._VAR_PROPS = _VAR_PROPS, exports._chk = _chk, 
    exports._deserialize = function(rawStateData, element) {
        if (null == rawStateData) {
            return [];
        }
        const stateData = JSON.parse(rawStateData);
        if (!Array.isArray(stateData)) {
            return [];
        }
        let container;
        container = isNode(element) && isElement$1(element) ? _createDeserializeContainer(stateData, element) : _createDeserializeContainer(stateData);
        const output = [];
        for (let i = 0; i < stateData.length; i += 2) {
            output[i / 2] = deserializeData(container, stateData[i], stateData[i + 1]);
        }
        return output;
    }, exports._dumpState = _dumpState, exports._fnSignal = (fn, args, fnStr) => new WrappedSignalImpl(null, fn, args, fnStr || null), 
    exports._getConstProps = props => props && _CONST_PROPS in props ? props[_CONST_PROPS] : null, 
    exports._getContextContainer = () => {
        const iCtx = tryGetInvokeContext();
        if (iCtx) {
            return iCtx.$container$;
        }
    }, exports._getContextElement = () => {
        const iCtx = tryGetInvokeContext();
        if (iCtx) {
            const hostElement = iCtx.$hostElement$;
            let element = null;
            return null != hostElement && (vnode_isVNode(hostElement) ? vnode_isElementVNode(hostElement) && (element = vnode_getNode(hostElement)) : element = hostElement), 
            element ?? iCtx.$qrl$?.$setContainer$(void 0);
        }
    }, exports._getContextEvent = () => {
        const iCtx = tryGetInvokeContext();
        if (iCtx) {
            return iCtx.$event$;
        }
    }, exports._getDomContainer = getDomContainer, exports._getQContainerElement = _getQContainerElement, 
    exports._getVarProps = props => props ? _VAR_PROPS in props ? "children" in props ? {
        ...props[_VAR_PROPS],
        children: props.children
    } : props[_VAR_PROPS] : props : null, exports._hasStoreEffects = (value, prop) => {
        const handler = getStoreHandler(value);
        return !!handler && (handler.$effects$?.get(prop)?.size ?? 0) > 0;
    }, exports._isJSXNode = isJSXNode, exports._isStore = isStore, exports._isStringifiable = function(value) {
        return null === value || "string" == typeof value || "number" == typeof value || "boolean" == typeof value;
    }, exports._isTask = isTask, exports._jsxBranch = input => input, exports._jsxC = (type, mutable, _flags, key) => jsx(type, mutable, key), 
    exports._jsxQ = (type, mutable, immutable, children, _flags, key) => jsx(type, {
        ...immutable,
        ...mutable,
        children
    }, key), exports._jsxS = (type, mutable, immutable, _flags, key) => jsx(type, {
        ...immutable,
        ...mutable
    }, key), exports._jsxSorted = _jsxSorted, exports._jsxSplit = _jsxSplit, exports._mapApp_findIndx = mapApp_findIndx, 
    exports._mapArray_get = mapArray_get, exports._mapArray_set = mapArray_set, exports._noopQrl = _noopQrl, 
    exports._noopQrlDEV = (symbolName, opts, lexicalScopeCapture = EMPTY_ARRAY) => {
        const newQrl = _noopQrl(symbolName, lexicalScopeCapture);
        return newQrl.dev = opts, newQrl;
    }, exports._preprocessState = preprocessState, exports._qrlSync = function(fn, serializedFn) {
        return void 0 === serializedFn && (serializedFn = fn.toString()), fn.serialized = serializedFn, 
        createQRL("", "<sync>", fn, null, null, null);
    }, exports._regSymbol = (symbol, hash) => (void 0 === globalThis.__qwik_reg_symbols && (globalThis.__qwik_reg_symbols = new Map), 
    globalThis.__qwik_reg_symbols.set(hash, symbol), symbol), exports._resolveContextWithoutSequentialScope = context => {
        const iCtx = getInvokeContext();
        const hostElement = iCtx.$hostElement$;
        if (hostElement) {
            return iCtx.$container$?.resolveContext(hostElement, context);
        }
    }, exports._restProps = (props, omit = [], target = {}) => {
        let constPropsTarget = null;
        const constProps = props[_CONST_PROPS];
        if (constProps) {
            for (const key in constProps) {
                omit.includes(key) || (constPropsTarget ||= {}, constPropsTarget[key] = constProps[key]);
            }
        }
        const varPropsTarget = target;
        const varProps = props[_VAR_PROPS];
        for (const key in varProps) {
            omit.includes(key) || (varPropsTarget[key] = varProps[key]);
        }
        return createPropsProxy(new JSXNodeImpl(null, varPropsTarget, constPropsTarget));
    }, exports._run = _run, exports._serialize = async function(data) {
        const serializationContext = createSerializationContext(null, null, () => "", () => "", () => {}, new WeakMap);
        for (const root of data) {
            serializationContext.$addRoot$(root);
        }
        return await serializationContext.$serialize$(), serializationContext.$writer$.toString();
    }, exports._task = scheduleTask, exports._val = _val, exports._verifySerializable = verifySerializable, 
    exports._vnode_ensureElementInflated = vnode_ensureElementInflated, exports._vnode_getAttrKeys = vnode_getAttrKeys, 
    exports._vnode_getFirstChild = vnode_getFirstChild, exports._vnode_getProps = vnode_getProps, 
    exports._vnode_isMaterialized = vnode_isMaterialized, exports._vnode_isTextVNode = vnode_isTextVNode, 
    exports._vnode_isVirtualVNode = vnode_isVirtualVNode, exports._vnode_toString = vnode_toString, 
    exports._waitUntilRendered = elm => {
        const container = _getQContainerElement(elm)?.qContainer;
        return container ? (async () => {
            for (;;) {
                await container.$scheduler$(255).$returnValue$;
                const firstEpoch = container.$flushEpoch$ || 0;
                await Promise.resolve();
                if (firstEpoch === (container.$flushEpoch$ || 0)) {
                    return;
                }
            }
        })() : Promise.resolve();
    }, exports._walkJSX = _walkJSX, exports._wrapProp = _wrapProp, exports._wrapSignal = (obj, prop) => {
        const r = _wrapProp(obj, prop);
        return r === _IMMUTABLE ? obj[prop] : r;
    }, exports.component$ = onMount => componentQrl(dollar(onMount)), exports.componentQrl = componentQrl, 
    exports.createAsyncComputed$ = createAsyncComputed$, exports.createAsyncComputedQrl = createAsyncComputedSignal, 
    exports.createComputed$ = createComputed$, exports.createComputedQrl = createComputedSignal, 
    exports.createContextId = createContextId, exports.createElement = h, exports.createSerializer$ = createSerializer$, 
    exports.createSerializerQrl = createSerializerSignal, exports.createSignal = createSignal, 
    exports.event$ = event$, exports.eventQrl = eventQrl, exports.forceStoreEffects = forceStoreEffects, 
    exports.getDomContainer = getDomContainer, exports.getLocale = function(defaultLocale) {
        if (localAsyncStore) {
            const locale = localAsyncStore.getStore();
            if (locale) {
                return locale;
            }
        }
        if (void 0 === _locale) {
            const ctx = tryGetInvokeContext();
            if (ctx && ctx.$locale$) {
                return ctx.$locale$;
            }
            if (void 0 !== defaultLocale) {
                return defaultLocale;
            }
            throw new Error("Reading `locale` outside of context.");
        }
        return _locale;
    }, exports.getPlatform = getPlatform, exports.h = h, exports.implicit$FirstArg = implicit$FirstArg, 
    exports.inlinedQrl = inlinedQrl, exports.inlinedQrlDEV = (symbol, symbolName, opts, lexicalScopeCapture = EMPTY_ARRAY) => {
        const qrl = inlinedQrl(symbol, symbolName, lexicalScopeCapture);
        return qrl.dev = opts, qrl;
    }, exports.isSignal = isSignal, exports.jsx = jsx, exports.jsxDEV = jsxDEV, exports.jsxs = jsxs, 
    exports.noSerialize = noSerialize, exports.qrl = qrl, exports.qrlDEV = (chunkOrFn, symbol, opts, lexicalScopeCapture = EMPTY_ARRAY) => {
        const newQrl = qrl(chunkOrFn, symbol, lexicalScopeCapture, 1);
        return newQrl.dev = opts, newQrl;
    }, exports.render = async (parent, jsxNode, opts = {}) => {
        if (9 === parent.nodeType) {
            let child = parent.firstChild;
            for (;child && !isElement$1(child); ) {
                child = child.nextSibling;
            }
            parent = child;
        }
        parent.setAttribute("q:container", "resumed");
        const container = getDomContainer(parent);
        container.$serverData$ = opts.serverData || {};
        const host = container.rootVNode;
        return container.$scheduler$(4, host, host, jsxNode), await container.$scheduler$(255).$returnValue$, 
        {
            cleanup: () => {
                cleanup(container, container.rootVNode);
            }
        };
    }, exports.setPlatform = plt => _platform = plt, exports.sync$ = fn => createQRL("", "<sync>", fn, null, null, null), 
    exports.untrack = untrack, exports.unwrapStore = unwrapStore, exports.useAsyncComputed$ = useAsyncComputed$, 
    exports.useAsyncComputedQrl = useAsyncComputedQrl, exports.useComputed$ = useComputed$, 
    exports.useComputedQrl = useComputedQrl, exports.useConstant = useConstant, exports.useContext = (context, defaultValue) => {
        const {val, set, iCtx} = useSequentialScope();
        if (void 0 !== val) {
            return val;
        }
        const value = iCtx.$container$.resolveContext(iCtx.$hostElement$, context);
        if ("function" == typeof defaultValue) {
            return set(invoke(void 0, defaultValue, value));
        }
        if (void 0 !== value) {
            return set(value);
        }
        if (void 0 !== defaultValue) {
            return set(defaultValue);
        }
        throw qError(8, [ context.id ]);
    }, exports.useContextProvider = useContextProvider, exports.useErrorBoundary = () => {
        const error = useStore({
            error: void 0
        });
        return useContextProvider(ERROR_CONTEXT, error), error;
    }, exports.useId = () => {
        const {val, set, iCtx} = useSequentialScope();
        if (null != val) {
            return val;
        }
        const containerBase = iCtx.$container$.$buildBase$ || "";
        const base = containerBase ? hashCode(containerBase).substring(0, 3) : "";
        const componentQrl = iCtx.$container$.getHostProp(iCtx.$hostElement$, "q:renderFn");
        let id = `${base}${componentQrl?.getHash().substring(0, 3) || ""}${(iCtx.$container$.$currentUniqueId$++).toString(36) || ""}`;
        let firstChar = id.charCodeAt(0);
        return firstChar >= 48 && firstChar <= 57 && (firstChar += 17, id = String.fromCharCode(firstChar) + id.substring(1)), 
        set(id);
    }, exports.useLexicalScope = useLexicalScope, exports.useOn = useOn, exports.useOnDocument = useOnDocument, 
    exports.useOnWindow = (event, eventQrl) => {
        _useOn("on-window:", event, eventQrl);
    }, exports.useResource$ = (generatorFn, opts) => useResourceQrl(dollar(generatorFn), opts), 
    exports.useResourceQrl = useResourceQrl, exports.useSerializer$ = useSerializer$, 
    exports.useSerializerQrl = useSerializerQrl, exports.useServerData = function(key, defaultValue) {
        const ctx = tryGetInvokeContext();
        return ctx?.$container$?.$serverData$[key] ?? defaultValue;
    }, exports.useSignal = initialState => useConstant(() => {
        const value = isFunction(initialState) && !isQwikComponent(initialState) ? invoke(void 0, initialState) : initialState;
        return createSignal(value);
    }), exports.useStore = useStore, exports.useStyles$ = useStyles$, exports.useStylesQrl = useStylesQrl, 
    exports.useStylesScoped$ = useStylesScoped$, exports.useStylesScopedQrl = useStylesScopedQrl, 
    exports.useTask$ = useTask$, exports.useTaskQrl = useTaskQrl, exports.useVisibleTask$ = useVisibleTask$, 
    exports.useVisibleTaskQrl = useVisibleTaskQrl, exports.version = version, exports.withLocale = function(locale, fn) {
        if (localAsyncStore) {
            return localAsyncStore.run(locale, fn);
        }
        const previousLang = _locale;
        try {
            return _locale = locale, fn();
        } finally {
            _locale = previousLang;
        }
    };
});
