/**
 * @license
 * @qwik.dev/core/optimizer 2.0.0-beta.13-dev+cb19ff7
 * Copyright QwikDev. All Rights Reserved.
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/QwikDev/qwik/blob/main/LICENSE
 */
function jt(e = {}) {
  function n(p) {
    if (typeof p != "string")
      throw new TypeError("Path must be a string. Received " + JSON.stringify(p));
  }
  function s(p, l) {
    let i = "", g = 0, h = -1, S = 0, v;
    for (let _ = 0; _ <= p.length; ++_) {
      if (_ < p.length)
        v = p.charCodeAt(_);
      else {
        if (v === 47)
          break;
        v = 47;
      }
      if (v === 47) {
        if (!(h === _ - 1 || S === 1)) if (h !== _ - 1 && S === 2) {
          if (i.length < 2 || g !== 2 || i.charCodeAt(i.length - 1) !== 46 || i.charCodeAt(i.length - 2) !== 46) {
            if (i.length > 2) {
              const k = i.lastIndexOf("/");
              if (k !== i.length - 1) {
                k === -1 ? (i = "", g = 0) : (i = i.slice(0, k), g = i.length - 1 - i.lastIndexOf("/")), h = _, S = 0;
                continue;
              }
            } else if (i.length === 2 || i.length === 1) {
              i = "", g = 0, h = _, S = 0;
              continue;
            }
          }
          l && (i.length > 0 ? i += "/.." : i = "..", g = 2);
        } else
          i.length > 0 ? i += "/" + p.slice(h + 1, _) : i = p.slice(h + 1, _), g = _ - h - 1;
        h = _, S = 0;
      } else v === 46 && S !== -1 ? ++S : S = -1;
    }
    return i;
  }
  function r(p, l) {
    const i = l.dir || l.root, g = l.base || (l.name || "") + (l.ext || "");
    return i ? i === l.root ? i + g : i + p + g : g;
  }
  const o = function(...l) {
    let i = "", g = !1, h;
    for (let S = l.length - 1; S >= -1 && !g; S--) {
      let v;
      S >= 0 ? v = l[S] : (h === void 0 && (e && typeof e.cwd == "function" ? h = e.cwd() : typeof process < "u" && typeof process.cwd == "function" ? h = process.cwd() : h = "/"), v = h), n(v), v.length !== 0 && (i = v + "/" + i, g = v.charCodeAt(0) === 47);
    }
    return i = s(i, !g), g ? i.length > 0 ? "/" + i : "/" : i.length > 0 ? i : ".";
  }, f = function(l) {
    if (n(l), l.length === 0)
      return ".";
    const i = l.charCodeAt(0) === 47, g = l.charCodeAt(l.length - 1) === 47;
    return l = s(l, !i), l.length === 0 && !i && (l = "."), l.length > 0 && g && (l += "/"), i ? "/" + l : l;
  }, c = function(l) {
    return n(l), l.length > 0 && l.charCodeAt(0) === 47;
  }, a = function(...l) {
    if (l.length === 0)
      return ".";
    let i;
    for (let g = 0; g < l.length; ++g) {
      const h = l[g];
      n(h), h.length > 0 && (i === void 0 ? i = h : i += "/" + h);
    }
    return i === void 0 ? "." : f(i);
  }, d = function(l, i) {
    if (n(l), n(i), l === i || (l = o(l), i = o(i), l === i))
      return "";
    let g = 1;
    for (; g < l.length && l.charCodeAt(g) === 47; ++g)
      ;
    const h = l.length, S = h - g;
    let v = 1;
    for (; v < i.length && i.charCodeAt(v) === 47; ++v)
      ;
    const k = i.length - v, C = S < k ? S : k;
    let $ = -1, L = 0;
    for (; L <= C; ++L) {
      if (L === C) {
        if (k > C) {
          if (i.charCodeAt(v + L) === 47)
            return i.slice(v + L + 1);
          if (L === 0)
            return i.slice(v + L);
        } else S > C && (l.charCodeAt(g + L) === 47 ? $ = L : L === 0 && ($ = 0));
        break;
      }
      const H = l.charCodeAt(g + L), Q = i.charCodeAt(v + L);
      if (H !== Q)
        break;
      H === 47 && ($ = L);
    }
    let U = "";
    for (L = g + $ + 1; L <= h; ++L)
      (L === h || l.charCodeAt(L) === 47) && (U.length === 0 ? U += ".." : U += "/..");
    return U.length > 0 ? U + i.slice(v + $) : (v += $, i.charCodeAt(v) === 47 && ++v, i.slice(v));
  }, t = function(l) {
    if (n(l), l.length === 0)
      return ".";
    let i = l.charCodeAt(0);
    const g = i === 47;
    let h = -1, S = !0;
    for (let v = l.length - 1; v >= 1; --v)
      if (i = l.charCodeAt(v), i === 47) {
        if (!S) {
          h = v;
          break;
        }
      } else
        S = !1;
    return h === -1 ? g ? "/" : "." : g && h === 1 ? "//" : l.slice(0, h);
  }, x = function(l, i) {
    if (i !== void 0 && typeof i != "string")
      throw new TypeError('"ext" argument must be a string');
    n(l);
    let g = 0, h = -1, S = !0, v;
    if (i !== void 0 && i.length > 0 && i.length <= l.length) {
      if (i.length === l.length && i === l)
        return "";
      let _ = i.length - 1, k = -1;
      for (v = l.length - 1; v >= 0; --v) {
        const C = l.charCodeAt(v);
        if (C === 47) {
          if (!S) {
            g = v + 1;
            break;
          }
        } else
          k === -1 && (S = !1, k = v + 1), _ >= 0 && (C === i.charCodeAt(_) ? --_ === -1 && (h = v) : (_ = -1, h = k));
      }
      return g === h ? h = k : h === -1 && (h = l.length), l.slice(g, h);
    } else {
      for (v = l.length - 1; v >= 0; --v)
        if (l.charCodeAt(v) === 47) {
          if (!S) {
            g = v + 1;
            break;
          }
        } else h === -1 && (S = !1, h = v + 1);
      return h === -1 ? "" : l.slice(g, h);
    }
  }, I = function(l) {
    n(l);
    let i = -1, g = 0, h = -1, S = !0, v = 0;
    for (let _ = l.length - 1; _ >= 0; --_) {
      const k = l.charCodeAt(_);
      if (k === 47) {
        if (!S) {
          g = _ + 1;
          break;
        }
        continue;
      }
      h === -1 && (S = !1, h = _ + 1), k === 46 ? i === -1 ? i = _ : v !== 1 && (v = 1) : i !== -1 && (v = -1);
    }
    return i === -1 || h === -1 || // We saw a non-dot character immediately before the dot
    v === 0 || // The (right-most) trimmed path component is exactly '..'
    v === 1 && i === h - 1 && i === g + 1 ? "" : l.slice(i, h);
  }, u = function(l) {
    if (l === null || typeof l != "object")
      throw new TypeError(
        'The "pathObject" argument must be of type Object. Received type ' + typeof l
      );
    return r("/", l);
  }, w = function(l) {
    n(l);
    const i = {
      root: "",
      dir: "",
      base: "",
      ext: "",
      name: ""
    };
    if (l.length === 0)
      return i;
    let g = l.charCodeAt(0), h;
    const S = g === 47;
    S ? (i.root = "/", h = 1) : h = 0;
    let v = -1, _ = 0, k = -1, C = !0, $ = l.length - 1, L = 0;
    for (; $ >= h; --$) {
      if (g = l.charCodeAt($), g === 47) {
        if (!C) {
          _ = $ + 1;
          break;
        }
        continue;
      }
      k === -1 && (C = !1, k = $ + 1), g === 46 ? v === -1 ? v = $ : L !== 1 && (L = 1) : v !== -1 && (L = -1);
    }
    return v === -1 || k === -1 || // We saw a non-dot character immediately before the dot
    L === 0 || // The (right-most) trimmed path component is exactly '..'
    L === 1 && v === k - 1 && v === _ + 1 ? k !== -1 && (_ === 0 && S ? i.base = i.name = l.slice(1, k) : i.base = i.name = l.slice(_, k)) : (_ === 0 && S ? (i.name = l.slice(1, v), i.base = l.slice(1, k)) : (i.name = l.slice(_, v), i.base = l.slice(_, k)), i.ext = l.slice(v, k)), _ > 0 ? i.dir = l.slice(0, _ - 1) : S && (i.dir = "/"), i;
  }, m = "/", y = ":";
  return {
    relative: d,
    resolve: o,
    parse: w,
    format: u,
    join: a,
    isAbsolute: c,
    basename: x,
    normalize: f,
    dirname: t,
    extname: I,
    delimiter: y,
    sep: m,
    win32: null,
    posix: {
      relative: d,
      resolve: o,
      parse: w,
      format: u,
      join: a,
      isAbsolute: c,
      basename: x,
      normalize: f,
      dirname: t,
      extname: I,
      delimiter: y,
      sep: m,
      win32: null,
      posix: null
    }
  };
}
const $t = {
  darwin: {
    arm64: [
      {
        platform: "darwin",
        arch: "arm64",
        abi: null,
        platformArchABI: "qwik.darwin-arm64.node"
      }
    ],
    x64: [
      {
        platform: "darwin",
        arch: "x64",
        abi: null,
        platformArchABI: "qwik.darwin-x64.node"
      }
    ]
  },
  win32: {
    x64: [
      {
        platform: "win32",
        arch: "x64",
        abi: "msvc",
        platformArchABI: "qwik.win32-x64-msvc.node"
      }
    ]
  },
  linux: {
    x64: [
      {
        platform: "linux",
        arch: "x64",
        abi: "gnu",
        platformArchABI: "qwik.linux-x64-gnu.node"
      }
    ]
  }
}, Fr = {
  qwik: "2.0.0-beta.13-dev+cb19ff7"
};
async function Ut() {
  const e = Et(), n = {
    dynamicImport: (s) => {
      throw new Error(
        `Qwik Optimizer sys.dynamicImport() not implemented, trying to import: "${s}"`
      );
    },
    strictDynamicImport: (s) => {
      throw new Error(
        `Qwik Optimizer sys.strictDynamicImport() not implemented, trying to import: "${s}"`
      );
    },
    path: null,
    cwd: () => "/",
    os: "unknown",
    env: e
  };
  if (n.path = jt(n), n.strictDynamicImport = n.dynamicImport = (s) => import(s), e !== "webworker" && e !== "browsermain")
    try {
      n.path = await n.dynamicImport("node:path"), n.cwd = () => process.cwd(), n.os = process.platform;
    } catch {
    }
  return n;
}
async function Bt(e) {
  const n = Et();
  if (n === "node" || n === "bun") {
    const s = $t[process.platform];
    if (s) {
      const r = s[process.arch];
      if (r)
        for (const o of r)
          try {
            return (await e.dynamicImport("node:module")).default.createRequire(import.meta.url)(
              `../bindings/${o.platformArchABI}`
            );
          } catch (f) {
            console.warn(
              `Unable to load native binding ${o.platformArchABI}. Falling back to wasm build.`,
              f?.message
            );
          }
    }
  }
  if (n === "node" || n === "bun") {
    const s = await e.dynamicImport("node:url"), r = e.path.dirname(s.fileURLToPath(import.meta.url)), o = e.path.join(r, "..", "bindings", "qwik_wasm_bg.wasm"), f = await e.dynamicImport("../bindings/qwik.wasm.mjs"), a = await (await e.dynamicImport("node:fs")).promises.readFile(o), d = await WebAssembly.compile(a);
    return await f.default(d), f;
  } else {
    const s = await e.dynamicImport("../bindings/qwik.wasm.mjs");
    return await s.default(), s;
  }
}
const Et = () => typeof Deno < "u" ? "deno" : typeof Bun < "u" ? "bun" : typeof process < "u" && typeof global < "u" && process.versions && process.versions.node ? "node" : typeof self < "u" && typeof location < "u" && typeof navigator < "u" && typeof fetch == "function" && typeof WorkerGlobalScope == "function" && typeof self.importScripts == "function" ? "webworker" : typeof window < "u" && typeof document < "u" && typeof location < "u" && typeof navigator < "u" && typeof Window == "function" && typeof fetch == "function" ? "browsermain" : "unknown", Rt = async (e = {}) => {
  const n = e?.sys || await Ut(), s = e?.binding || await Bt(n);
  return {
    async transformModules(o) {
      return At(s, o);
    },
    sys: n
  };
}, At = (e, n) => e.transform_modules(Ft(n)), Ft = (e) => {
  const n = {
    minify: "simplify",
    sourceMaps: !1,
    transpileTs: !1,
    transpileJsx: !1,
    preserveFilenames: !1,
    explicitExtensions: !1,
    mode: "lib",
    manualChunks: void 0,
    scope: void 0,
    regCtxName: void 0,
    stripEventHandlers: !1,
    rootDir: void 0,
    stripExports: void 0,
    stripCtxName: void 0,
    isServer: void 0
  };
  return Object.entries(e).forEach(([s, r]) => {
    r != null && (n[s] = r);
  }), n.entryStrategy = e.entryStrategy?.type ?? "smart", n.manualChunks = e.entryStrategy?.manual ?? void 0, n;
}, zt = (e, n = 0) => {
  for (let s = 0; s < e.length; s++) {
    const r = e.charCodeAt(s);
    n = (n << 5) - n + r, n |= 0;
  }
  return Number(Math.abs(n)).toString(36);
}, Ht = /* @__PURE__ */ new Set(["_chk", "_run", "_task", "_val"]);
function Wt(e) {
  const n = e.symbols;
  return Object.keys(n).sort((s, r) => {
    const o = n[s], f = n[r];
    if (o.ctxKind === "eventHandler" && f.ctxKind !== "eventHandler")
      return -1;
    if (o.ctxKind !== "eventHandler" && f.ctxKind === "eventHandler")
      return 1;
    if (o.ctxKind === "eventHandler" && f.ctxKind === "eventHandler") {
      const c = Xe.indexOf(o.ctxName.toLowerCase()), a = Xe.indexOf(f.ctxName.toLowerCase());
      if (c > -1 && a > -1) {
        if (c < a)
          return -1;
        if (c > a)
          return 1;
      } else {
        if (c > -1)
          return -1;
        if (a > -1)
          return 1;
      }
    } else if (o.ctxKind === "function" && f.ctxKind === "function") {
      const c = Ve.indexOf(o.ctxName.toLowerCase()), a = Ve.indexOf(f.ctxName.toLowerCase());
      if (c > -1 && a > -1) {
        if (c < a)
          return -1;
        if (c > a)
          return 1;
      } else {
        if (c > -1)
          return -1;
        if (a > -1)
          return 1;
      }
    }
    return !o.parent && f.parent ? -1 : o.parent && !f.parent ? 1 : o.hash < f.hash ? -1 : o.hash > f.hash ? 1 : 0;
  });
}
const Xe = [
  // Click Events
  "click",
  "dblclick",
  "contextmenu",
  "auxclick",
  // Pointer Events
  "pointerdown",
  "pointerup",
  "pointermove",
  "pointerover",
  "pointerenter",
  "pointerleave",
  "pointerout",
  "pointercancel",
  "gotpointercapture",
  "lostpointercapture",
  // Touch Events
  "touchstart",
  "touchend",
  "touchmove",
  "touchcancel",
  // Mouse Events
  "mousedown",
  "mouseup",
  "mousemove",
  "mouseenter",
  "mouseleave",
  "mouseover",
  "mouseout",
  "wheel",
  // Gesture Events
  "gesturestart",
  "gesturechange",
  "gestureend",
  // Keyboard Events
  "keydown",
  "keyup",
  "keypress",
  // Input/Change Events
  "input",
  "change",
  "search",
  "invalid",
  "beforeinput",
  "select",
  // Focus/Blur Events
  "focusin",
  "focusout",
  "focus",
  "blur",
  // Form Events
  "submit",
  "reset",
  // Scroll Events
  "scroll"
].map((e) => `on${e.toLowerCase()}$`), Ve = ["useTask$", "useVisibleTask$", "component$", "useStyles$", "useStylesScoped$"].map(
  (e) => e.toLowerCase()
);
function Gt(e) {
  return Object.keys(e.bundles).sort(Oe);
}
function Kt(e) {
  const n = Wt(e), s = {}, r = {};
  for (const c of n)
    s[c] = e.symbols[c], r[c] = e.mapping[c];
  const o = Gt(e), f = {};
  for (const c of o) {
    f[c] = e.bundles[c];
    const a = e.bundles[c];
    Array.isArray(a.imports) && a.imports.sort(Oe), Array.isArray(a.dynamicImports) && a.dynamicImports.sort(Oe);
    const d = [];
    for (const t of n)
      c === r[t] && d.push(t);
    d.length > 0 && (d.sort(Oe), a.symbols = d);
  }
  return e.symbols = s, e.mapping = r, e.bundles = f, e;
}
function Oe(e, n) {
  return e = e.toLocaleLowerCase(), n = n.toLocaleLowerCase(), e < n ? -1 : e > n ? 1 : 0;
}
function Ze(e) {
  if (e != null && e.mapping != null && typeof e.mapping == "object" && e.symbols != null && typeof e.symbols == "object" && e.bundles != null && typeof e.bundles == "object")
    return e;
}
const Qt = (e, n) => {
  let s = 0;
  if (e.symbols)
    for (const r of e.symbols) {
      let o = 1;
      const f = n.symbols[r];
      f && (f.ctxKind === "function" ? /(component|useStyles|useStylesScoped)/i.test(f.ctxName) ? o += 1 : /(useComputed|useTask|useVisibleTask|useOn)/i.test(f.ctxName) && (o += 2) : (o += 1, /(click|mouse|pointer|touch|key|scroll|gesture|wheel)/i.test(f.ctxName) && (o += 3))), s = Math.max(s, o);
    }
  return s;
};
function Jt(e) {
  let n = 0;
  const s = [], r = [], o = /* @__PURE__ */ new Map(), f = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Set();
  function a(m) {
    o.set(m, n), f.set(m, n), n++, s.push(m), c.add(m);
    const y = e[m].imports || [];
    for (const p of y)
      o.has(p) ? c.has(p) && f.set(m, Math.min(f.get(m), o.get(p))) : (a(p), f.set(m, Math.min(f.get(m), f.get(p))));
    if (f.get(m) === o.get(m)) {
      const p = [];
      let l;
      do
        l = s.pop(), c.delete(l), p.push(l);
      while (l !== m);
      r.push(p);
    }
  }
  for (const m of Object.keys(e))
    o.has(m) || a(m);
  const d = /* @__PURE__ */ new Map();
  r.forEach((m, y) => {
    for (const p of m)
      d.set(p, y);
  });
  const t = Array.from({ length: r.length }, () => /* @__PURE__ */ new Set());
  for (const m of Object.keys(e)) {
    const y = d.get(m);
    for (const p of e[m].imports || []) {
      const l = d.get(p);
      y !== l && t[y].add(l);
    }
  }
  const x = /* @__PURE__ */ new Set(), I = [];
  function u(m) {
    x.add(m);
    for (const y of t[m])
      x.has(y) || u(y);
    I.push(m);
  }
  for (let m = 0; m < r.length; m++)
    x.has(m) || u(m);
  I.reverse();
  const w = new Array(r.length).fill(0);
  for (let m = 0; m < r.length; m++) {
    let y = 0;
    for (const p of r[m])
      y += e[p].size;
    w[m] = y;
  }
  for (let m = I.length - 1; m >= 0; m--) {
    const y = I[m];
    let p = w[y];
    for (const l of t[y])
      p += w[l];
    w[y] = p;
  }
  for (let m = 0; m < r.length; m++) {
    const y = w[m];
    for (const p of r[m])
      e[p].total = y;
  }
}
const et = /[/\\](core|qwik)[/\\]dist[/\\]preloader\.(|c|m)js$/, tt = /[/\\](core|qwik)[/\\]dist[/\\]core(\.min|\.prod)?\.(|c|m)js$/, nt = /[/\\](core|qwik)[/\\](dist[/\\])?qwikloader(\.debug)?\.[^/]*js$/, rt = /[/\\](core|qwik)[/\\]handlers\.(|c|m)js$/;
function Yt(e, n, s, r, o, f, c) {
  var I;
  const a = {
    version: "1",
    manifestHash: "",
    options: {
      target: o.target,
      buildMode: o.buildMode,
      // don't copy the insights stuff
      entryStrategy: o.entryStrategy && { type: o.entryStrategy.type }
    },
    core: void 0,
    preloader: void 0,
    qwikLoader: void 0,
    bundleGraphAsset: void 0,
    injections: s,
    mapping: {},
    bundles: {},
    assets: {},
    symbols: {},
    bundleGraph: void 0
  }, d = (u) => {
    const w = r[u];
    if (!w) {
      console.warn(`Client manifest generation: skipping external import "${u}"`);
      return;
    }
    return c(w.fileName);
  };
  let t;
  const x = new Set(n.map((u) => u.name));
  for (const u of Object.values(r)) {
    if (u.type === "asset") {
      u.fileName.endsWith("js.map") || (a.assets[u.fileName] = {
        name: u.names[0],
        size: u.source.length
      });
      continue;
    }
    const w = c(u.fileName), y = {
      size: u.code.length,
      total: -1
    };
    for (const h of u.exports)
      x.has(h) && (!a.mapping[h] || u.exports.length !== 1) && (a.mapping[h] = w);
    const p = u.imports.filter((h) => u.code.includes(e.basename(h))).map((h) => d(h)).filter(Boolean);
    p.length > 0 && (y.imports = p);
    const l = u.dynamicImports.filter((h) => u.code.includes(e.basename(h))).map((h) => d(h)).filter(Boolean);
    l.length > 0 && (y.dynamicImports = l), u.facadeModuleId && (et.test(u.facadeModuleId) ? a.preloader = w : tt.test(u.facadeModuleId) ? a.core = w : nt.test(u.facadeModuleId) ? a.qwikLoader = w : rt.test(u.facadeModuleId) && (t = w));
    const g = (u.moduleIds || Object.keys(u.modules)).filter((h) => !h.startsWith("\0")).map((h) => e.relative(o.rootDir, h));
    g.length > 0 && (y.origins = g, !a.preloader && g.some((h) => et.test(h)) && (a.preloader = w), !a.core && g.some((h) => tt.test(h)) && (a.core = w), !a.qwikLoader && g.some((h) => nt.test(h)) && (a.qwikLoader = w), !t && g.some((h) => rt.test(h)) && (t = w)), a.bundles[w] = y;
  }
  for (const u of n) {
    const w = u.name, m = a.mapping[w];
    if (!m) {
      f(`Note: qrl ${u.name} is not in the bundle, likely tree shaken`, a);
      continue;
    }
    ((I = a.bundles[m]).symbols || (I.symbols = [])).push(w), a.symbols[w] = {
      displayName: u.displayName,
      hash: u.hash,
      ctxKind: u.ctxKind,
      ctxName: u.ctxName,
      captures: u.captures,
      canonicalFilename: u.canonicalFilename,
      parent: u.parent,
      origin: u.origin,
      loc: u.loc,
      paramNames: u.paramNames,
      captureNames: u.captureNames
    };
  }
  if (t)
    for (const u of Ht)
      a.symbols[u] = {
        origin: "Qwik core",
        displayName: u,
        canonicalFilename: "",
        hash: u,
        ctxKind: "function",
        ctxName: u,
        captures: !1,
        parent: null,
        loc: [0, 0]
      }, a.mapping[u] = t;
  else
    console.error("Qwik core bundle not found, is Qwik actually used in this project?");
  for (const u of Object.values(a.bundles)) {
    const w = Qt(u, a);
    u.interactivity = w;
  }
  return Jt(a.bundles), Kt(a);
}
const Xt = 300, Vt = 0.5 / (Xt * 1024 / 8), Zt = (e) => {
  const n = e.lastIndexOf("_");
  return n > -1 ? e.slice(n + 1) : e;
};
function en(e, n) {
  const s = [];
  if (!e.bundles)
    return [];
  const r = { ...e.bundles };
  for (const [d, t] of Object.entries(e.mapping)) {
    if (d.startsWith("_") && d.length < 10)
      continue;
    const x = Zt(d);
    x && (r[x] = { dynamicImports: [t] });
  }
  if (n) {
    const d = { ...e, bundles: r };
    for (const t of n) {
      const x = t(d);
      x && Object.assign(r, x);
    }
  }
  for (const d of Object.keys(r)) {
    const t = r[d], x = t.imports?.filter((u) => r[u]) || [], I = t.dynamicImports?.filter(
      // we only want to include dynamic imports that belong to the app
      // e.g. not all languages supported by shiki
      (u) => r[u] && // either there are qrls
      (r[u].symbols || // or it's a dynamic import from the app source
      r[u].origins?.some((w) => !w.includes("node_modules")))
    ) || [];
    r[d] = {
      ...t,
      imports: x,
      dynamicImports: I
    };
  }
  const o = new Set(Object.keys(r));
  for (const d of Object.keys(r)) {
    for (const t of r[d].imports)
      o.delete(t);
    for (const t of r[d].dynamicImports)
      o.delete(t);
  }
  for (const d of o) {
    const t = r[d];
    !t.imports?.length && !t.dynamicImports?.length && delete r[d];
  }
  const f = Object.keys(r), c = /* @__PURE__ */ new Map(), a = (d, t, x = /* @__PURE__ */ new Set()) => {
    const I = r[t];
    for (const u of I.imports)
      d.has(u) && d.delete(u), x.has(u) || (x.add(u), a(d, u, x));
  };
  for (const d of f) {
    const t = r[d], x = new Set(t.imports);
    for (const m of x)
      a(x, m);
    const I = new Set(t.dynamicImports), u = /* @__PURE__ */ new Map();
    for (const m of I) {
      a(I, m);
      const y = r[m];
      let p = 0.5;
      if (p += (y.interactivity || 0) * 0.08, t.origins && y.origins) {
        for (const l of t.origins)
          if (y.origins.some((i) => i.startsWith(l))) {
            p += 0.25;
            break;
          }
      }
      y.total > Vt && (p += p > 0.5 ? 0.02 : -0.02), y.total < 1e3 && (p += 0.15), u.set(m, Math.min(p, 0.99));
    }
    if (I.size > 0) {
      const m = Array.from(I).sort(
        (p, l) => u.get(l) - u.get(p)
      );
      let y = -1;
      for (const p of m)
        u.get(p) !== y && (y = u.get(p), x.add(-Math.round(y * 10))), x.add(p);
    }
    const w = s.length;
    s.push(d);
    for (let m = 0; m < x.size; m++)
      s.push(null);
    c.set(d, { index: w, deps: x });
  }
  for (const d of f) {
    const t = c.get(d);
    let { index: x, deps: I } = t;
    x++;
    for (const u of I) {
      if (typeof u == "number") {
        s[x++] = u;
        continue;
      }
      const m = c.get(u).index;
      s[x++] = m;
    }
  }
  return s;
}
async function tn(e, n, s) {
  const r = await e.dynamicImport("eslint");
  let o = new r.ESLint({ cache: !0 });
  if ((await o.calculateConfigForFile("no-real-file.tsx")).parser === null) {
    const a = {
      cache: !0,
      overrideConfig: {
        languageOptions: {
          parserOptions: {
            tsconfigRootDir: n,
            project: s,
            ecmaVersion: 2021,
            sourceType: "module",
            ecmaFeatures: {
              jsx: !0
            }
          }
        }
      }
    };
    o = new r.ESLint(a);
  }
  return {
    async lint(a, d, t) {
      try {
        const x = nn(t);
        if (await o.isPathIgnored(x))
          return null;
        (await o.lintText(d, {
          filePath: x
        })).forEach((u) => {
          for (const w of u.messages) {
            if (w.ruleId != null && !w.ruleId.startsWith("qwik/"))
              continue;
            const m = rn(u.filePath, w);
            a.warn(m);
          }
        });
      } catch (x) {
        console.warn(x);
      }
    }
  };
}
function nn(e) {
  return e.split("?", 2)[0];
}
function rn(e, n) {
  return Object.assign(new Error(n.message), {
    id: e,
    plugin: "vite-plugin-eslint",
    loc: {
      file: e,
      column: n.column,
      line: n.line
    },
    stack: ""
  });
}
async function on(e, n) {
  const s = n;
  let r = s.loc;
  if (!s.frame && !s.plugin && (r || (r = sn(s)), r && (s.loc = r, r.file))) {
    const o = await e.dynamicImport("node:fs"), { normalizePath: f } = await e.dynamicImport("vite");
    s.id = f(s.loc.file);
    try {
      const c = o.readFileSync(s.loc.file, "utf-8");
      s.frame = ln(c, s.loc);
    } catch {
    }
  }
  return n;
}
const sn = (e) => {
  const n = e.stack;
  if (typeof n == "string") {
    const s = n.split(`
`).filter((r) => !r.includes("/node_modules/") && !r.includes("(node:"));
    for (let r = 1; r < s.length; r++) {
      const o = s[r].replace("file:///", "/");
      if (/^\s+at/.test(o)) {
        const f = o.indexOf("/"), c = o.lastIndexOf(")", f);
        if (f > 0) {
          const d = o.slice(f, c).split(":"), t = ot(d[d.length - 1]), x = ot(d[d.length - 2]);
          return typeof t == "number" && typeof x == "number" ? (d.length -= 2, {
            file: d.join(":"),
            line: x,
            column: t
          }) : typeof t == "number" ? (d.length -= 1, {
            file: d.join(":"),
            line: t,
            column: void 0
          }) : {
            file: d.join(":"),
            line: void 0,
            column: void 0
          };
        }
      }
    }
  }
}, ee = (e) => e.startsWith("\0"), ot = (e) => {
  try {
    return parseInt(e, 10);
  } catch {
    return;
  }
}, _t = /\r?\n/, it = 2;
function an(e, n) {
  if (typeof n == "number")
    return n;
  if (n.lo != null)
    return n.lo;
  const s = e.split(_t), { line: r, column: o } = n;
  let f = 0;
  for (let c = 0; c < r - 1 && c < s.length; c++)
    f += s[c].length + 1;
  return f + o;
}
function ln(e, n = 0, s) {
  n = an(e, n), s = s || n;
  const r = e.split(_t);
  let o = 0;
  const f = [];
  for (let c = 0; c < r.length; c++)
    if (o += r[c].length + 1, o >= n) {
      for (let a = c - it; a <= c + it || s > o; a++) {
        if (a < 0 || a >= r.length)
          continue;
        const d = a + 1;
        f.push(`${d}${" ".repeat(Math.max(3 - String(d).length, 0))}|  ${r[a]}`);
        const t = r[a].length;
        if (a === c) {
          const x = Math.max(n - (o - t) + 1, 0), I = Math.max(1, s > o ? t - x : s - n);
          f.push("   |  " + " ".repeat(x) + "^".repeat(I));
        } else if (a > c) {
          if (s > o) {
            const x = Math.max(Math.min(s - o, t), 1);
            f.push("   |  " + "^".repeat(x));
          }
          o += t + 1;
        }
      }
      break;
    }
  return f.join(`
`);
}
function cn(e) {
  return e === "win32";
}
function Le(e) {
  const [n, s] = e.split("?"), r = s || "";
  return {
    originalId: e,
    pathId: n,
    query: r ? `?${s}` : "",
    params: new URLSearchParams(r)
  };
}
const dn = ["server"], un = [
  "onGet",
  "onPost",
  "onPut",
  "onRequest",
  "onDelete",
  "onHead",
  "onOptions",
  "onPatch",
  "onStaticGenerate"
], fn = [
  "useServer",
  "route",
  "server",
  "action$",
  "loader$",
  "zod$",
  "validator$",
  "globalAction$"
], pn = [
  "useClient",
  "useBrowser",
  "useVisibleTask",
  "client",
  "browser",
  "event$"
];
var Tt = /* @__PURE__ */ ((e) => (e.preventNavigate = "preventNavigate", e.valibot = "valibot", e.noSPA = "noSPA", e.enableRequestRewrite = "enableRequestRewrite", e.webWorker = "webWorker", e.insights = "insights", e))(Tt || {});
function Ct(e = {}) {
  const n = `${Math.round(Math.random() * 899) + 100}`, s = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), f = /* @__PURE__ */ new Map();
  let c = null, a, d = () => {
  };
  const t = {
    csr: !1,
    target: "client",
    buildMode: "development",
    debug: !1,
    rootDir: void 0,
    tsconfigFileNames: ["./tsconfig.json"],
    input: void 0,
    outDir: void 0,
    assetsDir: void 0,
    resolveQwikBuild: !0,
    entryStrategy: void 0,
    srcDir: void 0,
    ssrOutDir: void 0,
    clientOutDir: void 0,
    sourcemap: !!e.sourcemap,
    manifestInput: null,
    manifestInputPath: null,
    manifestOutput: null,
    transformedModuleOutput: null,
    scope: null,
    devTools: {
      imageDevTools: !0,
      clickToSource: ["Alt"]
    },
    inlineStylesUpToBytes: 2e4,
    lint: !1,
    experimental: void 0
  };
  let x, I;
  const u = async () => {
    if (!c && (c = await Rt(e), x = hn(c.sys), c.sys.env !== "browsermain" && c.sys.env !== "webworker"))
      try {
        I === void 0 && (I = await c.sys.dynamicImport("node:fs"));
      } catch {
        console.log("node:fs not available, disabling automatic manifest reading"), I = null;
      }
  }, w = () => {
    if (!c)
      throw new Error("Qwik plugin has not been initialized");
    return c;
  }, m = () => w().sys, y = () => w().sys.path;
  let p;
  const l = (E) => {
    p = E;
  }, i = async (E) => {
    const b = Object.assign({}, E), T = w(), N = T.sys.path, D = (...O) => J(N.resolve(...O));
    t.debug = !!b.debug, b.assetsDir && (t.assetsDir = b.assetsDir), b.target === "ssr" || b.target === "client" || b.target === "lib" || b.target === "test" ? t.target = b.target : t.target || (t.target = "client"), t.target === "lib" ? t.buildMode = "development" : b.buildMode === "production" || b.buildMode === "development" ? t.buildMode = b.buildMode : t.buildMode || (t.buildMode = "development"), t.csr = !!b.csr, b.entryStrategy && typeof b.entryStrategy == "object" && (t.entryStrategy = { ...b.entryStrategy }), t.entryStrategy || (t.target === "ssr" || t.target === "test" ? t.entryStrategy = { type: "hoist" } : t.target === "lib" ? t.entryStrategy = { type: "inline" } : t.buildMode === "production" ? t.entryStrategy = { type: "smart" } : t.entryStrategy = { type: "segment" }), typeof b.rootDir == "string" && (t.rootDir = b.rootDir), typeof t.rootDir != "string" && (t.rootDir || (t.rootDir = T.sys.cwd())), t.rootDir = D(T.sys.cwd(), t.rootDir);
    let P = D(t.rootDir, yn);
    if (typeof b.srcDir == "string" ? (t.srcDir = D(t.rootDir, b.srcDir), P = t.srcDir) : t.srcDir || (t.srcDir = P), t.srcDir = D(t.rootDir, t.srcDir), Array.isArray(b.tsconfigFileNames) && b.tsconfigFileNames.length > 0 && (t.tsconfigFileNames = b.tsconfigFileNames), !t.csr && !b.input && !t.input && (t.target === "ssr" ? t.input = [D(P, "entry.ssr")] : t.target === "client" ? t.input = [D(P, "root")] : t.input = void 0), b.outDir && (t.outDir = D(t.rootDir, b.outDir)), t.clientOutDir = D(t.rootDir, b.clientOutDir || st), t.ssrOutDir = D(t.rootDir, b.ssrOutDir || bn), t.target === "ssr" ? t.outDir || (t.outDir = t.ssrOutDir) : t.target === "lib" ? t.outDir || (t.outDir = D(t.rootDir, vn)) : t.outDir || (t.outDir = t.clientOutDir), typeof b.manifestOutput == "function" && (t.manifestOutput = b.manifestOutput), b.manifestInput && (t.manifestInput = Ze(b.manifestInput) || null), typeof b.transformedModuleOutput == "function" && (t.transformedModuleOutput = b.transformedModuleOutput), b.scope !== void 0)
      t.scope = b.scope;
    else if (!t.scope && I) {
      let O = "";
      try {
        let B = t.rootDir;
        for (; O = N.resolve(B, "package.json"), !await I.promises.stat(O).catch(() => !1); ) {
          const M = N.resolve(B, "..");
          if (M === B)
            break;
          B = M, O = "";
        }
        if (O) {
          const M = await I.promises.readFile(O, "utf-8"), q = JSON.parse(M);
          typeof q.name == "string" && (t.scope = q.name);
        }
      } catch (B) {
        console.warn(
          `could not read ${O || "package.json"} to determine package name, ignoring. (${B})`
        );
      }
    }
    if (typeof b.resolveQwikBuild == "boolean" && (t.resolveQwikBuild = b.resolveQwikBuild), typeof b.devTools == "object" && ("imageDevTools" in b.devTools && (t.devTools.imageDevTools = b.devTools.imageDevTools), "clickToSource" in b.devTools && (t.devTools.clickToSource = b.devTools.clickToSource)), "inlineStylesUpToBytes" in e && (typeof e.inlineStylesUpToBytes == "number" ? t.inlineStylesUpToBytes = e.inlineStylesUpToBytes : (typeof t.inlineStylesUpToBytes != "number" || t.inlineStylesUpToBytes < 0) && (t.inlineStylesUpToBytes = 0)), typeof b.lint == "boolean" && (t.lint = b.lint), "experimental" in b) {
      t.experimental = void 0;
      for (const O of b.experimental ?? [])
        Tt[O] ? (t.experimental || (t.experimental = {}))[O] = !0 : console.error(`Qwik plugin: Unknown experimental feature: ${O}`);
    }
    const R = { ...t };
    return t.input || (t.input = b.input), t.input && typeof t.input == "string" && (t.input = [t.input]), R;
  };
  let g = !1;
  const h = async (E) => {
    if (!g) {
      g = !0;
      const b = m();
      if (b.env === "node") {
        const T = await b.dynamicImport("node:fs");
        if (!T.existsSync(t.rootDir))
          throw new Error(`Qwik rootDir "${t.rootDir}" not found.`);
        if (typeof t.srcDir == "string" && !T.existsSync(t.srcDir))
          throw new Error(`Qwik srcDir "${t.srcDir}" not found.`);
        for (const [N, D] of Object.entries(t.input || {}))
          if (!await E(D))
            throw new Error(`Qwik input "${D}" not found.`);
      }
    }
  };
  let S, v = !1;
  const _ = async (E) => {
    if (j("buildStart()", t.buildMode, t.scope, t.target, t.rootDir, t.srcDir), S = w(), v = !p, S.sys.env === "node" && t.target === "ssr" && t.lint)
      try {
        a = await tn(S.sys, t.rootDir, t.tsconfigFileNames);
      } catch {
      }
    if (j("transformedOutputs.clear()"), r.clear(), o.clear(), t.target === "client") {
      const b = await E.resolve("@qwik.dev/core/qwikloader.js", void 0, {
        skipSelf: !0
      });
      b && E.emitFile({
        id: b.id,
        type: "chunk",
        preserveSignature: "allow-extension"
      });
    }
  }, k = (E) => p ? !!E?.ssr : t.target === "ssr" || t.target === "test";
  let C = 0, $ = !1;
  const L = async (E, b, T, N) => {
    if (ee(b))
      return;
    const D = p && /^(.*)\?editor(:(\d+)(:\d+)?)?$/.exec(b);
    if (D) {
      if (!$) {
        $ = !0, setTimeout(() => $ = !1, 500);
        const [, K, z] = D, ce = await E.resolve(K, T);
        if (ce) {
          const ae = p.moduleGraph.getModuleById(ce.id)?.file;
          if (ae) {
            const te = `${ae}${z}`;
            try {
              console.warn(`Opening in editor: ${te}`);
              const Y = (await import("launch-editor")).default;
              Y(te);
            } catch (Y) {
              console.error(`Failed to open editor: ${Y.message}`);
            }
          }
        }
      }
      return { id: "\0editor" };
    }
    const P = C++, R = k(N);
    j(`resolveId(${P})`, `begin ${b} | ${R ? "server" : "client"} | ${T}`);
    const O = T && Le(T);
    if (T = O && J(O.pathId), b.startsWith(".") && O) {
      const K = y(), z = K.dirname(O.pathId);
      z && (b = K.resolve(z, b));
    }
    const B = Le(b), M = J(B.pathId);
    let q;
    if (
      /**
       * Check if we know the QRL. During regular builds, we'll encounter and build parents before
       * their QRLs, so this will always match.
       */
      f.get(M)
    )
      j(`resolveId(${P}) Resolved already known ${M}`), q = {
        id: M + B.query,
        moduleSideEffects: !1
      };
    else if (
      /**
       * Now the requests we handle are for one of the virtual modules, or a QRL segment that hasn't
       * been transformed yet.
       */
      // We test with endsWith because the dev server adds the base pathname
      M.endsWith(ne)
    )
      t.resolveQwikBuild && (j(`resolveId(${P})`, "Resolved", ne), q = {
        id: ne,
        moduleSideEffects: !1
      });
    else if (M.endsWith(re))
      j(`resolveId(${P})`, "Resolved", re), q = {
        id: re,
        moduleSideEffects: !1
      };
    else if (!p && !R && M.endsWith(ze)) {
      j(`resolveId(${P})`, "Resolved", ze);
      const K = await E.resolve(ze, T, {
        skipSelf: !0
      });
      if (K)
        return E.emitFile({
          id: K.id,
          type: "chunk",
          preserveSignature: "allow-extension"
        }), K;
    } else if (M.endsWith(fe))
      j(`resolveId(${P})`, "Resolved", fe), q = {
        id: fe,
        moduleSideEffects: !1
      };
    else {
      if (!R && v && b.endsWith("@qwik.dev/core")) {
        v = !1;
        const z = await E.resolve("@qwik.dev/core/handlers.mjs", T, {
          skipSelf: !0
        });
        if (!z)
          throw new Error("Failed to resolve @qwik.dev/core/handlers.mjs");
        E.emitFile({
          id: z.id,
          type: "chunk",
          preserveSignature: "allow-extension"
        });
      }
      const K = /^(?<parent>.*\.[mc]?[jt]sx?)_(?<name>[^/]+)\.js(?<query>$|\?.*$)/.exec(b)?.groups;
      if (K) {
        const { parent: z, name: ce, query: ae } = K, te = await E.resolve(z, T, { skipSelf: !0 });
        if (te) {
          const Y = te.id.split("?")[0], Me = p && T?.endsWith(".html") ? `${Y}_${ce}.js` : M;
          j(`resolveId(${P})`, `resolved to QRL ${ce} of ${Y}`), f.set(Me, Y), q = {
            id: Me + ae,
            // QRL segments can't have side effects. Probably never useful, but it's here for consistency
            moduleSideEffects: !1
          };
        } else
          console.error(`resolveId(${P})`, `QRL parent ${z} does not exist!`);
      } else if (T) {
        const z = f.get(T);
        if (z)
          return j(`resolveId(${P}) end`, `resolving via ${z}`), E.resolve(b, z, { skipSelf: !0 });
      }
    }
    return j(`resolveId(${P}) end`, q?.id || q), q;
  };
  let U = 0;
  const H = async (E, b, T) => {
    if (b === "\0editor")
      return '"opening in editor"';
    if (ee(b) || b.startsWith("/@fs/"))
      return;
    const N = U++, D = k(T);
    if (t.resolveQwikBuild && b === ne)
      return j(`load(${N})`, ne, t.buildMode), {
        moduleSideEffects: !1,
        code: se(D, t.target)
      };
    if (b === re)
      return j(`load(${N})`, re, t.buildMode), {
        moduleSideEffects: !1,
        code: await De(D)
      };
    if (b === fe)
      return j(`load(${N})`, fe, t.buildMode), {
        moduleSideEffects: !1,
        code: "export * from '@qwik.dev/core';"
      };
    const P = Le(b);
    b = J(P.pathId);
    const R = D ? o : r;
    if (p && !R.has(b)) {
      const B = f.get(b);
      if (B) {
        const M = p.moduleGraph.getModuleById(B);
        if (M) {
          if (j(`load(${N})`, "transforming QRL parent", B), await p.transformRequest(M.url), !R.has(b))
            return j(`load(${N})`, `QRL segment ${b} not found in ${B}`), null;
        } else
          console.error(`load(${N})`, `${M} does not exist!`);
      }
    }
    const O = R.get(b);
    if (O) {
      j(`load(${N})`, "Found", b);
      const { code: B, map: M, segment: q } = O[0];
      return { code: B, map: M, meta: { segment: q } };
    }
    return j(`load(${N})`, "Not a QRL or virtual module", b), null;
  };
  let Q = 0;
  const ie = async function(E, b, T, N = {}) {
    if (ee(T))
      return;
    const D = Q++, P = k(N), R = P ? o : r;
    if (R.has(T))
      return;
    const O = w(), B = y(), { pathId: M } = Le(T), q = B.parse(M), K = q.dir, z = q.base;
    if (q.ext.toLowerCase() in gn || Pt.test(M)) {
      const ae = t.target === "client" || t.target === "ssr";
      j(
        `transform(${D})`,
        `Transforming ${T} (for: ${P ? "server" : "client"}${ae ? ", strip" : ""})`
      );
      const te = t.target === "lib" ? "lib" : t.buildMode === "development" ? "dev" : "prod";
      te !== "lib" && (b = b.replaceAll(/__EXPERIMENTAL__\.(\w+)/g, (Z, le) => t.experimental?.[le] ? "true" : "false"));
      let Y = z;
      t.srcDir && (Y = B.relative(t.srcDir, M)), Y = J(Y);
      const Ne = t.srcDir ? t.srcDir : J(K), Me = t.entryStrategy;
      let Ye;
      p && (Ye = p.moduleGraph.getModuleById(M)?.url);
      const de = {
        input: [{ code: b, path: Y, devPath: Ye }],
        entryStrategy: P ? { type: "hoist" } : Me,
        minify: "simplify",
        // Always enable sourcemaps in dev for click-to-source
        sourceMaps: t.sourcemap || t.buildMode === "development",
        transpileTs: !0,
        transpileJsx: !0,
        explicitExtensions: !0,
        preserveFilenames: !0,
        srcDir: Ne,
        rootDir: t.rootDir,
        mode: te,
        scope: t.scope || void 0,
        isServer: P
      };
      ae && (P ? (de.stripCtxName = pn, de.stripEventHandlers = !0, de.regCtxName = dn) : (de.stripCtxName = fn, de.stripExports = un));
      const Ot = Date.now(), ue = await O.transformModules(de);
      j(`transform(${D})`, `done in ${Date.now() - Ot}ms`);
      const qe = ue.modules.find((Z) => !mn(Z));
      d(ue.diagnostics, O, Ne), P ? ue.diagnostics.length === 0 && a && a.lint(E, b, T) : s.set(T, ue);
      const Ae = /* @__PURE__ */ new Set();
      for (const Z of ue.modules)
        if (Z !== qe) {
          const le = J(B.join(Ne, Z.path));
          j(`transform(${D})`, `segment ${le}`, Z.segment.displayName), f.set(le, T), R.set(le, [Z, T]), Ae.add(le), t.target === "client" && !p && E.emitFile({
            id: le,
            type: "chunk",
            preserveSignature: "allow-extension"
          });
        }
      return await Promise.all([...Ae.values()].map((Z) => E.load({ id: Z }))), E.addWatchFile(T), {
        code: qe.code,
        map: qe.map,
        meta: {
          segment: qe.segment,
          qwikdeps: Array.from(Ae)
        }
      };
    }
    return j(`transform(${D})`, "Not transforming", T), null;
  }, W = (E) => {
    const b = [], T = {
      addInjection: (N) => b.push(N)
    };
    return T.generateManifest = async (N) => {
      const P = w().sys.path, R = P.resolve(t.rootDir, t.outDir, "build"), O = (q) => P.relative(R, P.resolve(t.rootDir, t.outDir, q));
      T.canonPath = O;
      const B = Array.from(s.values()).flatMap((q) => q.modules).map((q) => q.segment).filter((q) => !!q), M = Yt(
        P,
        B,
        b,
        E,
        t,
        j,
        O
      );
      N && Object.assign(M, N);
      for (const q of Object.values(M.symbols))
        q.origin && (q.origin = J(q.origin));
      for (const q of Object.values(M.bundles))
        q.origins && (q.origins = q.origins.sort());
      return M.manifestHash = zt(JSON.stringify(M)), M;
    }, T;
  }, V = () => t, X = () => Array.from(r.values()).map((E) => E[0]), j = (...E) => {
    t.debug && console.debug(`[QWIK PLUGIN: ${n}]`, ...E);
  }, Re = (...E) => {
    console.log(`[QWIK PLUGIN: ${n}]`, ...E);
  }, G = (E) => {
    d = E;
  }, J = (E) => x(E);
  function se(E, b) {
    const T = t.buildMode === "development";
    return `// @qwik.dev/core/build
export const isServer = ${JSON.stringify(E)};
export const isBrowser = ${JSON.stringify(!E)};
export const isDev = ${JSON.stringify(T)};
`;
  }
  async function De(E) {
    if (!t.manifestInput && t.target === "ssr" && t.buildMode === "production" && I) {
      const N = y();
      let D = t.manifestInputPath || N.resolve(t.clientOutDir, He);
      await I.promises.stat(D).catch(() => !1) || (D = N.resolve(t.rootDir, st, He));
      try {
        const P = await I.promises.readFile(D, "utf-8");
        t.manifestInput = Ze(JSON.parse(P)) || null, console.info("Read client manifest from", D);
      } catch (P) {
        console.warn(
          `
==========
Could not read Qwik client manifest ${D}.
Make sure you provide it to the qwikVite plugin via the \`manifestInput\` \`manifestInputPath\`  arguments, or to the SSR renderer via the \`manifest\` argument, or define it in \`globalThis.__QWIK_MANIFEST__\` before the server bundle is loaded, or embed it in the server bundle by replacing \`globalThis.__QWIK_MANIFEST__\`.
Without the manifest, the SSR renderer will not be able to generate event handlers.
(${P})
==========
`
        );
      }
    }
    const b = E ? t.manifestInput : null;
    let T = null;
    return b?.manifestHash && (T = {
      manifestHash: b.manifestHash,
      core: b.core,
      preloader: b.preloader,
      qwikLoader: b.qwikLoader,
      bundleGraphAsset: b.bundleGraphAsset,
      injections: b.injections,
      mapping: b.mapping,
      bundleGraph: b.bundleGraph
    }), `// @qwik-client-manifest
export const manifest = ${T ? JSON.stringify(T) : "globalThis.__QWIK_MANIFEST__"};
`;
  }
  function Nt(E) {
    t.sourcemap = E;
  }
  function Mt(E) {
    j("handleHotUpdate()", E.file);
    for (const b of E.modules) {
      const { id: T } = b;
      if (T) {
        j("handleHotUpdate()", `invalidate ${T}`), s.delete(T);
        for (const N of [r, o])
          for (const [D, [P, R]] of N)
            if (R === T) {
              j("handleHotUpdate()", `invalidate ${T} segment ${D}`), N.delete(D);
              const O = E.server.moduleGraph.getModuleById(D);
              O && E.server.moduleGraph.invalidateModule(O);
            }
      }
    }
  }
  const qt = (E, { getModuleInfo: b }) => {
    if (t.target === "client") {
      if (
        // The preloader has to stay in a separate chunk if it's a client build
        // the vite preload helper must be included or to prevent breaking circular dependencies
        E.endsWith("@qwik.dev/core/build") || /[/\\](core|qwik)[/\\]dist[/\\]preloader\.[cm]js$/.test(E) || E === "\0vite/preload-helper.js"
      )
        return "qwik-preloader";
      if (
        // likewise, core and handlers have to be in the same chunk so there's no import waterfall
        /[/\\](core|qwik)[/\\](handlers|dist[/\\]core(\.prod|\.min)?)\.[cm]js$/.test(E)
      )
        return "qwik-core";
      if (/[/\\](core|qwik)[/\\]dist[/\\]qwikloader\.js$/.test(E))
        return "qwik-loader";
    }
    const T = b(E);
    if (T) {
      const N = T.meta.segment;
      if (N) {
        const { hash: D } = N, P = t.entryStrategy.manual?.[D] || N.entry;
        if (P)
          return P;
      }
    }
    return null;
  };
  async function Lt(E, b, T, N) {
    const P = await W(b).generateManifest(N);
    P.platform = {
      ...N?.platform,
      rollup: E.meta?.rollupVersion || "",
      env: S.sys.env,
      os: S.sys.os
    }, S.sys.env === "node" && (P.platform.node = process.versions.node);
    const R = en(P, T), O = E.emitFile({
      type: "asset",
      name: "bundle-graph.json",
      source: JSON.stringify(R)
    }), B = E.getFileName(O);
    P.bundleGraphAsset = B, P.assets[B] = {
      name: "bundle-graph.json",
      size: R.length
    };
    const M = JSON.stringify(P, null, "	");
    E.emitFile({
      fileName: He,
      type: "asset",
      source: M
    }), typeof t.manifestOutput == "function" && await t.manifestOutput(P), typeof t.transformedModuleOutput == "function" && await t.transformedModuleOutput(X());
  }
  return {
    buildStart: _,
    createOutputAnalyzer: W,
    getQwikBuildModule: se,
    getOptimizer: w,
    getOptions: V,
    getPath: y,
    getSys: m,
    getTransformedOutputs: X,
    init: u,
    load: H,
    debug: j,
    log: Re,
    normalizeOptions: i,
    normalizePath: J,
    onDiagnostics: G,
    resolveId: L,
    transform: ie,
    validateSource: h,
    setSourceMapSupport: Nt,
    configureServer: l,
    handleHotUpdate: Mt,
    manualChunks: qt,
    generateManifest: Lt
  };
}
const hn = (e) => (n) => typeof n == "string" ? cn(e.os) ? (n.startsWith("\\\\?\\") || /[^\u0000-\u0080]+/.test(n) || (n = n.replace(/\\/g, "/")), e.path.posix.normalize(n)) : e.path.normalize(n) : n;
function mn(e) {
  return e.isEntry || e.segment;
}
const gn = {
  ".jsx": !0,
  ".ts": !0,
  ".tsx": !0
}, Pt = /\.qwik\.[mc]?js$/, je = "@qwik.dev/core", $e = "@qwik.dev/core/internal", ne = "@qwik.dev/core/build", Ke = "@qwik.dev/core/jsx-runtime", Qe = "@qwik.dev/core/jsx-dev-runtime", Fe = "@qwik.dev/core/server", re = "@qwik-client-manifest", ze = "@qwik.dev/core/preloader", fe = "@qwik-handlers", yn = "src", st = "dist", bn = "server", vn = "lib", He = "q-manifest.json";
async function wn(e, n, s) {
  if (e.env === "browsermain" || e.env === "webworker")
    return;
  const r = await e.dynamicImport("node:fs");
  let o = s;
  for (; o; ) {
    const f = e.path.join(o, "node_modules", n, "package.json");
    try {
      return await r.promises.access(f), r.promises.realpath(f);
    } catch {
    }
    const c = e.path.dirname(o);
    if (c === o)
      break;
    o = c;
  }
}
function zr(e = {}) {
  const n = Ct(e.optimizerOptions);
  return {
    name: "rollup-plugin-qwik",
    api: {
      getOptimizer: () => n.getOptimizer(),
      getOptions: () => n.getOptions()
    },
    async options(r) {
      await n.init();
      const o = r.onwarn;
      r.onwarn = (a, d) => {
        a.plugin === "typescript" && a.message.includes("outputToFilesystem") || (o ? o(a, d) : d(a));
      };
      const f = {
        csr: e.csr,
        target: e.target,
        buildMode: e.buildMode,
        debug: e.debug,
        entryStrategy: e.entryStrategy,
        rootDir: e.rootDir,
        srcDir: e.srcDir,
        srcInputs: e.srcInputs,
        input: r.input,
        resolveQwikBuild: !0,
        manifestOutput: e.manifestOutput,
        manifestInput: e.manifestInput,
        transformedModuleOutput: e.transformedModuleOutput,
        inlineStylesUpToBytes: e.optimizerOptions?.inlineStylesUpToBytes,
        lint: e.lint,
        experimental: e.experimental
      };
      await n.normalizeOptions(f);
      const { input: c } = n.getOptions();
      return r.input = c, r;
    },
    outputOptions(r) {
      return Je(n, r, !1);
    },
    async buildStart() {
      n.onDiagnostics((r, o, f) => {
        r.forEach((c) => {
          const a = n.normalizePath(o.sys.path.join(f, c.file));
          c.category === "error" ? this.error(Ue(a, c)) : this.warn(Ue(a, c));
        });
      }), await n.buildStart(this);
    },
    resolveId(r, o) {
      return ee(r) ? null : n.resolveId(this, r, o);
    },
    load(r) {
      return ee(r) ? null : n.load(this, r);
    },
    transform(r, o) {
      return ee(o) ? null : n.transform(this, r, o);
    },
    async generateBundle(r, o) {
      n.getOptions().target === "client" && await n.generateManifest(this, o);
    }
  };
}
async function xn(e, n, s, r) {
  return Array.isArray(n) ? (n.length || n.push({}), await Promise.all(
    n.map(async (o) => ({
      ...await Je(e, o, s),
      dir: r || o.dir
    }))
  )) : {
    ...await Je(e, n, s),
    dir: r || n?.dir
  };
}
const In = (e, n, s) => n.buildMode === "production" && !n.debug ? `${e}build/q-[hash].js` : (r) => {
  if (r.moduleIds?.some((c) => /core\.(prod|min)\.mjs$/.test(c)))
    return `${e}build/core.js`;
  if (r.moduleIds?.some((c) => /qwik-router\/lib\/index\.qwik\.mjs$/.test(c)))
    return `${e}build/qwik-router.js`;
  const f = s.sys.path.relative(s.sys.cwd(), r.name).replace(/^(\.\.\/)+/, "").replace(/^\/+/, "").replace(/\//g, "-");
  return `${e}build/${f}.js`;
};
async function Je(e, n, s) {
  const r = { ...n }, o = e.getOptions(), f = e.getOptimizer(), c = e.manualChunks;
  r.assetFileNames || (r.assetFileNames = `${s ? `${o.assetsDir}/` : ""}assets/[hash]-[name].[ext]`);
  const a = In(s ? `${o.assetsDir}` : "", o, f);
  if (o.target === "client") {
    r.entryFileNames || (r.entryFileNames = a), r.chunkFileNames || (r.chunkFileNames = a), r.format = "es";
    const t = r.manualChunks;
    if (t && typeof t != "function")
      throw new Error("manualChunks must be a function");
    r.manualChunks = t ? (x, I) => t(x, I) || c(x, I) : c;
  } else
    r.chunkFileNames || (r.chunkFileNames = a);
  r.dir || (r.dir = o.outDir), r.format === "cjs" && typeof r.exports != "string" && (r.exports = "auto"), r.hoistTransitiveImports = !1;
  const d = await wn(f.sys, "rollup", f.sys.cwd());
  if (d)
    try {
      const x = await (await f.sys.dynamicImport("node:fs")).promises.readFile(d, "utf-8"), I = JSON.parse(x), u = String(I?.version || ""), [w, m, y] = u.split(".").map((l) => parseInt(l, 10));
      Number.isFinite(w) && (w > 4 || w === 4 && (m > 52 || m === 52 && (y || 0) >= 0)) ? r.onlyExplicitManualChunks = !0 : console.warn(
        ` We detected that you're using a Rollup version prior to 4.52.0 (${u}). For the latest and greatest, we recommend to let Vite install the latest version for you, or manually install the latest version of Rollup in your project if that doesn't work. It will enable the new Rollup \`outputOpts.onlyExplicitManualChunks\` feature flag, which improves preloading performance and reduces cache invalidation for a snappier user experience.`
      );
    } catch {
    }
  return r;
}
function Ue(e, n) {
  const s = n.highlights?.[0];
  return Object.assign(new Error(n.message), {
    id: e,
    plugin: "qwik",
    loc: s && {
      column: s.startCol,
      line: s.startLine
    },
    stack: ""
  });
}
function A(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var pe = {}, We = {}, at;
function F() {
  return at || (at = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.findBox = e.readUInt = e.readUInt32LE = e.readUInt32BE = e.readInt32LE = e.readUInt24LE = e.readUInt16LE = e.readUInt16BE = e.readInt16LE = e.toHexString = e.toUTF8String = void 0;
    const n = new TextDecoder(), s = (y, p = 0, l = y.length) => n.decode(y.slice(p, l));
    e.toUTF8String = s;
    const r = (y, p = 0, l = y.length) => y.slice(p, l).reduce((i, g) => i + ("0" + g.toString(16)).slice(-2), "");
    e.toHexString = r;
    const o = (y, p = 0) => {
      const l = y[p] + y[p + 1] * 256;
      return l | (l & 2 ** 15) * 131070;
    };
    e.readInt16LE = o;
    const f = (y, p = 0) => y[p] * 2 ** 8 + y[p + 1];
    e.readUInt16BE = f;
    const c = (y, p = 0) => y[p] + y[p + 1] * 2 ** 8;
    e.readUInt16LE = c;
    const a = (y, p = 0) => y[p] + y[p + 1] * 2 ** 8 + y[p + 2] * 2 ** 16;
    e.readUInt24LE = a;
    const d = (y, p = 0) => y[p] + y[p + 1] * 2 ** 8 + y[p + 2] * 2 ** 16 + (y[p + 3] << 24);
    e.readInt32LE = d;
    const t = (y, p = 0) => y[p] * 2 ** 24 + y[p + 1] * 2 ** 16 + y[p + 2] * 2 ** 8 + y[p + 3];
    e.readUInt32BE = t;
    const x = (y, p = 0) => y[p] + y[p + 1] * 2 ** 8 + y[p + 2] * 2 ** 16 + y[p + 3] * 2 ** 24;
    e.readUInt32LE = x;
    const I = {
      readUInt16BE: e.readUInt16BE,
      readUInt16LE: e.readUInt16LE,
      readUInt32BE: e.readUInt32BE,
      readUInt32LE: e.readUInt32LE
    };
    function u(y, p, l, i) {
      l = l || 0;
      const g = i ? "BE" : "LE", h = "readUInt" + p + g;
      return I[h](y, l);
    }
    e.readUInt = u;
    function w(y, p) {
      if (y.length - p < 4)
        return;
      const l = (0, e.readUInt32BE)(y, p);
      if (!(y.length - p < l))
        return {
          name: (0, e.toUTF8String)(y, 4 + p, 8 + p),
          offset: p,
          size: l
        };
    }
    function m(y, p, l) {
      for (; l < y.length; ) {
        const i = w(y, l);
        if (!i)
          break;
        if (i.name === p)
          return i;
        l += i.size > 0 ? i.size : 8;
      }
    }
    e.findBox = m;
  })(We)), We;
}
var lt;
function Sn() {
  if (lt) return pe;
  lt = 1, Object.defineProperty(pe, "__esModule", { value: !0 }), pe.BMP = void 0;
  const e = F();
  return pe.BMP = {
    validate: (n) => (0, e.toUTF8String)(n, 0, 2) === "BM",
    calculate: (n) => ({
      height: Math.abs((0, e.readInt32LE)(n, 22)),
      width: (0, e.readUInt32LE)(n, 18)
    })
  }, pe;
}
var kn = Sn();
const En = /* @__PURE__ */ A(kn);
var he = {}, me = {}, ct;
function Dt() {
  if (ct) return me;
  ct = 1, Object.defineProperty(me, "__esModule", { value: !0 }), me.ICO = void 0;
  const e = F(), n = 1, s = 6, r = 16;
  function o(c, a) {
    const d = c[a];
    return d === 0 ? 256 : d;
  }
  function f(c, a) {
    const d = s + a * r;
    return {
      height: o(c, d + 1),
      width: o(c, d)
    };
  }
  return me.ICO = {
    validate(c) {
      const a = (0, e.readUInt16LE)(c, 0), d = (0, e.readUInt16LE)(c, 4);
      return a !== 0 || d === 0 ? !1 : (0, e.readUInt16LE)(c, 2) === n;
    },
    calculate(c) {
      const a = (0, e.readUInt16LE)(c, 4), d = f(c, 0);
      if (a === 1)
        return d;
      const t = [d];
      for (let x = 1; x < a; x += 1)
        t.push(f(c, x));
      return {
        height: d.height,
        images: t,
        width: d.width
      };
    }
  }, me;
}
var dt;
function _n() {
  if (dt) return he;
  dt = 1, Object.defineProperty(he, "__esModule", { value: !0 }), he.CUR = void 0;
  const e = Dt(), n = F(), s = 2;
  return he.CUR = {
    validate(r) {
      const o = (0, n.readUInt16LE)(r, 0), f = (0, n.readUInt16LE)(r, 4);
      return o !== 0 || f === 0 ? !1 : (0, n.readUInt16LE)(r, 2) === s;
    },
    calculate: (r) => e.ICO.calculate(r)
  }, he;
}
var Tn = _n();
const Cn = /* @__PURE__ */ A(Tn);
var ge = {}, ut;
function Pn() {
  if (ut) return ge;
  ut = 1, Object.defineProperty(ge, "__esModule", { value: !0 }), ge.DDS = void 0;
  const e = F();
  return ge.DDS = {
    validate: (n) => (0, e.readUInt32LE)(n, 0) === 542327876,
    calculate: (n) => ({
      height: (0, e.readUInt32LE)(n, 12),
      width: (0, e.readUInt32LE)(n, 16)
    })
  }, ge;
}
var Dn = Pn();
const Nn = /* @__PURE__ */ A(Dn);
var ye = {}, ft;
function Mn() {
  if (ft) return ye;
  ft = 1, Object.defineProperty(ye, "__esModule", { value: !0 }), ye.GIF = void 0;
  const e = F(), n = /^GIF8[79]a/;
  return ye.GIF = {
    validate: (s) => n.test((0, e.toUTF8String)(s, 0, 6)),
    calculate: (s) => ({
      height: (0, e.readUInt16LE)(s, 8),
      width: (0, e.readUInt16LE)(s, 6)
    })
  }, ye;
}
var qn = Mn();
const Ln = /* @__PURE__ */ A(qn);
var be = {}, pt;
function On() {
  if (pt) return be;
  pt = 1, Object.defineProperty(be, "__esModule", { value: !0 }), be.ICNS = void 0;
  const e = F(), n = 8, s = 4, r = 4, o = {
    ICON: 32,
    "ICN#": 32,
    // m => 16 x 16
    "icm#": 16,
    icm4: 16,
    icm8: 16,
    // s => 16 x 16
    "ics#": 16,
    ics4: 16,
    ics8: 16,
    is32: 16,
    s8mk: 16,
    icp4: 16,
    // l => 32 x 32
    icl4: 32,
    icl8: 32,
    il32: 32,
    l8mk: 32,
    icp5: 32,
    ic11: 32,
    // h => 48 x 48
    ich4: 48,
    ich8: 48,
    ih32: 48,
    h8mk: 48,
    // . => 64 x 64
    icp6: 64,
    ic12: 32,
    // t => 128 x 128
    it32: 128,
    t8mk: 128,
    ic07: 128,
    // . => 256 x 256
    ic08: 256,
    ic13: 256,
    // . => 512 x 512
    ic09: 512,
    ic14: 512,
    // . => 1024 x 1024
    ic10: 1024
  };
  function f(a, d) {
    const t = d + r;
    return [
      (0, e.toUTF8String)(a, d, t),
      (0, e.readUInt32BE)(a, t)
    ];
  }
  function c(a) {
    const d = o[a];
    return { width: d, height: d, type: a };
  }
  return be.ICNS = {
    validate: (a) => (0, e.toUTF8String)(a, 0, 4) === "icns",
    calculate(a) {
      const d = a.length, t = (0, e.readUInt32BE)(a, s);
      let x = n, I = f(a, x), u = c(I[0]);
      if (x += I[1], x === t)
        return u;
      const w = {
        height: u.height,
        images: [u],
        width: u.width
      };
      for (; x < t && x < d; )
        I = f(a, x), u = c(I[0]), x += I[1], w.images.push(u);
      return w;
    }
  }, be;
}
var jn = On();
const $n = /* @__PURE__ */ A(jn);
var Un = Dt();
const Bn = /* @__PURE__ */ A(Un);
var ve = {}, ht;
function Rn() {
  if (ht) return ve;
  ht = 1, Object.defineProperty(ve, "__esModule", { value: !0 }), ve.J2C = void 0;
  const e = F();
  return ve.J2C = {
    // TODO: this doesn't seem right. SIZ marker doesn't have to be right after the SOC
    validate: (n) => (0, e.readUInt32BE)(n, 0) === 4283432785,
    calculate: (n) => ({
      height: (0, e.readUInt32BE)(n, 12),
      width: (0, e.readUInt32BE)(n, 8)
    })
  }, ve;
}
var An = Rn();
const Fn = /* @__PURE__ */ A(An);
var we = {}, mt;
function zn() {
  if (mt) return we;
  mt = 1, Object.defineProperty(we, "__esModule", { value: !0 }), we.JP2 = void 0;
  const e = F();
  return we.JP2 = {
    validate(n) {
      if ((0, e.toUTF8String)(n, 4, 8) !== "jP  ")
        return !1;
      const r = (0, e.findBox)(n, "ftyp", 0);
      return r ? (0, e.toUTF8String)(n, r.offset + 8, r.offset + 12) === "jp2 " : !1;
    },
    calculate(n) {
      const s = (0, e.findBox)(n, "jp2h", 0), r = s && (0, e.findBox)(n, "ihdr", s.offset + 8);
      if (r)
        return {
          height: (0, e.readUInt32BE)(n, r.offset + 8),
          width: (0, e.readUInt32BE)(n, r.offset + 12)
        };
      throw new TypeError("Unsupported JPEG 2000 format");
    }
  }, we;
}
var Hn = zn();
const Wn = /* @__PURE__ */ A(Hn);
var xe = {}, gt;
function Gn() {
  if (gt) return xe;
  gt = 1, Object.defineProperty(xe, "__esModule", { value: !0 }), xe.JPG = void 0;
  const e = F(), n = "45786966", s = 2, r = 6, o = 2, f = "4d4d", c = "4949", a = 12, d = 2;
  function t(m) {
    return (0, e.toHexString)(m, 2, 6) === n;
  }
  function x(m, y) {
    return {
      height: (0, e.readUInt16BE)(m, y),
      width: (0, e.readUInt16BE)(m, y + 2)
    };
  }
  function I(m, y) {
    const l = r + 8, i = (0, e.readUInt)(m, 16, l, y);
    for (let g = 0; g < i; g++) {
      const h = l + d + g * a, S = h + a;
      if (h > m.length)
        return;
      const v = m.slice(h, S);
      if ((0, e.readUInt)(v, 16, 0, y) === 274)
        return (0, e.readUInt)(v, 16, 2, y) !== 3 || (0, e.readUInt)(v, 32, 4, y) !== 1 ? void 0 : (0, e.readUInt)(v, 16, 8, y);
    }
  }
  function u(m, y) {
    const p = m.slice(s, y), l = (0, e.toHexString)(p, r, r + o), i = l === f;
    if (i || l === c)
      return I(p, i);
  }
  function w(m, y) {
    if (y > m.length)
      throw new TypeError("Corrupt JPG, exceeded buffer limits");
  }
  return xe.JPG = {
    validate: (m) => (0, e.toHexString)(m, 0, 2) === "ffd8",
    calculate(m) {
      m = m.slice(4);
      let y, p;
      for (; m.length; ) {
        const l = (0, e.readUInt16BE)(m, 0);
        if (m[l] !== 255) {
          m = m.slice(1);
          continue;
        }
        if (t(m) && (y = u(m, l)), w(m, l), p = m[l + 1], p === 192 || p === 193 || p === 194) {
          const i = x(m, l + 5);
          return y ? {
            height: i.height,
            orientation: y,
            width: i.width
          } : i;
        }
        m = m.slice(l + 2);
      }
      throw new TypeError("Invalid JPG, no size found");
    }
  }, xe;
}
var Kn = Gn();
const Qn = /* @__PURE__ */ A(Kn);
var Ie = {}, yt;
function Jn() {
  if (yt) return Ie;
  yt = 1, Object.defineProperty(Ie, "__esModule", { value: !0 }), Ie.KTX = void 0;
  const e = F();
  return Ie.KTX = {
    validate: (n) => {
      const s = (0, e.toUTF8String)(n, 1, 7);
      return ["KTX 11", "KTX 20"].includes(s);
    },
    calculate: (n) => {
      const s = n[5] === 49 ? "ktx" : "ktx2", r = s === "ktx" ? 36 : 20;
      return {
        height: (0, e.readUInt32LE)(n, r + 4),
        width: (0, e.readUInt32LE)(n, r),
        type: s
      };
    }
  }, Ie;
}
var Yn = Jn();
const Xn = /* @__PURE__ */ A(Yn);
var Se = {}, bt;
function Vn() {
  if (bt) return Se;
  bt = 1, Object.defineProperty(Se, "__esModule", { value: !0 }), Se.PNG = void 0;
  const e = F(), n = `PNG\r

`, s = "IHDR", r = "CgBI";
  return Se.PNG = {
    validate(o) {
      if (n === (0, e.toUTF8String)(o, 1, 8)) {
        let f = (0, e.toUTF8String)(o, 12, 16);
        if (f === r && (f = (0, e.toUTF8String)(o, 28, 32)), f !== s)
          throw new TypeError("Invalid PNG");
        return !0;
      }
      return !1;
    },
    calculate(o) {
      return (0, e.toUTF8String)(o, 12, 16) === r ? {
        height: (0, e.readUInt32BE)(o, 36),
        width: (0, e.readUInt32BE)(o, 32)
      } : {
        height: (0, e.readUInt32BE)(o, 20),
        width: (0, e.readUInt32BE)(o, 16)
      };
    }
  }, Se;
}
var Zn = Vn();
const er = /* @__PURE__ */ A(Zn);
var ke = {}, vt;
function tr() {
  if (vt) return ke;
  vt = 1, Object.defineProperty(ke, "__esModule", { value: !0 }), ke.PNM = void 0;
  const e = F(), n = {
    P1: "pbm/ascii",
    P2: "pgm/ascii",
    P3: "ppm/ascii",
    P4: "pbm",
    P5: "pgm",
    P6: "ppm",
    P7: "pam",
    PF: "pfm"
  }, s = {
    default: (r) => {
      let o = [];
      for (; r.length > 0; ) {
        const f = r.shift();
        if (f[0] !== "#") {
          o = f.split(" ");
          break;
        }
      }
      if (o.length === 2)
        return {
          height: parseInt(o[1], 10),
          width: parseInt(o[0], 10)
        };
      throw new TypeError("Invalid PNM");
    },
    pam: (r) => {
      const o = {};
      for (; r.length > 0; ) {
        const f = r.shift();
        if (f.length > 16 || f.charCodeAt(0) > 128)
          continue;
        const [c, a] = f.split(" ");
        if (c && a && (o[c.toLowerCase()] = parseInt(a, 10)), o.height && o.width)
          break;
      }
      if (o.height && o.width)
        return {
          height: o.height,
          width: o.width
        };
      throw new TypeError("Invalid PAM");
    }
  };
  return ke.PNM = {
    validate: (r) => (0, e.toUTF8String)(r, 0, 2) in n,
    calculate(r) {
      const o = (0, e.toUTF8String)(r, 0, 2), f = n[o], c = (0, e.toUTF8String)(r, 3).split(/[\r\n]+/);
      return (s[f] || s.default)(c);
    }
  }, ke;
}
var nr = tr();
const rr = /* @__PURE__ */ A(nr);
var Ee = {}, wt;
function or() {
  if (wt) return Ee;
  wt = 1, Object.defineProperty(Ee, "__esModule", { value: !0 }), Ee.PSD = void 0;
  const e = F();
  return Ee.PSD = {
    validate: (n) => (0, e.toUTF8String)(n, 0, 4) === "8BPS",
    calculate: (n) => ({
      height: (0, e.readUInt32BE)(n, 14),
      width: (0, e.readUInt32BE)(n, 18)
    })
  }, Ee;
}
var ir = or();
const sr = /* @__PURE__ */ A(ir);
var _e = {}, xt;
function ar() {
  if (xt) return _e;
  xt = 1, Object.defineProperty(_e, "__esModule", { value: !0 }), _e.SVG = void 0;
  const e = F(), n = /<svg\s([^>"']|"[^"]*"|'[^']*')*>/, s = {
    height: /\sheight=(['"])([^%]+?)\1/,
    root: n,
    viewbox: /\sviewBox=(['"])(.+?)\1/i,
    width: /\swidth=(['"])([^%]+?)\1/
  }, r = 2.54, o = {
    in: 96,
    cm: 96 / r,
    em: 16,
    ex: 8,
    m: 96 / r * 100,
    mm: 96 / r / 10,
    pc: 96 / 72 / 12,
    pt: 96 / 72,
    px: 1
  }, f = new RegExp(`^([0-9.]+(?:e\\d+)?)(${Object.keys(o).join("|")})?$`);
  function c(I) {
    const u = f.exec(I);
    if (u)
      return Math.round(Number(u[1]) * (o[u[2]] || 1));
  }
  function a(I) {
    const u = I.split(" ");
    return {
      height: c(u[3]),
      width: c(u[2])
    };
  }
  function d(I) {
    const u = I.match(s.width), w = I.match(s.height), m = I.match(s.viewbox);
    return {
      height: w && c(w[2]),
      viewbox: m && a(m[2]),
      width: u && c(u[2])
    };
  }
  function t(I) {
    return {
      height: I.height,
      width: I.width
    };
  }
  function x(I, u) {
    const w = u.width / u.height;
    return I.width ? {
      height: Math.floor(I.width / w),
      width: I.width
    } : I.height ? {
      height: I.height,
      width: Math.floor(I.height * w)
    } : {
      height: u.height,
      width: u.width
    };
  }
  return _e.SVG = {
    // Scan only the first kilo-byte to speed up the check on larger files
    validate: (I) => n.test((0, e.toUTF8String)(I, 0, 1e3)),
    calculate(I) {
      const u = (0, e.toUTF8String)(I).match(s.root);
      if (u) {
        const w = d(u[0]);
        if (w.width && w.height)
          return t(w);
        if (w.viewbox)
          return x(w, w.viewbox);
      }
      throw new TypeError("Invalid SVG");
    }
  }, _e;
}
var lr = ar();
const cr = /* @__PURE__ */ A(lr);
var Te = {}, It;
function dr() {
  if (It) return Te;
  It = 1, Object.defineProperty(Te, "__esModule", { value: !0 }), Te.TGA = void 0;
  const e = F();
  return Te.TGA = {
    validate(n) {
      return (0, e.readUInt16LE)(n, 0) === 0 && (0, e.readUInt16LE)(n, 4) === 0;
    },
    calculate(n) {
      return {
        height: (0, e.readUInt16LE)(n, 14),
        width: (0, e.readUInt16LE)(n, 12)
      };
    }
  }, Te;
}
var ur = dr();
const fr = /* @__PURE__ */ A(ur);
var Ce = {}, St;
function pr() {
  if (St) return Ce;
  St = 1, Object.defineProperty(Ce, "__esModule", { value: !0 }), Ce.WEBP = void 0;
  const e = F();
  function n(o) {
    return {
      height: 1 + (0, e.readUInt24LE)(o, 7),
      width: 1 + (0, e.readUInt24LE)(o, 4)
    };
  }
  function s(o) {
    return {
      height: 1 + ((o[4] & 15) << 10 | o[3] << 2 | (o[2] & 192) >> 6),
      width: 1 + ((o[2] & 63) << 8 | o[1])
    };
  }
  function r(o) {
    return {
      height: (0, e.readInt16LE)(o, 8) & 16383,
      width: (0, e.readInt16LE)(o, 6) & 16383
    };
  }
  return Ce.WEBP = {
    validate(o) {
      const f = (0, e.toUTF8String)(o, 0, 4) === "RIFF", c = (0, e.toUTF8String)(o, 8, 12) === "WEBP", a = (0, e.toUTF8String)(o, 12, 15) === "VP8";
      return f && c && a;
    },
    calculate(o) {
      const f = (0, e.toUTF8String)(o, 12, 16);
      if (o = o.slice(20, 30), f === "VP8X") {
        const a = o[0], d = (a & 192) === 0, t = (a & 1) === 0;
        if (d && t)
          return n(o);
        throw new TypeError("Invalid WebP");
      }
      if (f === "VP8 " && o[0] !== 47)
        return r(o);
      const c = (0, e.toHexString)(o, 3, 6);
      if (f === "VP8L" && c !== "9d012a")
        return s(o);
      throw new TypeError("Invalid WebP");
    }
  }, Ce;
}
var hr = pr();
const mr = /* @__PURE__ */ A(hr);
var Pe = {}, kt;
function gr() {
  if (kt) return Pe;
  kt = 1, Object.defineProperty(Pe, "__esModule", { value: !0 }), Pe.HEIF = void 0;
  const e = F(), n = {
    avif: "avif",
    mif1: "heif",
    msf1: "heif",
    // heif-sequence
    heic: "heic",
    heix: "heic",
    hevc: "heic",
    // heic-sequence
    hevx: "heic"
    // heic-sequence
  };
  return Pe.HEIF = {
    validate(s) {
      if ((0, e.toUTF8String)(s, 4, 8) !== "ftyp")
        return !1;
      const o = (0, e.findBox)(s, "ftyp", 0);
      return o ? (0, e.toUTF8String)(s, o.offset + 8, o.offset + 12) in n : !1;
    },
    calculate(s) {
      const r = (0, e.findBox)(s, "meta", 0), o = r && (0, e.findBox)(s, "iprp", r.offset + 12), f = o && (0, e.findBox)(s, "ipco", o.offset + 8), c = f && (0, e.findBox)(s, "ispe", f.offset + 8);
      if (c)
        return {
          height: (0, e.readUInt32BE)(s, c.offset + 16),
          width: (0, e.readUInt32BE)(s, c.offset + 12),
          type: (0, e.toUTF8String)(s, 8, 12)
        };
      throw new TypeError("Invalid HEIF, no size found");
    }
  }, Pe;
}
var yr = gr();
const br = /* @__PURE__ */ A(yr), vr = {
  56: "psd",
  66: "bmp",
  68: "dds",
  71: "gif",
  82: "webp",
  105: "icns",
  137: "png",
  255: "jpg"
}, Be = {
  webp: mr.WEBP,
  jpg: Qn.JPG,
  png: er.PNG,
  svg: cr.SVG,
  gif: Ln.GIF,
  avif: br.HEIF,
  bmp: En.BMP,
  cur: Cn.CUR,
  dds: Nn.DDS,
  icns: $n.ICNS,
  ico: Bn.ICO,
  j2c: Fn.J2C,
  jp2: Wn.JP2,
  ktx: Xn.KTX,
  pnm: rr.PNM,
  psd: sr.PSD,
  tga: fr.TGA
}, wr = Object.keys(Be);
function xr(e) {
  const n = e[0], s = vr[n];
  return s && Be[s].validate(e) ? s : wr.find((r) => Be[r].validate(e));
}
function Ir(e) {
  const n = xr(e);
  if (typeof n < "u") {
    const s = Be[n].calculate(e);
    if (s !== void 0)
      return s.type = n, s;
  }
}
async function Sr(e) {
  if (/^(https?|file|capacitor):/.test(e))
    try {
      const n = await fetch(e, {
        headers: { Accept: "image/*,*/*" }
      });
      if (!n.ok) {
        console.error("can not fetch", e);
        return;
      }
      const s = await n.arrayBuffer(), r = Ir(Buffer.from(s));
      if (r)
        return {
          width: r.width,
          height: r.height,
          type: r.type,
          size: s.byteLength
        };
    } catch (n) {
      console.error(n);
      return;
    }
}
const kr = (e, n, s) => async (r, o, f) => {
  try {
    const c = await e.dynamicImport("node:fs"), a = await e.dynamicImport("node:path");
    let d;
    try {
      d = new URL(r.url, "http://localhost:3000/");
    } catch {
      o.statusCode = 404, o.end();
      return;
    }
    if (r.method === "GET" && d.pathname === "/__image_info") {
      const t = d.searchParams.get("url");
      if (o.setHeader("content-type", "application/json"), t) {
        const x = await Sr(t);
        o.setHeader("cache-control", "public, max-age=31536000, immutable"), x ? o.write(JSON.stringify(x)) : o.statusCode = 404;
      } else {
        o.statusCode = 500;
        const x = { message: "error" };
        o.write(JSON.stringify(x));
      }
      o.end();
      return;
    } else if (r.method === "POST" && d.pathname === "/__image_fix") {
      const t = d.searchParams.get("loc"), x = d.searchParams.get("width"), I = d.searchParams.get("height"), u = d.searchParams.get("src"), w = d.searchParams.get("currentHref"), m = t.split(":"), y = parseInt(m[m.length - 1], 10) - 1;
      let p = parseInt(m[m.length - 2], 10) - 1;
      const l = a.resolve(s, m.slice(0, m.length - 2).join(":")), i = a.extname(l).toLowerCase();
      let h = c.readFileSync(l).toString("utf-8"), S = 0;
      for (; S < h.length; S++)
        if (p === 0) {
          S += y;
          break;
        } else if (h[S] === `
`) {
          p--;
          continue;
        }
      if (h.slice(S, S + 4) !== "<img") {
        console.error(
          "Could not apply auto fix, because it was not possible to find the original <img> tag"
        ), o.statusCode = 500;
        return;
      }
      const v = h.indexOf(">", S) + 1;
      if (v < S) {
        console.error(
          "Could not apply auto fix, because it was not possible to find the original <img> tag"
        ), o.statusCode = 500;
        return;
      }
      const _ = [".ts", ".tsx", ".js", ".jsx", ".mdx"].includes(i);
      let k = h.slice(S, v);
      if (u && w && _) {
        const C = new URL(u), $ = new URL(w);
        if (C.origin === $.origin) {
          const L = a.join(n, "public", C.pathname), U = a.join(n, C.pathname);
          let H;
          if (c.existsSync(L)) {
            const X = a.join(s, "media", a.dirname(C.pathname));
            await c.promises.mkdir(X, { recursive: !0 }), await c.promises.copyFile(
              L,
              a.join(s, "media", C.pathname)
            ), H = "~/media" + C.pathname;
          } else if (c.existsSync(U))
            H = C.pathname.replace("/src/", "~/");
          else
            return;
          const Q = Er(C.pathname), ie = `${H}?jsx`;
          k = k.replace(/^<img/, `<${Q}`), k = k.replace(/\bwidth=(({[^}]*})|('[^']*')|("[^"]*"))\s*/, ""), k = k.replace(/\bheight=(({[^}]*})|('[^']*')|("[^"]*"))\s*/, ""), k = k.replace(/\bsrc=(({[^}]*})|('[^']*')|("[^"]*"))\s*/, "");
          let W = 0;
          if (i === ".mdx" && h.startsWith("---") && (W = h.indexOf("---", 4) + 3, W === -1))
            return;
          const V = `
import ${Q} from '${ie}';`;
          h = `${h.slice(0, W)}${V}${h.slice(
            W,
            S
          )}${k}${h.slice(v)}`, c.writeFileSync(l, h);
          return;
        }
      }
      k = k.replace(/\bwidth=(({[^}]*})|('[^']*')|("[^"]*"))/, `width="${x}"`), k = k.replace(/\bheight=(({[^}]*})|('[^']*')|("[^"]*"))/, `height="${I}"`), k.includes("height=") || (k = k.replace(/<img/, `<img height="${I}"`)), k.includes("width=") || (k = k.replace(/<img/, `<img width="${x}"`)), h = h.slice(0, S) + k + h.slice(v), c.writeFileSync(l, h);
    } else
      f();
  } catch (c) {
    c instanceof Error && await on(e, c), f(c);
  }
};
function Er(e) {
  const n = e.lastIndexOf("."), s = e.lastIndexOf("/");
  return e = e.substring(s + 1, n), `Img${_r(e)}`;
}
function _r(e) {
  return `${e}`.toLowerCase().replace(new RegExp(/[-_]+/, "g"), " ").replace(new RegExp(/[^\w\s]/, "g"), "").replace(new RegExp(/\s+(.)(\w*)/, "g"), (n, s, r) => `${s.toUpperCase() + r}`).replace(new RegExp(/\w/), (n) => n.toUpperCase());
}
const Tr = `"undefined"==typeof window||window.__qwikViteLog||(window.__qwikViteLog=!0,console.debug("%c Qwik Dev SSR Mode","background: #0c75d2; color: white; padding: 2px 3px; border-radius: 2px; font-size: 0.8em;","App is running in SSR development mode!\\n - Additional JS is loaded by Vite for debugging and live reloading\\n - Rendering performance might not be optimal\\n - Delayed interactivity because prefetching is disabled\\n - Vite dev bundles do not represent production output\\n\\nProduction build can be tested running 'npm run preview'"))`, Cr = 'if("undefined"!=typeof document){const e=()=>{const e="data-qwik-inspector",t=globalThis.__HOTKEYS__;globalThis.__SRC_DIR__;let o=document.querySelector("#qwik-inspector-info-popup");o||(o=document.createElement("div"),o.id="qwik-inspector-info-popup",o["aria-hidden"]="true",document.body.appendChild(o)),o.textContent=`Click-to-Source: ${t.join(" + ")}`,console.debug("%c Qwik Click-To-Source","background: #564CE0; color: white; padding: 2px 3px; border-radius: 2px; font-size: 0.8em;",`Hold-press the \'${t.join(" + ")}\' key${t.length>1?"s":""} and click a component to jump directly to the source code in your IDE!`),window.__qwik_inspector_state={pressedKeys:new Set};const n=document.body,r=document.createElement("div");function i(t){return t&&t instanceof Element?t.closest(`[${e}]`):null}function s(){const e=window.__qwik_inspector_state.hoveredElement;if(e&&d()){const t=e.getBoundingClientRect();r.style.setProperty("height",t.height+"px"),r.style.setProperty("width",t.width+"px"),r.style.setProperty("top",t.top+"px"),r.style.setProperty("left",t.left+"px"),r.style.setProperty("visibility","visible"),n.style.setProperty("cursor","pointer")}else r.style.setProperty("height","0px"),r.style.setProperty("width","0px"),r.style.setProperty("visibility","hidden"),n.style.removeProperty("cursor")}function d(){return function(){const e=Array.from(window.__qwik_inspector_state.pressedKeys).map(e=>e?e.replace(/(Left|Right)$/g,""):void 0);return t.every(t=>e.includes(t))}()}r.id="qwik-inspector-overlay",r.setAttribute("aria-hidden","true"),n.appendChild(r),document.addEventListener("keydown",e=>{window.__qwik_inspector_state.pressedKeys.add(e.code),s()},{capture:!0}),document.addEventListener("keyup",e=>{window.__qwik_inspector_state.pressedKeys.delete(e.code),s()},{capture:!0}),window.addEventListener("blur",()=>{window.__qwik_inspector_state.pressedKeys.clear(),s()},{capture:!0}),document.addEventListener("mouseover",e=>{const t=i(e.target);window.__qwik_inspector_state.hoveredElement=t||void 0,s()},{capture:!0}),document.addEventListener("click",t=>{if(d()){window.__qwik_inspector_state.pressedKeys.clear();const o=i(t.target);if(o){t.preventDefault(),t.stopPropagation();const r=o.getAttribute(e);if("false"!==r){n.style.setProperty("cursor","progress");const e=r.match(/^(.*?)(:\\d+(:\\d+)?)?$/);if(e){const[,t,o]=e;fetch(`${t}?editor${o}`).then(()=>{n.style.removeProperty("cursor")})}}}}},{capture:!0}),document.addEventListener("contextmenu",e=>{if(d()){window.__qwik_inspector_state.pressedKeys.clear();i(e.target)&&e.preventDefault()}},{capture:!0}),window.addEventListener("resize",s),document.addEventListener("scroll",s)};document.addEventListener("DOMContentLoaded",e)}', Pr = `if("undefined"!=typeof HTMLElement){class e extends HTMLElement{get _root(){return this.shadowRoot||this}constructor(){super(),this.state={},this.props||(this.props={}),this.componentProps=["children","error"],this.nodesToDestroy=[],this.pendingUpdate=!1,this.attachShadow({mode:"open"})}destroyAnyNodes(){this.nodesToDestroy.forEach(e=>e.remove()),this.nodesToDestroy=[]}connectedCallback(){this.getAttributeNames().forEach(e=>{const t=e.replace(/-/g,""),o=new RegExp(t,"i");this.componentProps.forEach(t=>{if(o.test(t)){const o=this.getAttribute(e);this.props[t]!==o&&(this.props[t]=o)}})}),this._root.innerHTML='\\n\\n        <template data-el="show-errored-host">\\n        <div class="error">\\n          <template data-el="div-errored-host-2">\\n            \\x3c!-- String(props.error) --\\x3e\\n          </template>\\n        </div>\\n        </template>\\n\\n        <div class="arrow"> Uncaught error happened here \\n          <span class="dev-tools">DevTools: Cmd+Alt+I</span>\\n        </div>\\n        <div class="div">\\n          <slot></slot>\\n        </div>\\n\\n        <style>\\n          .error {\\n            border-radius: 5px 5px 0px 0;\\n            background: black;\\n            color: white;\\n            font-family: monospace;\\n            font-size: 12px;\\n            margin: 0;\\n            padding: 10px;\\n          }\\n          .arrow {\\n            background: #f47e81;\\n            color: black;\\n            font-size: 14px;\\n            padding: 10px;\\n            text-align: center;\\n            font-family: sans-serif;\\n          }\\n          .dev-tools {\\n            background: red;\\n            padding: 2px 5px;\\n            border-radius: 3px;\\n            font-weight: 800;\\n          }\\n          .div {\\n            outline: 5px solid red;\\n            border-radius: 10px;\\n          }\\n        </style>',this.pendingUpdate=!0,this.render(),this.onMount(),this.pendingUpdate=!1,this.update()}showContent(e){const t=e.content.cloneNode(!0);Array.from(t.childNodes).forEach(t=>{e?.scope&&(t.scope=e.scope),e?.context&&(t.context=e.context),this.nodesToDestroy.push(t)}),e.after(t)}onMount(){}onUpdate(){}update(){!0!==this.pendingUpdate&&(this.pendingUpdate=!0,this.render(),this.onUpdate(),this.pendingUpdate=!1)}render(){this.destroyAnyNodes(),this.updateBindings()}updateBindings(){this._root.querySelectorAll("[data-el='show-errored-host']").forEach(e=>{this.props.error&&this.showContent(e)}),this._root.querySelectorAll("[data-el='div-errored-host-2']").forEach(e=>{this.renderTextNode(e,String(this.props.error))})}renderTextNode(e,t){const o=document.createTextNode(t);e?.scope&&(o.scope=e.scope),e?.context&&(o.context=e.context),e.after(o),this.nodesToDestroy.push(e.nextSibling)}}customElements.define("errored-host",e),document.addEventListener("qerror",e=>{const t=customElements.get("vite-error-overlay");if(!t)return;const o=new t(e.detail.error);document.body.appendChild(o)})}`, Dr = '[data-qwik-cls]{outline:2px solid red}[data-qwik-cls]:after{position:absolute;font-size:12px;content:"CLS " attr(data-qwik-cls);font-family:monospace;font-weight:700;background:red;color:#fff;margin:-2px;padding:1px;line-height:1;pointer-events:none}#qwik-image-warning-container{position:absolute!important;top:0!important;left:0!important;width:0!important;overflow:visible!important;height:0!important;pointer-events:none!important;contain:size layout style content;z-index:1}', Nr = 'if("undefined"!=typeof document){const e=()=>{class e extends HTMLElement{#e=null;constructor(){super(),this.attachShadow({mode:"open"}),this.shadowRoot.appendChild(document.createElement("template").innerHTML=globalThis.__TEMPLATE__);const e=this.shadowRoot.querySelector("dialog");this.shadowRoot.addEventListener("click",async t=>{const o=t.target;"BUTTON"===o.nodeName&&("action-btn"===o.id?this.#e&&(this.#e(),e.close()):"icon"===o.id?e.open?e.close():(e.className=function(e){const{x:t}=e.getBoundingClientRect();let o="right";return t>window.innerWidth-260&&(o="left"),`bottom ${o}`}(o),e.show()):"loc"===o.id&&o.dataset.url&&globalThis.qwikOpenInEditor(o.dataset.url))})}set loc(e){const t=this.shadowRoot.querySelector("#loc");t.textContent=e,globalThis.qwikOpenInEditor&&(t.dataset.url=e)}set header(e){this.shadowRoot.querySelector("#title").textContent=e}set message(e){this.shadowRoot.querySelector("#message").innerHTML=e}set actionFn(e){this.#e=e}set actionName(e){e&&(this.shadowRoot.querySelector(".action-container").innerHTML=`<button id="action-btn" type="button">${e}</button>`)}}customElements.define("image-warning",e);const t=new Map;let o=document.querySelector("#qwik-image-warning-container");o||(o=document.createElement("div"),o.id="qwik-image-warning-container",document.body.appendChild(o));let n=!1;const i=new Map;function r(e){let t=i.get(e);return void 0===t&&(t=async function(e){if(!/^(https?|file|capacitor):/.test(e))return;const t=new URL("/__image_info",location.href);return t.searchParams.set("url",e),fetch(t).then(e=>e.json()).catch(()=>null)}(e),i.set(e,t)),t}function a(e){return e.endsWith("px")}async function s(e){const i=t.get(e);e.isConnected?e.complete&&async function(e){const i=window.scrollX,s=window.scrollY,c=e.getBoundingClientRect(),d=e.currentSrc,l=await r(d);let h=t.get(e);const u=window.innerWidth>500;if(l&&u){let r=!1;const d=e.getAttribute("data-qwik-inspector"),u=c.width*c.height;if(!e.hasAttribute("width")||!e.hasAttribute("height")){n=!0;const t=getComputedStyle(e),o="auto"!==t.getPropertyValue("aspect-ratio").toString(),i=a(t.getPropertyValue("width").toString()),s=a(t.getPropertyValue("height").toString()),c="absolute"===t.getPropertyValue("position").toString();r=u>1e3&&!c&&!o&&(!i||!s)}const g=u<.5*(l.width&&l.height)&&"svg"!==l.type;if(n=!1,r||g){if(h||(h=document.createElement("image-warning"),o.appendChild(h),t.set(e,h)),h.style.top=c.top+s+"px",h.style.left=c.left+i+"px",h.style.width=c.width+"px",h.style.height=c.height+"px",h.info=l,h.loc=d,r){const t=`width="${l.width}" height="${l.height}"`;h.header="Perf: layout shift",h.message=`Image\'s size is unknown until it\'s loaded, <a href="https://web.dev/cls/" target="_blank" rel="noopener noreferrer">causing layout shift</a>.</p><p>To solve this problem set the width/height in the img tag:</p><pre>&lt;img <span>${t}</span></pre>`;const o=1===document.querySelectorAll(\'[data-qwik-inspector="\'+d+\'"]\').length;d&&(o?(h.actionName="Auto fix",h.actionFn=async()=>{const t=new URL("/__image_fix",location.href);t.searchParams.set("loc",d),t.searchParams.set("width",l.width),t.searchParams.set("height",l.height),e.srcset||(t.searchParams.set("src",e.currentSrc),t.searchParams.set("currentHref",location.href)),await fetch(t,{method:"POST"})}):(h.actionName="Open in editor",h.actionFn=async()=>{await navigator.clipboard.writeText(t),globalThis.qwikOpenInEditor(d)}))}else g&&(h.header="Perf: properly size image",h.message=`The image is too big, <a href="https://developer.chrome.com/en/docs/lighthouse/performance/uses-responsive-images/" target="_blank" rel="noopener noreferrer">hurting performance</a>, it should be resized to the size it\'s displayed at. The image dimensions are ${l.width} x ${l.height} but it\'s displayed at ${c.width}x${c.height}.</p>`);return}}h&&(h.remove(),t.delete(e))}(e):i&&(i.remove(),t.delete(e))}const c=new ResizeObserver(e=>{if(!n)for(const t of e)s(t.target)}),d=new MutationObserver(e=>{for(const t of e){for(const e of t.addedNodes)"IMG"===e.nodeName?c.observe(e):1===e.nodeType&&e.querySelectorAll("img").forEach(e=>{c.observe(e)});for(const e of t.removedNodes)"IMG"===e.nodeName?(s(e),c.unobserve(e)):1===e.nodeType&&e.querySelectorAll("img").forEach(e=>{s(e),c.unobserve(e)})}});let l,h=0;const u=()=>{setTimeout(()=>{l&&(l.disconnect(),h>.005&&console.error("Detected Layout Shift during page load",h)),d.observe(document.body,{childList:!0,subtree:!0}),document.body.querySelectorAll("img").forEach(e=>{c.observe(e)})},100)};"complete"===document.readyState?u():window.addEventListener("load",u);const g=1===performance?.navigation.type||performance.getEntriesByType("navigation").map(e=>e.type).includes("reload");"undefined"==typeof PerformanceObserver||g||(l=new PerformanceObserver(e=>{e.getEntries().forEach(e=>{if(!e.hadRecentInput){if(e.value>.006)for(const t of e.sources)t.node&&1===t.node.nodeType&&"IMAGE-WARNING"!==t.node.nodeName&&t.node.setAttribute("data-qwik-cls",Number(e.value).toFixed(3));h+=e.value}})}),l.observe({type:"layout-shift",buffered:!0}))};document.addEventListener("load",e)}', Mr = `<style>
  :host {
    position: absolute;
    border: 1px solid red;
    pointer-events: none;
    z-index: 1;
    contain: layout size;
  }

  #icon {
    border: 0;
    margin: 5px;
    color: black;
    max-width: 100%;
    width: 20px;
    background: yellow;
    border-radius: 100%;
    height: 20px;
    padding: 3px;
    pointer-events: all;
    cursor: pointer;
  }

  #icon svg {
    width: 100%;
    height: auto;
    pointer-events: none;
  }

  dialog {
    padding: 0;
    border: 0;
    margin: 0 5px;
    background: #ffffe8;
    color: black;
    width: 250px;
    font-size: 11px;
    position: absolute;
    inset-inline-start: unset;
    inset-inline-end: unset;
    border-radius: 5px;
    pointer-events: all;
    overflow: hidden;
    box-shadow: 0px -2px 20px 0px #0000002e;
    z-index: 10000;
  }

  .top {
    bottom: calc(100% + 5px);
  }
  .bottom {
    top: 40px;
  }
  .right {
    inset-inline-start: 0;
    inset-inline-end: unset;
  }
  .left {
    inset-inline-start: unset;
    inset-inline-end: calc(100% - 40px);
  }

  .content {
    padding: 5px;
  }

  #loc {
    background: #2e3801;
    color: #d2d2d2;
    font-family: monospace;
    padding: 3px 5px;
    pointer-events: all;
    margin: 0;
    border: 0;
    cursor: pointer;
    font-size: 11px;
    width: calc(100% - 24px);
    text-overflow: ellipsis;
    overflow: hidden;
    display: block;
    direction: rtl;
    text-align: right;
  }
  #loc:hover {
    background: #3a4a01;
  }

  pre {
    background: #f1fb8e;
    padding: 5px;
    margin: 5px 0;
    border-radius: 3px;
    user-select: none;
  }

  pre span {
    user-select: all;
  }

  a {
    text-decoration: underline;
  }

  #close {
    border: 0;
    width: 25px;
    height: 25px;
    position: absolute;
    right: 0;
    top: 0;
    background: #ffe14f;
    color: black;
    font-weight: 900;
    padding: 0;
    margin: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    line-height: 1;
    cursor: pointer;
  }
  #close:hover {
    background: #ffeb6f;
  }

  #action-btn {
    border: 2px solid #18ae00;
    padding: 2px 4px;
    background: #50ff50;
    border-radius: 5px;
    color: #0c5500;
    font-weight: 800;
    font-size: 10px;
    cursor: pointer;
  }

  p {
    margin: 5px 0;
  }

  h2 {
    font-weight: 900;
    margin: 10px 0;
  }
</style>
<button id="icon" type="button" aria-label="Open image dev dialog">
  <svg width="32" height="32" viewBox="0 0 24 24">
    <path
      fill="currentColor"
      d="M2.725 21q-.275 0-.5-.138t-.35-.362q-.125-.225-.138-.488t.138-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137H2.725ZM12 18q.425 0 .713-.288T13 17q0-.425-.288-.713T12 16q-.425 0-.713.288T11 17q0 .425.288.713T12 18Zm0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.713T12 10q-.425 0-.713.288T11 11v3q0 .425.288.713T12 15Z"
    />
  </svg>
</button>
<dialog>
  <form method="dialog">
    <button id="close" type="submit" aria-label="Close">X</button>
  </form>
  <button id="loc"></button>
  <div class="content">
    <h2 id="title"></h2>
    <p id="message"></p>
    <p class="action-container"></p>
  </div>
</dialog>
`, qr = `vite-error-overlay{--color-bright: rgba(255, 255, 255, .8);--color-yellow: rgba(255, 246, 85, .8);--qwik-dark-blue: #006ce9;--qwik-light-blue: #3ec2f7;--qwik-light-purple: #ac7ff4;--qwik-dark-purple: #713fc2;--yellow: #fff;--purple: var(--color-bright);--red: var(--qwik-light-blue);--vertical-box-spacing: 15px;--box-padding: 20px;--box-margin: 0 0 var(--vertical-box-spacing) 0;--box-background: rgba(0, 0, 0, .5);--box-border-radius: 8px}vite-error-overlay::part(backdrop){background:#020b1199}vite-error-overlay::part(window){background:transparent;border:none;box-shadow:none;box-sizing:border-box;margin:50px auto;max-width:1200px;padding:var(--box-padding);width:90%}vite-error-overlay::part(message){display:flex;flex-direction:column;font-size:1.6rem;line-height:1.7;margin-bottom:30px}vite-error-overlay::part(plugin){font-size:.8rem;font-weight:100}vite-error-overlay::part(file),vite-error-overlay::part(frame),vite-error-overlay::part(stack),vite-error-overlay::part(tip){background:var(--box-background);border-left:5px solid transparent;border-radius:var(--box-border-radius);margin:var(--box-margin);min-height:50px;padding:var(--box-padding);position:relative}vite-error-overlay::part(file){border-left-color:#19b6f6;color:var(--color-bright)}vite-error-overlay::part(frame){border-left-color:var(--color-yellow);color:var(--color-yellow)}vite-error-overlay::part(stack){border-left-color:#ff5722}vite-error-overlay::part(tip){border-top:none;border-left-color:#ac7ff4}vite-error-overlay::part(file):before,vite-error-overlay::part(frame):before,vite-error-overlay::part(stack):before{border-bottom:1px solid #222;color:var(--color-bright);display:block;margin-bottom:15px;padding-bottom:5px;padding-left:30px;font-size:.8rem}vite-error-overlay::part(file):before{content:"File"}vite-error-overlay::part(frame):before{content:"Frame"}vite-error-overlay::part(stack):before{content:"Stack Trace"}vite-error-overlay::part(file):after,vite-error-overlay::part(frame):after,vite-error-overlay::part(stack):after{content:"";display:block;height:20px;position:absolute;left:var(--box-padding);top:var(--box-padding);width:20px}vite-error-overlay::part(file):after{background-image:url("data:image/svg+xml,%3Csvg width='20px' height='20px' viewBox='0 0 24 24' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3EFile-Generic%3C/title%3E%3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E%3Cg id='File-Generic'%3E%3Crect id='Rectangle' fill-rule='nonzero' x='0' y='0' width='24' height='24'%3E%3C/rect%3E%3Cpath d='M4 5 C4 3.89543 4.89543 3 6 3 L15.1716 3 C15.702 3 16.2107 3.21071 16.5858 3.58579 L19.4142 6.41421 C19.7893 6.78929 20 7.29799 20 7.82843 L20 19 C20 20.1046 19.1046 21 18 21 L6 21 C4.89543 21 4 20.1046 4 19 L4 5 Z' id='Path' stroke='rgba(255,255,255,0.7)' stroke-width='1' stroke-linecap='round'%3E%3C/path%3E%3Cpath d='M15 4 L15 6 C15 7.10457 15.8954 8 17 8 L19 8' id='Path' stroke='rgba(255,255,255,0.7)' stroke-width='1' stroke-linecap='round'%3E%3C/path%3E%3C/g%3E%3C/g%3E%3C/svg%3E")}vite-error-overlay::part(frame):after{background-image:url("data:image/svg+xml,%3Csvg width='20px' height='20px' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M15.6602 2.84952H19.1516C20.2555 2.84952 21.1504 3.74444 21.1504 4.84839V8.3398' stroke='rgba(255,255,255,0.7)' stroke-width='1.69904' stroke-linecap='round'/%3E%3Cpath d='M2.84949 8.33981L2.84949 4.8484C2.84949 3.74446 3.74441 2.84953 4.84836 2.84953L8.33977 2.84953' stroke='rgba(255,255,255,0.7)' stroke-width='1.69904' stroke-linecap='round'/%3E%3Cpath d='M21.1505 15.6602L21.1505 19.1516C21.1505 20.2555 20.2556 21.1505 19.1516 21.1505L15.6602 21.1505' stroke='rgba(255,255,255,0.7)' stroke-width='1.69904' stroke-linecap='round'/%3E%3Cpath d='M8.33984 21.1505L4.84843 21.1505C3.74449 21.1505 2.84956 20.2555 2.84956 19.1516L2.84956 15.6602' stroke='rgba(255,255,255,0.7)' stroke-width='1.69904' stroke-linecap='round'/%3E%3C/svg%3E")}vite-error-overlay::part(stack):after{background-image:url("data:image/svg+xml,%3Csvg width='20px' height='20px' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M14.78 20H9.78C7.98 20 4.58 19.09 4.58 15.64C4.58 12.19 7.98 11.28 9.78 11.28H14.22C14.37 11.28 17.92 11.23 17.92 8.42C17.92 5.61 14.37 5.56 14.22 5.56H9.22C9.02109 5.56 8.83032 5.48098 8.68967 5.34033C8.54902 5.19968 8.47 5.00891 8.47 4.81C8.47 4.61109 8.54902 4.42032 8.68967 4.27967C8.83032 4.13902 9.02109 4.06 9.22 4.06H14.22C16.02 4.06 19.42 4.97 19.42 8.42C19.42 11.87 16.02 12.78 14.22 12.78H9.78C9.63 12.78 6.08 12.83 6.08 15.64C6.08 18.45 9.63 18.5 9.78 18.5H14.78C14.9789 18.5 15.1697 18.579 15.3103 18.7197C15.451 18.8603 15.53 19.0511 15.53 19.25C15.53 19.4489 15.451 19.6397 15.3103 19.7803C15.1697 19.921 14.9789 20 14.78 20Z' fill='rgba(255,255,255,0.7)'/%3E%3Cpath d='M6.44 8.31C5.74314 8.30407 5.06363 8.09202 4.48708 7.70056C3.91054 7.30909 3.46276 6.75573 3.20018 6.11021C2.93759 5.46469 2.87195 4.75589 3.01153 4.07312C3.1511 3.39036 3.48965 2.76418 3.9845 2.2735C4.47935 1.78281 5.10837 1.44958 5.79229 1.31579C6.47622 1.182 7.18444 1.25363 7.82771 1.52167C8.47099 1.78971 9.02054 2.24215 9.40711 2.82199C9.79368 3.40182 9.99998 4.08311 10 4.78C10 5.2461 9.90773 5.70759 9.72846 6.13783C9.54919 6.56808 9.28648 6.95856 8.95551 7.28675C8.62453 7.61494 8.23184 7.87433 7.80009 8.04995C7.36834 8.22558 6.90609 8.31396 6.44 8.31ZM6.44 2.75C6.04444 2.75 5.65776 2.86729 5.32886 3.08706C4.99996 3.30682 4.74362 3.61918 4.59224 3.98463C4.44087 4.35008 4.40126 4.75221 4.47843 5.14018C4.5556 5.52814 4.74609 5.8845 5.02579 6.16421C5.3055 6.44391 5.66186 6.6344 6.04982 6.71157C6.43779 6.78874 6.83992 6.74913 7.20537 6.59776C7.57082 6.44638 7.88318 6.19003 8.10294 5.86114C8.32271 5.53224 8.44 5.14556 8.44 4.75C8.44 4.48735 8.38827 4.22728 8.28776 3.98463C8.18725 3.74198 8.03993 3.5215 7.85422 3.33578C7.6685 3.15007 7.44802 3.00275 7.20537 2.90224C6.96272 2.80173 6.70265 2.75 6.44 2.75Z' fill='rgba(255,255,255,0.7)'/%3E%3Cpath d='M17.56 22.75C16.8614 22.752 16.1779 22.5466 15.5961 22.1599C15.0143 21.7733 14.5603 21.2227 14.2916 20.5778C14.0229 19.933 13.9515 19.2229 14.0866 18.5375C14.2217 17.8521 14.5571 17.2221 15.0504 16.7275C15.5437 16.2328 16.1726 15.8956 16.8577 15.7586C17.5427 15.6215 18.253 15.6909 18.8986 15.9577C19.5442 16.2246 20.0961 16.6771 20.4844 17.2578C20.8727 17.8385 21.08 18.5214 21.08 19.22C21.08 20.1545 20.7095 21.0508 20.0496 21.7125C19.3898 22.3743 18.4945 22.7473 17.56 22.75ZM17.56 17.19C17.1644 17.19 16.7778 17.3073 16.4489 17.5271C16.12 17.7468 15.8636 18.0592 15.7122 18.4246C15.5609 18.7901 15.5213 19.1922 15.5984 19.5802C15.6756 19.9681 15.8661 20.3245 16.1458 20.6042C16.4255 20.8839 16.7819 21.0744 17.1698 21.1516C17.5578 21.2287 17.9599 21.1891 18.3254 21.0377C18.6908 20.8864 19.0032 20.63 19.2229 20.3011C19.4427 19.9722 19.56 19.5856 19.56 19.19C19.56 18.6596 19.3493 18.1508 18.9742 17.7758C18.5991 17.4007 18.0904 17.19 17.56 17.19Z' fill='rgba(255,255,255,0.7)'/%3E%3C/svg%3E")}vite-error-overlay::part(tip):before{content:"Not sure how to solve this? Visit https://qwik.dev or connect with the community on Discord.";display:block;margin-bottom:1em}`, Lr = "#qwik-inspector-overlay{position:fixed;background:#18b6f645;pointer-events:none;box-sizing:border-box;border:2px solid rgba(172,126,244,.46);border-radius:4px;contain:strict;cursor:pointer;z-index:999999}#qwik-inspector-info-popup{position:fixed;bottom:10px;right:10px;font-family:monospace;background:#000000c2;color:#fff;padding:10px 20px;border-radius:8px;box-shadow:0 20px 25px -5px #00000057,0 8px 10px -6px #0000003d;backdrop-filter:blur(4px);-webkit-animation:fadeOut .3s 3s ease-in-out forwards;animation:fadeOut .3s 3s ease-in-out forwards;z-index:999999;contain:layout}#qwik-inspector-info-popup p{margin:0}@-webkit-keyframes fadeOut{0%{opacity:1}to{opacity:0}}@keyframes fadeOut{0%{opacity:1}to{opacity:0;visibility:hidden}}";
async function Or(e, n, s, r) {
  const o = await s.dynamicImport("node:fs"), f = await s.dynamicImport("node:url"), a = ["mjs", "cjs", "js"].map(
    (d) => r.join(n, `entry.preview.${d}`)
  ).find((d) => o.existsSync(d));
  if (!a)
    return Ge(
      e,
      `Unable to find output "${n}/entry.preview" module.

Please ensure "src/entry.preview.tsx" has been built before the "preview" command.`
    );
  try {
    const d = f.pathToFileURL(a).href, t = await s.strictDynamicImport(d);
    let x = null, I = null;
    if (t.default && (typeof t.default == "function" ? x = t.default : typeof t.default == "object" && (x = t.default.router, I = t.default.notFound)), typeof x != "function")
      return Ge(
        e,
        `Entry preview module "${a}" does not export a default middleware function`
      );
    e.use(x), typeof I == "function" && e.use(I);
  } catch (d) {
    return Ge(e, String(d));
  }
}
function Ge(e, n) {
  console.log(`
 ${n}
`), e.use((s, r) => {
    r.writeHead(400, {
      "Content-Type": "text/plain"
    }), r.end(n);
  });
}
const jr = (e, n) => {
  const s = [
    { tag: "style", children: qr, injectTo: "body" },
    { tag: "style", children: Lr, injectTo: "body" },
    { tag: "script", attrs: { type: "module" }, children: Pr, injectTo: "body" },
    { tag: "script", attrs: { type: "module" }, children: Tr, injectTo: "body" }
  ];
  if ((e.devTools?.imageDevTools ?? !0) && s.push(
    {
      tag: "style",
      children: Dr,
      injectTo: "body"
    },
    {
      tag: "script",
      attrs: { type: "module" },
      children: Nr.replace(
        "globalThis.__TEMPLATE__",
        JSON.stringify(Mr)
      ),
      injectTo: "body"
    }
  ), e.devTools?.clickToSource ?? !0) {
    const r = e.devTools.clickToSource ?? [], o = new URL(n + "/", "http://local.local").href;
    s.push({
      tag: "script",
      attrs: { type: "module" },
      children: Cr.replace("globalThis.__HOTKEYS__", JSON.stringify(r)).replace("globalThis.__SRC_DIR__", JSON.stringify(o)),
      injectTo: "body"
    });
  }
  return s;
}, $r = [
  je,
  Ke,
  Qe,
  $e,
  "@builder.io/qwik",
  "@builder.io/qwik/jsx-runtime",
  "@builder.io/qwik/jsx-dev-runtime"
], Ur = [".css", ".scss", ".sass", ".less", ".styl", ".stylus"], Br = [".woff", ".woff2", ".ttf"];
function Hr(e = {}) {
  let n = "serve", s = null, r = null, o = "/", f = null, c, a = null, d = null, t = null;
  const x = e.fileFilter ? (i, g) => Pt.test(i) || e.fileFilter(i, g) : () => !0, I = e.disableFontPreload ?? !1, u = [], w = Ct(e.optimizerOptions), m = /* @__PURE__ */ new Set();
  return [{
    name: "vite-plugin-qwik",
    enforce: "pre",
    api: {
      getOptimizer: () => w.getOptimizer(),
      getOptions: () => w.getOptions(),
      getManifest: () => s,
      getRootDir: () => w.getOptions().rootDir,
      getClientOutDir: () => r,
      getClientPublicOutDir: () => f,
      getAssetsDir: () => c,
      registerBundleGraphAdder: (i) => m.add(i),
      _oldDevSsrServer: () => e.devSsrServer
    },
    async config(i, g) {
      await w.init();
      const h = w.getPath();
      let S;
      i.build?.ssr || g.mode === "ssr" ? S = "ssr" : g.mode === "lib" ? S = "lib" : g.mode === "test" ? S = "test" : S = "client", n = g.command;
      let v;
      g.mode === "production" ? v = "production" : g.mode === "development" ? v = "development" : n === "build" && S === "client" ? v = "production" : v = "development", w.debug(`vite config(), command: ${n}, env.mode: ${g.mode}`), n === "serve" ? e.entryStrategy = { type: "segment" } : S === "ssr" ? e.entryStrategy = { type: "hoist" } : S === "lib" && (e.entryStrategy = { type: "inline" });
      const _ = S === "ssr" ? typeof i.build?.ssr == "string" ? i.build.ssr : e.ssr?.input : void 0, k = S === "client" ? e.client?.input : void 0;
      let C = i.build?.rollupOptions?.input || k || _;
      C && typeof C == "string" && (C = [C]), c = i.build?.assetsDir;
      const $ = S === "client" && !!c && c !== "_astro", L = {
        target: S,
        buildMode: v,
        csr: e.csr,
        debug: e.debug,
        entryStrategy: e.entryStrategy,
        srcDir: e.srcDir,
        rootDir: i.root,
        tsconfigFileNames: e.tsconfigFileNames,
        resolveQwikBuild: !0,
        transformedModuleOutput: e.transformedModuleOutput,
        outDir: i.build?.outDir,
        ssrOutDir: e.ssr?.outDir || i.build?.outDir,
        clientOutDir: e.client?.outDir || // When ssr is true, this is probably an adapter build and not where the client build is
        (i.build?.ssr ? void 0 : i.build?.outDir),
        assetsDir: $ ? c : void 0,
        devTools: e.devTools,
        sourcemap: !!i.build?.sourcemap,
        lint: e.lint,
        experimental: e.experimental,
        input: C,
        manifestInput: e.ssr?.manifestInput,
        manifestInputPath: e.ssr?.manifestInputPath,
        manifestOutput: e.client?.manifestOutput
      }, U = await w.normalizeOptions(L);
      C || (C = U.input), s = U.manifestInput, a = U.srcDir, d = U.rootDir, e.csr || (r = U.clientOutDir, f = i.base ? h.join(r, i.base) : r, t = U.ssrOutDir);
      const H = v === "development", Q = "globalThis.qDev", ie = "globalThis.qTest", W = "globalThis.qInspector", V = "globalThis.qSerialize", X = i?.define?.[Q] ?? H, j = i?.define?.[W] ?? H, Re = i?.define?.[V] ?? H, G = {
        ssr: {
          noExternal: [je, $e, Fe, ne]
        },
        envPrefix: ["VITE_", "PUBLIC_"],
        resolve: {
          dedupe: [...$r],
          conditions: v === "production" && S === "client" ? ["min"] : [],
          alias: {
            "@builder.io/qwik": "@qwik.dev/core",
            "@builder.io/qwik/build": "@qwik.dev/core/build",
            "@builder.io/qwik/server": "@qwik.dev/core/server",
            "@builder.io/qwik/preloader": "@qwik.dev/core/preloader",
            "@builder.io/qwik/jsx-runtime": "@qwik.dev/core/jsx-runtime",
            "@builder.io/qwik/jsx-dev-runtime": "@qwik.dev/core/jsx-dev-runtime",
            "@builder.io/qwik/optimizer": "@qwik.dev/core/optimizer",
            "@builder.io/qwik/loader": "@qwik.dev/core/loader",
            "@builder.io/qwik/backpatch": "@qwik.dev/core/backpatch",
            "@builder.io/qwik/cli": "@qwik.dev/core/cli",
            "@builder.io/qwik/testing": "@qwik.dev/core/testing"
          }
        },
        esbuild: n === "serve" ? !1 : {
          logLevel: "error",
          jsx: "automatic"
        },
        optimizeDeps: {
          exclude: [
            // using optimized deps for qwik libraries will lead to duplicate imports
            // this breaks Qwik because it relies a lot on module scoped symbols
            je,
            $e,
            Fe,
            Ke,
            Qe,
            ne,
            re,
            "@builder.io/qwik"
          ],
          // Enforce scanning our input even when overridden later
          entries: C && (typeof C == "string" ? [C] : typeof C == "object" ? Object.values(C) : C)
        },
        build: {
          modulePreload: !1,
          dynamicImportVarsOptions: {
            exclude: [/./]
          },
          rollupOptions: {
            external: ["node:async_hooks"],
            /**
             * This is a workaround to have predictable chunk hashes between builds. It doesn't seem
             * to impact the build time.
             * https://github.com/QwikDev/qwik/issues/7226#issuecomment-2647122505
             */
            maxParallelFileOps: 1,
            // This will amend the existing input
            input: C
            // temporary fix for rolldown-vite types
          }
        },
        define: {
          [Q]: X,
          [W]: j,
          [V]: Re,
          [ie]: JSON.stringify(process.env.NODE_ENV === "test")
        }
      };
      if (!e.csr) {
        G.build.cssCodeSplit = !1, U.outDir && (G.build.outDir = U.outDir);
        const J = G.build.rollupOptions?.onwarn;
        G.build.rollupOptions = {
          ...G.build.rollupOptions,
          output: await xn(
            w,
            i.build?.rollupOptions?.output,
            $,
            U.outDir
          ),
          preserveEntrySignatures: "exports-only",
          onwarn: (se, De) => {
            se.plugin === "typescript" && se.message.includes("outputToFilesystem") || (J ? J(se, De) : De(se));
          }
        }, U.target === "ssr" ? n === "build" && (G.publicDir = !1, G.build.ssr = !0, i.build?.minify == null && v === "production" && (G.build.minify = !0)) : U.target === "client" || (U.target === "lib" ? (G.build.minify = !1, G.build.rollupOptions.external = [
          je,
          $e,
          Fe,
          Ke,
          Qe,
          ne,
          re
        ]) : G.define = {
          [Q]: !0,
          [ie]: !0,
          [W]: !1
        }), globalThis.qDev = X, globalThis.qTest = !0, globalThis.qInspector = j;
      }
      return G;
    },
    async configResolved(i) {
      if (o = i.base, !(o.startsWith("/") && o.endsWith("/")))
        throw new Error("vite's config.base must begin and end with /");
      !!i.build.sourcemap && e.optimizerOptions?.sourcemap === void 0 && w.setSourceMapSupport(!0), w.normalizeOptions(e);
    },
    async buildStart() {
      u.length = 0;
      const i = this.resolve.bind(this);
      await w.validateSource(i), w.onDiagnostics((g, h, S) => {
        g.forEach((v) => {
          const _ = w.normalizePath(h.sys.path.join(S, v.file));
          v.category === "error" ? this.error(Ue(_, v)) : this.warn(Ue(_, v));
        });
      }), await w.buildStart(this);
    },
    resolveId(i, g, h) {
      const S = x(i, "resolveId");
      return ee(i) || !S ? null : w.resolveId(this, i, g, h);
    },
    load(i, g) {
      const h = x(i, "load");
      return ee(i) || !h ? null : (i = w.normalizePath(i), n === "serve" && i.endsWith(re) ? {
        code: "export const manifest = undefined;"
      } : w.load(this, i, g));
    },
    transform(i, g, h) {
      if (g.includes(".vite/deps/") && i.slice(0, 5e3).includes("qwik") && /import[^\n]*qwik[^\n]*\n/.test(i)) {
        const _ = d && g.startsWith(d) ? g.slice(d.length) : g;
        throw new Error(
          `

==============

 IMPORTANT: This dependency was pre-bundled by Vite, but it seems to use Qwik, which needs processing by the optimizer.

 Please add the original modulename to the "optimizeDeps.exclude" array in your Vite config
   ${_}

==============

`
        );
      }
      const S = x(g, "transform"), v = g.includes("?raw");
      return ee(g) || !S || v ? null : w.transform(this, i, g, h);
    }
  }, {
    name: "vite-plugin-qwik-post",
    enforce: "post",
    generateBundle: {
      order: "post",
      async handler(i, g) {
        const h = w.getOptions();
        if (h.target === "client") {
          for (const [S, v] of Object.entries(g))
            if (v.type === "asset") {
              const _ = o + S;
              if (Ur.some((k) => S.endsWith(k)))
                typeof v.source == "string" && v.source.length < h.inlineStylesUpToBytes ? u.push({
                  tag: "style",
                  location: "head",
                  attributes: {
                    "data-src": _,
                    dangerouslySetInnerHTML: v.source
                  }
                }) : u.push({
                  tag: "link",
                  location: "head",
                  attributes: {
                    rel: "stylesheet",
                    href: _
                  }
                });
              else {
                const k = Br.find((C) => S.endsWith(C));
                k && !I && u.unshift({
                  tag: "link",
                  location: "head",
                  attributes: {
                    rel: "preload",
                    href: _,
                    as: "font",
                    type: `font/${k.slice(1)}`,
                    crossorigin: ""
                  }
                });
              }
            }
          await w.generateManifest(this, g, m, {
            injections: u,
            platform: { vite: "" }
          });
        }
      }
    },
    async writeBundle(i, g) {
      const h = w.getOptions();
      if (h.target === "ssr") {
        const S = w.getSys();
        if (S.env === "node" || S.env === "bun") {
          const v = Object.keys(g), _ = async (k) => {
            try {
              const C = S.path.basename(k), $ = S.path.extname(C);
              if ((C.startsWith("entry.") || C.startsWith("entry_")) && !C.includes("preview") && ($ === ".mjs" || $ === ".cjs")) {
                const U = S.path.basename(C, $), H = `${U}.js`, Q = U + $;
                if (!v.some((W) => S.path.basename(W) === H)) {
                  const W = S.path.dirname(k), V = await S.dynamicImport("node:fs"), X = S.path.join(h.outDir, W);
                  await V.promises.mkdir(X, { recursive: !0 }), await V.promises.writeFile(
                    S.path.join(X, H),
                    `export * from "./${Q}";`
                  );
                }
              }
            } catch (C) {
              console.error("patchModuleFormat", C);
            }
          };
          await Promise.all(v.map(_));
        }
      }
    },
    transformIndexHtml() {
      if (n === "serve")
        return jr(w.getOptions(), a);
    },
    configureServer(i) {
      w.configureServer(i), (e?.devTools?.imageDevTools ?? !0) && i.middlewares.use(kr(w.getSys(), d, a));
    },
    configurePreviewServer(i) {
      return async () => {
        const g = w.getSys(), h = w.getPath();
        await Or(i.middlewares, t, g, h);
      };
    },
    handleHotUpdate(i) {
      w.handleHotUpdate(i), i.modules.length && i.server.hot.send({
        type: "full-reload"
      });
    },
    onLog(i, g) {
      if (g.plugin == "vite-plugin-qwik") {
        const h = Ar[i] || oe.White, S = (g.frame || "").split(`
`).map(
          (v) => (v.match(/^\s*\^\s*$/) ? oe.BrightWhite : oe.BrightBlack) + v
        );
        return console[i](
          `${h}%s
${oe.BrightWhite}%s
%s${oe.RESET}`,
          `[${g.plugin}](${i}): ${g.message}
`,
          `  ${g?.loc?.file}:${g?.loc?.line}:${g?.loc?.column}
`,
          `  ${S.join(`
  `)}
`
        ), !1;
      }
    }
  }, Rr()];
}
async function Rr() {
  let e, n;
  try {
    e = await import("node:fs").then((a) => a.promises), n = await import("node:path");
  } catch {
    return;
  }
  const s = /* @__PURE__ */ new Set();
  let r;
  const o = "@qwik-dev/core", f = "@builder.io/qwik";
  async function c(a, d) {
    for (; d; ) {
      const t = n.join(d, "node_modules", a, "package.json");
      try {
        await e.access(t);
        const I = await e.readFile(t, {
          encoding: "utf-8"
        }), u = JSON.parse(I);
        return !!(u.qwik || u.dependencies?.[o] || u.peerDependencies?.[o] || u.dependencies?.[f] || u.peerDependencies?.[f]);
      } catch {
      }
      const x = n.dirname(d);
      if (x === d)
        break;
      d = x;
    }
    return !1;
  }
  return {
    name: "checkQwikExternals",
    enforce: "pre",
    configResolved: (a) => {
      r = a.root;
    },
    // Attempt to mark the Qwik dependencies as non-optimizeable
    config: {
      order: "post",
      async handler(a) {
        const d = [], t = [a.ssr?.noExternal, a.environments?.ssr?.resolve?.noExternal].flat().filter((I) => typeof I == "string"), x = a.optimizeDeps?.exclude ?? [];
        for (const I of t)
          x.includes(I) || await c(I, a.root || process.cwd()) && d.push(I);
        return { optimizeDeps: { exclude: d } };
      }
    },
    // We check all SSR build lookups for external Qwik deps
    resolveId: {
      order: "pre",
      async handler(a, d, t) {
        if (!t.ssr || /^([./]|node:|[^a-z@])/i.test(a) || s.has(a))
          return;
        const x = (a.startsWith("@") ? a.split("/").slice(0, 2).join("/") : a.split("/")[0]).split("?")[0];
        if (s.has(x))
          return;
        s.add(a), s.add(x);
        let I;
        try {
          I = await this.resolve(x, d, { ...t, skipSelf: !0 });
        } catch {
          return;
        }
        if (I?.external && await c(x, d ? n.dirname(d) : r))
          throw new Error(
            `
==============
${x} is being treated as an external dependency, but it should be included in the server bundle, because it uses Qwik and it needs to be processed by the optimizer.
Please add the package to "ssr.noExternal[]" as well as "optimizeDeps.exclude[]" in the Vite config. 
==============
`
          );
        if (x === a)
          return I;
      }
    }
  };
}
const oe = {
  Yellow: "\x1B[33m",
  Cyan: "\x1B[36m",
  White: "\x1B[37m",
  BrightBlack: "\x1B[90m",
  BrightWhite: "\x1B[97m",
  RESET: "\x1B[0m"
}, Ar = {
  warn: oe.Yellow,
  info: oe.Cyan,
  debug: oe.BrightBlack
}, Wr = void 0;
export {
  Rt as createOptimizer,
  zr as qwikRollup,
  Hr as qwikVite,
  Wr as symbolMapper,
  Fr as versions
};
