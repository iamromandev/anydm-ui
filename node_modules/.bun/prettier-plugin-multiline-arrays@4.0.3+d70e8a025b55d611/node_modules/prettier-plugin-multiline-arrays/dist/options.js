import { getObjectTypedKeys } from '@augment-vir/common';
export const envDebugKey = 'MULTILINE_DEBUG';
export const nextLinePatternComment = 'prettier-multiline-arrays-next-line-pattern:';
// all the text up until the comment trigger
export const untilNextLinePatternCommentRegExp = new RegExp(`.*${nextLinePatternComment}`);
export const setLinePatternComment = 'prettier-multiline-arrays-set-line-pattern:';
// all the text up until the comment trigger
export const untilSetLinePatternCommentRegExp = new RegExp(`.*${setLinePatternComment}`);
export const nextWrapThresholdComment = 'prettier-multiline-arrays-next-threshold:';
// all the text up until the comment trigger
export const untilNextWrapThresholdCommentRegExp = new RegExp(`.*${nextWrapThresholdComment}`);
export const setWrapThresholdComment = 'prettier-multiline-arrays-set-threshold:';
// all the text up until the comment trigger
export const untilSetWrapThresholdCommentRegExp = new RegExp(`.*${setWrapThresholdComment}`);
export const resetComment = 'prettier-multiline-arrays-reset';
export const optionHelp = {
    multilineArraysWrapThreshold: `A number indicating that all arrays should wrap when they have MORE than the specified number. Defaults to -1, indicating that no special wrapping enforcement will take place.\nExample: multilineArraysWrapThreshold: 3\nCan be overridden with a comment starting with ${nextWrapThresholdComment}.\nComment example: // ${nextWrapThresholdComment} 5`,
    multilineArraysLinePattern: `A string with a space separated list of numbers indicating how many elements should be on each line. The pattern repeats if an array is longer than the pattern. Defaults to an empty string. Any invalid numbers causes the whole pattern to revert to the default. This overrides the wrap threshold option.\nExample: elementsPerLinePattern: "3 2 1"\nCan be overridden with a comment starting with ${nextLinePatternComment}.\nComment example: // ${nextLinePatternComment} 3 2 1\nThis option overrides Prettier's default wrapping; multiple elements on one line will not be wrapped even if they don't fit within the column count.`,
};
export const optionPropertyValidators = {
    multilineArraysWrapThreshold(input) {
        return typeof input === 'number' && !isNaN(input);
    },
    multilineArraysLinePattern(input) {
        if (typeof input !== 'string') {
            return false;
        }
        const splitNumbers = input.split(' ');
        return splitNumbers.every((splitNumber) => {
            const numericSplit = Number(splitNumber);
            return !isNaN(numericSplit);
        });
    },
};
export const defaultMultilineArrayOptions = {
    multilineArraysWrapThreshold: -1,
    multilineArraysLinePattern: '',
};
const optionTypeToPrettierOptionTypeMapping = {
    number: 'int',
    boolean: 'boolean',
    string: 'string',
};
export function getPrettierOptionType(input) {
    const mappedType = optionTypeToPrettierOptionTypeMapping[typeof input];
    if (mappedType) {
        return mappedType;
    }
    else {
        throw new Error(`Unmapped option type: '${typeof input}'`);
    }
}
export function fillInOptions(input) {
    if (!input || typeof input !== 'object') {
        return defaultMultilineArrayOptions;
    }
    const newOptions = {
        ...input,
    };
    getObjectTypedKeys(defaultMultilineArrayOptions).forEach((optionsKey) => {
        const inputValue = input[optionsKey];
        const defaultValue = defaultMultilineArrayOptions[optionsKey];
        if (optionPropertyValidators[optionsKey](inputValue)) {
            newOptions[optionsKey] = inputValue;
        }
        else {
            newOptions[optionsKey] =
                defaultValue;
        }
    });
    return newOptions;
}
