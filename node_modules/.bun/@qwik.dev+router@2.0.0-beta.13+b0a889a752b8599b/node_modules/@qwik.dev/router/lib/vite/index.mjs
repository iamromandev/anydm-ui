var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import { mergeConfig, loadEnv } from "vite";
import fs, { existsSync } from "node:fs";
import path, { join, dirname, basename, resolve, isAbsolute, extname } from "node:path";
import { g as getExtension, r as removeExtension, i as isIndexModule, a as isErrorName, b as isLayoutModule, c as isEntryName, d as isMenuFileName, e as isServiceWorkerName, f as isPageModuleExt, h as isModuleExt, j as isMarkdownExt, k as isSameOriginUrl, l as normalizePath, m as getPathnameFromDirPath, o as getMenuPathname, p as createFileId, q as parseRouteIndexName, s as isPluginModule, t as addError, u as addWarning, v as isPageExt } from "../chunks/fs.mjs";
import { marked } from "marked";
import { SourceMapGenerator } from "source-map";
import { visit } from "unist-util-visit";
import { parse } from "yaml";
import Slugger from "github-slugger";
import { valueToEstree } from "estree-util-value-to-estree";
import { headingRank } from "hast-util-heading-rank";
import { toString } from "hast-util-to-string";
import { refractor } from "refractor";
import tsxLang from "refractor/lang/tsx.js";
import { optimize } from "svgo";
import { p as parseId, f as formatError } from "../chunks/format-error.mjs";
function extendConfig(baseConfigExport, serverConfigExport) {
  return async (env) => {
    let resolvedBase = await baseConfigExport;
    if (typeof resolvedBase === "function") {
      resolvedBase = await resolvedBase(env);
    }
    let resolvedServer = await serverConfigExport;
    if (typeof resolvedServer === "function") {
      resolvedServer = await resolvedServer(env);
    }
    return mergeConfig(resolvedBase, resolvedServer);
  };
}
const swRegister = 'export default""';
function getSourceFile(fileName) {
  const ext = getExtension(fileName);
  const extlessName = removeExtension(fileName);
  const isPageModule = isPageModuleExt(ext);
  const isModule = isModuleExt(ext);
  const isMarkdown = isMarkdownExt(ext);
  let type = null;
  if ((isIndexModule(extlessName) || isErrorName(extlessName)) && (isPageModule || isModule || isMarkdown)) {
    type = "route";
  } else if (isLayoutModule(extlessName) && (isPageModule || isModule)) {
    type = "layout";
  } else if (isEntryName(extlessName) && isModule) {
    type = "entry";
  } else if (isMenuFileName(fileName)) {
    type = "menu";
  } else if (isModule && isServiceWorkerName(extlessName)) {
    type = "service-worker";
  }
  if (type !== null) {
    const sourceFileName = {
      type,
      extlessName,
      ext
    };
    return sourceFileName;
  }
  return null;
}
function getMarkdownRelativeUrl(opts, containingFilePath, url, checkFileExists) {
  if (typeof url !== "string" || !isSameOriginUrl(url)) {
    return url;
  }
  const querySplit = url.split("?");
  const hashSplit = url.split("#");
  const strippedUrl = url.split("?")[0].split("#")[0];
  const extension = getExtension(strippedUrl);
  if (isMarkdownExt(extension)) {
    const isAbsolute2 = strippedUrl.startsWith("/");
    const parts = normalizePath(strippedUrl).split("/").filter((p) => p.length > 0);
    const filePath = isAbsolute2 ? join(opts.routesDir, ...parts) : join(dirname(containingFilePath), ...parts);
    if (checkFileExists && !existsSync(filePath)) {
      console.warn(
        `
The link "${url}", found within "${containingFilePath}" does not have a matching source file.
`
      );
    }
    const fileName = basename(filePath);
    const sourceFileName = getSourceFile(fileName);
    if (sourceFileName) {
      const mdDirPath = dirname(filePath);
      let pathname = getPathnameFromDirPath(opts, mdDirPath);
      if (querySplit.length > 1) {
        pathname += "?" + querySplit[1];
      } else if (hashSplit.length > 1) {
        pathname += "#" + hashSplit[1];
      }
      return pathname;
    }
  } else if (extension === "") {
    if (url.endsWith("/")) {
      if (globalThis.__NO_TRAILING_SLASH__) {
        url = url.slice(0, -1);
      }
    } else if (!globalThis.__NO_TRAILING_SLASH__) {
      url += "/";
    }
  }
  return url;
}
function createMenu(opts, filePath) {
  const menu = {
    pathname: getMenuPathname(opts, filePath),
    filePath
  };
  return menu;
}
function resolveMenu(opts, menuSourceFile) {
  return createMenu(opts, menuSourceFile.filePath);
}
async function transformMenu(opts, filePath, content) {
  const parsedMenu = parseMenu(opts, filePath, content);
  const id = createFileId(opts.routesDir, filePath);
  const code = `const ${id} = ${JSON.stringify(parsedMenu, null, 2)};`;
  return `${code} export default ${id}`;
}
function parseMenu(opts, filePath, content, checkFileExists = true) {
  const tokens = marked.lexer(content, {});
  let currentDepth = 0;
  const stack = [];
  for (const t of tokens) {
    if (t.type === "heading") {
      const diff = currentDepth - t.depth;
      if (diff >= 0) {
        stack.length -= diff + 1;
      }
      if (diff < -1) {
        throw new Error(
          `Menu hierarchy skipped a level, went from <h${"#".repeat(
            currentDepth
          )}> to <h${"#".repeat(t.depth)}>, in menu: ${filePath}`
        );
      }
      currentDepth = t.depth;
      const parentNode = stack[stack.length - 1];
      for (const h2Token of t.tokens || []) {
        const lastNode = {
          text: ""
        };
        if (h2Token.type === "text") {
          lastNode.text = h2Token.text;
        } else if (h2Token.type === "link") {
          lastNode.text = h2Token.text;
          lastNode.href = getMarkdownRelativeUrl(opts, filePath, h2Token.href, checkFileExists);
        } else {
          throw new Error(
            `Headings can only be a text or link. Received "${h2Token.type}", value "${h2Token.raw}", in menu: ${filePath}`
          );
        }
        if (parentNode) {
          parentNode.items = parentNode.items || [];
          parentNode.items.push(lastNode);
        }
        stack.push(lastNode);
      }
    } else if (t.type === "list") {
      const parentNode = stack[stack.length - 1];
      parentNode.items = parentNode.items || [];
      for (const li of t.items) {
        if (li.type === "list_item") {
          for (const liToken of li.tokens) {
            if (liToken.type === "text") {
              for (const liItem of liToken.tokens) {
                if (liItem.type === "text") {
                  parentNode.items.push({ text: liItem.text });
                } else if (liItem.type === "link") {
                  parentNode.items.push({
                    text: liItem.text,
                    href: getMarkdownRelativeUrl(opts, filePath, liItem.href, checkFileExists)
                  });
                } else {
                  throw new Error(
                    `List items can only be a text or link. Received "${liItem.type}", value "${liItem.raw}", in menu: ${filePath}`
                  );
                }
              }
            } else if (liToken.type === "link") {
              parentNode.items.push({
                text: liToken.text,
                href: getMarkdownRelativeUrl(opts, filePath, liToken.href, checkFileExists)
              });
            } else {
              throw new Error(
                `List items can only be a text or link. Received "${liToken.type}", value "${liToken.raw}", in menu: ${filePath}`
              );
            }
          }
        } else {
          throw new Error(
            `Only list items can be used in lists. Received "${li.type}", value "${li.raw}", in menu: ${filePath}`
          );
        }
      }
    } else if (t.type === "space") {
      continue;
    } else {
      throw new Error(
        `Menu has a "${t.type}" with the value "${t.raw}". However, only headings and lists can be used in the menu: ${filePath}`
      );
    }
  }
  if (stack.length === 0) {
    throw new Error(`Menu must start with an h1 in the index: ${filePath}`);
  }
  return stack[0];
}
function parseRoutePathname(basePathname, pathname) {
  if (pathname === basePathname) {
    return {
      pattern: new RegExp("^" + pathname.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + "$"),
      routeName: pathname,
      paramNames: [],
      segments: [[{ content: "", dynamic: false, rest: false }]]
    };
  }
  pathname = pathname.slice(1);
  const segments = pathname.split("/");
  const paramNames = [];
  const pattern = new RegExp(
    `^${segments.filter((segment) => segment.length > 0).map((s) => {
      const segment = decodeURI(s);
      const catchAll = /^\[\.\.\.(\w+)?\]$/.exec(segment);
      if (catchAll) {
        paramNames.push(catchAll[1]);
        return "(?:/(.*))?";
      }
      return "/" + segment.split(DYNAMIC_SEGMENT).map((content, i) => {
        if (i % 2) {
          const rg = PARAM_PATTERN.exec(content);
          if (rg) {
            const [, rest, name] = rg;
            paramNames.push(name);
            return rest ? "(.*?)" : "([^/]+?)";
          }
        }
        return encodeURI(content).normalize().replace(/%5[Bb]/g, "[").replace(/%5[Dd]/g, "]").replace(/#/g, "%23").replace(/\?/g, "%3F").replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }).join("");
    }).join("")}/?$`
    // always match with and without a trailing slash
  );
  return {
    pattern,
    routeName: pathname,
    paramNames,
    segments: segments.map((segment) => {
      const parts = [];
      segment.split(/\[(.+?)\]/).map((content, i) => {
        if (content) {
          const dynamic = !!(i % 2);
          parts.push({
            content,
            dynamic,
            rest: dynamic && content.startsWith("...")
          });
        }
      });
      return parts;
    })
  };
}
const PARAM_PATTERN = /^(\.\.\.)?(\w+)?$/;
const DYNAMIC_SEGMENT = /\[(.+?)\]/;
function routeSortCompare(a, b) {
  const maxSegments = Math.max(a.segments.length, b.segments.length);
  for (let i = 0; i < maxSegments; i += 1) {
    const sa = a.segments[i];
    const sb = b.segments[i];
    if (!sa) {
      return a.pathname.includes("[...") ? 1 : -1;
    }
    if (!sb) {
      return b.pathname.includes("[...") ? -1 : 1;
    }
    const maxParts = Math.max(sa.length, sb.length);
    for (let i2 = 0; i2 < maxParts; i2 += 1) {
      const pa = sa[i2];
      const pb = sb[i2];
      if (pa === void 0) {
        return pb.dynamic ? -1 : 1;
      }
      if (pb === void 0) {
        return pa.dynamic ? 1 : -1;
      }
      if (pa.dynamic !== pb.dynamic) {
        return pa.dynamic ? 1 : -1;
      }
      if (pa.dynamic) {
        if (pa.rest !== pb.rest) {
          return pa.rest ? 1 : -1;
        }
      }
    }
  }
  if (a.pathname === b.pathname) {
    return a.ext > b.ext ? -1 : 1;
  }
  return a.pathname < b.pathname ? -1 : 1;
}
function resolveSourceFiles(opts, sourceFiles) {
  const layouts = sourceFiles.filter((s) => s.type === "layout").map((s) => resolveLayout(opts, s)).sort((a, b) => {
    return a.id < b.id ? -1 : 1;
  });
  const routes = sourceFiles.filter((s) => s.type === "route").map((s) => resolveRoute(opts, layouts, s)).sort(routeSortCompare);
  const entries = sourceFiles.filter((s) => s.type === "entry").map((s) => resolveEntry(opts, s)).sort((a, b) => {
    return a.chunkFileName < b.chunkFileName ? -1 : 1;
  });
  const serviceWorkers = sourceFiles.filter((s) => s.type === "service-worker").map((p) => resolveServiceWorkerEntry(opts, p)).sort((a, b) => {
    return a.chunkFileName < b.chunkFileName ? -1 : 1;
  });
  const menus = sourceFiles.filter((s) => s.type === "menu").map((p) => resolveMenu(opts, p)).sort((a, b) => {
    return a.pathname < b.pathname ? -1 : 1;
  });
  let inc = 0;
  const ids = /* @__PURE__ */ new Set();
  const uniqueIds = (b) => {
    for (const r of b) {
      let id = r.id;
      while (ids.has(id)) {
        id = `${r.id}_${inc++}`;
      }
      r.id = id;
      ids.add(id);
    }
  };
  uniqueIds(layouts);
  uniqueIds(routes);
  uniqueIds(entries);
  uniqueIds(serviceWorkers);
  return { layouts, routes, entries, menus, serviceWorkers };
}
function resolveLayout(opts, layoutSourceFile) {
  let extlessName = layoutSourceFile.extlessName;
  const filePath = layoutSourceFile.filePath;
  const dirPath = layoutSourceFile.dirPath;
  let layoutName;
  let layoutType;
  if (extlessName.endsWith(LAYOUT_TOP_SUFFIX)) {
    layoutType = "top";
    extlessName = extlessName.slice(0, extlessName.length - 1);
  } else {
    layoutType = "nested";
  }
  if (extlessName.startsWith(LAYOUT_NAMED_PREFIX)) {
    layoutName = extlessName.slice(LAYOUT_NAMED_PREFIX.length);
  } else {
    layoutName = "";
  }
  const layout = {
    id: createFileId(opts.routesDir, filePath),
    filePath,
    dirPath,
    layoutType,
    layoutName
  };
  return layout;
}
const LAYOUT_ID = "layout";
const LAYOUT_NAMED_PREFIX = LAYOUT_ID + "-";
const LAYOUT_TOP_SUFFIX = "!";
function resolveRoute(opts, appLayouts, sourceFile) {
  const filePath = sourceFile.filePath;
  const layouts = [];
  const routesDir = opts.routesDir;
  const { layoutName, layoutStop } = parseRouteIndexName(sourceFile.extlessName);
  let pathname = getPathnameFromDirPath(opts, sourceFile.dirPath);
  if (sourceFile.extlessName === "404") {
    pathname += sourceFile.extlessName + ".html";
  }
  if (!layoutStop) {
    let currentDir = normalizePath(dirname(filePath));
    let hasFoundNamedLayout = false;
    const hasNamedLayout = layoutName !== "";
    for (let i = 0; i < 20; i++) {
      let layout = void 0;
      if (hasNamedLayout && !hasFoundNamedLayout) {
        layout = appLayouts.find((l) => l.dirPath === currentDir && l.layoutName === layoutName);
        if (layout) {
          hasFoundNamedLayout = true;
        }
      } else {
        layout = appLayouts.find((l) => l.dirPath === currentDir && l.layoutName === "");
      }
      if (layout) {
        layouts.push(layout);
        if (layout.layoutType === "top") {
          break;
        }
      }
      if (currentDir === routesDir) {
        break;
      }
      currentDir = normalizePath(dirname(currentDir));
    }
  }
  const buildRoute = {
    id: createFileId(opts.routesDir, filePath, "Route"),
    filePath,
    pathname,
    layouts: layouts.reverse(),
    ext: sourceFile.ext,
    ...parseRoutePathname(opts.basePathname, pathname)
  };
  return buildRoute;
}
function resolveEntry(opts, sourceFile) {
  const pathname = getPathnameFromDirPath(opts, sourceFile.dirPath);
  const chunkFileName = pathname.slice(opts.basePathname.length);
  const buildEntry = {
    id: createFileId(opts.routesDir, sourceFile.filePath, "Route"),
    filePath: sourceFile.filePath,
    chunkFileName,
    ...parseRoutePathname(opts.basePathname, pathname)
  };
  return buildEntry;
}
function resolveServiceWorkerEntry(opts, sourceFile) {
  const dirPathname = getPathnameFromDirPath(opts, sourceFile.dirPath);
  const pathname = dirPathname + sourceFile.extlessName + ".js";
  const chunkFileName = pathname.slice(opts.basePathname.length);
  const buildEntry = {
    id: createFileId(opts.routesDir, sourceFile.filePath, "ServiceWorker"),
    filePath: sourceFile.filePath,
    chunkFileName,
    ...parseRoutePathname(opts.basePathname, pathname)
  };
  return buildEntry;
}
async function walkRoutes(routesDir) {
  const sourceFiles = [];
  await walkRouteDir(sourceFiles, normalizePath(routesDir), basename(routesDir));
  return sourceFiles;
}
async function walkRouteDir(sourceFiles, dirPath, dirName) {
  const dirItemNames = await fs.promises.readdir(dirPath);
  await Promise.all(
    dirItemNames.map(async (itemName) => {
      const itemPath = normalizePath(join(dirPath, itemName));
      const stat = await fs.promises.stat(itemPath);
      if (stat.isDirectory()) {
        await walkRouteDir(sourceFiles, itemPath, itemName);
      } else {
        const sourceFileName = getSourceFile(itemName);
        if (sourceFileName !== null) {
          sourceFiles.push({
            ...sourceFileName,
            fileName: itemName,
            filePath: itemPath,
            dirName,
            dirPath
          });
        }
      }
    })
  );
}
async function walkServerPlugins(opts) {
  const dirPath = opts.serverPluginsDir;
  const dirItemNames = await fs.promises.readdir(dirPath);
  const sourceFiles = [];
  await Promise.all(
    dirItemNames.map(async (itemName) => {
      const itemPath = normalizePath(join(dirPath, itemName));
      const ext = getExtension(itemName);
      const extlessName = removeExtension(itemName);
      if ((isModuleExt(ext) || isPageModuleExt(ext)) && isPluginModule(extlessName)) {
        sourceFiles.push({
          id: createFileId(opts.serverPluginsDir, itemPath, "Plugin"),
          filePath: itemPath,
          ext
        });
      }
    })
  );
  return sourceFiles;
}
async function parseRoutesDir(ctx) {
  try {
    await updateRoutingContext(ctx);
    validateBuild(ctx);
  } catch (e) {
    addError(ctx, e);
  }
  for (const d of ctx.diagnostics) {
    if (d.type === "error") {
      throw new Error(d.message);
    } else {
      console.warn(d.message);
    }
  }
}
function updateRoutingContext(ctx) {
  ctx.activeBuild || (ctx.activeBuild = _updateRoutingContext(ctx).finally(() => {
    ctx.activeBuild = null;
  }));
  return ctx.activeBuild;
}
async function _updateRoutingContext(ctx) {
  const serverPlugins = await walkServerPlugins(ctx.opts);
  const sourceFiles = await walkRoutes(ctx.opts.routesDir);
  const resolved = resolveSourceFiles(ctx.opts, sourceFiles);
  resolved.routes = rewriteRoutes(ctx, resolved.routes);
  ctx.serverPlugins = serverPlugins;
  ctx.layouts = resolved.layouts;
  ctx.routes = resolved.routes;
  ctx.entries = resolved.entries;
  ctx.serviceWorkers = resolved.serviceWorkers;
  ctx.menus = resolved.menus;
}
function rewriteRoutes(ctx, routes) {
  if (!ctx.opts.rewriteRoutes) {
    return routes;
  }
  const translatedRoutes = [];
  let segmentsToTranslate = ctx.opts.rewriteRoutes.flatMap((rewriteConfig) => {
    return Object.keys(rewriteConfig.paths || {});
  });
  segmentsToTranslate = Array.from(new Set(segmentsToTranslate));
  routes.forEach((route) => {
    translatedRoutes.push(route);
    const currentRouteSegments = route.pathname.split("/");
    const foundSegmentToTranslate = currentRouteSegments.some(
      (segment) => segmentsToTranslate.includes(segment)
    );
    if (foundSegmentToTranslate || route.pathname === "/") {
      ctx.opts.rewriteRoutes.forEach((config, configIndex) => {
        if (route.pathname === "/" && !config.prefix) {
          return;
        }
        const routeToPush = translateRoute(route, config, configIndex);
        if (!translatedRoutes.some(
          (item) => item.pathname === routeToPush.pathname && item.routeName === routeToPush.routeName
        )) {
          translatedRoutes.push(routeToPush);
        }
      });
    }
  });
  return translatedRoutes.sort(routeSortCompare);
}
function translateRoute(route, config, configIndex) {
  const replacePath = (part) => (config.paths || {})[part] ?? part;
  const pathnamePrefix = config.prefix ? "/" + config.prefix : "";
  const routeNamePrefix = config.prefix ? config.prefix + "/" : "";
  const idSuffix = config.prefix?.toUpperCase().replace(/-/g, "");
  const patternInfix = config.prefix ? [config.prefix] : [];
  const splittedPathName = route.pathname.split("/");
  const translatedPathParts = splittedPathName.map(replacePath);
  const splittedRouteName = route.routeName.split("/");
  const translatedRouteParts = splittedRouteName.map(replacePath);
  const splittedPattern = route.pattern.toString().split("\\/");
  const [translatedPatternFirst, ...translatedPatternOthers] = splittedPattern.map(replacePath);
  const translatedPatternParts = [
    translatedPatternFirst,
    ...patternInfix,
    ...translatedPatternOthers
  ];
  const translatedPatternString = translatedPatternParts.join("\\/");
  const translatedRegExp = translatedPatternString.substring(
    1,
    route.pathname === "/" ? translatedPatternString.length - 1 : translatedPatternString.length - 2
  );
  const translatedSegments = route.segments.map(
    (segment) => segment.map((item) => ({ ...item, content: replacePath(item.content) }))
  );
  if (config.prefix) {
    translatedSegments.splice(0, 0, [
      {
        content: config.prefix,
        dynamic: false,
        rest: false
      }
    ]);
  }
  const translatedPath = translatedPathParts.join("/");
  const translatedRoute = translatedRouteParts.join("/");
  const routeToPush = {
    ...route,
    id: route.id + (idSuffix || configIndex),
    pathname: pathnamePrefix + translatedPath,
    routeName: routeNamePrefix + (translatedRoute !== "/" ? translatedRoute : ""),
    pattern: new RegExp(translatedRegExp),
    segments: translatedSegments
  };
  return routeToPush;
}
function validateBuild(ctx) {
  const pathnames = Array.from(new Set(ctx.routes.map((r) => r.pathname))).sort();
  for (const pathname of pathnames) {
    const foundRoutes = ctx.routes.filter((r) => r.pathname === pathname);
    if (foundRoutes.length > 1) {
      addError(
        ctx,
        `More than one route has been found for pathname "${pathname}". Please narrow it down to only one of these:
${foundRoutes.map((r) => `  - ${r.filePath}`).join("\n")}`
      );
    }
  }
  ctx.layouts.filter((l) => l.layoutType === "top").forEach((l) => {
    addWarning(
      ctx,
      `The "top" layout feature, which is used by "${l.filePath}" has been deprecated and will be removed from future versions. In most cases the "group" layout feature can be used in its place: https://qwik.dev/docs/advanced/routing/`
    );
  });
}
function createBuildContext(rootDir, viteBasePath, userOpts, target, dynamicImports) {
  const ctx = {
    rootDir: normalizePath(rootDir),
    opts: normalizeOptions(rootDir, viteBasePath, userOpts),
    routes: [],
    serverPlugins: [],
    layouts: [],
    entries: [],
    serviceWorkers: [],
    menus: [],
    diagnostics: [],
    frontmatter: /* @__PURE__ */ new Map(),
    target: target || "ssr",
    dynamicImports: target === "client" || !!dynamicImports,
    isDirty: true,
    activeBuild: null
  };
  return ctx;
}
function resetBuildContext(ctx) {
  if (ctx) {
    ctx.routes.length = 0;
    ctx.layouts.length = 0;
    ctx.entries.length = 0;
    ctx.menus.length = 0;
    ctx.diagnostics.length = 0;
    ctx.frontmatter.clear();
    ctx.isDirty = true;
  }
}
function normalizeOptions(rootDir, viteBasePath, userOpts) {
  if (!(viteBasePath.startsWith("/") && viteBasePath.endsWith("/"))) {
    console.error(
      `warning: vite's config.base must begin and end with /. This will be an error in v2. If you have a valid use case, please open an issue.`
    );
    if (!viteBasePath.endsWith("/")) {
      viteBasePath += "/";
    }
  }
  const opts = { ...userOpts };
  if (typeof opts.routesDir !== "string") {
    opts.routesDir = resolve(rootDir, "src", "routes");
  } else if (!isAbsolute(opts.routesDir)) {
    opts.routesDir = resolve(rootDir, opts.routesDir);
  }
  opts.routesDir = normalizePath(opts.routesDir);
  if (typeof opts.serverPluginsDir !== "string") {
    opts.serverPluginsDir = opts.routesDir;
  } else if (!isAbsolute(opts.serverPluginsDir)) {
    opts.serverPluginsDir = resolve(rootDir, opts.serverPluginsDir);
  }
  opts.serverPluginsDir = normalizePath(opts.serverPluginsDir);
  if (typeof opts.baseUrl === "string") {
    opts.basePathname = opts.baseUrl;
  }
  if (typeof opts.basePathname !== "string") {
    opts.basePathname = viteBasePath;
  }
  if (!opts.basePathname.endsWith("/")) {
    console.error(
      `Warning: qwik-router plugin basePathname must end with /. This will be an error in v2`
    );
    opts.basePathname += "/";
  }
  const url = new URL(opts.basePathname, "https://qwik.dev/");
  opts.basePathname = url.pathname;
  opts.mdx = opts.mdx || {};
  opts.platform = opts.platform || {};
  return opts;
}
function parseFrontmatter(ctx) {
  return (mdast, vfile) => {
    const attrs = {};
    visit(mdast, "yaml", (node) => {
      const parsedAttrs = parseFrontmatterAttrs(node.value);
      for (const k in parsedAttrs) {
        attrs[k] = parsedAttrs[k];
      }
    });
    if (Object.keys(attrs).length > 0) {
      ctx.frontmatter.set(normalizePath(vfile.path), attrs);
    }
  };
}
function parseFrontmatterAttrs(yaml) {
  if (typeof yaml === "string") {
    yaml = yaml.trim();
    if (yaml !== "") {
      return parse(yaml);
    }
  }
  return null;
}
const metaNames = {
  author: true,
  creator: true,
  "color-scheme": true,
  description: true,
  generator: true,
  keywords: true,
  publisher: true,
  referrer: true,
  robots: true,
  "theme-color": true,
  viewport: true
};
function frontmatterAttrsToDocumentHead(attrs) {
  if (attrs != null && typeof attrs === "object") {
    const attrNames = Object.keys(attrs);
    if (attrNames.length > 0) {
      const head = {
        title: "",
        meta: [],
        styles: [],
        links: [],
        scripts: [],
        frontmatter: {}
      };
      for (const attrName of attrNames) {
        const attrValue = attrs[attrName];
        if (attrValue != null) {
          if (attrName === "title") {
            head.title = attrValue.toString();
            head.title = head.title.replace(/\\@/g, "@");
          } else if (attrName === "og" || attrName === "opengraph") {
            if (typeof attrValue === "object") {
              for (const opengraph of Array.isArray(attrValue) ? attrValue : [attrValue]) {
                if (opengraph != null && typeof opengraph === "object" && !Array.isArray(opengraph)) {
                  for (const [property, content] of Object.entries(opengraph)) {
                    if ((property === "title" || property === "description") && content === true) {
                      if (attrNames.includes(property)) {
                        head.meta.push({
                          property: `og:${property}`,
                          content: attrs[property]?.toString()
                        });
                      }
                    } else {
                      head.meta.push({
                        property: `og:${property}`,
                        content: content?.toString()
                      });
                    }
                  }
                }
              }
            }
          } else if (metaNames[attrName]) {
            head.meta.push({
              name: attrName,
              content: attrValue.toString()
            });
          } else {
            head.frontmatter[attrName] = attrValue;
          }
        }
      }
      return head;
    }
  }
  return null;
}
function rehypeSlug() {
  return (ast) => {
    const mdast = ast;
    const slugs = new Slugger();
    visit(mdast, "element", (node) => {
      const level = headingRank(node);
      if (level && node.properties) {
        const text = toString(node);
        if (!hasProperty(node, "id")) {
          node.properties.id = slugs.slug(text);
        }
      }
    });
  };
}
function rehypePage(ctx) {
  return (ast, vfile) => {
    const mdast = ast;
    const sourcePath = normalizePath(vfile.path);
    updateContentLinks(mdast, ctx.opts, sourcePath);
    exportFrontmatter(ctx, mdast, sourcePath);
    exportContentHead(ctx, mdast, sourcePath);
    exportContentHeadings(mdast);
  };
}
function renameClassname() {
  return (ast) => {
    const mdast = ast;
    visit(mdast, "element", (node) => {
      if (node.properties) {
        if (node.properties.className) {
          node.properties.class = node.properties.className;
          node.properties.className = void 0;
        }
      }
    });
  };
}
function wrapTableWithDiv() {
  return (ast) => {
    const mdast = ast;
    visit(mdast, "element", (node) => {
      if (node.tagName === "table" && !node.done) {
        const table = { ...node };
        table.done = true;
        node.tagName = "div";
        node.properties = { className: "table-wrapper" };
        node.children = [table];
      }
    });
  };
}
function updateContentLinks(mdast, opts, sourcePath) {
  visit(mdast, "element", (node) => {
    const tagName = node && node.type === "element" && node.tagName.toLowerCase();
    if (tagName === "a") {
      const href = (node.properties && node.properties.href || "").trim();
      if (isSameOriginUrl(href)) {
        const ext = getExtension(href);
        if (isMarkdownExt(ext)) {
          node.properties.href = getMarkdownRelativeUrl(
            opts,
            sourcePath,
            node.properties.href,
            true
          );
        }
      }
    }
  });
}
function exportFrontmatter(ctx, mdast, sourcePath) {
  const attrs = ctx.frontmatter.get(sourcePath);
  createExport(mdast, "frontmatter", attrs);
}
function exportContentHead(ctx, mdast, sourcePath) {
  const attrs = ctx.frontmatter.get(sourcePath);
  const head = frontmatterAttrsToDocumentHead(attrs);
  if (head) {
    createExport(mdast, "head", head);
  }
}
function exportContentHeadings(mdast) {
  const headings = [];
  visit(mdast, "element", (node) => {
    const level = headingRank(node);
    if (level && node.properties) {
      if (hasProperty(node, "id")) {
        const text = toString(node);
        headings.push({
          text,
          id: node.properties.id,
          level
        });
      }
    }
  });
  if (headings.length > 0) {
    createExport(mdast, "headings", headings);
  }
}
function createExport(mdast, identifierName, val) {
  const mdxjsEsm = {
    type: "mdxjsEsm",
    value: "",
    data: {
      estree: {
        type: "Program",
        sourceType: "module",
        body: [
          {
            type: "ExportNamedDeclaration",
            source: null,
            specifiers: [],
            attributes: [],
            declaration: {
              type: "VariableDeclaration",
              kind: "const",
              declarations: [
                {
                  type: "VariableDeclarator",
                  id: { type: "Identifier", name: identifierName },
                  init: valueToEstree(val)
                }
              ]
            }
          }
        ]
      }
    }
  };
  mdast.children.unshift(mdxjsEsm);
}
const own = {}.hasOwnProperty;
function hasProperty(node, propName) {
  const value = node && typeof node === "object" && node.type === "element" && node.properties && own.call(node.properties, propName) && node.properties[propName];
  return value != null && value !== false;
}
function rehypeSyntaxHighlight() {
  refractor.register(tsxLang);
  return async (ast) => {
    visit(ast, "element", (node, _index, parent) => {
      if (!parent || parent.tagName !== "pre" || node.tagName !== "code" || !Array.isArray(node.properties.className)) {
        return;
      }
      for (let i = 0; i < node.properties.className.length; i++) {
        const className = node.properties.className[i];
        const lang = getLanguage(className);
        if (lang && refractor.registered(lang)) {
          node.properties.className[i] = "language-" + lang;
          syntaxHighlight(node, lang);
          return;
        }
      }
    });
  };
}
function syntaxHighlight(node, lang) {
  const code = toString(node);
  const result = refractor.highlight(code, lang);
  if (result && Array.isArray(node.children)) {
    node.children = result.children;
  }
}
function getLanguage(className) {
  if (typeof className === "string") {
    className = className.toLowerCase();
    if (className.startsWith("language-")) {
      return className.slice(9);
    }
  }
  return null;
}
async function createMdxTransformer(ctx) {
  const { compile } = await import("@mdx-js/mdx");
  const { default: remarkFrontmatter } = await import("remark-frontmatter");
  const { default: remarkGfm } = await import("remark-gfm");
  const { default: rehypeAutolinkHeadings } = await import("rehype-autolink-headings");
  const { VFile } = await import("vfile");
  const userMdxOpts = ctx.opts.mdx;
  const userRemarkPlugins = userMdxOpts.remarkPlugins || [];
  const userRehypePlugins = userMdxOpts.rehypePlugins || [];
  const coreMdxPlugins = ctx.opts.mdxPlugins;
  const coreRemarkPlugins = [];
  if (typeof coreMdxPlugins?.remarkGfm === "undefined" || coreMdxPlugins.remarkGfm) {
    coreRemarkPlugins.push(remarkGfm);
  }
  const coreRehypePlugins = [];
  if (typeof coreMdxPlugins?.rehypeSyntaxHighlight === "undefined" || coreMdxPlugins.rehypeSyntaxHighlight) {
    coreRehypePlugins.push(rehypeSyntaxHighlight);
  }
  if (typeof coreMdxPlugins?.rehypeAutolinkHeadings === "undefined" || coreMdxPlugins.rehypeAutolinkHeadings) {
    coreRehypePlugins.push(rehypeAutolinkHeadings);
  }
  const options = {
    SourceMapGenerator,
    jsxImportSource: "@qwik.dev/core",
    ...userMdxOpts,
    elementAttributeNameCase: "html",
    remarkPlugins: [
      ...userRemarkPlugins,
      ...coreRemarkPlugins,
      remarkFrontmatter,
      [parseFrontmatter, ctx]
    ],
    rehypePlugins: [
      rehypeSlug,
      ...userRehypePlugins,
      ...coreRehypePlugins,
      [rehypePage, ctx],
      renameClassname,
      wrapTableWithDiv
    ]
  };
  return async function(code, id) {
    const ext = getExtension(id);
    if ([".mdx", ".md", ".markdown"].includes(ext)) {
      const file = new VFile({ value: code, path: id });
      const compiled = await compile(file, options);
      const output = String(compiled.value);
      const addImport = `import { jsx } from '@qwik.dev/core';
`;
      const newDefault = `
function _missingMdxReference(id, component, place) {
  throw new Error("${id}: Expected " + (component ? "component" : "object") + " \`" + id + "\` to be defined: you likely forgot to import, pass, or provide it." + (place ? "\\nItâ€™s referenced in your code at \`" + place + "\`" : ""));
}
const WrappedMdxContent = () => {
  const content = _createMdxContent({});
  return typeof MDXLayout === 'function' ? jsx(MDXLayout, {children: content}) : content;
};
export default WrappedMdxContent;
`;
      const exportIndex = output.lastIndexOf("export default ");
      if (exportIndex === -1) {
        throw new Error("Could not find default export in mdx output");
      }
      const wrappedOutput = addImport + output.slice(0, exportIndex) + newDefault;
      return {
        code: wrappedOutput,
        map: compiled.map
      };
    }
  };
}
function createEntries(ctx, c) {
  const isClient = ctx.target === "client";
  const entries = [...ctx.entries, ...ctx.serviceWorkers];
  if (isClient && entries.length > 0) {
    c.push(`
/** Qwik Router Entries Entry */`);
    c.push(`export const e = () => import("@qwik-router-entries");
`);
  }
}
function generateQwikRouterEntries(ctx) {
  const c = [];
  const entries = [...ctx.entries, ...ctx.serviceWorkers];
  c.push(`
/** Qwik Router Entries (${entries.length}) */`);
  for (let i = 0; i < entries.length; i++) {
    const entry = entries[i];
    c.push(`export const ${entry.id} = () => import(${JSON.stringify(entry.filePath)});`);
  }
  return c.join("\n") + "\n";
}
function getImportPath(importPath) {
  const lowerCasePath = importPath.toLowerCase();
  if (lowerCasePath.endsWith(".tsx") || lowerCasePath.endsWith(".jsx")) {
    return importPath.slice(0, importPath.length - 4);
  }
  if (lowerCasePath.endsWith(".ts")) {
    return importPath.slice(0, importPath.length - 3);
  }
  return importPath;
}
function createMenus(ctx, c, esmImports, isSSR) {
  c.push(`
/** Qwik Router Menus (${ctx.menus.length}) */`);
  c.push(`export const menus = [`);
  const dynamicImports = !isSSR;
  const routesDir = ctx.opts.routesDir;
  for (const m of ctx.menus) {
    const importPath = JSON.stringify(getImportPath(m.filePath));
    if (dynamicImports) {
      c.push(`  [${JSON.stringify(m.pathname)}, ()=>import(${importPath})],`);
    } else {
      const id = createFileId(routesDir, m.filePath);
      esmImports.push(`import * as ${id} from ${importPath};`);
      c.push(`  [${JSON.stringify(m.pathname)}, ()=>${id}],`);
    }
  }
  c.push(`];`);
}
function createRoutes(ctx, qwikPlugin, c, esmImports, isSSR) {
  const includeEndpoints = isSSR;
  const dynamicImports = ctx.dynamicImports;
  if (ctx.layouts.length > 0) {
    c.push(`
/** Qwik Router Layouts (${ctx.layouts.length}) */`);
    for (const layout of ctx.layouts) {
      const importPath = JSON.stringify(getImportPath(layout.filePath));
      if (dynamicImports) {
        c.push(`const ${layout.id} = ()=>import(${importPath});`);
      } else {
        esmImports.push(`import * as ${layout.id}_ from ${importPath};`);
        c.push(`const ${layout.id} = ()=>${layout.id}_;`);
      }
    }
  }
  c.push(`
/** Qwik Router Routes (${ctx.routes.length}) */`);
  c.push(`export const routes = [`);
  for (const route of ctx.routes) {
    const layouts = [];
    if (isPageExt(route.ext)) {
      for (const layout of route.layouts) {
        layouts.push(layout.id);
      }
      const importPath = getImportPath(route.filePath);
      if (dynamicImports) {
        layouts.push(`()=>import(${JSON.stringify(importPath)})`);
      } else {
        esmImports.push(`import * as ${route.id} from ${JSON.stringify(importPath)};`);
        layouts.push(`()=>${route.id}`);
      }
    } else if (includeEndpoints && isModuleExt(route.ext)) {
      const importPath = getImportPath(route.filePath);
      esmImports.push(`import * as ${route.id} from ${JSON.stringify(importPath)};`);
      for (const layout of route.layouts) {
        layouts.push(layout.id);
      }
      layouts.push(`()=>${route.id}`);
    }
    if (layouts.length > 0) {
      c.push(`  ${createRouteData(qwikPlugin, route, layouts, isSSR)},`);
    }
  }
  c.push(`];`);
}
function createRouteData(qwikPlugin, r, layouts, isSsr) {
  const routeName = JSON.stringify(r.routeName);
  const moduleLayouts = `[ ${layouts.join(", ")} ]`;
  if (isSsr) {
    const originalPathname = JSON.stringify(r.pathname);
    const clientBundleNames = JSON.stringify(getClientRouteBundleNames(qwikPlugin, r));
    return `[ ${routeName}, ${moduleLayouts}, ${originalPathname}, ${clientBundleNames} ]`;
  }
  return `[ ${routeName}, ${moduleLayouts} ]`;
}
function getClientRouteBundleNames(qwikPlugin, r) {
  const bundlesNames = [];
  const manifest = qwikPlugin.api.getManifest();
  if (manifest) {
    const manifestBundleNames = Object.keys(manifest.bundles);
    const addRouteFile = (filePath) => {
      filePath = removeExtension(filePath);
      for (const bundleName of manifestBundleNames) {
        const bundle = manifest.bundles[bundleName];
        if (bundle.origins) {
          for (const bundleOrigin of bundle.origins) {
            const originPath = removeExtension(bundleOrigin);
            if (filePath.endsWith(originPath)) {
              if (!bundlesNames.includes(bundleName)) {
                bundlesNames.push(bundleName);
              }
            }
          }
        }
      }
    };
    for (const layout of r.layouts) {
      addRouteFile(layout.filePath);
    }
    addRouteFile(r.filePath);
  }
  return bundlesNames;
}
function createServerPlugins(ctx, _qwikPlugin, c, esmImports, isSSR) {
  c.push(`
/** Qwik Router ServerPlugins (${ctx.serverPlugins.length}) */`);
  c.push(`export const serverPlugins = [`);
  if (isSSR) {
    for (const file of ctx.serverPlugins) {
      const importPath = JSON.stringify(getImportPath(file.filePath));
      esmImports.push(`import * as ${file.id} from ${importPath};`);
    }
    for (const file of ctx.serverPlugins) {
      c.push(`  ${file.id},`);
    }
  }
  c.push(`];`);
}
function generateQwikRouterConfig(ctx, qwikPlugin, isSSR) {
  const esmImports = [];
  const c = [];
  c.push(`
/** Qwik Router Config */`);
  c.push(`
import { isDev } from '@qwik.dev/core/build';`);
  createServerPlugins(ctx, qwikPlugin, c, esmImports, isSSR);
  createRoutes(ctx, qwikPlugin, c, esmImports, isSSR);
  createMenus(ctx, c, esmImports, isSSR);
  createEntries(ctx, c);
  c.push(`export const trailingSlash = ${JSON.stringify(!globalThis.__NO_TRAILING_SLASH__)};`);
  c.push(`export const basePathname = ${JSON.stringify(ctx.opts.basePathname)};`);
  c.push(`export const cacheModules = !isDev;`);
  c.push(
    `export default { routes, serverPlugins, menus, trailingSlash, basePathname, cacheModules };`
  );
  return esmImports.join("\n") + c.join("\n");
}
function generateServiceWorkerRegister(ctx, swRegister2) {
  let swReg;
  let swUrl = "/service-worker.js";
  if (ctx.serviceWorkers.length === 0) {
    swReg = SW_UNREGISTER;
  } else {
    swReg = swRegister2;
    const sw = ctx.serviceWorkers.sort(
      (a, b) => a.chunkFileName.length < b.chunkFileName.length ? -1 : 1
    )[0];
    swUrl = ctx.opts.basePathname + sw.chunkFileName;
  }
  swReg = swReg.replace("__url", swUrl);
  return `export default ${JSON.stringify(swReg)};`;
}
const SW_UNREGISTER = `
"serviceWorker"in navigator&&navigator.serviceWorker.getRegistrations().then(r=>{for(const e of r){const c='__url'.split("/").pop();e.active?.scriptURL.endsWith(c||"service-worker.js")&&e.unregister().catch(console.error)}}),"caches"in window&&caches.keys().then(r=>{const e=r.find(c=>c.startsWith("QwikBuild"));e&&caches.delete(e).catch(console.error)}).catch(console.error)
`;
function getRouteImports(routes, manifest) {
  const result = {};
  routes.forEach((route) => {
    const routePath = removeExtension(route.filePath);
    const layoutPaths = route.layouts ? route.layouts.map((layout) => removeExtension(layout.filePath)) : [];
    const routeAndLayoutPaths = [routePath, ...layoutPaths];
    const bundles = [];
    for (const [bundleName, bundle] of Object.entries(manifest.bundles)) {
      if (isBundlePartOfRoute(bundle, routeAndLayoutPaths)) {
        bundles.push(bundleName);
      }
    }
    if (bundles.length > 0) {
      result[route.routeName] = { dynamicImports: bundles };
    }
  });
  for (const bundleName of Object.keys(manifest.bundles)) {
    const bundle = manifest.bundles[bundleName];
    if (bundle.origins?.some((s) => s.endsWith(QWIK_ROUTER_CONFIG_ID))) {
      result[bundleName] = {
        ...bundle,
        dynamicImports: bundle.dynamicImports?.filter(
          (d) => manifest.bundles[d].origins?.some((s) => s.endsWith("menu.md"))
        )
      };
      break;
    }
  }
  return result;
}
function isBundlePartOfRoute(bundle, routeAndLayoutPaths) {
  if (!bundle.origins) {
    return false;
  }
  for (const bundleOrigin of bundle.origins) {
    const originPath = removeExtension(bundleOrigin);
    return routeAndLayoutPaths.some((path2) => path2.endsWith(originPath));
  }
}
function imagePlugin(userOpts) {
  const supportedExtensions = [".jpg", ".jpeg", ".png", ".webp", ".gif", ".avif", ".tiff"];
  return [
    import("vite-imagetools").then(
      ({ imagetools }) => imagetools({
        exclude: [],
        extendOutputFormats(builtins) {
          const jsx = () => (metadatas) => {
            const srcSet = metadatas.map((meta) => `${meta.src} ${meta.width}w`).join(", ");
            let largestImage;
            let largestImageSize = 0;
            for (let i = 0; i < metadatas.length; i++) {
              const m = metadatas[i];
              if (m.width > largestImageSize) {
                largestImage = m;
                largestImageSize = m.width;
              }
            }
            return {
              srcSet,
              width: largestImage === null || largestImage === void 0 ? void 0 : largestImage.width,
              height: largestImage === null || largestImage === void 0 ? void 0 : largestImage.height
            };
          };
          return {
            ...builtins,
            jsx
          };
        },
        defaultDirectives: (url) => {
          if (url.searchParams.has("jsx")) {
            const { jsx: _, ...params } = Object.fromEntries(url.searchParams.entries());
            return new URLSearchParams({
              format: "webp",
              quality: "75",
              w: "200;400;600;800;1200",
              withoutEnlargement: "",
              ...userOpts?.imageOptimization?.jsxDirectives,
              ...params,
              as: "jsx"
            });
          }
          return new URLSearchParams();
        }
      })
    ).catch((err) => {
      console.error("Error loading vite-imagetools, image imports are not available", err);
      return null;
    }),
    {
      name: "qwik-router-image-jsx",
      load: {
        order: "pre",
        handler: async (id) => {
          const { params, pathId } = parseId(id);
          const extension = path.extname(pathId).toLowerCase();
          if (extension === ".svg" && params.has("jsx")) {
            const code = await fs.promises.readFile(pathId, "utf-8");
            return {
              code,
              moduleSideEffects: false
            };
          }
        }
      },
      transform(code, id) {
        id = id.toLowerCase();
        const { params, pathId } = parseId(id);
        if (params.has("jsx")) {
          const extension = path.extname(pathId).toLowerCase();
          if (supportedExtensions.includes(extension)) {
            if (!code.includes("srcSet")) {
              this.error(`Image '${id}' could not be optimized to JSX`);
            }
            const index = code.indexOf("export default");
            return {
              code: code.slice(0, index) + `
  import { _jsxSorted } from '@qwik.dev/core';
  const PROPS = {srcSet, width, height};
  export default function (props, key, _, dev) {
    return _jsxSorted('img', {...{decoding: 'async', loading: 'lazy'}, ...props}, PROPS, undefined, 3, key, dev);
  }`,
              map: null
            };
          } else if (extension === ".svg") {
            const { svgAttributes } = optimizeSvg({ code, path: pathId }, userOpts);
            return {
              code: `
  import { _jsxSorted } from '@qwik.dev/core';
  const PROPS = ${JSON.stringify(svgAttributes)};
  export default function (props, key, _, dev) {
    return _jsxSorted('svg', props, PROPS, undefined, 3, key, dev);
  }`,
              map: null
            };
          }
        }
        return null;
      }
    }
  ];
}
function optimizeSvg({ code, path: path2 }, userOpts) {
  const svgAttributes = {};
  const prefixIdsConfiguration = userOpts?.imageOptimization?.svgo?.prefixIds;
  const maybePrefixIdsPlugin = prefixIdsConfiguration !== false ? [{ name: "prefixIds", params: prefixIdsConfiguration }] : [];
  const userPlugins = userOpts?.imageOptimization?.svgo?.plugins?.filter((plugin) => {
    if (plugin === "preset-default" || typeof plugin === "object" && plugin.name === "preset-default") {
      console.warn(
        `You are trying to use the preset-default SVGO plugin. This plugin is already included by default, you can customize it through the defaultPresetOverrides option.`
      );
      return false;
    }
    if (plugin === "prefixIds" || typeof plugin === "object" && plugin.name === "prefixIds") {
      console.warn(
        `You are trying to use the preset-default SVGO plugin. This plugin is already included by default, you can customize it through the prefixIds option.`
      );
      return false;
    }
    return true;
  }) || [];
  const data = optimize(code, {
    floatPrecision: userOpts?.imageOptimization?.svgo?.floatPrecision,
    multipass: userOpts?.imageOptimization?.svgo?.multipass,
    path: path2,
    plugins: [
      {
        name: "preset-default",
        params: {
          overrides: {
            removeViewBox: false,
            ...userOpts?.imageOptimization?.svgo?.defaultPresetOverrides
          }
        }
      },
      {
        name: "customPluginName",
        fn: () => {
          return {
            element: {
              exit: (node) => {
                if (node.name === "svg") {
                  node.name = "g";
                  Object.assign(svgAttributes, node.attributes);
                  node.attributes = {};
                }
              }
            }
          };
        }
      },
      ...maybePrefixIdsPlugin,
      ...userPlugins
    ]
  }).data;
  svgAttributes.dangerouslySetInnerHTML = data.slice(3, -4);
  return {
    data,
    svgAttributes
  };
}
async function validatePlugin(opts) {
  if (typeof opts.routesDir !== "string") {
    throw new Error(`qwikRouter plugin "routesDir" option missing`);
  }
  if (!isAbsolute(opts.routesDir)) {
    throw new Error(
      `qwikRouter plugin "routesDir" option must be an absolute path: ${opts.routesDir}`
    );
  }
  try {
    const s = await fs.promises.stat(opts.routesDir);
    if (!s.isDirectory()) {
      throw new Error(
        `qwikRouter plugin "routesDir" option must be a directory: ${opts.routesDir}`
      );
    }
  } catch (e) {
    throw new Error(`qwikRouter plugin "routesDir" not found: ${e}`);
  }
}
class HtmlTransformPatcher {
  constructor(req, res, server) {
    __publicField(this, "state", 0);
    __publicField(this, "buffer", "");
    __publicField(this, "headInnerIndex", -1);
    __publicField(this, "bodyInnerIndex", -1);
    __publicField(this, "isHtmlResponse", false);
    __publicField(this, "bodyPostContent", "");
    __publicField(this, "response");
    __publicField(this, "server");
    __publicField(this, "request");
    __publicField(this, "origWrite");
    __publicField(this, "origEnd");
    __publicField(this, "origSetHeader");
    __publicField(this, "origWriteHead");
    __publicField(this, "processingPromise", null);
    this.request = req;
    this.response = res;
    this.server = server;
    this.origWrite = this.response.write.bind(this.response);
    this.origEnd = this.response.end.bind(this.response);
    this.origSetHeader = this.response.setHeader.bind(this.response);
    this.origWriteHead = this.response.writeHead.bind(this.response);
    this.response.setHeader = (name, value) => {
      if (name.toLowerCase() === "content-type") {
        const contentType = String(value).toLowerCase();
        this.isHtmlResponse = contentType.includes("text/html");
      }
      return this.origSetHeader(name, value);
    };
    this.response.writeHead = (statusCode, statusMessage, headers) => {
      if (typeof statusMessage === "object" && statusMessage !== null) {
        headers = statusMessage;
        statusMessage = void 0;
      }
      if (headers && typeof headers === "object") {
        for (const [key, value] of Object.entries(headers)) {
          if (key.toLowerCase() === "content-type") {
            const contentType = String(value).toLowerCase();
            this.isHtmlResponse = contentType.includes("text/html");
          }
        }
      }
      return this.origWriteHead(statusCode, statusMessage, headers);
    };
    this.response.write = this.handleWrite.bind(this);
    this.response.end = (chunk, encoding, callback) => {
      this.handleEnd(chunk, encoding, callback).catch((error) => {
        console.error("Error in handleEnd:", error);
        this.transitionToPassthrough();
        this.origEnd(chunk, encoding, callback);
      });
      return this.response;
    };
  }
  handleWrite(chunk, encoding, callback) {
    if (!this.isHtmlResponse || this.state === 3) {
      return this.origWrite(chunk, encoding, callback);
    }
    if (typeof encoding === "function") {
      callback = encoding;
      encoding = void 0;
    }
    let data;
    if (chunk instanceof ArrayBuffer || chunk instanceof Uint8Array || chunk instanceof Uint16Array || chunk instanceof Uint32Array) {
      data = new TextDecoder().decode(chunk);
    } else if (Buffer.isBuffer(chunk)) {
      data = chunk.toString(encoding || "utf8");
    } else if (typeof chunk === "string") {
      data = chunk;
    } else {
      data = chunk?.toString() || "";
    }
    this.buffer += data;
    switch (this.state) {
      case 0:
        if (this.headInnerIndex === -1) {
          const headMatch = this.buffer.match(/<head[^>]*>/i);
          if (headMatch) {
            const headOuterIndex = this.buffer.indexOf(headMatch[0]);
            this.headInnerIndex = headOuterIndex + headMatch[0].length;
          }
        }
        if (this.headInnerIndex !== -1) {
          const bodyMatch = this.buffer.slice(this.headInnerIndex).match(/<body[^>]*>/i);
          if (bodyMatch) {
            this.state = 1;
            const bodyOuterIndex = this.buffer.indexOf(bodyMatch[0]);
            this.bodyInnerIndex = bodyOuterIndex + bodyMatch[0].length;
            this.processingPromise = this.processHead();
          }
        }
        break;
      case 1:
        break;
      case 2:
        this.handleStreamingBodyState();
        break;
      default:
        throw new Error(`Invalid state: ${this.state}`);
    }
    callback?.();
    return true;
  }
  async processHead() {
    try {
      const fakeHtml = "<html><head>[FAKE_HEAD]</head><body>[FAKE_BODY]</body></html>";
      const transformedHtml = await this.server.transformIndexHtml(
        this.request.url || "/",
        fakeHtml
      );
      const fakeHeadIndex = transformedHtml.indexOf("[FAKE_HEAD]");
      const fakeHeadCloseIndex = transformedHtml.indexOf("</head>", fakeHeadIndex);
      if (fakeHeadIndex === -1 || fakeHeadCloseIndex === -1) {
        throw new Error("Transformed HTML does not contain [FAKE_HEAD]...</head>");
      }
      const headPreContent = transformedHtml.slice("<html><head>".length, fakeHeadIndex).trim();
      const headPostContent = transformedHtml.slice(
        fakeHeadIndex + "[FAKE_HEAD]".length,
        fakeHeadCloseIndex
      );
      const fakeBodyStartIndex = transformedHtml.indexOf("<body>", fakeHeadCloseIndex);
      const fakeBodyIndex = transformedHtml.indexOf("[FAKE_BODY]", fakeBodyStartIndex);
      const fakeBodyEndIndex = transformedHtml.indexOf("</body>", fakeBodyIndex);
      if (fakeBodyIndex === -1 || fakeBodyEndIndex === -1) {
        throw new Error("Transformed HTML does not contain [FAKE_BODY]...</body>");
      }
      const bodyPreContent = transformedHtml.slice(
        fakeBodyStartIndex + "<body>".length,
        fakeBodyIndex
      );
      this.bodyPostContent = transformedHtml.slice(
        fakeBodyIndex + "[FAKE_BODY]".length,
        fakeBodyEndIndex
      );
      const headCloseIndex = this.buffer.indexOf("</head>", this.headInnerIndex);
      if (headCloseIndex === -1) {
        throw new Error("Buffered HTML does not contain </head>");
      }
      this.buffer = this.buffer.slice(0, this.headInnerIndex) + headPreContent + this.buffer.slice(this.headInnerIndex, headCloseIndex) + headPostContent + this.buffer.slice(headCloseIndex, this.bodyInnerIndex) + bodyPreContent + this.buffer.slice(this.bodyInnerIndex);
      if (this.bodyPostContent.length > 0) {
        this.state = 2;
        this.handleStreamingBodyState();
        return;
      }
      this.transitionToPassthrough();
      return;
    } catch (error) {
      console.error("Error transforming HTML:", error);
      this.transitionToPassthrough();
      return;
    }
  }
  handleStreamingBodyState() {
    const bodyEndMatch = this.buffer.match(/<\/body>/i);
    if (bodyEndMatch) {
      const bodyEndPos = this.buffer.indexOf(bodyEndMatch[0]);
      this.buffer = this.buffer.slice(0, bodyEndPos) + this.bodyPostContent + this.buffer.slice(bodyEndPos);
      this.transitionToPassthrough();
      return;
    }
    this.flushBuffer(6);
  }
  transitionToPassthrough() {
    this.state = 3;
    this.flushBuffer();
  }
  flushBuffer(keep = 0) {
    if (this.buffer.length > keep) {
      if (keep > 0) {
        this.origWrite(this.buffer.slice(0, -keep));
        this.buffer = this.buffer.slice(-keep);
      } else {
        this.origWrite(this.buffer);
        this.buffer = "";
      }
    }
  }
  async handleEnd(chunk, encoding, callback) {
    if (typeof encoding === "function") {
      callback = encoding;
      encoding = void 0;
    }
    if (chunk) {
      this.handleWrite(chunk, encoding);
    }
    await this.processingPromise;
    this.flushBuffer();
    this.origEnd(callback);
  }
}
function wrapResponseForHtmlTransform(request, response, server) {
  new HtmlTransformPatcher(request, response, server);
  return response;
}
const makeRouterDevMiddleware = (server, ctx) => async (req, res, next) => {
  const mod = await server.ssrLoadModule("src/entry.ssr");
  if (!mod.default) {
    console.error("No default export found in src/entry.ssr");
    return next();
  }
  const renderer = mod.default;
  if (ctx.isDirty) {
    await updateRoutingContext(ctx);
    ctx.isDirty = false;
  }
  const entry = ctx.entries.find((e) => req.url === `${server.config.base}${e.chunkFileName}`);
  if (entry) {
    const entryContents = await server.transformRequest(
      `/@fs${entry.filePath.startsWith("/") ? "" : "/"}${entry.filePath}`
    );
    if (entryContents) {
      res.setHeader("Content-Type", "text/javascript");
      res.end(entryContents.code);
    } else {
      next();
    }
    return;
  }
  if (req.url === `${server.config.base}service-worker.js`) {
    res.setHeader("Content-Type", "text/javascript");
    res.end(
      `/* Qwik Router Dev Service Worker */self.addEventListener('install', () => self.skipWaiting());self.addEventListener('activate', (ev) => ev.waitUntil(self.clients.claim()));`
    );
    return;
  }
  globalThis.__qwik = void 0;
  const { createQwikRouter } = await server.ssrLoadModule(
    "@qwik.dev/router/middleware/node"
  );
  try {
    const render = (async (opts) => {
      return await renderer(opts);
    });
    const { router, staticFile, notFound } = createQwikRouter({ render });
    const wrappedRes = wrapResponseForHtmlTransform(req, res, server);
    staticFile(req, wrappedRes, () => {
      router(req, wrappedRes, () => {
        notFound(req, wrappedRes, next);
      });
    });
  } catch (e) {
    if (e instanceof Error) {
      server.ssrFixStacktrace(e);
      formatError(e);
    }
    next(e);
    return;
  }
};
const CSS_EXTENSIONS = [".css", ".scss", ".sass", ".less", ".styl", ".stylus"];
const JS_EXTENSIONS = /\.[mc]?[tj]sx?$/;
const isCssPath = (url) => CSS_EXTENSIONS.some((ext) => url.endsWith(ext));
const getCssUrls = (server) => {
  const cssModules = /* @__PURE__ */ new Set();
  const cssImportedByCSS = /* @__PURE__ */ new Set();
  Array.from(server.moduleGraph.fileToModulesMap.entries()).forEach(([_name, modules]) => {
    modules.forEach((mod) => {
      const [pathId, query] = mod.url.split("?");
      if (!query && isCssPath(pathId)) {
        const isEntryCSS = mod.importers.size === 0;
        const hasCSSImporter = Array.from(mod.importers).some((importer) => {
          const importerPath = importer.url || importer.file;
          const isCSS = importerPath && isCssPath(importerPath);
          if (isCSS && mod.url) {
            cssImportedByCSS.add(mod.url);
          }
          return isCSS;
        });
        const hasJSImporter = Array.from(mod.importers).some((importer) => {
          const importerPath = importer.url || importer.file;
          return importerPath && JS_EXTENSIONS.test(importerPath);
        });
        if ((isEntryCSS || hasJSImporter) && !hasCSSImporter && !cssImportedByCSS.has(mod.url)) {
          cssModules.add(mod);
        }
      }
    });
  });
  return [...cssModules].map(
    ({ url, lastHMRTimestamp }) => `${url}${lastHMRTimestamp ? `?t=${lastHMRTimestamp}` : ""}`
  );
};
const getRouterIndexTags = (server) => {
  const cssUrls = getCssUrls(server);
  return cssUrls.map((url) => ({
    tag: "link",
    attrs: { rel: "stylesheet", href: url }
  }));
};
const QWIK_ROUTER_CONFIG_ID = "@qwik-router-config";
const QWIK_ROUTER_ENTRIES_ID = "@qwik-router-entries";
const QWIK_ROUTER = "@qwik.dev/router";
const QWIK_ROUTER_SW_REGISTER = "@qwik-router-sw-register";
function qwikCity(userOpts) {
  return qwikRouter(userOpts);
}
function qwikRouter(userOpts) {
  return [qwikRouterPlugin(userOpts), ...imagePlugin(userOpts)];
}
function qwikRouterPlugin(userOpts) {
  let ctx = null;
  let mdxTransform = null;
  let rootDir = null;
  let qwikPlugin;
  let ssrFormat = "esm";
  let outDir = null;
  let viteCommand;
  let devServer = null;
  let devSsrServer = userOpts?.devSsrServer;
  const routesDir = userOpts?.routesDir ?? "src/routes";
  const serverPluginsDir = userOpts?.serverPluginsDir ?? routesDir;
  const api = {
    getBasePathname: () => ctx?.opts.basePathname ?? "/",
    getRoutes: () => {
      return ctx?.routes.slice() ?? [];
    },
    getServiceWorkers: () => {
      return ctx?.serviceWorkers.slice() ?? [];
    }
  };
  const plugin = {
    name: "vite-plugin-qwik-router",
    enforce: "pre",
    api,
    async config(_viteConfig, viteEnv) {
      viteCommand = viteEnv.command;
      const updatedViteConfig = {
        define: {
          "globalThis.__DEFAULT_LOADERS_SERIALIZATION_STRATEGY__": JSON.stringify(
            userOpts?.defaultLoadersSerializationStrategy || "never"
          ),
          "globalThis.__NO_TRAILING_SLASH__": JSON.stringify(userOpts?.trailingSlash === false)
        },
        appType: "custom",
        resolve: {
          dedupe: [QWIK_ROUTER, "@builder.io/qwik-city"],
          alias: [
            { find: "@builder.io/qwik-city", replacement: "@qwik.dev/router" },
            { find: /^@builder\.io\/qwik-city\/(.*)/, replacement: "@qwik.dev/router/$1" },
            { find: "@qwik-city-plan", replacement: QWIK_ROUTER_CONFIG_ID },
            { find: "@qwik-city-entries", replacement: QWIK_ROUTER_ENTRIES_ID },
            { find: "@qwik-city-sw-register", replacement: QWIK_ROUTER_SW_REGISTER }
          ]
        },
        optimizeDeps: {
          // Let Vite find all app deps, these are not part of the static imports from `src/root`
          entries: [
            `${routesDir}/**/index*`,
            `${routesDir}/**/layout*`,
            `${serverPluginsDir}/plugin@*`
          ],
          // These need processing by the optimizer during dev
          exclude: [
            QWIK_ROUTER,
            QWIK_ROUTER_CONFIG_ID,
            QWIK_ROUTER_ENTRIES_ID,
            QWIK_ROUTER_SW_REGISTER
          ]
        },
        ssr: {
          external: ["node:async_hooks"],
          noExternal: [
            QWIK_ROUTER,
            QWIK_ROUTER_CONFIG_ID,
            QWIK_ROUTER_ENTRIES_ID,
            QWIK_ROUTER_SW_REGISTER,
            // We've had reports of bundling issues with zod
            "zod"
          ]
        },
        server: {
          watch: {
            // needed for recursive watching of index and layout files in the src/routes directory
            disableGlobbing: false
          }
        }
      };
      return updatedViteConfig;
    },
    async configResolved(config) {
      Object.assign(process.env, loadEnv(config.mode, process.cwd(), ""));
      rootDir = resolve(config.root);
      const target = config.build?.ssr || config.mode === "ssr" ? "ssr" : "client";
      ctx = createBuildContext(
        rootDir,
        config.base,
        userOpts,
        target,
        !userOpts?.staticImportRoutes
      );
      await validatePlugin(ctx.opts);
      mdxTransform = await createMdxTransformer(ctx);
      qwikPlugin = config.plugins.find(
        (p) => p.name === "vite-plugin-qwik"
      );
      if (!qwikPlugin) {
        throw new Error("Missing vite-plugin-qwik");
      }
      if (typeof devSsrServer !== "boolean") {
        devSsrServer = qwikPlugin.api._oldDevSsrServer();
      }
      qwikPlugin.api.registerBundleGraphAdder?.((manifest) => {
        return getRouteImports(ctx.routes, manifest);
      });
      if (config.ssr?.format === "cjs") {
        ssrFormat = "cjs";
      }
      outDir = config.build?.outDir;
    },
    async configureServer(server) {
      devServer = server;
      const toWatch = resolve(
        rootDir,
        "src/routes/**/{index,layout,entry,service-worker}{.,@,-}*"
      );
      server.watcher.add(toWatch);
      await new Promise((resolve2) => setTimeout(resolve2, 1e3));
      server.watcher.on("change", (path2) => {
        if (!/\/(index[.@]|layout[.-]|entry\.|service-worker\.)[^/]*$/.test(path2)) {
          return;
        }
        ctx.isDirty = true;
        const graph = server.environments?.ssr?.moduleGraph;
        if (graph) {
          const mod = graph.getModuleById("@qwik-router-config");
          if (mod) {
            graph.invalidateModule(mod);
          }
        }
      });
      if (userOpts?.devSsrServer !== false) {
        return () => {
          server.middlewares.use(makeRouterDevMiddleware(server, ctx));
        };
      }
    },
    transformIndexHtml() {
      if (viteCommand !== "serve") {
        return;
      }
      return getRouterIndexTags(devServer);
    },
    buildStart() {
      resetBuildContext(ctx);
    },
    resolveId(id) {
      if (id === QWIK_ROUTER_CONFIG_ID || id === QWIK_ROUTER_ENTRIES_ID) {
        return {
          id,
          // user entries added in the routes, like src/routes/service-worker.ts
          // are added as dynamic imports to the qwik-router-config as a way to create
          // a new entry point for the build. Ensure these are not treeshaken.
          moduleSideEffects: "no-treeshake"
        };
      }
      if (id === QWIK_ROUTER_SW_REGISTER) {
        return id;
      }
      return null;
    },
    async load(id, opts) {
      if (ctx) {
        if (id.endsWith(QWIK_ROUTER_ENTRIES_ID)) {
          return generateQwikRouterEntries(ctx);
        }
        const isRouterConfig = id.endsWith(QWIK_ROUTER_CONFIG_ID);
        const isSwRegister = id.endsWith(QWIK_ROUTER_SW_REGISTER);
        if (isRouterConfig || isSwRegister) {
          if (ctx.isDirty) {
            await parseRoutesDir(ctx);
            ctx.isDirty = false;
            ctx.diagnostics.forEach((d) => {
              this.warn(d.message);
            });
          }
          if (isRouterConfig) {
            return generateQwikRouterConfig(ctx, qwikPlugin, opts?.ssr ?? false);
          }
          if (isSwRegister) {
            return generateServiceWorkerRegister(ctx, swRegister);
          }
        }
      }
      return null;
    },
    async transform(code, id) {
      const isVirtualId = id.startsWith("\0");
      if (isVirtualId) {
        return;
      }
      const ext = extname(id).toLowerCase();
      const isMD = ext === ".md" || ext === ".mdx";
      if (ctx && isMD) {
        const fileName = basename(id);
        if (isMenuFileName(fileName)) {
          const menuCode = await transformMenu(ctx.opts, id, code);
          return { code: menuCode, map: null };
        }
        if (mdxTransform) {
          try {
            const mdxResult = await mdxTransform(code, id);
            return mdxResult;
          } catch (e) {
            if (e && typeof e == "object" && "position" in e && "reason" in e) {
              const column = e.position?.start.column;
              const line = e.position?.start.line;
              const err = Object.assign(new Error(e.reason), {
                id,
                plugin: "qwik-router-mdx",
                loc: {
                  column,
                  line
                },
                stack: ""
              });
              this.error(err);
            } else if (e instanceof Error) {
              this.error(e);
            } else {
              this.error(String(e));
            }
          }
        }
      }
      return null;
    },
    generateBundle(_, bundles) {
      if (ctx?.target === "client") {
        const entries = [...ctx.entries, ...ctx.serviceWorkers].map((entry) => {
          return {
            chunkFileName: entry.chunkFileName,
            extensionlessFilePath: removeExtension(entry.filePath)
          };
        });
        for (const entry of entries) {
          for (const fileName in bundles) {
            const c = bundles[fileName];
            if (c.type === "chunk" && c.isDynamicEntry && c.facadeModuleId) {
              const extensionlessFilePath = removeExtension(normalizePath(c.facadeModuleId));
              if (entry.extensionlessFilePath === extensionlessFilePath) {
                c.fileName = entry.chunkFileName;
                continue;
              }
            }
          }
        }
      }
    },
    closeBundle: {
      sequential: true,
      async handler() {
        if (ctx?.target === "ssr" && outDir) {
          await generateServerPackageJson(outDir, ssrFormat);
        }
      }
    }
  };
  return plugin;
}
async function generateServerPackageJson(outDir, ssrFormat) {
  await fs.promises.mkdir(outDir, { recursive: true });
  const serverPackageJsonPath = join(outDir, "package.json");
  let packageJson = {};
  if (fs.existsSync(serverPackageJsonPath)) {
    const content = await fs.promises.readFile(serverPackageJsonPath, "utf-8");
    const contentAsJson = JSON.parse(content);
    packageJson = {
      ...contentAsJson
    };
  }
  packageJson = {
    ...packageJson,
    type: ssrFormat == "cjs" ? "commonjs" : "module"
  };
  const serverPackageJsonCode = JSON.stringify(packageJson, null, 2);
  await fs.promises.writeFile(serverPackageJsonPath, serverPackageJsonCode);
}
export {
  extendConfig,
  qwikCity,
  qwikRouter
};
