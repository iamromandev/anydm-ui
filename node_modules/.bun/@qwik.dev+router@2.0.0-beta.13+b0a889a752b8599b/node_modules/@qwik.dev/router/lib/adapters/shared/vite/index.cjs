"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const path = require("node:path");
const fs = require("node:fs");
const errorHandler = require("../../../chunks/error-handler.cjs");
async function postBuild(clientOutDir, serverOutDir, pathName, userStaticPaths, cleanStatic) {
  if (pathName && !pathName.endsWith("/")) {
    pathName += "/";
  }
  const ignorePathnames = /* @__PURE__ */ new Set([
    pathName + "/" + (globalThis.__QWIK_BUILD_DIR__ || "build") + "/",
    pathName + "/" + (globalThis.__QWIK_ASSETS_DIR__ || "assets") + "/"
  ]);
  const staticPaths = new Set(userStaticPaths.map(normalizeTrailingSlash));
  const notFounds = [];
  const loadItem = async (fsDir, fsName, pathname) => {
    pathname = normalizeTrailingSlash(pathname);
    if (ignorePathnames.has(pathname)) {
      return;
    }
    const fsPath = path.join(fsDir, fsName);
    if (fsName === "index.html" || fsName === "q-data.json") {
      if (!staticPaths.has(pathname) && cleanStatic) {
        await fs.promises.unlink(fsPath);
      }
      return;
    }
    if (fsName === "404.html") {
      const notFoundHtml = await fs.promises.readFile(fsPath, "utf-8");
      notFounds.push([pathname, notFoundHtml]);
      return;
    }
    const stat = await fs.promises.stat(fsPath);
    if (stat.isDirectory()) {
      await loadDir(fsPath, pathname + fsName + "/");
    } else if (stat.isFile()) {
      staticPaths.add(pathname + fsName);
    }
  };
  const loadDir = async (fsDir, pathname) => {
    const itemNames = await fs.promises.readdir(fsDir);
    await Promise.all(itemNames.map((i) => loadItem(fsDir, i, pathname)));
  };
  if (fs.existsSync(clientOutDir)) {
    await loadDir(clientOutDir, pathName);
  }
  const notFoundPathsCode = createNotFoundPathsCode(pathName, notFounds);
  const staticPathsCode = createStaticPathsCode(staticPaths);
  await injectStatics(staticPathsCode, notFoundPathsCode, serverOutDir);
}
function normalizeTrailingSlash(pathname) {
  if (!pathname.endsWith("/")) {
    return pathname + "/";
  }
  return pathname;
}
function createNotFoundPathsCode(basePathname, notFounds) {
  notFounds.sort((a, b) => {
    if (a[0].length > b[0].length) {
      return -1;
    }
    if (a[0].length < b[0].length) {
      return 1;
    }
    if (a[0] < b[0]) {
      return -1;
    }
    if (a[0] > b[0]) {
      return 1;
    }
    return 0;
  });
  if (!notFounds.some((r) => r[0] === basePathname)) {
    const html = errorHandler.getErrorHtml(404, "Resource Not Found");
    notFounds.push([basePathname, html]);
  }
  return JSON.stringify(notFounds, null, 2).slice(1, -1);
}
function createStaticPathsCode(staticPaths) {
  return JSON.stringify(Array.from(new Set(staticPaths)).sort()).slice(1, -1);
}
const injectStatics = async (staticPathsCode, notFoundPathsCode, outDir) => {
  const promises = /* @__PURE__ */ new Set();
  const doReplace = async (path2) => {
    const code = await fs.promises.readFile(path2, "utf-8");
    let replaced = false;
    const newCode = code.replace(
      /(['"])__QWIK_ROUTER_(STATIC_PATHS|NOT_FOUND)_ARRAY__\1/g,
      (_, _quote, type) => {
        replaced = true;
        return type === "STATIC_PATHS" ? staticPathsCode : notFoundPathsCode;
      }
    );
    if (replaced) {
      await fs.promises.writeFile(path2, newCode);
    }
  };
  const walk = async (dir) => {
    const entries = await fs.promises.readdir(dir, { withFileTypes: true });
    for (const entry of entries) {
      if (entry.isDirectory()) {
        await walk(path.join(dir, entry.name));
      } else if (entry.name.endsWith("js")) {
        const p = doReplace(path.join(dir, entry.name)).finally(() => {
          promises.delete(p);
        });
        promises.add(p);
      }
    }
  };
  await walk(outDir);
  await Promise.all(promises);
};
function viteAdapter(opts) {
  let qwikRouterPlugin = null;
  let qwikVitePlugin = null;
  let serverOutDir = null;
  let renderModulePath = null;
  let qwikRouterConfigModulePath = null;
  let isSsrBuild = false;
  let viteCommand;
  const outputEntries = [];
  const plugin = {
    name: `vite-plugin-qwik-router-ssg-${opts.name}`,
    enforce: "post",
    apply: "build",
    config(config) {
      if (typeof opts.config === "function") {
        config = opts.config(config);
      }
      config.define = {
        "process.env.NODE_ENV": JSON.stringify(process.env.NODE_ENV || "production"),
        ...config.define
      };
      return config;
    },
    configResolved(config) {
      isSsrBuild = !!config.build.ssr;
      viteCommand = config.command;
      if (isSsrBuild) {
        qwikRouterPlugin = config.plugins.find(
          (p) => p.name === "vite-plugin-qwik-router"
        );
        if (!qwikRouterPlugin) {
          throw new Error("Missing vite-plugin-qwik-router");
        }
        qwikVitePlugin = config.plugins.find(
          (p) => p.name === "vite-plugin-qwik"
        );
        if (!qwikVitePlugin) {
          throw new Error("Missing vite-plugin-qwik");
        }
        serverOutDir = config.build.outDir;
        if (config.build?.ssr !== true) {
          throw new Error(
            `"build.ssr" must be set to "true" in order to use the "${opts.name}" adapter.`
          );
        }
        if (!config.build?.rollupOptions?.input) {
          throw new Error(
            `"build.rollupOptions.input" must be set in order to use the "${opts.name}" adapter.`
          );
        }
      }
    },
    buildStart() {
      if (isSsrBuild && opts.ssg !== null) {
        const { srcDir } = qwikVitePlugin.api.getOptions();
        if (viteCommand === "build" && serverOutDir && srcDir) {
          this.emitFile({
            id: "@qwik-router-config",
            type: "chunk",
            fileName: "@qwik-router-config.js"
          });
          this.emitFile({
            id: `${srcDir}/entry.ssr`,
            type: "chunk",
            fileName: "entry.ssr.js"
          });
        }
      }
    },
    generateBundle(_, bundles) {
      if (isSsrBuild) {
        outputEntries.length = 0;
        for (const fileName in bundles) {
          const chunk = bundles[fileName];
          if (chunk.type === "chunk" && chunk.isEntry) {
            outputEntries.push(fileName);
            if (chunk.name === "entry.ssr") {
              renderModulePath = path.join(serverOutDir, fileName);
            } else if (chunk.name === "@qwik-router-config") {
              qwikRouterConfigModulePath = path.join(serverOutDir, fileName);
            }
          }
        }
      }
    },
    closeBundle: {
      sequential: true,
      async handler() {
        if (isSsrBuild && serverOutDir && qwikRouterPlugin?.api && qwikVitePlugin?.api) {
          const staticPaths = opts.staticPaths || [];
          const routes = qwikRouterPlugin.api.getRoutes();
          const basePathname = qwikRouterPlugin.api.getBasePathname();
          const clientOutDir = qwikVitePlugin.api.getClientOutDir();
          const clientPublicOutDir = qwikVitePlugin.api.getClientPublicOutDir();
          const assetsDir = qwikVitePlugin.api.getAssetsDir();
          const rootDir = qwikVitePlugin.api.getRootDir() ?? void 0;
          if (opts.ssg !== null && renderModulePath && qwikRouterConfigModulePath && clientOutDir && clientPublicOutDir) {
            let ssgOrigin = opts.ssg?.origin ?? opts.origin;
            if (!ssgOrigin) {
              ssgOrigin = `https://yoursite.qwik.dev`;
            }
            if (ssgOrigin.length > 0 && !/:\/\//.test(ssgOrigin)) {
              ssgOrigin = `https://${ssgOrigin}`;
            }
            if (ssgOrigin.startsWith("//")) {
              ssgOrigin = `https:${ssgOrigin}`;
            }
            try {
              ssgOrigin = new URL(ssgOrigin).origin;
            } catch {
              this.warn(
                `Invalid "origin" option: "${ssgOrigin}". Using default origin: "https://yoursite.qwik.dev"`
              );
              ssgOrigin = `https://yoursite.qwik.dev`;
            }
            const staticGenerate = await Promise.resolve().then(() => require("../../../ssg/index.cjs"));
            const generateOpts = {
              maxWorkers: opts.maxWorkers,
              basePathname,
              outDir: clientPublicOutDir,
              rootDir,
              ...opts.ssg,
              origin: ssgOrigin,
              renderModulePath,
              qwikRouterConfigModulePath
            };
            const staticGenerateResult = await staticGenerate.generate(generateOpts);
            if (staticGenerateResult.errors > 0) {
              const err = new Error(
                `Error while running SSG from "${opts.name}" adapter. At least one path failed to render.`
              );
              err.stack = void 0;
              this.error(err);
            }
            staticPaths.push(...staticGenerateResult.staticPaths);
          }
          await postBuild(
            clientPublicOutDir,
            serverOutDir,
            assetsDir ? path.join(basePathname, assetsDir) : basePathname,
            staticPaths,
            !!opts.cleanStaticGenerated
          );
          if (typeof opts.generate === "function") {
            await opts.generate({
              outputEntries,
              serverOutDir,
              clientOutDir,
              clientPublicOutDir,
              basePathname,
              routes,
              assetsDir,
              warn: (message) => this.warn(message),
              error: (message) => this.error(message)
            });
          }
          this.warn(
            `
==============================================
Note: Make sure that you are serving the built files with proper cache headers.
See https://qwik.dev/docs/deployments/#cache-headers for more information.
==============================================`
          );
          if (opts.ssg !== null) {
            setTimeout(() => {
              console.warn(
                "SSG seems to be hanging after completion, forcing process to exit. Everything is likely fine."
              );
              process.exit(0);
            }, 5e3).unref();
          }
        }
      }
    }
  };
  return plugin;
}
function getParentDir(startDir, dirName) {
  const root = path.resolve("/");
  let dir = startDir;
  for (let i = 0; i < 20; i++) {
    dir = path.dirname(dir);
    if (path.basename(dir) === dirName) {
      return dir;
    }
    if (dir === root) {
      break;
    }
  }
  throw new Error(`Unable to find "${dirName}" directory from "${startDir}"`);
}
exports.getParentDir = getParentDir;
exports.viteAdapter = viteAdapter;
