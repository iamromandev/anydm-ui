import { setServerPlatform } from "@qwik.dev/core/server";
import { isStaticPath, getNotFound, requestHandler } from "@qwik.dev/router/middleware/request-handler";
import { createReadStream } from "node:fs";
import { join, basename, extname } from "node:path";
import { fileURLToPath } from "node:url";
import { M as MIME_TYPES } from "../../chunks/mime-types.mjs";
import { Http2ServerRequest } from "node:http2";
function computeOrigin(req, opts) {
  return opts?.getOrigin?.(req) ?? opts?.origin ?? process.env.ORIGIN ?? fallbackOrigin(req);
}
function fallbackOrigin(req) {
  const { PROTOCOL_HEADER, HOST_HEADER } = process.env;
  const headers = req.headers;
  const protocol = PROTOCOL_HEADER && headers[PROTOCOL_HEADER] || (req.socket.encrypted || req.connection.encrypted ? "https" : "http");
  const hostHeader = HOST_HEADER ?? (req instanceof Http2ServerRequest ? ":authority" : "host");
  const host = headers[hostHeader];
  return `${protocol}://${host}`;
}
function getUrl(req, origin) {
  return normalizeUrl(req.originalUrl || req.url || "/", origin);
}
function isIgnoredError(message = "") {
  const ignoredErrors = ["The stream has been destroyed", "write after end"];
  return ignoredErrors.some((ignored) => message.includes(ignored));
}
const invalidHeadersPattern = /^:(method|scheme|authority|path)$/i;
function normalizeUrl(url, base) {
  const DOUBLE_SLASH_REG = /\/\/|\\\\/g;
  return new URL(url.replace(DOUBLE_SLASH_REG, "/"), base);
}
async function fromNodeHttp(url, req, res, mode, getClientConn) {
  const requestHeaders = new Headers();
  const nodeRequestHeaders = req.headers;
  try {
    for (const [key, value] of Object.entries(nodeRequestHeaders)) {
      if (invalidHeadersPattern.test(key)) {
        continue;
      }
      if (typeof value === "string") {
        requestHeaders.set(key, value);
      } else if (Array.isArray(value)) {
        for (const v of value) {
          requestHeaders.append(key, v);
        }
      }
    }
  } catch (err) {
    console.error(err);
  }
  const getRequestBody = async function* () {
    for await (const chunk of req) {
      yield chunk;
    }
  };
  const body = req.method === "HEAD" || req.method === "GET" ? void 0 : getRequestBody();
  const controller = new AbortController();
  const options = {
    method: req.method,
    headers: requestHeaders,
    body,
    signal: controller.signal,
    duplex: "half"
  };
  res.on("close", () => {
    controller.abort();
  });
  const serverRequestEv = {
    mode,
    url,
    request: new Request(url.href, options),
    env: {
      get(key) {
        return process.env[key];
      }
    },
    getWritableStream: (status, headers, cookies) => {
      res.statusCode = status;
      try {
        for (const [key, value] of headers) {
          if (invalidHeadersPattern.test(key)) {
            continue;
          }
          res.setHeader(key, value);
        }
        const cookieHeaders = cookies.headers();
        if (cookieHeaders.length > 0) {
          res.setHeader("Set-Cookie", cookieHeaders);
        }
      } catch (err) {
        console.error(err);
      }
      return new WritableStream({
        write(chunk) {
          if (res.closed || res.destroyed) {
            return;
          }
          res.write(chunk, (error) => {
            if (error && !isIgnoredError(error.message)) {
              console.error(error);
            }
          });
        },
        close() {
          res.end();
        }
      });
    },
    getClientConn: () => {
      return getClientConn ? getClientConn(req) : {
        ip: req.socket.remoteAddress
      };
    },
    platform: {
      ssr: true,
      incomingMessage: req,
      node: process.versions.node
      // Weirdly needed to make typecheck of insights happy
    },
    locale: void 0
  };
  return serverRequestEv;
}
function createQwikRouter(opts) {
  if (opts.qwikCityPlan && !opts.qwikRouterConfig) {
    console.warn("qwikCityPlan is deprecated. Simply remove it.");
    opts.qwikRouterConfig = opts.qwikCityPlan;
  }
  if (opts.manifest) {
    setServerPlatform(opts.manifest);
  }
  const staticFolder = opts.static?.root ?? join(fileURLToPath(import.meta.url), "..", "..", "dist");
  const router = async (req, res, next) => {
    try {
      const origin = computeOrigin(req, opts);
      const serverRequestEv = await fromNodeHttp(
        getUrl(req, origin),
        req,
        res,
        "server",
        opts.getClientConn
      );
      const handled = await requestHandler(serverRequestEv, opts);
      if (handled) {
        const err = await handled.completion;
        if (err) {
          throw err;
        }
        if (handled.requestEv.headersSent) {
          return;
        }
      }
      next();
    } catch (e) {
      console.error(e);
      next(e);
    }
  };
  const notFound = async (req, res, next) => {
    try {
      if (!res.headersSent) {
        const origin = computeOrigin(req, opts);
        const url = getUrl(req, origin);
        const notFoundHtml = !req.headers.accept?.includes("text/html") || isStaticPath(req.method || "GET", url) ? "Not Found" : getNotFound(url.pathname);
        res.writeHead(404, {
          "Content-Type": "text/html; charset=utf-8",
          "X-Not-Found": url.pathname
        });
        res.end(notFoundHtml);
      }
    } catch (e) {
      console.error(e);
      next(e);
    }
  };
  const staticFile = async (req, res, next) => {
    try {
      const origin = computeOrigin(req, opts);
      const url = getUrl(req, origin);
      if (isStaticPath(req.method || "GET", url)) {
        const pathname = url.pathname;
        let filePath;
        if (basename(pathname).includes(".")) {
          filePath = join(staticFolder, pathname);
        } else if (!globalThis.__NO_TRAILING_SLASH__) {
          filePath = join(staticFolder, pathname + "index.html");
        } else {
          filePath = join(staticFolder, pathname, "index.html");
        }
        const ext = extname(filePath).replace(/^\./, "");
        const stream = createReadStream(filePath);
        stream.on("error", next);
        const contentType = MIME_TYPES[ext];
        if (contentType) {
          res.setHeader("Content-Type", contentType);
        }
        if (opts.static?.cacheControl) {
          res.setHeader("Cache-Control", opts.static.cacheControl);
        }
        stream.pipe(res);
        return;
      }
      return next();
    } catch (e) {
      console.error(e);
      next(e);
    }
  };
  return {
    router,
    notFound,
    staticFile
  };
}
const createQwikCity = createQwikRouter;
export {
  createQwikCity,
  createQwikRouter
};
