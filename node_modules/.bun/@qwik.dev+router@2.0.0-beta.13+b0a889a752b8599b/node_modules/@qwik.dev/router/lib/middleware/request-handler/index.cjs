"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _a, _b, _c, _pendingHighSurrogate, _handle, _transform;
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const build = require("@qwik.dev/core/build");
const routing = require("../../chunks/routing.qwik.cjs");
const core = require("@qwik.dev/core");
const internal = require("@qwik.dev/core/internal");
const types = require("../../chunks/types.qwik.cjs");
const requestHandler$1 = require("@qwik.dev/router/middleware/request-handler");
const errorHandler = require("../../chunks/error-handler.cjs");
require("@qwik.dev/core/preloader");
var HttpStatus = /* @__PURE__ */ ((HttpStatus2) => {
  HttpStatus2[HttpStatus2["Continue"] = 100] = "Continue";
  HttpStatus2[HttpStatus2["SwitchingProtocols"] = 101] = "SwitchingProtocols";
  HttpStatus2[HttpStatus2["Processing"] = 102] = "Processing";
  HttpStatus2[HttpStatus2["Ok"] = 200] = "Ok";
  HttpStatus2[HttpStatus2["Created"] = 201] = "Created";
  HttpStatus2[HttpStatus2["Accepted"] = 202] = "Accepted";
  HttpStatus2[HttpStatus2["NonAuthoritativeInformation"] = 203] = "NonAuthoritativeInformation";
  HttpStatus2[HttpStatus2["NoContent"] = 204] = "NoContent";
  HttpStatus2[HttpStatus2["ResetContent"] = 205] = "ResetContent";
  HttpStatus2[HttpStatus2["PartialContent"] = 206] = "PartialContent";
  HttpStatus2[HttpStatus2["MultiStatus"] = 207] = "MultiStatus";
  HttpStatus2[HttpStatus2["AlreadyReported"] = 208] = "AlreadyReported";
  HttpStatus2[HttpStatus2["ImUsed"] = 226] = "ImUsed";
  HttpStatus2[HttpStatus2["MultipleChoices"] = 300] = "MultipleChoices";
  HttpStatus2[HttpStatus2["MovedPermanently"] = 301] = "MovedPermanently";
  HttpStatus2[HttpStatus2["Found"] = 302] = "Found";
  HttpStatus2[HttpStatus2["SeeOther"] = 303] = "SeeOther";
  HttpStatus2[HttpStatus2["NotModified"] = 304] = "NotModified";
  HttpStatus2[HttpStatus2["UseProxy"] = 305] = "UseProxy";
  HttpStatus2[HttpStatus2["SwitchProxy"] = 306] = "SwitchProxy";
  HttpStatus2[HttpStatus2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
  HttpStatus2[HttpStatus2["PermanentRedirect"] = 308] = "PermanentRedirect";
  HttpStatus2[HttpStatus2["BadRequest"] = 400] = "BadRequest";
  HttpStatus2[HttpStatus2["Unauthorized"] = 401] = "Unauthorized";
  HttpStatus2[HttpStatus2["PaymentRequired"] = 402] = "PaymentRequired";
  HttpStatus2[HttpStatus2["Forbidden"] = 403] = "Forbidden";
  HttpStatus2[HttpStatus2["NotFound"] = 404] = "NotFound";
  HttpStatus2[HttpStatus2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
  HttpStatus2[HttpStatus2["NotAcceptable"] = 406] = "NotAcceptable";
  HttpStatus2[HttpStatus2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
  HttpStatus2[HttpStatus2["RequestTimeout"] = 408] = "RequestTimeout";
  HttpStatus2[HttpStatus2["Conflict"] = 409] = "Conflict";
  HttpStatus2[HttpStatus2["Gone"] = 410] = "Gone";
  HttpStatus2[HttpStatus2["LengthRequired"] = 411] = "LengthRequired";
  HttpStatus2[HttpStatus2["PreconditionFailed"] = 412] = "PreconditionFailed";
  HttpStatus2[HttpStatus2["PayloadTooLarge"] = 413] = "PayloadTooLarge";
  HttpStatus2[HttpStatus2["UriTooLong"] = 414] = "UriTooLong";
  HttpStatus2[HttpStatus2["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
  HttpStatus2[HttpStatus2["RangeNotSatisfiable"] = 416] = "RangeNotSatisfiable";
  HttpStatus2[HttpStatus2["ExpectationFailed"] = 417] = "ExpectationFailed";
  HttpStatus2[HttpStatus2["IAmATeapot"] = 418] = "IAmATeapot";
  HttpStatus2[HttpStatus2["MisdirectedRequest"] = 421] = "MisdirectedRequest";
  HttpStatus2[HttpStatus2["UnprocessableEntity"] = 422] = "UnprocessableEntity";
  HttpStatus2[HttpStatus2["Locked"] = 423] = "Locked";
  HttpStatus2[HttpStatus2["FailedDependency"] = 424] = "FailedDependency";
  HttpStatus2[HttpStatus2["UpgradeRequired"] = 426] = "UpgradeRequired";
  HttpStatus2[HttpStatus2["PreconditionRequired"] = 428] = "PreconditionRequired";
  HttpStatus2[HttpStatus2["TooManyRequests"] = 429] = "TooManyRequests";
  HttpStatus2[HttpStatus2["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
  HttpStatus2[HttpStatus2["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
  HttpStatus2[HttpStatus2["InternalServerError"] = 500] = "InternalServerError";
  HttpStatus2[HttpStatus2["NotImplemented"] = 501] = "NotImplemented";
  HttpStatus2[HttpStatus2["BadGateway"] = 502] = "BadGateway";
  HttpStatus2[HttpStatus2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
  HttpStatus2[HttpStatus2["GatewayTimeout"] = 504] = "GatewayTimeout";
  HttpStatus2[HttpStatus2["HttpVersionNotSupported"] = 505] = "HttpVersionNotSupported";
  HttpStatus2[HttpStatus2["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
  HttpStatus2[HttpStatus2["InsufficientStorage"] = 507] = "InsufficientStorage";
  HttpStatus2[HttpStatus2["LoopDetected"] = 508] = "LoopDetected";
  HttpStatus2[HttpStatus2["NotExtended"] = 510] = "NotExtended";
  HttpStatus2[HttpStatus2["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
  return HttpStatus2;
})(HttpStatus || {});
function createCacheControl(cacheControl) {
  const controls = [];
  if (cacheControl === "day") {
    cacheControl = 60 * 60 * 24;
  } else if (cacheControl === "week") {
    cacheControl = 60 * 60 * 24 * 7;
  } else if (cacheControl === "month") {
    cacheControl = 60 * 60 * 24 * 30;
  } else if (cacheControl === "year") {
    cacheControl = 60 * 60 * 24 * 365;
  } else if (cacheControl === "private") {
    cacheControl = {
      private: true,
      noCache: true
    };
  } else if (cacheControl === "immutable") {
    cacheControl = {
      public: true,
      immutable: true,
      maxAge: 60 * 60 * 24 * 365
    };
  } else if (cacheControl === "no-cache") {
    cacheControl = {
      noCache: true
    };
  }
  if (typeof cacheControl === "number") {
    cacheControl = {
      maxAge: cacheControl,
      sMaxAge: cacheControl
    };
  }
  if (cacheControl.immutable) {
    controls.push("immutable");
  }
  if (cacheControl.maxAge) {
    controls.push(`max-age=${cacheControl.maxAge}`);
  }
  if (cacheControl.sMaxAge) {
    controls.push(`s-maxage=${cacheControl.sMaxAge}`);
  }
  if (cacheControl.noStore) {
    controls.push("no-store");
  }
  if (cacheControl.noCache) {
    controls.push("no-cache");
  }
  if (cacheControl.private) {
    controls.push("private");
  }
  if (cacheControl.public) {
    controls.push("public");
  }
  if (cacheControl.staleWhileRevalidate) {
    controls.push(`stale-while-revalidate=${cacheControl.staleWhileRevalidate}`);
  }
  if (cacheControl.staleIfError) {
    controls.push(`stale-if-error=${cacheControl.staleIfError}`);
  }
  return controls.join(", ");
}
const SAMESITE = {
  lax: "Lax",
  Lax: "Lax",
  None: "None",
  none: "None",
  strict: "Strict",
  Strict: "Strict"
};
const UNIT = {
  seconds: 1,
  minutes: 1 * 60,
  hours: 1 * 60 * 60,
  days: 1 * 60 * 60 * 24,
  weeks: 1 * 60 * 60 * 24 * 7
};
const createSetCookieValue = (cookieName, cookieValue, options) => {
  const c = [`${cookieName}=${cookieValue}`];
  if (typeof options.domain === "string") {
    c.push(`Domain=${options.domain}`);
  }
  if (typeof options.maxAge === "number") {
    c.push(`Max-Age=${options.maxAge}`);
  } else if (Array.isArray(options.maxAge)) {
    c.push(`Max-Age=${options.maxAge[0] * UNIT[options.maxAge[1]]}`);
  } else if (typeof options.expires === "number" || typeof options.expires == "string") {
    c.push(`Expires=${options.expires}`);
  } else if (options.expires instanceof Date) {
    c.push(`Expires=${options.expires.toUTCString()}`);
  }
  if (options.httpOnly) {
    c.push("HttpOnly");
  }
  if (typeof options.path === "string") {
    c.push(`Path=${options.path}`);
  }
  const sameSite = resolveSameSite(options.sameSite);
  if (sameSite) {
    c.push(`SameSite=${sameSite}`);
  }
  if (options.secure) {
    c.push("Secure");
  }
  return c.join("; ");
};
function tryDecodeUriComponent(str) {
  try {
    return decodeURIComponent(str);
  } catch {
    return str;
  }
}
const parseCookieString = (cookieString) => {
  const cookie = {};
  if (typeof cookieString === "string" && cookieString !== "") {
    const cookieSegments = cookieString.split(";");
    for (const cookieSegment of cookieSegments) {
      const separatorIndex = cookieSegment.indexOf("=");
      if (separatorIndex !== -1) {
        cookie[tryDecodeUriComponent(cookieSegment.slice(0, separatorIndex).trim())] = tryDecodeUriComponent(cookieSegment.slice(separatorIndex + 1).trim());
      }
    }
  }
  return cookie;
};
function resolveSameSite(sameSite) {
  if (sameSite === true) {
    return "Strict";
  }
  if (sameSite === false) {
    return "None";
  }
  if (sameSite) {
    return SAMESITE[sameSite];
  }
  return void 0;
}
const REQ_COOKIE = Symbol("request-cookies");
const RES_COOKIE = Symbol("response-cookies");
const LIVE_COOKIE = Symbol("live-cookies");
_c = REQ_COOKIE, _b = RES_COOKIE, _a = LIVE_COOKIE;
class Cookie {
  constructor(cookieString) {
    __publicField(this, _c);
    __publicField(this, _b, {});
    __publicField(this, _a, {});
    __publicField(this, "appendCounter", 0);
    this[REQ_COOKIE] = parseCookieString(cookieString);
    this[LIVE_COOKIE] = { ...this[REQ_COOKIE] };
  }
  get(cookieName, live = true) {
    const value = this[live ? LIVE_COOKIE : REQ_COOKIE][cookieName];
    if (!value) {
      return null;
    }
    return {
      value,
      json() {
        return JSON.parse(value);
      },
      number() {
        return Number(value);
      }
    };
  }
  getAll(live = true) {
    return Object.keys(this[live ? LIVE_COOKIE : REQ_COOKIE]).reduce(
      (cookies, cookieName) => {
        cookies[cookieName] = this.get(cookieName);
        return cookies;
      },
      {}
    );
  }
  has(cookieName, live = true) {
    return !!this[live ? LIVE_COOKIE : REQ_COOKIE][cookieName];
  }
  set(cookieName, cookieValue, options = {}) {
    this[LIVE_COOKIE][cookieName] = typeof cookieValue === "string" ? cookieValue : JSON.stringify(cookieValue);
    const resolvedValue = typeof cookieValue === "string" ? cookieValue : encodeURIComponent(JSON.stringify(cookieValue));
    this[RES_COOKIE][cookieName] = createSetCookieValue(cookieName, resolvedValue, options);
  }
  append(cookieName, cookieValue, options = {}) {
    this[LIVE_COOKIE][cookieName] = typeof cookieValue === "string" ? cookieValue : JSON.stringify(cookieValue);
    const resolvedValue = typeof cookieValue === "string" ? cookieValue : encodeURIComponent(JSON.stringify(cookieValue));
    this[RES_COOKIE][++this.appendCounter] = createSetCookieValue(
      cookieName,
      resolvedValue,
      options
    );
  }
  delete(name, options) {
    this.set(name, "deleted", { ...options, maxAge: 0 });
    this[LIVE_COOKIE][name] = null;
  }
  headers() {
    return Object.values(this[RES_COOKIE]);
  }
}
const mergeHeadersCookies = (headers, cookies) => {
  const cookieHeaders = cookies.headers();
  if (cookieHeaders.length > 0) {
    const newHeaders = new Headers(headers);
    for (const cookie of cookieHeaders) {
      newHeaders.append("Set-Cookie", cookie);
    }
    return newHeaders;
  }
  return headers;
};
function runQwikRouter(serverRequestEv, loadedRoute, requestHandlers, rebuildRouteInfo, basePathname = "/") {
  let resolve;
  const responsePromise = new Promise((r) => resolve = r);
  const requestEv = createRequestEvent(
    serverRequestEv,
    loadedRoute,
    requestHandlers,
    basePathname,
    resolve
  );
  return {
    response: responsePromise,
    requestEv,
    completion: requestHandler$1._asyncRequestStore ? requestHandler$1._asyncRequestStore.run(requestEv, runNext, requestEv, rebuildRouteInfo, resolve) : runNext(requestEv, rebuildRouteInfo, resolve)
  };
}
async function runNext(requestEv, rebuildRouteInfo, resolve) {
  try {
    const isValidURL = (url) => new URL(url.pathname + url.search, url);
    isValidURL(requestEv.originalUrl);
  } catch {
    const status = 404;
    const message = "Resource Not Found";
    requestEv.status(status);
    const html = errorHandler.getErrorHtml(status, message);
    requestEv.html(status, html);
    return new requestHandler$1.ServerError(status, message);
  }
  let rewriteAttempt = 1;
  async function _runNext() {
    try {
      await requestEv.next();
    } catch (e) {
      if (e instanceof requestHandler$1.RedirectMessage) {
        const stream = requestEv.getWritableStream();
        await stream.close();
        return e;
      } else if (e instanceof requestHandler$1.RewriteMessage) {
        if (rewriteAttempt > 50) {
          return new Error(`Infinite rewrite loop`);
        }
        rewriteAttempt += 1;
        const url = new URL(requestEv.url);
        url.pathname = e.pathname;
        const { loadedRoute, requestHandlers } = await rebuildRouteInfo(url);
        requestEv.resetRoute(loadedRoute, requestHandlers, url);
        return await _runNext();
      } else if (e instanceof requestHandler$1.AbortMessage) {
        return;
      } else if (e instanceof requestHandler$1.ServerError && !requestEv.headersSent) {
        const status = e.status;
        const accept = requestEv.request.headers.get("Accept");
        if (accept && !accept.includes("text/html")) {
          requestEv.headers.set("Content-Type", "application/qwik-json");
          requestEv.send(status, await internal._serialize([e.data]));
        } else {
          requestEv.html(status, errorHandler.getErrorHtml(status, e.data));
        }
        return e;
      }
      if (getRequestMode(requestEv) !== "dev") {
        try {
          if (!requestEv.headersSent) {
            requestEv.headers.set("content-type", "text/html; charset=utf-8");
            requestEv.cacheControl({ noCache: true });
            requestEv.status(500);
          }
          const stream = requestEv.getWritableStream();
          if (!stream.locked) {
            const writer = stream.getWriter();
            await writer.write(encoder.encode(errorHandler.getErrorHtml(500, "Internal Server Error")));
            await writer.close();
          }
        } catch {
          console.error("Unable to render error page");
        }
      }
      return e;
    }
  }
  try {
    return await _runNext();
  } finally {
    if (!requestEv.isDirty()) {
      resolve(null);
    }
  }
}
function getRouteMatchPathname(pathname) {
  const isInternal = pathname.endsWith(QDATA_JSON);
  if (isInternal) {
    const trimEnd = pathname.length - QDATA_JSON.length + (globalThis.__NO_TRAILING_SLASH__ ? 0 : 1);
    pathname = pathname.slice(0, trimEnd);
    if (pathname === "") {
      pathname = "/";
    }
  }
  return { pathname, isInternal };
}
const IsQData = "@isQData";
const QDATA_JSON = "/q-data.json";
const RequestEvLoaders = Symbol("RequestEvLoaders");
const RequestEvMode = Symbol("RequestEvMode");
const RequestEvRoute = Symbol("RequestEvRoute");
const RequestEvLoaderSerializationStrategyMap = Symbol(
  "RequestEvLoaderSerializationStrategyMap"
);
const RequestRouteName = "@routeName";
const RequestEvSharedActionId = "@actionId";
const RequestEvSharedActionFormData = "@actionFormData";
const RequestEvSharedNonce = "@nonce";
const RequestEvIsRewrite = "@rewrite";
const RequestEvShareServerTiming = "@serverTiming";
const RequestEvShareQData = "qData";
function createRequestEvent(serverRequestEv, loadedRoute, requestHandlers, basePathname, resolved) {
  const { request, platform, env } = serverRequestEv;
  const sharedMap = /* @__PURE__ */ new Map();
  const cookie = new Cookie(request.headers.get("cookie"));
  const headers = new Headers();
  const url = new URL(request.url);
  const { pathname, isInternal } = getRouteMatchPathname(url.pathname);
  if (isInternal) {
    url.pathname = pathname;
    sharedMap.set(IsQData, true);
  }
  let routeModuleIndex = -1;
  let writableStream = null;
  let requestData = void 0;
  let locale = serverRequestEv.locale;
  let status = 200;
  const next = async () => {
    routeModuleIndex++;
    while (routeModuleIndex < requestHandlers.length) {
      const moduleRequestHandler = requestHandlers[routeModuleIndex];
      const result = moduleRequestHandler(requestEv);
      if (routing.isPromise(result)) {
        await result;
      }
      routeModuleIndex++;
    }
  };
  const resetRoute = (_loadedRoute, _requestHandlers, _url = url) => {
    loadedRoute = _loadedRoute;
    requestHandlers = _requestHandlers;
    url.pathname = _url.pathname;
    url.search = _url.search;
    routeModuleIndex = -1;
  };
  const check = () => {
    if (writableStream !== null) {
      throw new Error("Response already sent");
    }
  };
  const send = (statusOrResponse, body) => {
    check();
    if (typeof statusOrResponse === "number") {
      status = statusOrResponse;
      const writableStream2 = requestEv.getWritableStream();
      const writer = writableStream2.getWriter();
      writer.write(typeof body === "string" ? encoder.encode(body) : body);
      writer.close();
    } else {
      status = statusOrResponse.status;
      statusOrResponse.headers.forEach((value, key) => {
        if (key.toLowerCase() === "set-cookie") {
          return;
        }
        headers.append(key, value);
      });
      statusOrResponse.headers.getSetCookie().forEach((ck) => {
        const index = ck.indexOf("=");
        if (index === -1) {
          return;
        }
        const key = ck.slice(0, index).trim();
        const value = ck.slice(index + 1).trim();
        cookie.set(key, value);
      });
      if (statusOrResponse.body) {
        const writableStream2 = requestEv.getWritableStream();
        statusOrResponse.body.pipeTo(writableStream2);
      } else {
        requestEv.getWritableStream().getWriter().close();
      }
    }
    return exit();
  };
  const exit = (message = new requestHandler$1.AbortMessage()) => {
    routeModuleIndex = ABORT_INDEX;
    return message;
  };
  const loaders = {};
  const requestEv = {
    [RequestEvLoaders]: loaders,
    [RequestEvLoaderSerializationStrategyMap]: /* @__PURE__ */ new Map(),
    [RequestEvMode]: serverRequestEv.mode,
    get [RequestEvRoute]() {
      return loadedRoute;
    },
    cookie,
    headers,
    env,
    method: request.method,
    signal: request.signal,
    originalUrl: new URL(url),
    get params() {
      return loadedRoute?.[types.LoadedRouteProp.Params] ?? {};
    },
    get pathname() {
      return url.pathname;
    },
    platform,
    get query() {
      return url.searchParams;
    },
    request,
    url,
    basePathname,
    sharedMap,
    get headersSent() {
      return writableStream !== null;
    },
    get exited() {
      return routeModuleIndex >= ABORT_INDEX;
    },
    get clientConn() {
      return serverRequestEv.getClientConn();
    },
    next,
    resetRoute,
    exit,
    cacheControl: (cacheControl, target = "Cache-Control") => {
      check();
      headers.set(target, createCacheControl(cacheControl));
    },
    resolveValue: (async (loaderOrAction) => {
      const id = loaderOrAction.__id;
      if (loaderOrAction.__brand === "server_loader") {
        if (!(id in loaders)) {
          throw new Error(
            "You can not get the returned data of a loader that has not been executed for this request."
          );
        }
        if (loaders[id] === internal._UNINITIALIZED) {
          const isDev = getRequestMode(requestEv) === "dev";
          await getRouteLoaderPromise(loaderOrAction, loaders, requestEv, isDev);
        }
      }
      return loaders[id];
    }),
    status: (statusCode) => {
      if (typeof statusCode === "number") {
        check();
        status = statusCode;
        return statusCode;
      }
      return status;
    },
    locale: (_locale) => {
      if (typeof _locale === "string") {
        locale = _locale;
      }
      return locale || "";
    },
    error: (statusCode, message) => {
      status = statusCode;
      headers.delete("Cache-Control");
      return new requestHandler$1.ServerError(statusCode, message);
    },
    redirect: (statusCode, url2) => {
      check();
      status = statusCode;
      if (url2) {
        if (/([^:])\/{2,}/.test(url2)) {
          const fixedURL = url2.replace(/([^:])\/{2,}/g, "$1/");
          console.warn(`Redirect URL ${url2} is invalid, fixing to ${fixedURL}`);
          url2 = fixedURL;
        }
        headers.set("Location", url2);
      }
      headers.delete("Cache-Control");
      if (statusCode > 301) {
        headers.set("Cache-Control", "no-store");
      }
      return exit(new requestHandler$1.RedirectMessage());
    },
    rewrite: (pathname2) => {
      check();
      if (pathname2.startsWith("http")) {
        throw new Error("Rewrite does not support absolute urls");
      }
      sharedMap.set(RequestEvIsRewrite, true);
      return exit(new requestHandler$1.RewriteMessage(pathname2.replace(/\/+/g, "/")));
    },
    defer: (returnData) => {
      return typeof returnData === "function" ? returnData : () => returnData;
    },
    fail: (statusCode, data) => {
      check();
      status = statusCode;
      headers.delete("Cache-Control");
      return {
        failed: true,
        ...data
      };
    },
    text: (statusCode, text) => {
      headers.set("Content-Type", "text/plain; charset=utf-8");
      return send(statusCode, text);
    },
    html: (statusCode, html) => {
      headers.set("Content-Type", "text/html; charset=utf-8");
      return send(statusCode, html);
    },
    parseBody: async () => {
      if (requestData !== void 0) {
        return requestData;
      }
      return requestData = parseRequest(requestEv, sharedMap);
    },
    json: (statusCode, data) => {
      headers.set("Content-Type", "application/json; charset=utf-8");
      return send(statusCode, JSON.stringify(data));
    },
    send,
    isDirty: () => {
      return writableStream !== null;
    },
    getWritableStream: () => {
      if (writableStream === null) {
        if (serverRequestEv.mode === "dev") {
          const serverTiming = sharedMap.get(RequestEvShareServerTiming);
          if (serverTiming) {
            headers.set(
              "Server-Timing",
              serverTiming.map(([name, duration]) => `${name};dur=${duration}`).join(",")
            );
          }
        }
        writableStream = serverRequestEv.getWritableStream(
          status,
          headers,
          cookie,
          resolved,
          requestEv
        );
      }
      return writableStream;
    }
  };
  return Object.freeze(requestEv);
}
function getRequestLoaders(requestEv) {
  return requestEv[RequestEvLoaders];
}
function getRequestLoaderSerializationStrategyMap(requestEv) {
  return requestEv[RequestEvLoaderSerializationStrategyMap];
}
function getRequestRoute(requestEv) {
  return requestEv[RequestEvRoute];
}
function getRequestMode(requestEv) {
  return requestEv[RequestEvMode];
}
const ABORT_INDEX = Number.MAX_SAFE_INTEGER;
const parseRequest = async ({ request, method, query }, sharedMap) => {
  const type = request.headers.get("content-type")?.split(/[;,]/, 1)[0].trim() ?? "";
  if (type === "application/x-www-form-urlencoded" || type === "multipart/form-data") {
    const formData = await request.formData();
    sharedMap.set(RequestEvSharedActionFormData, formData);
    return formToObj(formData);
  } else if (type === "application/json") {
    const data = await request.json();
    return data;
  } else if (type === "application/qwik-json") {
    if (method === "GET" && query.has(routing.QDATA_KEY)) {
      const data = query.get(routing.QDATA_KEY);
      if (data) {
        try {
          return internal._deserialize(decodeURIComponent(data));
        } catch {
        }
      }
    }
    return internal._deserialize(await request.text());
  }
  return void 0;
};
const formToObj = (formData) => {
  const values = [...formData.entries()].reduce((values2, [name, value]) => {
    name.split(".").reduce((object, key, index, keys) => {
      if (key.endsWith("[]")) {
        const arrayKey = key.slice(0, -2);
        object[arrayKey] = object[arrayKey] || [];
        return object[arrayKey] = [...object[arrayKey], value];
      }
      if (index < keys.length - 1) {
        return object[key] = object[key] || (Number.isNaN(+keys[index + 1]) ? {} : []);
      }
      return object[key] = value;
    }, values2);
    return values2;
  }, {});
  return values;
};
function getQwikRouterServerData(requestEv) {
  const { params, request, status, locale, originalUrl } = requestEv;
  const requestHeaders = {};
  request.headers.forEach((value, key) => requestHeaders[key] = value);
  const action = requestEv.sharedMap.get(RequestEvSharedActionId);
  const formData = requestEv.sharedMap.get(RequestEvSharedActionFormData);
  const routeName = requestEv.sharedMap.get(RequestRouteName);
  const nonce = requestEv.sharedMap.get(RequestEvSharedNonce);
  const headers = requestEv.request.headers;
  const reconstructedUrl = new URL(originalUrl.pathname + originalUrl.search, originalUrl);
  const host = headers.get("X-Forwarded-Host");
  const protocol = headers.get("X-Forwarded-Proto");
  if (host) {
    reconstructedUrl.port = "";
    reconstructedUrl.host = host;
  }
  if (protocol) {
    reconstructedUrl.protocol = protocol;
  }
  const loaders = getRequestLoaders(requestEv);
  const loadersSerializationStrategy = getRequestLoaderSerializationStrategyMap(requestEv);
  return {
    url: reconstructedUrl.href,
    requestHeaders,
    locale: locale(),
    nonce,
    containerAttributes: {
      [routing.Q_ROUTE]: routeName
    },
    qwikrouter: {
      routeName,
      ev: requestEv,
      params: { ...params },
      loadedRoute: getRequestRoute(requestEv),
      response: {
        status: status(),
        loaders,
        loadersSerializationStrategy,
        action,
        formData
      }
    }
  };
}
const resolveRequestHandlers = (serverPlugins, route, method, checkOrigin, renderHandler, isInternal) => {
  const routeLoaders = [];
  const routeActions = [];
  const requestHandlers = [];
  const isPageRoute = !!(route && isLastModulePageRoute(route[types.LoadedRouteProp.Mods]));
  if (isInternal) {
    requestHandlers.push(handleQDataRedirect);
  }
  if (serverPlugins) {
    _resolveRequestHandlers(
      routeLoaders,
      routeActions,
      requestHandlers,
      serverPlugins,
      isPageRoute,
      method
    );
  }
  if (route) {
    const routeModules = route[types.LoadedRouteProp.Mods];
    _resolveRequestHandlers(
      routeLoaders,
      routeActions,
      requestHandlers,
      routeModules,
      isPageRoute,
      method
    );
    const routeName = route[types.LoadedRouteProp.RouteName];
    if (checkOrigin && (method === "POST" || method === "PUT" || method === "PATCH" || method === "DELETE")) {
      if (checkOrigin === "lax-proto") {
        requestHandlers.unshift(csrfLaxProtoCheckMiddleware);
      } else {
        requestHandlers.unshift(csrfCheckMiddleware);
      }
    }
    if (isPageRoute) {
      if (method === "POST" || method === "GET") {
        requestHandlers.push(runServerFunction);
      }
      requestHandlers.push(fixTrailingSlash);
      if (isInternal) {
        requestHandlers.push(renderQData);
      }
    }
    if (isPageRoute) {
      requestHandlers.push((ev) => {
        ev.sharedMap.set(RequestRouteName, routeName);
      });
      requestHandlers.push(actionsMiddleware(routeActions));
      requestHandlers.push(loadersMiddleware(routeLoaders));
      requestHandlers.push(renderHandler);
    }
  }
  return requestHandlers;
};
const _resolveRequestHandlers = (routeLoaders, routeActions, requestHandlers, routeModules, collectActions, method) => {
  for (const routeModule of routeModules) {
    if (typeof routeModule.onRequest === "function") {
      requestHandlers.push(routeModule.onRequest);
    } else if (Array.isArray(routeModule.onRequest)) {
      requestHandlers.push(...routeModule.onRequest);
    }
    let methodReqHandler;
    switch (method) {
      case "GET": {
        methodReqHandler = routeModule.onGet;
        break;
      }
      case "POST": {
        methodReqHandler = routeModule.onPost;
        break;
      }
      case "PUT": {
        methodReqHandler = routeModule.onPut;
        break;
      }
      case "PATCH": {
        methodReqHandler = routeModule.onPatch;
        break;
      }
      case "DELETE": {
        methodReqHandler = routeModule.onDelete;
        break;
      }
      case "OPTIONS": {
        methodReqHandler = routeModule.onOptions;
        break;
      }
      case "HEAD": {
        methodReqHandler = routeModule.onHead;
        break;
      }
    }
    if (typeof methodReqHandler === "function") {
      requestHandlers.push(methodReqHandler);
    } else if (Array.isArray(methodReqHandler)) {
      requestHandlers.push(...methodReqHandler);
    }
    if (collectActions) {
      for (const module2 of Object.values(routeModule)) {
        if (typeof module2 === "function") {
          if (module2.__brand === "server_loader") {
            routeLoaders.push(module2);
          } else if (module2.__brand === "server_action") {
            routeActions.push(module2);
          }
        }
      }
    }
  }
};
function actionsMiddleware(routeActions) {
  return async (requestEvent) => {
    const requestEv = requestEvent;
    if (requestEv.headersSent) {
      requestEv.exit();
      return;
    }
    const { method } = requestEv;
    const loaders = getRequestLoaders(requestEv);
    const isDev = getRequestMode(requestEv) === "dev";
    if (isDev && method === "GET") {
      if (requestEv.query.has(routing.QACTION_KEY)) {
        console.warn(
          'Seems like you are submitting a Qwik Action via GET request. Qwik Actions should be submitted via POST request.\nMake sure your <form> has method="POST" attribute, like this: <form method="POST">'
        );
      }
    }
    if (method === "POST") {
      const selectedActionId = requestEv.query.get(routing.QACTION_KEY);
      if (selectedActionId) {
        const serverActionsMap = globalThis._qwikActionsMap;
        const action = routeActions.find((action2) => action2.__id === selectedActionId) ?? serverActionsMap?.get(selectedActionId);
        if (action) {
          requestEv.sharedMap.set(RequestEvSharedActionId, selectedActionId);
          const data = await requestEv.parseBody();
          if (!data || typeof data !== "object") {
            throw new Error(
              `Expected request data for the action id ${selectedActionId} to be an object`
            );
          }
          const result = await runValidators(requestEv, action.__validators, data, isDev);
          if (!result.success) {
            loaders[selectedActionId] = requestEv.fail(result.status ?? 500, result.error);
          } else {
            const actionResolved = isDev ? await measure(
              requestEv,
              action.__qrl.getHash(),
              () => action.__qrl.call(requestEv, result.data, requestEv)
            ) : await action.__qrl.call(requestEv, result.data, requestEv);
            if (isDev) {
              verifySerializable(actionResolved, action.__qrl);
            }
            loaders[selectedActionId] = actionResolved;
          }
        }
      }
    }
  };
}
function loadersMiddleware(routeLoaders) {
  return async (requestEvent) => {
    const requestEv = requestEvent;
    if (requestEv.headersSent) {
      requestEv.exit();
      return;
    }
    const loaders = getRequestLoaders(requestEv);
    const isDev = getRequestMode(requestEv) === "dev";
    if (routeLoaders.length > 0) {
      const resolvedLoadersPromises = routeLoaders.map(
        (loader) => getRouteLoaderPromise(loader, loaders, requestEv, isDev)
      );
      await Promise.all(resolvedLoadersPromises);
    }
  };
}
async function getRouteLoaderPromise(loader, loaders, requestEv, isDev) {
  const loaderId = loader.__id;
  loaders[loaderId] = runValidators(
    requestEv,
    loader.__validators,
    void 0,
    // data
    isDev
  ).then((res) => {
    if (res.success) {
      if (isDev) {
        return measure(
          requestEv,
          loader.__qrl.getHash(),
          () => loader.__qrl.call(requestEv, requestEv)
        );
      } else {
        return loader.__qrl.call(requestEv, requestEv);
      }
    } else {
      return requestEv.fail(res.status ?? 500, res.error);
    }
  }).then((resolvedLoader) => {
    if (typeof resolvedLoader === "function") {
      loaders[loaderId] = resolvedLoader();
    } else {
      if (isDev) {
        verifySerializable(resolvedLoader, loader.__qrl);
      }
      loaders[loaderId] = resolvedLoader;
    }
    return resolvedLoader;
  });
  const loadersSerializationStrategy = getRequestLoaderSerializationStrategyMap(requestEv);
  loadersSerializationStrategy.set(loaderId, loader.__serializationStrategy);
  return loaders[loaderId];
}
async function runValidators(requestEv, validators, data, isDev) {
  let lastResult = {
    success: true,
    data
  };
  if (validators) {
    for (const validator of validators) {
      if (isDev) {
        lastResult = await measure(
          requestEv,
          `validator$`,
          () => validator.validate(requestEv, data)
        );
      } else {
        lastResult = await validator.validate(requestEv, data);
      }
      if (!lastResult.success) {
        return lastResult;
      } else {
        data = lastResult.data;
      }
    }
  }
  return lastResult;
}
function isAsyncIterator(obj) {
  return obj ? typeof obj === "object" && Symbol.asyncIterator in obj : false;
}
async function runServerFunction(ev) {
  const serverFnHash = ev.query.get(routing.QFN_KEY);
  if (serverFnHash && ev.request.headers.get("X-QRL") === serverFnHash && ev.request.headers.get("Content-Type") === "application/qwik-json") {
    ev.exit();
    const isDev = getRequestMode(ev) === "dev";
    const data = await ev.parseBody();
    if (Array.isArray(data)) {
      const qrl = core.inlinedQrl(null, serverFnHash, data[1]);
      let result;
      try {
        if (isDev) {
          result = await measure(
            ev,
            `server_${serverFnHash}`,
            () => qrl.apply(ev, data[0])
          );
        } else {
          result = await qrl.apply(ev, data[0]);
        }
      } catch (err) {
        if (err instanceof requestHandler$1.ServerError) {
          throw ev.error(err.status, err.data);
        }
        console.error(`Server function ${serverFnHash} failed:`, err);
        throw ev.error(500, "Invalid request");
      }
      if (isAsyncIterator(result)) {
        ev.headers.set("Content-Type", "text/qwik-json-stream");
        const writable = ev.getWritableStream();
        const stream = writable.getWriter();
        for await (const item of result) {
          if (isDev) {
            verifySerializable(item, qrl);
          }
          const message = await internal._serialize([item]);
          if (ev.signal.aborted) {
            break;
          }
          await stream.write(encoder.encode(`${message}
`));
        }
        stream.close();
      } else {
        verifySerializable(result, qrl);
        ev.headers.set("Content-Type", "application/qwik-json");
        const message = await internal._serialize([result]);
        ev.send(200, message);
      }
      return;
    }
    throw ev.error(500, "Invalid request");
  }
}
function fixTrailingSlash(ev) {
  const { basePathname, originalUrl, sharedMap } = ev;
  const { pathname, search } = originalUrl;
  const isQData = sharedMap.has(IsQData);
  if (!isQData && pathname !== basePathname && !pathname.endsWith(".html")) {
    if (!globalThis.__NO_TRAILING_SLASH__) {
      if (!pathname.endsWith("/")) {
        throw ev.redirect(HttpStatus.MovedPermanently, pathname + "/" + search);
      }
    } else {
      if (pathname.endsWith("/")) {
        throw ev.redirect(
          HttpStatus.MovedPermanently,
          pathname.slice(0, pathname.length - 1) + search
        );
      }
    }
  }
}
function verifySerializable(data, qrl) {
  try {
    internal._verifySerializable(data, void 0);
  } catch (e) {
    if (e instanceof Error && qrl.dev) {
      e.loc = qrl.dev;
    }
    throw e;
  }
}
function isLastModulePageRoute(routeModules) {
  const lastRouteModule = routeModules[routeModules.length - 1];
  return lastRouteModule && typeof lastRouteModule.default === "function";
}
function getPathname(url) {
  url = new URL(url);
  if (url.pathname.endsWith(QDATA_JSON)) {
    url.pathname = url.pathname.slice(0, -QDATA_JSON.length);
  }
  if (!globalThis.__NO_TRAILING_SLASH__) {
    if (!url.pathname.endsWith("/")) {
      url.pathname += "/";
    }
  } else {
    if (url.pathname.endsWith("/")) {
      url.pathname = url.pathname.slice(0, -1);
    }
  }
  const search = url.search.slice(1).replaceAll(/&?q(action|data|func|loaders)=[^&]+/g, "");
  return `${url.pathname}${search ? `?${search}` : ""}${url.hash}`;
}
const encoder = /* @__PURE__ */ new TextEncoder();
function csrfLaxProtoCheckMiddleware(requestEv) {
  checkCSRF(requestEv, "lax-proto");
}
function csrfCheckMiddleware(requestEv) {
  checkCSRF(requestEv);
}
function checkCSRF(requestEv, laxProto) {
  const isForm = isContentType(
    requestEv.request.headers,
    "application/x-www-form-urlencoded",
    "multipart/form-data",
    "text/plain"
  );
  if (isForm) {
    const inputOrigin = requestEv.request.headers.get("origin");
    const origin = requestEv.url.origin;
    let forbidden = inputOrigin !== origin;
    if (forbidden && laxProto && inputOrigin?.replace(/^http(s)?/g, "") === origin.replace(/^http(s)?/g, "")) {
      forbidden = false;
    }
    if (forbidden) {
      throw requestEv.error(
        403,
        `CSRF check failed. Cross-site ${requestEv.method} form submissions are forbidden.
The request origin "${inputOrigin}" does not match the server origin "${origin}".`
      );
    }
  }
}
function renderQwikMiddleware(render) {
  return async (requestEv) => {
    if (requestEv.headersSent) {
      return;
    }
    const isPageDataReq = requestEv.sharedMap.has(IsQData);
    if (isPageDataReq) {
      return;
    }
    requestEv.request.headers.forEach((value, key) => value);
    const responseHeaders = requestEv.headers;
    if (!responseHeaders.has("Content-Type")) {
      responseHeaders.set("Content-Type", "text/html; charset=utf-8");
    }
    const { readable, writable } = new TextEncoderStream();
    const writableStream = requestEv.getWritableStream();
    const pipe = readable.pipeTo(writableStream, { preventClose: true });
    const stream = writable.getWriter();
    const status = requestEv.status();
    try {
      const isStatic = getRequestMode(requestEv) === "static";
      const serverData = getQwikRouterServerData(requestEv);
      const result = await render({
        base: requestEv.basePathname + "build/",
        stream,
        serverData,
        containerAttributes: {
          ["q:render"]: isStatic ? "static" : "",
          ...serverData.containerAttributes
        }
      });
      const qData = {
        loaders: getRequestLoaders(requestEv),
        action: requestEv.sharedMap.get(RequestEvSharedActionId),
        status: status !== 200 ? status : 200,
        href: getPathname(requestEv.url)
      };
      if (typeof result.html === "string") {
        await stream.write(result.html);
      }
      requestEv.sharedMap.set(RequestEvShareQData, qData);
    } finally {
      await stream.ready;
      await stream.close();
      await pipe;
    }
    await writableStream.close();
  };
}
async function handleQDataRedirect(requestEv) {
  try {
    await requestEv.next();
  } catch (err) {
    if (!(err instanceof requestHandler$1.RedirectMessage)) {
      throw err;
    }
  }
  if (requestEv.headersSent) {
    return;
  }
  const status = requestEv.status();
  const location = requestEv.headers.get("Location");
  const isRedirect = status >= 301 && status <= 308 && location;
  if (isRedirect) {
    const adaptedLocation = makeQDataPath(location);
    if (adaptedLocation) {
      requestEv.headers.set("Location", adaptedLocation);
      requestEv.getWritableStream().close();
      return;
    } else {
      requestEv.status(200);
      requestEv.headers.delete("Location");
    }
  }
}
async function renderQData(requestEv) {
  await requestEv.next();
  if (requestEv.headersSent || requestEv.exited) {
    return;
  }
  const status = requestEv.status();
  const redirectLocation = requestEv.headers.get("Location");
  requestEv.request.headers.forEach((value, key) => value);
  requestEv.headers.set("Content-Type", "application/json; charset=utf-8");
  let loaders = getRequestLoaders(requestEv);
  const selectedLoaderIds = requestEv.query.getAll(routing.QLOADER_KEY);
  const hasCustomLoaders = selectedLoaderIds.length > 0;
  if (hasCustomLoaders) {
    const selectedLoaders = {};
    for (const loaderId of selectedLoaderIds) {
      const loader = loaders[loaderId];
      selectedLoaders[loaderId] = loader;
    }
    loaders = selectedLoaders;
  }
  const qData = hasCustomLoaders ? {
    // send minimal data to the client
    loaders,
    status: status !== 200 ? status : 200,
    href: getPathname(requestEv.url)
  } : {
    loaders,
    action: requestEv.sharedMap.get(RequestEvSharedActionId),
    status: status !== 200 ? status : 200,
    href: getPathname(requestEv.url),
    redirect: redirectLocation ?? void 0,
    isRewrite: requestEv.sharedMap.get(RequestEvIsRewrite)
  };
  const writer = requestEv.getWritableStream().getWriter();
  const data = await internal._serialize([qData]);
  writer.write(encoder.encode(data));
  requestEv.sharedMap.set(RequestEvShareQData, qData);
  writer.close();
}
function makeQDataPath(href) {
  if (href.startsWith("/")) {
    if (!href.includes(QDATA_JSON)) {
      const url = new URL(href, "http://localhost");
      const pathname = url.pathname.endsWith("/") ? url.pathname.slice(0, -1) : url.pathname;
      return pathname + QDATA_JSON + url.search;
    }
    return href;
  } else {
    return void 0;
  }
}
function now() {
  return typeof performance !== "undefined" ? performance.now() : 0;
}
async function measure(requestEv, name, fn) {
  const start = now();
  try {
    return await fn();
  } finally {
    const duration = now() - start;
    let measurements = requestEv.sharedMap.get(RequestEvShareServerTiming);
    if (!measurements) {
      requestEv.sharedMap.set(RequestEvShareServerTiming, measurements = []);
    }
    measurements.push([name, duration]);
  }
}
function isContentType(headers, ...types2) {
  const type = headers.get("content-type")?.split(/;/, 1)[0].trim() ?? "";
  return types2.includes(type);
}
exports._asyncRequestStore = void 0;
if (build.isServer) {
  import("node:async_hooks").then((module2) => {
    exports._asyncRequestStore = new module2.AsyncLocalStorage();
  }).catch((err) => {
    console.warn(
      "\n=====================\n  Qwik Router Warning:\n    AsyncLocalStorage is not available, continuing without it.\n    This impacts concurrent async server calls, where they lose access to the ServerRequestEv object.\n=====================\n\n",
      err
    );
  });
}
let qwikRouterConfigActual;
async function requestHandler(serverRequestEv, opts) {
  const { render, checkOrigin } = opts;
  let { qwikRouterConfig } = opts;
  if (!qwikRouterConfig) {
    if (!qwikRouterConfigActual) {
      qwikRouterConfigActual = await import("@qwik-router-config");
    }
    qwikRouterConfig = qwikRouterConfigActual;
  }
  if (!qwikRouterConfig) {
    throw new Error("qwikRouterConfig is required.");
  }
  const { pathname, isInternal } = getRouteMatchPathname(serverRequestEv.url.pathname);
  const routeAndHandlers = await loadRequestHandlers(
    qwikRouterConfig,
    pathname,
    serverRequestEv.request.method,
    checkOrigin ?? true,
    render,
    isInternal
  );
  if (routeAndHandlers) {
    const [route, requestHandlers] = routeAndHandlers;
    const rebuildRouteInfo = async (url) => {
      const { pathname: pathname2 } = getRouteMatchPathname(url.pathname);
      const routeAndHandlers2 = await loadRequestHandlers(
        qwikRouterConfig,
        pathname2,
        serverRequestEv.request.method,
        checkOrigin ?? true,
        render,
        isInternal
      );
      if (routeAndHandlers2) {
        const [loadedRoute, requestHandlers2] = routeAndHandlers2;
        return { loadedRoute, requestHandlers: requestHandlers2 };
      } else {
        return { loadedRoute: null, requestHandlers: [] };
      }
    };
    return runQwikRouter(
      serverRequestEv,
      route,
      requestHandlers,
      rebuildRouteInfo,
      qwikRouterConfig.basePathname
    );
  }
  return null;
}
async function loadRequestHandlers(qwikRouterConfig, pathname, method, checkOrigin, renderFn, isInternal) {
  const { routes, serverPlugins, menus, cacheModules } = qwikRouterConfig;
  const route = await routing.loadRoute(routes, menus, cacheModules, pathname, isInternal);
  const requestHandlers = resolveRequestHandlers(
    serverPlugins,
    route,
    method,
    checkOrigin,
    renderQwikMiddleware(renderFn),
    isInternal
  );
  if (requestHandlers.length > 0) {
    return [route, requestHandlers];
  }
  return null;
}
const notFounds = [
  // Will be replaced in post-build with the 404s generated by SSG
  "__QWIK_ROUTER_NOT_FOUND_ARRAY__"
];
function getNotFound(prefix) {
  for (const [path, html] of notFounds) {
    if (prefix.startsWith(path)) {
      return html;
    }
  }
  return errorHandler.minimalHtmlResponse(404, "Resource Not Found");
}
const staticPaths = /* @__PURE__ */ new Set(["__QWIK_ROUTER_STATIC_PATHS_ARRAY__"]);
function isStaticPath(method, url) {
  if (method.toUpperCase() !== "GET") {
    return false;
  }
  const p = url.pathname;
  if (p.startsWith("/" + (globalThis.__QWIK_BUILD_DIR__ || "build") + "/")) {
    return true;
  }
  if (p.startsWith("/" + (globalThis.__QWIK_ASSETS_DIR__ || "assets") + "/")) {
    return true;
  }
  if (staticPaths.has(p)) {
    return true;
  }
  if (p.endsWith("/q-data.json")) {
    const pWithoutQdata = p.replace(/\/q-data.json$/, "");
    if (staticPaths.has(pWithoutQdata + "/")) {
      return true;
    }
    if (staticPaths.has(pWithoutQdata)) {
      return true;
    }
  }
  return false;
}
class ServerError extends Error {
  constructor(status, data) {
    super(typeof data === "string" ? data : void 0);
    this.status = status;
    this.data = data;
  }
}
class AbortMessage {
}
class RedirectMessage extends AbortMessage {
}
class RewriteMessage extends AbortMessage {
  constructor(pathname) {
    super();
    this.pathname = pathname;
  }
}
class _TextEncoderStream_polyfill {
  constructor() {
    __privateAdd(this, _pendingHighSurrogate, null);
    __privateAdd(this, _handle, new TextEncoder());
    __privateAdd(this, _transform, new TransformStream({
      transform: (chunk, controller) => {
        chunk = String(chunk);
        let finalChunk = "";
        for (let i = 0; i < chunk.length; i++) {
          const item = chunk[i];
          const codeUnit = item.charCodeAt(0);
          if (__privateGet(this, _pendingHighSurrogate) !== null) {
            const highSurrogate = __privateGet(this, _pendingHighSurrogate);
            __privateSet(this, _pendingHighSurrogate, null);
            if (56320 <= codeUnit && codeUnit <= 57343) {
              finalChunk += highSurrogate + item;
              continue;
            }
            finalChunk += "�";
          }
          if (55296 <= codeUnit && codeUnit <= 56319) {
            __privateSet(this, _pendingHighSurrogate, item);
            continue;
          }
          if (56320 <= codeUnit && codeUnit <= 57343) {
            finalChunk += "�";
            continue;
          }
          finalChunk += item;
        }
        if (finalChunk) {
          controller.enqueue(__privateGet(this, _handle).encode(finalChunk));
        }
      },
      flush: (controller) => {
        if (__privateGet(this, _pendingHighSurrogate) !== null) {
          controller.enqueue(new Uint8Array([239, 191, 189]));
        }
      }
    }));
  }
  get encoding() {
    return __privateGet(this, _handle).encoding;
  }
  get readable() {
    return __privateGet(this, _transform).readable;
  }
  get writable() {
    return __privateGet(this, _transform).writable;
  }
  get [Symbol.toStringTag]() {
    return "TextEncoderStream";
  }
}
_pendingHighSurrogate = new WeakMap();
_handle = new WeakMap();
_transform = new WeakMap();
exports.getErrorHtml = errorHandler.getErrorHtml;
exports.AbortMessage = AbortMessage;
exports.RedirectMessage = RedirectMessage;
exports.RequestEvShareQData = RequestEvShareQData;
exports.RewriteMessage = RewriteMessage;
exports.ServerError = ServerError;
exports._TextEncoderStream_polyfill = _TextEncoderStream_polyfill;
exports.getNotFound = getNotFound;
exports.isStaticPath = isStaticPath;
exports.mergeHeadersCookies = mergeHeadersCookies;
exports.requestHandler = requestHandler;
