import fs from "node:fs";
import { isAbsolute, resolve, extname, join, dirname, relative } from "node:path";
import { cpus } from "node:os";
import { Worker, parentPort, isMainThread, workerData, threadId } from "node:worker_threads";
import { l as normalizePath, w as msToString, x as getPathnameForDynamicRoute } from "./fs.mjs";
import { bold, green, dim, red, magenta } from "kleur/colors";
import { pathToFileURL } from "node:url";
import { buildErrorMessage } from "vite";
import { f as formatError } from "./format-error.mjs";
import { getErrorHtml, RequestEvShareQData, requestHandler, RedirectMessage } from "@qwik.dev/router/middleware/request-handler";
import { R as RouteDataProp } from "./types.qwik.mjs";
import { _serialize } from "@qwik.dev/core/internal";
import { WritableStream } from "node:stream/web";
async function createNodeMainProcess(sys, opts) {
  const ssgWorkers = [];
  const sitemapBuffer = [];
  let sitemapPromise = null;
  opts = { ...opts };
  let outDir = opts.outDir;
  if (typeof outDir !== "string") {
    throw new Error(`Missing "outDir" option`);
  }
  if (!isAbsolute(outDir)) {
    throw new Error(`"outDir" must be an absolute file path, received: ${outDir}`);
  }
  outDir = normalizePath(outDir);
  let maxWorkers = cpus().length;
  if (typeof opts.maxWorkers === "number") {
    maxWorkers = Math.max(1, Math.min(opts.maxWorkers, maxWorkers));
  }
  let maxTasksPerWorker = 20;
  if (typeof opts.maxTasksPerWorker === "number") {
    maxTasksPerWorker = Math.max(1, Math.min(opts.maxTasksPerWorker, 50));
  }
  let sitemapOutFile = opts.sitemapOutFile;
  if (sitemapOutFile !== null) {
    if (typeof sitemapOutFile !== "string") {
      sitemapOutFile = "sitemap.xml";
    }
    if (!isAbsolute(sitemapOutFile)) {
      sitemapOutFile = resolve(outDir, sitemapOutFile);
    }
  }
  const createWorker = () => {
    let terminateResolve = null;
    const mainTasks = /* @__PURE__ */ new Map();
    let workerFilePath;
    let terminateTimeout = null;
    if (typeof __filename === "string") {
      const ext = extname(__filename) || ".js";
      workerFilePath = join(dirname(__filename), `index${ext}`);
    } else {
      const thisUrl = new URL(import.meta.url);
      const pathname = thisUrl.pathname || "";
      let ext = ".js";
      if (pathname.endsWith(".ts")) {
        ext = ".ts";
      } else if (pathname.endsWith(".mjs")) {
        ext = ".mjs";
      }
      workerFilePath = new URL(`./index${ext}`, thisUrl);
    }
    const nodeWorker = new Worker(workerFilePath, { workerData: opts });
    nodeWorker.unref();
    const ssgWorker = {
      activeTasks: 0,
      totalTasks: 0,
      render: (staticRoute) => {
        return new Promise((resolve2, reject) => {
          try {
            ssgWorker.activeTasks++;
            ssgWorker.totalTasks++;
            mainTasks.set(staticRoute.pathname, resolve2);
            nodeWorker.postMessage(staticRoute);
          } catch (e) {
            ssgWorker.activeTasks--;
            mainTasks.delete(staticRoute.pathname);
            reject(e);
          }
        });
      },
      terminate: async () => {
        mainTasks.clear();
        const msg = { type: "close" };
        await new Promise((resolve2) => {
          terminateResolve = resolve2;
          nodeWorker.postMessage(msg);
        });
        terminateTimeout = setTimeout(async () => {
          await nodeWorker.terminate();
        }, 1e3);
      }
    };
    nodeWorker.on("message", (msg) => {
      switch (msg.type) {
        case "render": {
          const mainTask = mainTasks.get(msg.pathname);
          if (mainTask) {
            mainTasks.delete(msg.pathname);
            ssgWorker.activeTasks--;
            mainTask(msg);
          }
          break;
        }
        case "close": {
          if (terminateResolve) {
            terminateResolve();
            terminateResolve = null;
          }
          break;
        }
      }
    });
    nodeWorker.on("error", (e) => {
      console.error(`worker error`, e);
    });
    nodeWorker.on("exit", (code) => {
      if (terminateTimeout) {
        clearTimeout(terminateTimeout);
        terminateTimeout = null;
      }
      if (code !== 0) {
        console.error(`worker exit ${code}`);
      }
    });
    return ssgWorker;
  };
  const getNextWorker = () => ssgWorkers.sort(ssgWorkerCompare)[0];
  const hasAvailableWorker = () => {
    const ssgWorker = getNextWorker();
    return ssgWorker.activeTasks < maxTasksPerWorker;
  };
  const render = async (ssgRoute) => {
    const ssgWorker = getNextWorker();
    const result = await ssgWorker.render(ssgRoute);
    if (sitemapOutFile && result.ok && result.resourceType === "page") {
      sitemapBuffer.push(`<url><loc>${result.url}</loc></url>`);
      if (sitemapBuffer.length > 50) {
        if (sitemapPromise) {
          await sitemapPromise;
        }
        const siteMapUrls = sitemapBuffer.join("\n") + "\n";
        sitemapBuffer.length = 0;
        sitemapPromise = fs.promises.appendFile(sitemapOutFile, siteMapUrls);
      }
    }
    return result;
  };
  const close = async () => {
    const promises = [];
    if (sitemapOutFile) {
      if (sitemapPromise) {
        await sitemapPromise;
      }
      sitemapBuffer.push(`</urlset>`);
      promises.push(fs.promises.appendFile(sitemapOutFile, sitemapBuffer.join("\n")));
      sitemapBuffer.length = 0;
    }
    for (const ssgWorker of ssgWorkers) {
      try {
        promises.push(ssgWorker.terminate());
      } catch (e) {
        console.error(e);
      }
    }
    await Promise.all(promises);
    ssgWorkers.length = 0;
    if (process.platform === "win32") {
      await new Promise((resolve2) => setTimeout(resolve2, 300));
    }
  };
  if (sitemapOutFile) {
    await ensureDir(sitemapOutFile);
    await fs.promises.writeFile(
      sitemapOutFile,
      `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
`
    );
  }
  for (let i = 0; i < maxWorkers; i++) {
    ssgWorkers.push(createWorker());
    if (process.platform === "win32" && i < maxWorkers - 1) {
      await new Promise((resolve2) => setTimeout(resolve2, 100));
    }
  }
  const mainCtx = {
    hasAvailableWorker,
    render,
    close
  };
  return mainCtx;
}
function ssgWorkerCompare(a, b) {
  if (a.activeTasks < b.activeTasks) {
    return -1;
  }
  if (a.activeTasks > b.activeTasks) {
    return 1;
  }
  return a.totalTasks < b.totalTasks ? -1 : 1;
}
async function createNodeWorkerProcess(onMessage) {
  parentPort?.on("message", async (msg) => {
    parentPort?.postMessage(await onMessage(msg));
    if (msg.type === "close") {
      parentPort?.close();
    }
  });
}
async function createSystem(opts, threadId2) {
  const createWriteStream = (filePath) => {
    return fs.createWriteStream(filePath, {
      flags: "w"
    });
  };
  const NS_PER_SEC = 1e9;
  const MS_PER_NS = 1e-6;
  const createTimer = () => {
    const start = process.hrtime();
    return () => {
      const diff = process.hrtime(start);
      return (diff[0] * NS_PER_SEC + diff[1]) * MS_PER_NS;
    };
  };
  const createLogger = async () => {
    if (threadId2 !== void 0) {
      return {
        debug: opts.log === "debug" ? console.debug.bind(console, `[${threadId2}]`) : () => {
        },
        error: console.error.bind(console, `[${threadId2}]`),
        info: console.info.bind(console, `[${threadId2}]`)
      };
    }
    return {
      debug: opts.log === "debug" ? console.debug.bind(console) : () => {
      },
      error: console.error.bind(console),
      info: console.info.bind(console)
    };
  };
  const outDir = normalizePath(opts.outDir);
  const basePathname = opts.basePathname || "/";
  const basenameLen = basePathname.length;
  const getRouteFilePath = (pathname, isHtml) => {
    pathname = pathname.slice(basenameLen);
    if (isHtml) {
      if (!pathname.endsWith(".html")) {
        if (pathname.endsWith("/")) {
          pathname += "index.html";
        } else {
          pathname += "/index.html";
        }
      }
    } else {
      if (pathname.endsWith("/")) {
        pathname = pathname.slice(0, -1);
      }
    }
    return join(outDir, pathname);
  };
  const getDataFilePath = (pathname) => {
    pathname = pathname.slice(basenameLen);
    if (pathname.endsWith("/")) {
      pathname += "q-data.json";
    } else {
      pathname += "/q-data.json";
    }
    return join(outDir, pathname);
  };
  const sys = {
    createMainProcess: null,
    createWorkerProcess: createNodeWorkerProcess,
    createLogger,
    getOptions: () => opts,
    ensureDir,
    createWriteStream,
    createTimer,
    access,
    getRouteFilePath,
    getDataFilePath,
    getEnv: (key) => process.env[key],
    platform: {
      static: true,
      node: process.versions.node
    }
  };
  sys.createMainProcess = () => createNodeMainProcess(sys, opts);
  return sys;
}
const ensureDir = async (filePath) => {
  await fs.promises.mkdir(dirname(filePath), { recursive: true });
};
const access = async (path) => {
  try {
    await fs.promises.access(path);
    return true;
  } catch {
    return false;
  }
};
function extractParamNames(routeName) {
  const params = [];
  let idx = 0;
  while (idx < routeName.length) {
    const start = routeName.indexOf("[", idx);
    if (start !== -1) {
      const end = routeName.indexOf("]", start);
      const param = routeName.slice(start + 1, end);
      params.push(param.startsWith("...") ? param.substring(3) : param);
      idx = end + 1;
    } else {
      idx = routeName.length;
    }
  }
  return params;
}
async function generateNotFoundPages(sys, opts, routes) {
  if (opts.emit404Pages !== false) {
    const basePathname = opts.basePathname || "/";
    const rootNotFoundPathname = basePathname + "404.html";
    const hasRootNotFound = routes.some(
      (r) => r[RouteDataProp.OriginalPathname] === rootNotFoundPathname
    );
    if (!hasRootNotFound) {
      const filePath = sys.getRouteFilePath(rootNotFoundPathname, true);
      const html = getErrorHtml(404, "Resource Not Found");
      await sys.ensureDir(filePath);
      return new Promise((resolve2) => {
        const writer = sys.createWriteStream(filePath);
        writer.write(html);
        writer.end(resolve2);
      });
    }
  }
}
function createRouteTester(basePathname, includeRoutes, excludeRoutes) {
  const includes = routesToRegExps(includeRoutes);
  const excludes = routesToRegExps(excludeRoutes);
  return (pathname) => {
    if (pathname.endsWith("404.html")) {
      return true;
    }
    if (basePathname !== "/") {
      pathname = pathname.slice(basePathname.length - 1);
    }
    for (const exclude of excludes) {
      if (exclude.test(pathname)) {
        return false;
      }
    }
    for (const include of includes) {
      if (include.test(pathname)) {
        return true;
      }
    }
    return false;
  };
}
function routesToRegExps(routes) {
  if (!Array.isArray(routes)) {
    return [];
  }
  return routes.filter((r) => typeof r === "string").map(routeToRegExp);
}
function routeToRegExp(rule) {
  let transformedRule;
  if (rule === "/" || rule === "/*") {
    transformedRule = rule;
  } else if (rule.endsWith("/*")) {
    transformedRule = `${rule.substring(0, rule.length - 2)}(/*)?`;
  } else if (rule.endsWith("/")) {
    transformedRule = `${rule.substring(0, rule.length - 1)}(/)?`;
  } else if (rule.endsWith("*")) {
    transformedRule = rule;
  } else {
    transformedRule = `${rule}(/)?`;
  }
  transformedRule = `^${transformedRule.replace(/\*/g, ".*")}$`;
  return new RegExp(transformedRule);
}
async function mainThread(sys) {
  const opts = sys.getOptions();
  validateOptions(opts);
  const main = await sys.createMainProcess();
  const log = await sys.createLogger();
  log.info("\n" + bold(green("Starting Qwik Router SSG...")));
  const qwikRouterConfig = (await import(pathToFileURL(opts.qwikRouterConfigModulePath).href)).default;
  const queue = [];
  const active = /* @__PURE__ */ new Set();
  const routes = qwikRouterConfig.routes || [];
  const trailingSlash = !!qwikRouterConfig.trailingSlash;
  const includeRoute = createRouteTester(opts.basePathname || "/", opts.include, opts.exclude);
  return new Promise((resolve2, reject) => {
    try {
      const timer = sys.createTimer();
      const generatorResult = {
        duration: 0,
        rendered: 0,
        errors: 0,
        staticPaths: []
      };
      let isCompleted = false;
      let isRoutesLoaded = false;
      const completed = async () => {
        const closePromise = main.close();
        await generateNotFoundPages(sys, opts, routes);
        generatorResult.duration = timer();
        if (generatorResult.errors === 0) {
          log.info(`
${green("SSG results")}`);
          if (generatorResult.rendered > 0) {
            log.info(
              `- Generated: ${dim(
                `${generatorResult.rendered} page${generatorResult.rendered === 1 ? "" : "s"}`
              )}`
            );
          }
          log.info(`- Duration: ${dim(msToString(generatorResult.duration))}`);
          const total = generatorResult.rendered + generatorResult.errors;
          if (total > 0) {
            log.info(
              `- Average: ${dim(msToString(generatorResult.duration / total) + " per page")}`
            );
          }
          log.info(``);
        }
        closePromise.then(() => {
          setTimeout(() => resolve2(generatorResult));
        }).catch(reject);
      };
      const next = () => {
        while (!isCompleted && main.hasAvailableWorker() && queue.length > 0) {
          const staticRoute = queue.shift();
          if (staticRoute) {
            render(staticRoute).catch((e) => {
              console.error(`render failed for ${staticRoute.pathname}`, e);
            });
          }
        }
        if (!isCompleted && isRoutesLoaded && queue.length === 0 && active.size === 0) {
          isCompleted = true;
          completed().catch((e) => {
            console.error("SSG completion failed", e);
          });
        }
      };
      let isPendingDrain = false;
      const flushQueue = () => {
        if (!isPendingDrain) {
          isPendingDrain = true;
          setTimeout(() => {
            isPendingDrain = false;
            next();
          });
        }
      };
      const render = async (staticRoute) => {
        try {
          active.add(staticRoute.pathname);
          const result = await main.render({ type: "render", ...staticRoute });
          active.delete(staticRoute.pathname);
          if (result.error) {
            const err = new Error(result.error.message);
            err.stack = result.error.stack;
            log.error(`
${bold(red(`!!! ${result.pathname}: Error during SSG`))}`);
            log.error(red(err.message));
            log.error(`  Pathname: ${magenta(staticRoute.pathname)}`);
            Object.assign(formatError(err), {
              plugin: "qwik-ssg"
            });
            log.error(buildErrorMessage(err));
            generatorResult.errors++;
          }
          if (result.filePath != null) {
            generatorResult.rendered++;
            generatorResult.staticPaths.push(result.pathname);
            const base = opts.rootDir ?? opts.outDir;
            const path = relative(base, result.filePath);
            const lastSlash = path.lastIndexOf("/");
            log.info(`${dim(path.slice(0, lastSlash + 1))}${path.slice(lastSlash + 1)}`);
          }
          flushQueue();
        } catch (e) {
          console.error(`render failed for ${staticRoute.pathname}`, e);
          isCompleted = true;
          reject(e);
        }
      };
      const addToQueue = (pathname, params) => {
        if (pathname) {
          pathname = new URL(pathname, `https://qwik.dev`).pathname;
          if (pathname !== opts.basePathname) {
            if (trailingSlash) {
              if (!pathname.endsWith("/")) {
                const segments = pathname.split("/");
                const lastSegment = segments[segments.length - 1];
                if (!lastSegment.includes(".")) {
                  pathname += "/";
                }
              }
            } else {
              if (pathname.endsWith("/")) {
                pathname = pathname.slice(0, pathname.length - 1);
              }
            }
          }
          if (includeRoute(pathname) && !queue.some((s) => s.pathname === pathname)) {
            queue.push({
              pathname,
              params
            });
            flushQueue();
          }
        }
      };
      const loadStaticRoute = async (route) => {
        const [routeName, loaders, originalPathname] = route;
        const modules = await Promise.all(loaders.map((loader) => loader()));
        const pageModule = modules[modules.length - 1];
        const paramNames = extractParamNames(routeName);
        const isValidStaticModule = pageModule && (pageModule.default || pageModule.onRequest || pageModule.onGet);
        if (isValidStaticModule) {
          if (Array.isArray(paramNames) && paramNames.length > 0) {
            if (typeof pageModule.onStaticGenerate === "function" && paramNames.length > 0) {
              const staticGenerate = await pageModule.onStaticGenerate({
                env: {
                  get(key) {
                    return sys.getEnv(key);
                  }
                }
              });
              if (Array.isArray(staticGenerate.params)) {
                for (const params of staticGenerate.params) {
                  const pathname = getPathnameForDynamicRoute(
                    originalPathname,
                    paramNames,
                    params
                  );
                  addToQueue(pathname, params);
                }
              }
            }
          } else {
            addToQueue(originalPathname, void 0);
          }
        }
      };
      const loadStaticRoutes = async () => {
        await Promise.all(routes.map(loadStaticRoute));
        isRoutesLoaded = true;
        flushQueue();
      };
      loadStaticRoutes().catch((e) => {
        console.error("SSG route loading failed", e);
        reject(e);
      });
    } catch (e) {
      console.error("SSG main thread failed", e);
      reject(e);
    }
  });
}
function validateOptions(opts) {
  if (!opts.qwikRouterConfigModulePath) {
    if (!opts.qwikCityPlanModulePath) {
      throw new Error(`Missing "qwikRouterConfigModulePath" option`);
    } else {
      console.warn(
        "`qwikCityPlanModulePath` is deprecated. Use `qwikRouterConfigModulePath` instead."
      );
    }
  }
  if (!opts.renderModulePath) {
    throw new Error(`Missing "renderModulePath" option`);
  }
  let siteOrigin = opts.origin;
  if (typeof siteOrigin !== "string" || siteOrigin.trim().length === 0) {
    throw new Error(`Missing "origin" option`);
  }
  siteOrigin = siteOrigin.trim();
  if (!/:\/\//.test(siteOrigin) || siteOrigin.startsWith("://")) {
    throw new Error(
      `"origin" must start with a valid protocol, such as "https://" or "http://", received "${siteOrigin}"`
    );
  }
  try {
    new URL(siteOrigin);
  } catch (e) {
    throw new Error(`Invalid "origin"`, { cause: e });
  }
}
async function workerThread(sys) {
  delete globalThis.__qwik;
  const ssgOpts = sys.getOptions();
  const pendingPromises = /* @__PURE__ */ new Set();
  const log = await sys.createLogger();
  const opts = {
    ...ssgOpts,
    // TODO export this from server
    render: (await import(pathToFileURL(ssgOpts.renderModulePath).href)).default,
    // TODO this should be built-in
    qwikRouterConfig: (await import(pathToFileURL(ssgOpts.qwikRouterConfigModulePath).href)).default
  };
  sys.createWorkerProcess(async (msg) => {
    switch (msg.type) {
      case "render": {
        log.debug(`Worker thread rendering: ${msg.pathname}`);
        return new Promise((resolve2) => {
          workerRender(sys, opts, msg, pendingPromises, resolve2).catch((e) => {
            console.error("Error during render", msg.pathname, e);
          });
        });
      }
      case "close": {
        if (pendingPromises.size) {
          log.debug(`Worker thread closing, waiting for ${pendingPromises.size} pending renders`);
          const promises = Array.from(pendingPromises);
          pendingPromises.clear();
          await Promise.all(promises);
        }
        log.debug(`Worker thread closed`);
        return { type: "close" };
      }
    }
  })?.catch((e) => {
    console.error("Worker process creation failed", e);
  });
}
async function workerRender(sys, opts, staticRoute, pendingPromises, callback) {
  const url = new URL(staticRoute.pathname, opts.origin);
  const result = {
    type: "render",
    pathname: staticRoute.pathname,
    url: url.href,
    ok: false,
    error: null,
    filePath: null,
    contentType: null,
    resourceType: null
  };
  try {
    let routeWriter = null;
    let closeResolved;
    const closePromise = new Promise((closePromiseResolve) => {
      closeResolved = closePromiseResolve;
    });
    const request = new Request(url);
    const requestCtx = {
      mode: "static",
      locale: void 0,
      url,
      request,
      env: {
        get(key) {
          return sys.getEnv(key);
        }
      },
      platform: sys.platform,
      getClientConn: () => {
        return {};
      },
      getWritableStream: (status, headers, _, _r, requestEv) => {
        result.ok = status >= 200 && status < 300;
        if (!result.ok) {
          return noopWritableStream;
        }
        result.contentType = (headers.get("Content-Type") || "").toLowerCase();
        const isHtml = result.contentType.includes("text/html");
        const is404ErrorPage = url.pathname.endsWith("/404.html");
        const routeFilePath = sys.getRouteFilePath(url.pathname, isHtml);
        if (is404ErrorPage) {
          result.resourceType = "404";
        } else if (isHtml) {
          result.resourceType = "page";
        }
        const hasRouteWriter = isHtml ? opts.emitHtml !== false : true;
        const writeQDataEnabled = isHtml && opts.emitData !== false;
        const stream = new WritableStream({
          async start() {
            try {
              if (hasRouteWriter || writeQDataEnabled) {
                await sys.ensureDir(routeFilePath);
              }
              if (hasRouteWriter) {
                routeWriter = sys.createWriteStream(routeFilePath);
                routeWriter.on("error", (e) => {
                  console.error(e);
                  routeWriter = null;
                  result.error = {
                    message: e.message,
                    stack: e.stack
                  };
                });
              }
            } catch (e) {
              console.error("Error during stream start", staticRoute.pathname, e);
              routeWriter = null;
              result.error = {
                message: String(e),
                stack: e.stack || ""
              };
            }
          },
          write(chunk) {
            try {
              if (routeWriter) {
                routeWriter.write(Buffer.from(chunk.buffer));
              }
            } catch (e) {
              console.error("Error during stream write", staticRoute.pathname, e);
              routeWriter = null;
              result.error = {
                message: String(e),
                stack: e.stack || ""
              };
            }
          },
          async close() {
            const writePromises = [];
            try {
              if (writeQDataEnabled) {
                const qData = requestEv.sharedMap.get(RequestEvShareQData);
                if (qData && !is404ErrorPage) {
                  const qDataFilePath = sys.getDataFilePath(url.pathname);
                  const dataWriter = sys.createWriteStream(qDataFilePath);
                  dataWriter.on("error", (e) => {
                    console.error(e);
                    result.error = {
                      message: e.message,
                      stack: e.stack
                    };
                  });
                  const serialized = await _serialize([qData]);
                  dataWriter.write(serialized);
                  writePromises.push(
                    new Promise((resolve2) => {
                      result.filePath = routeFilePath;
                      dataWriter.end(resolve2);
                    })
                  );
                }
              }
              if (routeWriter) {
                writePromises.push(
                  new Promise((resolve2) => {
                    result.filePath = routeFilePath;
                    routeWriter.end(resolve2);
                  }).finally(closeResolved)
                );
              }
              if (writePromises.length > 0) {
                await Promise.all(writePromises);
              }
            } catch (e) {
              console.error("Error during stream close", staticRoute.pathname, e);
              routeWriter = null;
              result.error = {
                message: String(e),
                stack: e.stack || ""
              };
            }
          }
        });
        return stream;
      }
    };
    const promise = requestHandler(requestCtx, opts).then((rsp) => {
      if (rsp != null) {
        return rsp.completion.then((r) => {
          if (routeWriter) {
            return closePromise.then(() => r);
          }
          return r;
        });
      }
    }).then((e) => {
      if (e !== void 0) {
        if (e instanceof RedirectMessage) {
          return;
        }
        if (e instanceof Error) {
          result.error = {
            message: e.message,
            stack: e.stack
          };
        } else {
          result.error = {
            message: String(e),
            stack: void 0
          };
        }
        console.error("Error during request handling", staticRoute.pathname, e);
      }
    }).catch((e) => {
      console.error("Unhandled error during request handling", staticRoute.pathname, e);
      result.error = {
        message: String(e),
        stack: e.stack || ""
      };
    }).finally(() => {
      pendingPromises.delete(promise);
      callback(result);
    });
    pendingPromises.add(promise);
  } catch (e) {
    console.error("Error during render", staticRoute.pathname, e);
    if (e instanceof Error) {
      result.error = {
        message: e.message,
        stack: e.stack
      };
    } else {
      result.error = {
        message: String(e),
        stack: void 0
      };
    }
    callback(result);
  }
}
const noopWriter = {
  closed: Promise.resolve(void 0),
  ready: Promise.resolve(void 0),
  desiredSize: 0,
  async close() {
  },
  async abort() {
  },
  async write() {
  },
  releaseLock() {
  }
};
const noopWritableStream = {
  get locked() {
    return false;
  },
  set locked(_) {
  },
  async abort() {
  },
  async close() {
  },
  getWriter() {
    return noopWriter;
  }
};
async function generate(opts) {
  if (isMainThread) {
    const sys = await createSystem(opts);
    const result = await mainThread(sys);
    return result;
  }
  throw new Error(`generate() cannot be called from a worker thread`);
}
if (!isMainThread && workerData) {
  const opts = workerData;
  (async () => {
    try {
      if (opts.log === "debug") {
        console.debug(`Worker thread starting (ID: ${threadId})`);
      }
      const sys = await createSystem(opts, threadId);
      await workerThread(sys);
    } catch (error) {
      console.error(`Error occurred in worker thread (ID: ${threadId}): ${error}`);
    }
  })().catch((e) => {
    console.error(e);
  });
}
export {
  generate
};
