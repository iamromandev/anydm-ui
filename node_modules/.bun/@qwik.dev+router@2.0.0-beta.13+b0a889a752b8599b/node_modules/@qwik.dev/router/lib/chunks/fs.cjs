"use strict";
const path = require("node:path");
function toTitleCase(str) {
  return str.replace(/\w\S*/g, (txt) => {
    return txt.charAt(0).toUpperCase() + txt.slice(1).toLowerCase();
  });
}
function addError(ctx, e) {
  ctx.diagnostics.push({
    type: "error",
    message: e ? String(e.stack || e) : "Error"
  });
}
function addWarning(ctx, message) {
  ctx.diagnostics.push({
    type: "warn",
    message: String(message)
  });
}
function msToString(ms) {
  if (ms < 1) {
    return ms.toFixed(2) + " ms";
  }
  if (ms < 1e3) {
    return ms.toFixed(1) + " ms";
  }
  if (ms < 6e4) {
    return (ms / 1e3).toFixed(1) + " s";
  }
  return (ms / 6e4).toFixed(1) + " m";
}
function normalizePathname(pathname, basePathname) {
  if (typeof pathname === "string") {
    pathname = pathname.trim();
    if (pathname !== "") {
      try {
        pathname = pathname.replace(/\/+/g, "/");
        if (pathname.startsWith("/")) {
          pathname = pathname.slice(1);
        }
        pathname = new URL(basePathname + pathname, `https://qwik.dev`).pathname;
        if (pathname !== basePathname) {
          if (!globalThis.__NO_TRAILING_SLASH__) {
            if (!pathname.endsWith("/")) {
              const segments = pathname.split("/");
              const lastSegment = segments[segments.length - 1];
              if (!lastSegment.includes(".")) {
                pathname += "/";
              }
            }
          } else {
            if (pathname.endsWith("/")) {
              pathname = pathname.slice(0, pathname.length - 1);
            }
          }
        }
        return pathname;
      } catch (e) {
        console.error(e);
      }
    }
  }
  return null;
}
function getPathnameForDynamicRoute(originalPathname, paramNames, params) {
  let pathname = originalPathname;
  if (paramNames && params) {
    for (const paramName of paramNames) {
      const paramKey = `[${paramName}]`;
      const restParamKey = `[...${paramName}]`;
      const paramValue = params[paramName];
      pathname = pathname.replace(restParamKey, paramValue);
      pathname = pathname.replace(paramKey, paramValue);
    }
  }
  return pathname;
}
function isSameOriginUrl(url) {
  if (typeof url === "string") {
    url = url.trim();
    if (url !== "") {
      const firstChar = url.charAt(0);
      if (firstChar !== "/" && firstChar !== ".") {
        if (firstChar === "#") {
          return false;
        }
        const i = url.indexOf(":");
        if (i > -1) {
          const protocol = url.slice(0, i).toLowerCase();
          return !PROTOCOLS[protocol];
        }
      }
      return true;
    }
  }
  return false;
}
const PROTOCOLS = {
  https: true,
  http: true,
  about: true,
  javascript: true,
  file: true
};
function parseRouteIndexName(extlessName) {
  let layoutName = "";
  const layoutStop = extlessName.endsWith("!");
  if (layoutStop) {
    extlessName = extlessName.slice(0, extlessName.length - 1);
  }
  const namedLayoutParts = extlessName.split("@");
  if (namedLayoutParts.length > 1) {
    namedLayoutParts.shift();
    layoutName = namedLayoutParts.join("@");
  }
  return { layoutName, layoutStop };
}
function getPathnameFromDirPath(opts, dirPath) {
  const relFilePath = path.relative(opts.routesDir, dirPath);
  let pathname = normalizePath(relFilePath);
  pathname = normalizePathname(pathname, opts.basePathname).split("/").filter((segment) => !isGroupedLayoutName(segment)).join("/");
  if (pathname === "") {
    return "/";
  }
  return pathname;
}
function getMenuPathname(opts, filePath) {
  let pathname = normalizePath(path.relative(opts.routesDir, filePath));
  pathname = `/` + normalizePath(path.dirname(pathname));
  let result = normalizePathname(pathname, opts.basePathname);
  if (!result.endsWith("/")) {
    result += "/";
  }
  return result;
}
function getExtension(fileName) {
  if (typeof fileName === "string") {
    const parts = fileName.trim().toLowerCase().split(".");
    if (parts.length > 1) {
      const ext = parts.pop().split("?")[0].split("#")[0];
      if (ext === "ts" && parts.pop() === "d") {
        return ".d.ts";
      }
      return "." + ext;
    }
  }
  return "";
}
function removeExtension(fileName) {
  if (typeof fileName === "string") {
    fileName = fileName.trim();
    const ext = getExtension(fileName);
    return fileName.slice(0, fileName.length - ext.length);
  }
  return "";
}
function normalizePath(path$1) {
  return normalizePathSlash(path.normalize(path$1));
}
function normalizePathSlash(path2) {
  const isExtendedLengthPath = path2.startsWith("\\\\?\\");
  const hasNonAscii = /[^\u0000-\u0080]+/.test(path2);
  if (isExtendedLengthPath || hasNonAscii) {
    return path2;
  }
  path2 = path2.replace(/\\/g, "/");
  if (path2.endsWith("/")) {
    path2 = path2.slice(0, path2.length - 1);
  }
  return path2;
}
function createFileId(routesDir, fsPath, explicitFileType) {
  const ids = [];
  for (let i = 0; i < 25; i++) {
    let baseName = removeExtension(path.basename(fsPath));
    baseName = baseName.replace(/[\W_]+/g, "");
    if (baseName === "") {
      baseName = "Q" + i;
    } else if (!isNaN(baseName.charAt(0))) {
      baseName = "Q" + baseName;
    }
    ids.push(toTitleCase(baseName));
    fsPath = normalizePath(path.dirname(fsPath));
    if (fsPath === routesDir) {
      break;
    }
  }
  if (ids.length > 1 && ids[0] === "Index") {
    ids.shift();
  }
  return ids.reverse().join("").concat(explicitFileType || "");
}
const PAGE_MODULE_EXTS = {
  ".tsx": true,
  ".jsx": true
};
const MODULE_EXTS = {
  ".ts": true,
  ".js": true
};
const MARKDOWN_EXTS = {
  ".md": true,
  ".mdx": true
};
function isIndexModule(extlessName) {
  return /^index(|!|@.+)$/.test(extlessName);
}
function isPluginModule(extlessName) {
  return /^plugin(|@.+)$/.test(extlessName);
}
function isLayoutModule(extlessName) {
  return /^layout(|!|-.+)$/.test(extlessName);
}
function isPageModuleExt(ext) {
  return ext in PAGE_MODULE_EXTS;
}
function isModuleExt(ext) {
  return ext in MODULE_EXTS;
}
function isMarkdownExt(ext) {
  return ext in MARKDOWN_EXTS;
}
function isPageExt(ext) {
  return ext in PAGE_MODULE_EXTS || ext in MARKDOWN_EXTS;
}
function isMenuFileName(fileName) {
  return fileName === "menu.md";
}
function isServiceWorkerName(extlessName) {
  return extlessName === "service-worker";
}
function isEntryName(extlessName) {
  return extlessName === "entry";
}
function isErrorName(extlessName) {
  return /^[45][0-9]{2}$/.test(extlessName);
}
function isGroupedLayoutName(dirName, warn = true) {
  if (dirName.startsWith("__")) {
    if (warn) {
      console.warn(
        `Grouped (pathless) layout "${dirName}" should use the "(${dirName.slice(
          2
        )})" directory name instead. Prefixing a directory with "__" has been deprecated and will be removed in future versions.`
      );
    }
    return true;
  }
  return dirName.startsWith("(") && dirName.endsWith(")");
}
exports.addError = addError;
exports.addWarning = addWarning;
exports.createFileId = createFileId;
exports.getExtension = getExtension;
exports.getMenuPathname = getMenuPathname;
exports.getPathnameForDynamicRoute = getPathnameForDynamicRoute;
exports.getPathnameFromDirPath = getPathnameFromDirPath;
exports.isEntryName = isEntryName;
exports.isErrorName = isErrorName;
exports.isIndexModule = isIndexModule;
exports.isLayoutModule = isLayoutModule;
exports.isMarkdownExt = isMarkdownExt;
exports.isMenuFileName = isMenuFileName;
exports.isModuleExt = isModuleExt;
exports.isPageExt = isPageExt;
exports.isPageModuleExt = isPageModuleExt;
exports.isPluginModule = isPluginModule;
exports.isSameOriginUrl = isSameOriginUrl;
exports.isServiceWorkerName = isServiceWorkerName;
exports.msToString = msToString;
exports.normalizePath = normalizePath;
exports.normalizePathSlash = normalizePathSlash;
exports.parseRouteIndexName = parseRouteIndexName;
exports.removeExtension = removeExtension;
