import { jsx } from "@builder.io/qwik/jsx-runtime";
import { component$, useContext, useSignal, $, sync$, Slot } from "@builder.io/qwik";
import { HCollapsibleTrigger } from "../collapsible/collapsible-trigger.qwik.mjs";
import { accordionContextId, accordionItemContextId } from "./accordion-context.qwik.mjs";
import { useEnabledIndex } from "../../hooks/use-enabled-index.qwik.mjs";
const HAccordionTrigger = component$((props) => {
  const context = useContext(accordionContextId);
  const itemContext = useContext(accordionItemContextId);
  const { getNextEnabledItemIndex$, getPrevEnabledItemIndex$ } = useEnabledIndex();
  const focusedIndexSig = useSignal(null);
  const focusManager$ = $(async (direction) => {
    if (!context.itemsMapSig?.value) {
      throw new Error("Qwik UI: Accordion item does not have a map of the available item info.");
    }
    let index = null;
    switch (direction) {
      case "next":
        if (focusedIndexSig.value === itemContext.localIndexSig.value) {
          index = await getNextEnabledItemIndex$(itemContext.localIndexSig.value, context.itemsMapSig.value);
        }
        break;
      case "prev":
        if (focusedIndexSig.value === itemContext.localIndexSig.value) {
          index = await getPrevEnabledItemIndex$(itemContext.localIndexSig.value, context.itemsMapSig.value);
        }
        break;
      case "first":
        index = await getNextEnabledItemIndex$(-1, context.itemsMapSig.value);
        break;
      case "last":
        index = await getPrevEnabledItemIndex$(context.itemsMapSig.value.size, context.itemsMapSig.value, false);
        break;
    }
    if (index !== null) {
      context.triggerRefsArray.value[index].value.focus();
    }
  });
  const handleKeyDown$ = $(async (e) => {
    switch (e.key) {
      case "ArrowDown":
        await focusManager$("next");
        break;
      case "ArrowUp":
        await focusManager$("prev");
        break;
      case "Home":
        await focusManager$("first");
        break;
      case "End":
        await focusManager$("last");
        break;
    }
  });
  const handleKeyDownSync$ = sync$((e) => {
    const keys = [
      "ArrowDown",
      "ArrowUp",
      "Home",
      "End"
    ];
    if (keys.includes(e.key)) {
      e.preventDefault();
    }
  });
  return /* @__PURE__ */ jsx(HCollapsibleTrigger, {
    onClick$: () => {
      context.selectedIndexSig.value = itemContext.localIndexSig.value;
    },
    onFocus$: () => focusedIndexSig.value = itemContext.localIndexSig.value,
    onKeyDown$: [
      handleKeyDownSync$,
      handleKeyDown$
    ],
    ...props,
    children: /* @__PURE__ */ jsx(Slot, {})
  });
});
export {
  HAccordionTrigger
};
