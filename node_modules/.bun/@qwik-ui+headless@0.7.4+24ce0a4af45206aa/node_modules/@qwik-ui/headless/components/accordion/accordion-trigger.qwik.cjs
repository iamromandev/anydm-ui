"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@builder.io/qwik/jsx-runtime");
const qwik = require("@builder.io/qwik");
const collapsibleTrigger = require("../collapsible/collapsible-trigger.qwik.cjs");
const accordionContext = require("./accordion-context.qwik.cjs");
const useEnabledIndex = require("../../hooks/use-enabled-index.qwik.cjs");
const HAccordionTrigger = qwik.component$((props) => {
  const context = qwik.useContext(accordionContext.accordionContextId);
  const itemContext = qwik.useContext(accordionContext.accordionItemContextId);
  const { getNextEnabledItemIndex$, getPrevEnabledItemIndex$ } = useEnabledIndex.useEnabledIndex();
  const focusedIndexSig = qwik.useSignal(null);
  const focusManager$ = qwik.$(async (direction) => {
    if (!context.itemsMapSig?.value) {
      throw new Error("Qwik UI: Accordion item does not have a map of the available item info.");
    }
    let index = null;
    switch (direction) {
      case "next":
        if (focusedIndexSig.value === itemContext.localIndexSig.value) {
          index = await getNextEnabledItemIndex$(itemContext.localIndexSig.value, context.itemsMapSig.value);
        }
        break;
      case "prev":
        if (focusedIndexSig.value === itemContext.localIndexSig.value) {
          index = await getPrevEnabledItemIndex$(itemContext.localIndexSig.value, context.itemsMapSig.value);
        }
        break;
      case "first":
        index = await getNextEnabledItemIndex$(-1, context.itemsMapSig.value);
        break;
      case "last":
        index = await getPrevEnabledItemIndex$(context.itemsMapSig.value.size, context.itemsMapSig.value, false);
        break;
    }
    if (index !== null) {
      context.triggerRefsArray.value[index].value.focus();
    }
  });
  const handleKeyDown$ = qwik.$(async (e) => {
    switch (e.key) {
      case "ArrowDown":
        await focusManager$("next");
        break;
      case "ArrowUp":
        await focusManager$("prev");
        break;
      case "Home":
        await focusManager$("first");
        break;
      case "End":
        await focusManager$("last");
        break;
    }
  });
  const handleKeyDownSync$ = qwik.sync$((e) => {
    const keys = [
      "ArrowDown",
      "ArrowUp",
      "Home",
      "End"
    ];
    if (keys.includes(e.key)) {
      e.preventDefault();
    }
  });
  return /* @__PURE__ */ jsxRuntime.jsx(collapsibleTrigger.HCollapsibleTrigger, {
    onClick$: () => {
      context.selectedIndexSig.value = itemContext.localIndexSig.value;
    },
    onFocus$: () => focusedIndexSig.value = itemContext.localIndexSig.value,
    onKeyDown$: [
      handleKeyDownSync$,
      handleKeyDown$
    ],
    ...props,
    children: /* @__PURE__ */ jsxRuntime.jsx(qwik.Slot, {})
  });
});
exports.HAccordionTrigger = HAccordionTrigger;
