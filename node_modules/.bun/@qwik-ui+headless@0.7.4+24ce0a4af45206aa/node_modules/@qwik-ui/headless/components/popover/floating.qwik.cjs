"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@builder.io/qwik/jsx-runtime");
const dom = require("@floating-ui/dom");
const qwik = require("@builder.io/qwik");
const popoverPanelImpl = require("./popover-panel-impl.qwik.cjs");
const build = require("@builder.io/qwik/build");
const popoverTypes = require("./popover-types.qwik.cjs");
const FloatingPopover = qwik.component$((props) => {
  const context = qwik.useContext(popoverTypes.popoverContextId);
  qwik.useTask$(async ({ track, cleanup }) => {
    track(() => context.isOpenSig.value);
    if (build.isServer) return;
    const anchor = context.anchorRef?.value ? context.anchorRef.value : context.triggerRef?.value;
    const popover = context.panelRef?.value;
    if (!popover || !anchor) return;
    const updatePosition = async () => {
      const middleware = [
        dom.offset(context.gutter),
        dom.hide({
          strategy: context.hide
        }),
        context.flip && dom.flip(),
        context.shift && dom.shift(),
        context.arrow && dom.arrow({
          padding: 0,
          element: context.arrowRef?.value
        })
      ];
      let placement;
      if (typeof context.floating === "boolean") {
        placement = "bottom";
      } else {
        placement = context.floating;
      }
      if (popover) {
        popover.hidden = false;
      }
      await dom.computePosition(anchor, popover, {
        placement,
        middleware,
        strategy: context.strategy
      }).then(async (resolvedData) => {
        const { x, y } = resolvedData;
        const isRTL = document.documentElement.dir === "rtl";
        if (isRTL) {
          const documentWidth = document.body.getBoundingClientRect().width;
          const popoverWidth = popover.getBoundingClientRect().width;
          const boundaryX = Math.max(x, 0);
          Object.assign(popover.style, {
            right: `${documentWidth - boundaryX - popoverWidth}px`,
            top: `${y}px`,
            transform: context.transform
          });
        } else {
          Object.assign(popover.style, {
            left: `${x}px`,
            top: `${y}px`,
            transform: context.transform
          });
        }
        if (resolvedData.middlewareData.arrow && context.arrowRef?.value) {
          const { x: x2, y: y2 } = resolvedData.middlewareData.arrow;
          Object.assign(context.arrowRef.value.style, {
            left: x2 != null ? `${x2}px` : "",
            top: y2 != null ? `${y2}px` : ""
          });
        }
      });
    };
    const cleanupFunc = dom.autoUpdate(anchor, popover, updatePosition, {
      ancestorScroll: context.ancestorScroll,
      ancestorResize: context.ancestorResize,
      elementResize: context.elementResize,
      animationFrame: context.animationFrame
    });
    cleanup(cleanupFunc);
  });
  return /* @__PURE__ */ jsxRuntime.jsx(popoverPanelImpl.HPopoverPanelImpl, {
    hidden: true,
    ...props,
    children: /* @__PURE__ */ jsxRuntime.jsx(qwik.Slot, {})
  });
});
exports.FloatingPopover = FloatingPopover;
