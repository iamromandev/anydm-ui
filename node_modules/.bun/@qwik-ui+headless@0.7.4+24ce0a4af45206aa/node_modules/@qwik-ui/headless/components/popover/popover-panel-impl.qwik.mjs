import { jsxs, jsx } from "@builder.io/qwik/jsx-runtime";
import { component$, useContext, useStyles$, useSignal, useTask$, $, Slot, createContextId } from "@builder.io/qwik";
import { isServer } from "@builder.io/qwik/build";
import { useCombinedRef } from "../../hooks/combined-refs.qwik.mjs";
import { popoverContextId } from "./popover-types.qwik.mjs";
import popoverStyles from "./popover.css.qwik.mjs";
const ensureContextId = createContextId("qui-popover-null-context");
const EnsuredContext = component$(() => {
  useContext(ensureContextId, null);
  return null;
});
const HPopoverPanelImpl = component$((props) => {
  const context = useContext(popoverContextId);
  const panelId = `${context.compId}-panel`;
  const contextRefOpts = {
    context,
    givenContextRef: context.panelRef
  };
  const panelRef = useCombinedRef(props.ref, contextRefOpts);
  useStyles$(popoverStyles);
  const isPolyfillSig = useSignal(false);
  const hasRenderedOnClientSig = useSignal(isServer ? 0 : 2);
  const teleportSig = useSignal(false);
  const hasTopLayerAncestorSig = useSignal(false);
  if (hasRenderedOnClientSig.value === 1) {
    setTimeout(() => {
      teleportSig.value = true;
    }, 0);
  }
  useTask$(async ({ track, cleanup }) => {
    track(() => teleportSig.value);
    if (isServer) return;
    isPolyfillSig.value = true;
    const findTopLayerAncestor$ = $((element) => {
      while (element?.parentElement) {
        if (element.parentElement?.tagName === "DIALOG" || element.parentElement?.hasAttribute("popover")) {
          return element.parentElement;
        }
        element = element.parentElement;
      }
      return null;
    });
    let polyfillContainer = document.querySelector("div[data-qwik-ui-popover-polyfill]");
    if (!polyfillContainer) {
      polyfillContainer = document.createElement("div");
      polyfillContainer.setAttribute("data-qwik-ui-popover-polyfill", "");
      document.body.appendChild(polyfillContainer);
    }
    if (context.panelRef?.value) {
      const topLayerAncestor = await findTopLayerAncestor$(context.panelRef.value);
      if (topLayerAncestor === null) {
        polyfillContainer.appendChild(context.panelRef.value);
      } else {
        hasTopLayerAncestorSig.value = true;
      }
      document.dispatchEvent(new CustomEvent("showpopoverpoly"));
      cleanup(() => context.panelRef?.value);
    }
  });
  return /* @__PURE__ */ jsxs("div", {
    ...props,
    id: panelId,
    ref: panelRef,
    popover: context.manual && "manual" || props.popover === "manual" ? "manual" : "auto",
    onBeforeToggle$: [
      $(async (e) => {
        if (!context.panelRef?.value) return;
        const popover = context.panelRef.value;
        if (e.newState === "open") {
          delete popover.dataset.closed;
          popover.dataset.open = "";
        }
        if (e.newState === "closed") {
          delete popover.dataset.open;
          popover.dataset.closed = "";
        }
      }),
      props.onBeforeToggle$
    ],
    onToggle$: [
      $((e) => {
        context.isOpenSig.value = e.newState === "open";
        if (!context.panelRef?.value) return;
        if (context.panelRef?.value.classList.contains(":popover-open") && context.panelRef?.value.parentElement && // TODO: Get the top layer ancestor popovers to be above the other when the next one is opened.
        !hasTopLayerAncestorSig.value) {
          context.panelRef.value.parentElement.appendChild(context.panelRef.value);
        }
      }),
      props.onToggle$
    ],
    "document:onPopPolyLoad$": () => {
      if (hasRenderedOnClientSig.value === 0) {
        hasRenderedOnClientSig.value = 1;
        return;
      }
    },
    children: [
      hasRenderedOnClientSig.value === 1 && /* @__PURE__ */ jsx(EnsuredContext, {}),
      /* @__PURE__ */ jsx(Slot, {})
    ]
  });
});
export {
  EnsuredContext,
  HPopoverPanelImpl
};
