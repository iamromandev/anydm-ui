"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@builder.io/qwik/jsx-runtime");
const qwik = require("@builder.io/qwik");
const build = require("@builder.io/qwik/build");
const combinedRefs = require("../../hooks/combined-refs.qwik.cjs");
const popoverTypes = require("./popover-types.qwik.cjs");
const popover = require("./popover.css.qwik.cjs");
const ensureContextId = qwik.createContextId("qui-popover-null-context");
const EnsuredContext = qwik.component$(() => {
  qwik.useContext(ensureContextId, null);
  return null;
});
const HPopoverPanelImpl = qwik.component$((props) => {
  const context = qwik.useContext(popoverTypes.popoverContextId);
  const panelId = `${context.compId}-panel`;
  const contextRefOpts = {
    context,
    givenContextRef: context.panelRef
  };
  const panelRef = combinedRefs.useCombinedRef(props.ref, contextRefOpts);
  qwik.useStyles$(popover);
  const isPolyfillSig = qwik.useSignal(false);
  const hasRenderedOnClientSig = qwik.useSignal(build.isServer ? 0 : 2);
  const teleportSig = qwik.useSignal(false);
  const hasTopLayerAncestorSig = qwik.useSignal(false);
  if (hasRenderedOnClientSig.value === 1) {
    setTimeout(() => {
      teleportSig.value = true;
    }, 0);
  }
  qwik.useTask$(async ({ track, cleanup }) => {
    track(() => teleportSig.value);
    if (build.isServer) return;
    isPolyfillSig.value = true;
    const findTopLayerAncestor$ = qwik.$((element) => {
      while (element?.parentElement) {
        if (element.parentElement?.tagName === "DIALOG" || element.parentElement?.hasAttribute("popover")) {
          return element.parentElement;
        }
        element = element.parentElement;
      }
      return null;
    });
    let polyfillContainer = document.querySelector("div[data-qwik-ui-popover-polyfill]");
    if (!polyfillContainer) {
      polyfillContainer = document.createElement("div");
      polyfillContainer.setAttribute("data-qwik-ui-popover-polyfill", "");
      document.body.appendChild(polyfillContainer);
    }
    if (context.panelRef?.value) {
      const topLayerAncestor = await findTopLayerAncestor$(context.panelRef.value);
      if (topLayerAncestor === null) {
        polyfillContainer.appendChild(context.panelRef.value);
      } else {
        hasTopLayerAncestorSig.value = true;
      }
      document.dispatchEvent(new CustomEvent("showpopoverpoly"));
      cleanup(() => context.panelRef?.value);
    }
  });
  return /* @__PURE__ */ jsxRuntime.jsxs("div", {
    ...props,
    id: panelId,
    ref: panelRef,
    popover: context.manual && "manual" || props.popover === "manual" ? "manual" : "auto",
    onBeforeToggle$: [
      qwik.$(async (e) => {
        if (!context.panelRef?.value) return;
        const popover2 = context.panelRef.value;
        if (e.newState === "open") {
          delete popover2.dataset.closed;
          popover2.dataset.open = "";
        }
        if (e.newState === "closed") {
          delete popover2.dataset.open;
          popover2.dataset.closed = "";
        }
      }),
      props.onBeforeToggle$
    ],
    onToggle$: [
      qwik.$((e) => {
        context.isOpenSig.value = e.newState === "open";
        if (!context.panelRef?.value) return;
        if (context.panelRef?.value.classList.contains(":popover-open") && context.panelRef?.value.parentElement && // TODO: Get the top layer ancestor popovers to be above the other when the next one is opened.
        !hasTopLayerAncestorSig.value) {
          context.panelRef.value.parentElement.appendChild(context.panelRef.value);
        }
      }),
      props.onToggle$
    ],
    "document:onPopPolyLoad$": () => {
      if (hasRenderedOnClientSig.value === 0) {
        hasRenderedOnClientSig.value = 1;
        return;
      }
    },
    children: [
      hasRenderedOnClientSig.value === 1 && /* @__PURE__ */ jsxRuntime.jsx(EnsuredContext, {}),
      /* @__PURE__ */ jsxRuntime.jsx(qwik.Slot, {})
    ]
  });
});
exports.EnsuredContext = EnsuredContext;
exports.HPopoverPanelImpl = HPopoverPanelImpl;
