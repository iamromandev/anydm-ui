import { jsx } from "@builder.io/qwik/jsx-runtime";
import { autoUpdate, offset, hide, flip, shift, arrow, computePosition } from "@floating-ui/dom";
import { component$, useContext, useTask$, Slot } from "@builder.io/qwik";
import { HPopoverPanelImpl } from "./popover-panel-impl.qwik.mjs";
import { isServer } from "@builder.io/qwik/build";
import { popoverContextId } from "./popover-types.qwik.mjs";
const FloatingPopover = component$((props) => {
  const context = useContext(popoverContextId);
  useTask$(async ({ track, cleanup }) => {
    track(() => context.isOpenSig.value);
    if (isServer) return;
    const anchor = context.anchorRef?.value ? context.anchorRef.value : context.triggerRef?.value;
    const popover = context.panelRef?.value;
    if (!popover || !anchor) return;
    const updatePosition = async () => {
      const middleware = [
        offset(context.gutter),
        hide({
          strategy: context.hide
        }),
        context.flip && flip(),
        context.shift && shift(),
        context.arrow && arrow({
          padding: 0,
          element: context.arrowRef?.value
        })
      ];
      let placement;
      if (typeof context.floating === "boolean") {
        placement = "bottom";
      } else {
        placement = context.floating;
      }
      if (popover) {
        popover.hidden = false;
      }
      await computePosition(anchor, popover, {
        placement,
        middleware,
        strategy: context.strategy
      }).then(async (resolvedData) => {
        const { x, y } = resolvedData;
        const isRTL = document.documentElement.dir === "rtl";
        if (isRTL) {
          const documentWidth = document.body.getBoundingClientRect().width;
          const popoverWidth = popover.getBoundingClientRect().width;
          const boundaryX = Math.max(x, 0);
          Object.assign(popover.style, {
            right: `${documentWidth - boundaryX - popoverWidth}px`,
            top: `${y}px`,
            transform: context.transform
          });
        } else {
          Object.assign(popover.style, {
            left: `${x}px`,
            top: `${y}px`,
            transform: context.transform
          });
        }
        if (resolvedData.middlewareData.arrow && context.arrowRef?.value) {
          const { x: x2, y: y2 } = resolvedData.middlewareData.arrow;
          Object.assign(context.arrowRef.value.style, {
            left: x2 != null ? `${x2}px` : "",
            top: y2 != null ? `${y2}px` : ""
          });
        }
      });
    };
    const cleanupFunc = autoUpdate(anchor, popover, updatePosition, {
      ancestorScroll: context.ancestorScroll,
      ancestorResize: context.ancestorResize,
      elementResize: context.elementResize,
      animationFrame: context.animationFrame
    });
    cleanup(cleanupFunc);
  });
  return /* @__PURE__ */ jsx(HPopoverPanelImpl, {
    hidden: true,
    ...props,
    children: /* @__PURE__ */ jsx(Slot, {})
  });
});
export {
  FloatingPopover
};
