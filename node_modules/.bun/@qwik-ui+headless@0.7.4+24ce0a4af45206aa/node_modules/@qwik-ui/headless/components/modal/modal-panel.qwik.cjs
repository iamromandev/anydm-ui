"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@builder.io/qwik/jsx-runtime");
const qwik = require("@builder.io/qwik");
const modalContext = require("./modal-context.qwik.cjs");
const modal = require("./modal.css.qwik.cjs");
const useModal = require("./use-modal.qwik.cjs");
const build = require("@builder.io/qwik/build");
const bodyScrollLockUpgrade = require("body-scroll-lock-upgrade");
const HModalPanel = qwik.component$((props) => {
  qwik.useStyles$(modal);
  const { activateFocusTrap, closeModal, deactivateFocusTrap, showModal, trapFocus, wasModalBackdropClicked } = useModal.useModal();
  const context = qwik.useContext(modalContext.modalContextId);
  const panelRef = qwik.useSignal();
  qwik.useTask$(async function toggleModal({ track, cleanup }) {
    const isOpen = track(() => context.showSig.value);
    if (!panelRef.value) return;
    const focusTrap = await trapFocus(panelRef.value);
    if (isOpen) {
      const storedRequestAnimationFrame = window.requestAnimationFrame;
      window.requestAnimationFrame = () => 42;
      await showModal(panelRef.value);
      window.requestAnimationFrame = storedRequestAnimationFrame;
      activateFocusTrap(focusTrap);
    } else {
      await closeModal(panelRef.value);
    }
    cleanup(async () => {
      if (build.isServer) return;
      await deactivateFocusTrap(focusTrap);
      if (!panelRef.value) return;
      bodyScrollLockUpgrade.enableBodyScroll(panelRef.value);
    });
  });
  qwik.useTask$(async ({ track }) => {
    track(() => context.showSig.value);
    if (context.showSig.value) {
      await context.onShow$?.();
    } else {
      await context.onClose$?.();
    }
  });
  const closeOnBackdropClick$ = qwik.$(async (e) => {
    if (context.alert === true || context.closeOnBackdropClick === false) {
      return;
    }
    if (!(e.target instanceof HTMLDialogElement)) {
      return;
    }
    if (await wasModalBackdropClicked(panelRef.value, e)) {
      context.showSig.value = false;
    }
  });
  const handleKeyDownSync$ = qwik.sync$((e) => {
    const keys = [
      " ",
      "Enter"
    ];
    if (e.target instanceof HTMLDialogElement && keys.includes(e.key)) {
      e.preventDefault();
    }
    if (e.key === "Escape") {
      e.preventDefault();
    }
  });
  const handleKeyDown$ = qwik.$((e) => {
    if (e.key === "Escape") {
      context.showSig.value = false;
      e.stopPropagation();
    }
  });
  return /* @__PURE__ */ jsxRuntime.jsx("dialog", {
    ...props,
    id: `${context.localId}-root`,
    "aria-labelledby": `${context.localId}-title`,
    "aria-describedby": `${context.localId}-description`,
    // TODO: deprecate data-state in favor of data-open, data-closing, and data-closed
    "data-state": context.showSig.value ? "open" : "closed",
    "data-open": context.showSig.value && "",
    "data-closed": !context.showSig.value && "",
    role: context.alert === true ? "alertdialog" : "dialog",
    ref: panelRef,
    onKeyDown$: [
      handleKeyDownSync$,
      handleKeyDown$,
      props.onKeyDown$
    ],
    onClick$: async (e) => {
      e.stopPropagation();
      await closeOnBackdropClick$(e);
    },
    children: /* @__PURE__ */ jsxRuntime.jsx(qwik.Slot, {})
  });
});
exports.HModalPanel = HModalPanel;
