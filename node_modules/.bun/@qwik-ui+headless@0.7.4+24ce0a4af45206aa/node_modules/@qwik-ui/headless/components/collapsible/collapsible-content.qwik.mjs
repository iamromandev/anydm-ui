import { jsx } from "@builder.io/qwik/jsx-runtime";
import { component$, useContext, useSignal, $, useTask$, Slot } from "@builder.io/qwik";
import { collapsibleContextId } from "./collapsible-context.qwik.mjs";
import { isServer } from "@builder.io/qwik/build";
const HCollapsibleContent = component$((props) => {
  const context = useContext(collapsibleContextId);
  const isHiddenSig = useSignal(!context.isOpenSig.value);
  const isAnimatedSig = useSignal(false);
  const contentId = `${context.itemId}-content`;
  const triggerId = `${context.itemId}-trigger`;
  const hideContent$ = $(() => {
    if (!context.isOpenSig.value) {
      isHiddenSig.value = true;
    }
  });
  useTask$(async function automaticAnimations({ track }) {
    track(() => context.isOpenSig.value);
    if (isServer || !context.contentRef.value) {
      return;
    }
    await context.getContentDimensions$();
    if (context.isOpenSig.value) {
      context.contentRef.value.removeAttribute("data-closed");
      context.contentRef.value.dataset.open = "";
      isHiddenSig.value = false;
    } else {
      context.contentRef.value.dataset.closed = "";
      context.contentRef.value.removeAttribute("data-open");
    }
    const { animationDuration, transitionDuration } = getComputedStyle(context.contentRef.value);
    if (animationDuration !== "0s" || transitionDuration !== "0s") {
      isAnimatedSig.value = true;
    } else {
      isAnimatedSig.value = false;
    }
  });
  return /* @__PURE__ */ jsx("div", {
    ...props,
    ref: context.contentRef,
    id: contentId,
    "data-collapsible-content": true,
    "data-disabled": context.disabled ? "" : void 0,
    onAnimationEnd$: [
      hideContent$,
      props.onAnimationEnd$
    ],
    onTransitionEnd$: [
      hideContent$,
      props.onTransitionEnd$
    ],
    hidden: isAnimatedSig.value ? isHiddenSig.value : !context.isOpenSig.value,
    "aria-labelledby": triggerId,
    children: /* @__PURE__ */ jsx(Slot, {})
  });
});
export {
  HCollapsibleContent
};
