"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@builder.io/qwik/jsx-runtime");
const qwik = require("@builder.io/qwik");
const usePopover = require("../popover/use-popover.qwik.cjs");
const popoverPanel = require("../popover/popover-panel.qwik.cjs");
const dropdownContext = require("./dropdown-context.qwik.cjs");
const popoverRoot = require("../popover/popover-root.qwik.cjs");
const build = require("@builder.io/qwik/build");
const useDebouncer = require("../../hooks/use-debouncer.qwik.cjs");
const dropdown = require("./dropdown.css.qwik.cjs");
const HDropdownPopover = qwik.component$((props) => {
  qwik.useStyles$(dropdown);
  const context = qwik.useContext(dropdownContext.dropdownContextId);
  const { showPopover, hidePopover } = usePopover.usePopover(context.localId);
  const initialLoadSig = qwik.useSignal(true);
  const { floating, flip, hover, gutter, shift, ...rest } = props;
  qwik.useTask$(async ({ track }) => {
    track(() => context.isOpenSig.value);
    if (build.isServer) return;
    if (!initialLoadSig.value) {
      if (context.isOpenSig.value) {
        await showPopover();
      } else {
        await hidePopover();
      }
    }
  });
  const menuId = `${context.localId}-panel`;
  const isOutside = qwik.$((rect, x, y) => {
    return x < rect.left || x > rect.right || y < rect.top || y > rect.bottom;
  });
  const handleDismiss$ = qwik.$(async (e) => {
    if (!context.isOpenSig.value) {
      return;
    }
    if (!context.panelRef.value || !context.triggerRef.value) {
      return;
    }
    const menuRect = context.panelRef.value.getBoundingClientRect();
    const triggerRect = context.triggerRef.value.getBoundingClientRect();
    const { clientX, clientY } = e;
    const isOutsideMenu = await isOutside(menuRect, clientX, clientY);
    const isOutsideTrigger = await isOutside(triggerRect, clientX, clientY);
    if (isOutsideMenu && isOutsideTrigger) {
      context.isOpenSig.value = false;
    }
  });
  qwik.useTask$(({ track, cleanup }) => {
    track(() => context.isOpenSig.value);
    if (build.isServer) return;
    if (context.isOpenSig.value) {
      window.addEventListener("pointerdown", handleDismiss$);
    }
    cleanup(() => {
      window.removeEventListener("pointerdown", handleDismiss$);
    });
  });
  qwik.useTask$(() => {
    initialLoadSig.value = false;
  });
  const resetScrollMove = useDebouncer.useDebouncer(qwik.$(() => {
    context.isMouseOverPopupSig.value = false;
  }), 650);
  return /* @__PURE__ */ jsxRuntime.jsx(popoverRoot.HPopoverRoot, {
    floating,
    flip,
    hover,
    gutter,
    "bind:anchor": props["bind:anchor"] ?? context.triggerRef,
    "bind:panel": context.panelRef,
    manual: true,
    id: context.localId,
    style: {
      display: "contents"
    },
    shift,
    children: /* @__PURE__ */ jsxRuntime.jsx(popoverPanel.HPopoverPanel, {
      id: menuId,
      "data-open": context.isOpenSig.value ? "" : void 0,
      "data-closed": !context.isOpenSig.value ? "" : void 0,
      role: "menu",
      "aria-expanded": context.isOpenSig.value ? "true" : "false",
      onMouseMove$: async () => {
        context.isMouseOverPopupSig.value = true;
        await resetScrollMove();
      },
      onMouseOut$: () => context.isMouseOverPopupSig.value = false,
      onKeyDown$: () => context.isMouseOverPopupSig.value = true,
      ...rest,
      children: /* @__PURE__ */ jsxRuntime.jsx(qwik.Slot, {})
    })
  });
});
exports.HDropdownPopover = HDropdownPopover;
