import { jsx } from "@builder.io/qwik/jsx-runtime";
import { component$, useContext, useId, useSignal, useTask$, $, Slot } from "@builder.io/qwik";
import { isBrowser, isServer } from "@builder.io/qwik/build";
import { toggleGroupRootApiContextId } from "./toggle-group-context.qwik.mjs";
import { HToggle } from "../toggle/toggle.qwik.mjs";
const keyNavigationMap = {
  horizontal: {
    ltr: {
      ArrowRight: 1,
      ArrowLeft: -1,
      ArrowDown: 0,
      ArrowUp: 0
    },
    rtl: {
      ArrowRight: -1,
      ArrowLeft: 1,
      ArrowDown: 0,
      ArrowUp: 0
    }
  },
  vertical: {
    ltr: {
      ArrowDown: 1,
      ArrowUp: -1,
      ArrowRight: 0,
      ArrowLeft: 0
    },
    rtl: {
      ArrowDown: -1,
      ArrowUp: 1,
      ArrowRight: 0,
      ArrowLeft: 0
    }
  }
};
const HToggleGroupItem = component$((props) => {
  const { value, disabled: itemDisabled = false, ...itemProps } = props;
  const rootApiContext = useContext(toggleGroupRootApiContextId);
  const disabled = rootApiContext.rootIsDisabled || itemDisabled;
  const itemId = useId();
  const isPressedSig = useSignal(false);
  const itemRef = useSignal();
  const itemTabIndex = useSignal(isPressedSig.value ? 0 : -1);
  const itemSig = useSignal(() => ({
    itemId,
    isPressed: isPressedSig,
    isDisabled: disabled,
    ref: itemRef,
    tabIndex: itemTabIndex
  }));
  useTask$(async ({ track }) => {
    const pressedValue = track(() => rootApiContext.pressedValuesSig.value);
    if (pressedValue == null) {
      itemSig.value.isPressed.value = false;
      return;
    }
    if (typeof pressedValue === "string") {
      itemSig.value.isPressed.value = pressedValue === value;
    } else {
      itemSig.value.isPressed.value = pressedValue.includes(value);
    }
  });
  useTask$(async () => {
    await rootApiContext.registerItem$(itemId, itemSig);
    const allItems = await rootApiContext.getAllItem$();
    if (isBrowser) return;
    const currentPressedItems = allItems.filter((item) => item.isPressed.value === true);
    if (currentPressedItems.length > 0) {
      return currentPressedItems.forEach(async (item) => {
        await rootApiContext.getAndSetTabIndexItem$(item.itemId, 0);
      });
    }
    const firstNotDisabledItem = allItems.find((item) => item.isDisabled === false);
    if (firstNotDisabledItem !== void 0) {
      await rootApiContext.getAndSetTabIndexItem$(firstNotDisabledItem.itemId, 0);
    }
  });
  useTask$(async ({ track }) => {
    if (isServer) return;
    track(() => itemRef.value);
    if (!itemRef.value) return;
    rootApiContext.itemsCSR.value = [
      ...rootApiContext.itemsCSR.value,
      itemRef.value
    ];
    if (rootApiContext.itemsCSR.value.length === (await rootApiContext.getAllItem$()).length) {
      const allItems = rootApiContext.itemsCSR.value;
      const currentPressedItems = allItems.filter((item) => item.ariaPressed === "true");
      if (currentPressedItems.length > 0) {
        return currentPressedItems.forEach(async (item) => {
          const itemRef2 = allItems.find((i) => i.id === item.id);
          if (!itemRef2) throw "Item Not Found";
          itemRef2.tabIndex = 0;
        });
      }
      const firstNotDisabledItem = allItems.find((item) => item.ariaDisabled === "false");
      if (firstNotDisabledItem !== void 0) {
        firstNotDisabledItem.tabIndex = 0;
      }
    }
  });
  const handlePressed$ = $((pressed) => {
    if (pressed) {
      rootApiContext.activateItem$(value);
    } else {
      rootApiContext.deActivateItem$(value);
    }
  });
  const handleKeyDown$ = $(async (event) => {
    const items = Array.from(document.querySelectorAll(`.toggle-group-item-${rootApiContext.rootId}`));
    if (items.length === 0) return;
    const enabledItems = items.filter((item) => item.ariaDisabled === "false");
    const currentElement = event.target;
    const currentIndex = enabledItems.findIndex((e) => e.id === currentElement.id);
    if (currentIndex === -1) return;
    const direction = keyNavigationMap[rootApiContext.rootOrientation][rootApiContext.rootDirection][event.key];
    if (direction !== 0) {
      let nextIndex = currentIndex + direction;
      if (rootApiContext.rootIsLoopEnabled) {
        nextIndex = (currentIndex + direction + enabledItems.length) % enabledItems.length;
      } else {
        if (nextIndex >= enabledItems.length) nextIndex = enabledItems.length - 1;
        if (nextIndex < 0) nextIndex = 0;
      }
      enabledItems[nextIndex]?.focus();
    }
  });
  return /* @__PURE__ */ jsx(HToggle, {
    ref: itemRef,
    ...itemProps,
    "bind:pressed": itemSig.value.isPressed,
    disabled,
    onPressedChange$: handlePressed$,
    onKeyDown$: handleKeyDown$,
    class: `toggle-group-item-${rootApiContext.rootId} ${props.class}`,
    id: itemId,
    tabIndex: itemSig.value.tabIndex.value,
    "aria-orientation": rootApiContext.rootOrientation,
    dir: rootApiContext.rootDirection,
    "data-qui-togglegroup-item": true,
    children: /* @__PURE__ */ jsx(Slot, {})
  });
});
export {
  HToggleGroupItem
};
