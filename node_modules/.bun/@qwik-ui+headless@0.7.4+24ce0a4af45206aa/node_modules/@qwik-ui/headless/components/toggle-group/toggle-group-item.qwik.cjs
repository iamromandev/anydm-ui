"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@builder.io/qwik/jsx-runtime");
const qwik = require("@builder.io/qwik");
const build = require("@builder.io/qwik/build");
const toggleGroupContext = require("./toggle-group-context.qwik.cjs");
const toggle = require("../toggle/toggle.qwik.cjs");
const keyNavigationMap = {
  horizontal: {
    ltr: {
      ArrowRight: 1,
      ArrowLeft: -1,
      ArrowDown: 0,
      ArrowUp: 0
    },
    rtl: {
      ArrowRight: -1,
      ArrowLeft: 1,
      ArrowDown: 0,
      ArrowUp: 0
    }
  },
  vertical: {
    ltr: {
      ArrowDown: 1,
      ArrowUp: -1,
      ArrowRight: 0,
      ArrowLeft: 0
    },
    rtl: {
      ArrowDown: -1,
      ArrowUp: 1,
      ArrowRight: 0,
      ArrowLeft: 0
    }
  }
};
const HToggleGroupItem = qwik.component$((props) => {
  const { value, disabled: itemDisabled = false, ...itemProps } = props;
  const rootApiContext = qwik.useContext(toggleGroupContext.toggleGroupRootApiContextId);
  const disabled = rootApiContext.rootIsDisabled || itemDisabled;
  const itemId = qwik.useId();
  const isPressedSig = qwik.useSignal(false);
  const itemRef = qwik.useSignal();
  const itemTabIndex = qwik.useSignal(isPressedSig.value ? 0 : -1);
  const itemSig = qwik.useSignal(() => ({
    itemId,
    isPressed: isPressedSig,
    isDisabled: disabled,
    ref: itemRef,
    tabIndex: itemTabIndex
  }));
  qwik.useTask$(async ({ track }) => {
    const pressedValue = track(() => rootApiContext.pressedValuesSig.value);
    if (pressedValue == null) {
      itemSig.value.isPressed.value = false;
      return;
    }
    if (typeof pressedValue === "string") {
      itemSig.value.isPressed.value = pressedValue === value;
    } else {
      itemSig.value.isPressed.value = pressedValue.includes(value);
    }
  });
  qwik.useTask$(async () => {
    await rootApiContext.registerItem$(itemId, itemSig);
    const allItems = await rootApiContext.getAllItem$();
    if (build.isBrowser) return;
    const currentPressedItems = allItems.filter((item) => item.isPressed.value === true);
    if (currentPressedItems.length > 0) {
      return currentPressedItems.forEach(async (item) => {
        await rootApiContext.getAndSetTabIndexItem$(item.itemId, 0);
      });
    }
    const firstNotDisabledItem = allItems.find((item) => item.isDisabled === false);
    if (firstNotDisabledItem !== void 0) {
      await rootApiContext.getAndSetTabIndexItem$(firstNotDisabledItem.itemId, 0);
    }
  });
  qwik.useTask$(async ({ track }) => {
    if (build.isServer) return;
    track(() => itemRef.value);
    if (!itemRef.value) return;
    rootApiContext.itemsCSR.value = [
      ...rootApiContext.itemsCSR.value,
      itemRef.value
    ];
    if (rootApiContext.itemsCSR.value.length === (await rootApiContext.getAllItem$()).length) {
      const allItems = rootApiContext.itemsCSR.value;
      const currentPressedItems = allItems.filter((item) => item.ariaPressed === "true");
      if (currentPressedItems.length > 0) {
        return currentPressedItems.forEach(async (item) => {
          const itemRef2 = allItems.find((i) => i.id === item.id);
          if (!itemRef2) throw "Item Not Found";
          itemRef2.tabIndex = 0;
        });
      }
      const firstNotDisabledItem = allItems.find((item) => item.ariaDisabled === "false");
      if (firstNotDisabledItem !== void 0) {
        firstNotDisabledItem.tabIndex = 0;
      }
    }
  });
  const handlePressed$ = qwik.$((pressed) => {
    if (pressed) {
      rootApiContext.activateItem$(value);
    } else {
      rootApiContext.deActivateItem$(value);
    }
  });
  const handleKeyDown$ = qwik.$(async (event) => {
    const items = Array.from(document.querySelectorAll(`.toggle-group-item-${rootApiContext.rootId}`));
    if (items.length === 0) return;
    const enabledItems = items.filter((item) => item.ariaDisabled === "false");
    const currentElement = event.target;
    const currentIndex = enabledItems.findIndex((e) => e.id === currentElement.id);
    if (currentIndex === -1) return;
    const direction = keyNavigationMap[rootApiContext.rootOrientation][rootApiContext.rootDirection][event.key];
    if (direction !== 0) {
      let nextIndex = currentIndex + direction;
      if (rootApiContext.rootIsLoopEnabled) {
        nextIndex = (currentIndex + direction + enabledItems.length) % enabledItems.length;
      } else {
        if (nextIndex >= enabledItems.length) nextIndex = enabledItems.length - 1;
        if (nextIndex < 0) nextIndex = 0;
      }
      enabledItems[nextIndex]?.focus();
    }
  });
  return /* @__PURE__ */ jsxRuntime.jsx(toggle.HToggle, {
    ref: itemRef,
    ...itemProps,
    "bind:pressed": itemSig.value.isPressed,
    disabled,
    onPressedChange$: handlePressed$,
    onKeyDown$: handleKeyDown$,
    class: `toggle-group-item-${rootApiContext.rootId} ${props.class}`,
    id: itemId,
    tabIndex: itemSig.value.tabIndex.value,
    "aria-orientation": rootApiContext.rootOrientation,
    dir: rootApiContext.rootDirection,
    "data-qui-togglegroup-item": true,
    children: /* @__PURE__ */ jsxRuntime.jsx(qwik.Slot, {})
  });
});
exports.HToggleGroupItem = HToggleGroupItem;
