import { jsx } from "@builder.io/qwik/jsx-runtime";
import { component$, useContext, useSignal, useOnWindow, $, useComputed$, useTask$, sync$, useContextProvider, Slot } from "@builder.io/qwik";
import SelectContextId, { selectItemContextId } from "./select-context.qwik.mjs";
import { useSelect } from "./use-select.qwik.mjs";
import { useCombinedRef } from "../../hooks/combined-refs.qwik.mjs";
import { isServer } from "@builder.io/qwik/build";
const HSelectItem = component$((props) => {
  const { _index, disabled, ...rest } = props;
  const context = useContext(SelectContextId);
  const itemRef = useCombinedRef(props.ref);
  const localIndexSig = useSignal(null);
  const itemId = `${context.localId}-${_index}`;
  const typeaheadFnSig = useSignal();
  const debounceTimeoutSig = useSignal();
  const { selectionManager$, getNextEnabledItemIndex$, getPrevEnabledItemIndex$ } = useSelect();
  useOnWindow("typeaheadFn", $((e) => {
    typeaheadFnSig.value = e.detail;
  }));
  const isSelectedSig = useComputed$(() => {
    const index = _index ?? null;
    return !disabled && context.selectedIndexSetSig.value.has(index);
  });
  const isHighlightedSig = useComputed$(() => {
    if (disabled) return;
    if (context.highlightedIndexSig.value === _index) {
      if (!isServer) {
        itemRef.value?.focus({
          preventScroll: true
        });
      }
      return true;
    } else {
      return false;
    }
  });
  useTask$(async function getIndexTask() {
    if (_index === void 0) throw Error("Qwik UI: Select component item cannot find its proper index.");
    localIndexSig.value = _index;
  });
  const checkVisibility$ = $(async (entries) => {
    const [entry] = entries;
    if (isHighlightedSig.value && !entry.isIntersecting) {
      const containerRect = context.popoverRef.value?.getBoundingClientRect();
      const itemRect = itemRef.value?.getBoundingClientRect();
      if (!containerRect || !itemRect || !context.isKeyboardFocusSig.value) return;
      const offset = itemRect.top - containerRect.top - containerRect.height / 2 + itemRect.height / 2;
      context.popoverRef.value?.scrollBy({
        top: document.hasFocus() ? offset : void 0,
        ...context.scrollOptions
      });
    }
  });
  useTask$(function handleScrolling({ track, cleanup }) {
    track(() => context.highlightedIndexSig.value);
    if (localIndexSig.value === context.highlightedIndexSig.value) {
      context.highlightedItemRef = itemRef;
    }
    if (isServer || !context.popoverRef.value) return;
    const hasScrollbar = context.popoverRef.value.scrollHeight > context.popoverRef.value.clientHeight;
    if (!hasScrollbar) return;
    if (debounceTimeoutSig.value !== void 0) {
      clearTimeout(debounceTimeoutSig.value);
    }
    debounceTimeoutSig.value = setTimeout(() => {
      if (props._index !== context.highlightedIndexSig.value) return;
      const observer = new IntersectionObserver(checkVisibility$, {
        root: context.popoverRef.value,
        threshold: 0
      });
      cleanup(() => observer?.disconnect());
      if (itemRef.value) {
        observer.observe(itemRef.value);
      }
    }, 100);
    cleanup(() => {
      if (debounceTimeoutSig.value !== void 0) {
        clearTimeout(debounceTimeoutSig.value);
      }
    });
  });
  const handleClick$ = $(async () => {
    if (disabled || localIndexSig.value === null) return;
    if (context.multiple) {
      await selectionManager$(localIndexSig.value, "toggle");
      context.triggerRef.value?.focus();
    } else {
      await selectionManager$(localIndexSig.value, "add");
      context.isListboxOpenSig.value = false;
    }
  });
  const handlePointerOver$ = $(() => {
    if (disabled) return;
    if (localIndexSig.value !== null) {
      context.highlightedIndexSig.value = localIndexSig.value;
    }
  });
  const selectContext = {
    isSelectedSig
  };
  const handleKeyDownSync$ = sync$((e) => {
    const keys = [
      "ArrowUp",
      "ArrowDown",
      "ArrowRight",
      "ArrowLeft",
      "Home",
      "End",
      "PageDown",
      "PageUp",
      "Enter",
      " "
    ];
    if (keys.includes(e.key)) {
      e.preventDefault();
    }
  });
  const handleKeyDown$ = $(async (e) => {
    typeaheadFnSig.value?.(e.key);
    context.isKeyboardFocusSig.value = true;
    switch (e.key) {
      case "ArrowDown":
        if (context.isListboxOpenSig.value) {
          context.highlightedIndexSig.value = await getNextEnabledItemIndex$(context.highlightedIndexSig.value);
          if (context.multiple && e.shiftKey) {
            await selectionManager$(context.highlightedIndexSig.value, "toggle");
          }
        }
        break;
      case "ArrowUp":
        if (context.isListboxOpenSig.value) {
          context.highlightedIndexSig.value = await getPrevEnabledItemIndex$(context.highlightedIndexSig.value);
          if (context.multiple && e.shiftKey) {
            await selectionManager$(context.highlightedIndexSig.value, "toggle");
          }
        }
        break;
      case "Home":
        if (context.isListboxOpenSig.value) {
          context.highlightedIndexSig.value = await getNextEnabledItemIndex$(-1);
        }
        break;
      case "End":
        if (context.isListboxOpenSig.value) {
          const lastEnabledOptionIndex = await getPrevEnabledItemIndex$(context.itemsMapSig.value.size);
          context.highlightedIndexSig.value = lastEnabledOptionIndex;
        }
        break;
      case "Escape":
        context.triggerRef.value?.focus();
        context.isListboxOpenSig.value = false;
        break;
      case "Tab":
        context.isListboxOpenSig.value = false;
        break;
      case "Enter":
      case " ":
        if (context.isListboxOpenSig.value) {
          const action = context.multiple ? "toggle" : "add";
          await selectionManager$(context.highlightedIndexSig.value, action);
          if (!context.multiple) {
            context.triggerRef.value?.focus();
          }
        }
        context.isListboxOpenSig.value = context.multiple ? true : !context.isListboxOpenSig.value;
        break;
      case "a":
        if (e.ctrlKey && context.multiple) {
          for (const [index, item] of context.itemsMapSig.value) {
            if (!item.disabled) {
              await selectionManager$(index, "add");
            }
          }
        }
        break;
    }
  });
  useContextProvider(selectItemContextId, selectContext);
  return /* @__PURE__ */ jsx("div", {
    ...rest,
    id: itemId,
    onClick$: [
      handleClick$,
      props.onClick$
    ],
    onKeyDown$: [
      handleKeyDownSync$,
      handleKeyDown$,
      props.onKeyDown$
    ],
    onPointerOver$: [
      handlePointerOver$,
      props.onPointerOver$
    ],
    ref: itemRef,
    tabIndex: -1,
    "aria-selected": isSelectedSig.value,
    "aria-disabled": disabled === true ? "true" : "false",
    "data-selected": isSelectedSig.value ? "" : void 0,
    "data-highlighted": isHighlightedSig.value ? "" : void 0,
    "data-disabled": disabled ? "" : void 0,
    "data-item": true,
    role: "option",
    children: /* @__PURE__ */ jsx(Slot, {})
  });
});
export {
  HSelectItem
};
