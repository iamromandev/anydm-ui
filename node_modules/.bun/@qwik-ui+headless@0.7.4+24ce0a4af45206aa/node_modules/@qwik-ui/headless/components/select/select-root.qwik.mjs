import { jsx } from "@builder.io/qwik/jsx-runtime";
import { component$, useSignal, useId, useComputed$, useTask$, useContextProvider, Slot } from "@builder.io/qwik";
import SelectContextId from "./select-context.qwik.mjs";
import { useSelect } from "./use-select.qwik.mjs";
import { useCombinedRef } from "../../hooks/combined-refs.qwik.mjs";
const HSelectImpl = component$((props) => {
  const { _itemsMap, _valuePropIndex: givenValuePropIndex, onChange$, onOpenChange$, scrollOptions: givenScrollOptions, loop: givenLoop, multiple = false, _label, name, required, disabled, invalid, ...rest } = props;
  const rootRef = useCombinedRef(props.ref);
  const triggerRef = useSignal();
  const popoverRef = useSignal();
  const listboxRef = useSignal();
  const labelRef = useSignal();
  const groupRef = useSignal();
  const loop = givenLoop ?? false;
  const localId = useId();
  const itemsMapSig = useComputed$(() => {
    return _itemsMap;
  });
  const selectedIndexSetSig = useSignal(new Set([
    givenValuePropIndex ?? []
  ].flat()));
  const highlightedIndexSig = useSignal(givenValuePropIndex ?? null);
  const isListboxOpenSig = useSignal(false);
  const scrollOptions = givenScrollOptions ?? {
    behavior: "smooth",
    block: "center",
    inline: "nearest"
  };
  const currDisplayValueSig = useSignal();
  const initialLoadSig = useSignal(true);
  const highlightedItemRef = useSignal();
  const isDisabledSig = useSignal(disabled ?? false);
  const isInvalidSig = useSignal(props.invalid ?? false);
  const isKeyboardFocusSig = useSignal(false);
  const isMouseOverPopupSig = useSignal(false);
  useTask$(({ track }) => {
    isInvalidSig.value = track(() => props.invalid ?? false);
  });
  const context = {
    itemsMapSig,
    currDisplayValueSig,
    triggerRef,
    popoverRef,
    listboxRef,
    labelRef,
    groupRef,
    highlightedItemRef,
    localId,
    highlightedIndexSig,
    selectedIndexSetSig,
    isKeyboardFocusSig,
    isMouseOverPopupSig,
    isListboxOpenSig,
    scrollOptions,
    loop,
    multiple,
    name,
    required,
    isDisabledSig,
    isInvalidSig
  };
  useContextProvider(SelectContextId, context);
  const { selectionManager$ } = useSelect();
  useTask$(async function reactiveUserValue({ track }) {
    const bindValueSig = props["bind:value"];
    if (!bindValueSig) return;
    track(() => bindValueSig.value);
    for (const [index, item] of itemsMapSig.value) {
      if (bindValueSig.value?.includes(item.value)) {
        await selectionManager$(index, "add");
        if (initialLoadSig.value) {
          context.highlightedIndexSig.value = index;
        }
      } else {
        await selectionManager$(index, "remove");
      }
    }
  });
  useTask$(function reactiveUserOpen({ track }) {
    const bindOpenSig = props["bind:open"];
    if (!bindOpenSig) return;
    track(() => bindOpenSig.value);
    isListboxOpenSig.value = bindOpenSig.value ?? isListboxOpenSig.value;
  });
  useTask$(function onOpenChangeTask({ track }) {
    track(() => isListboxOpenSig.value);
    if (!initialLoadSig.value) {
      onOpenChange$?.(isListboxOpenSig.value);
    }
  });
  useTask$(async function updateConsumerProps({ track }) {
    const bindValueSig = props["bind:value"];
    const bindDisplayTextSig = props["bind:displayValue"];
    track(() => selectedIndexSetSig.value);
    const values = [];
    const displayValues = [];
    for (const index of context.selectedIndexSetSig.value) {
      const item = context.itemsMapSig.value.get(index);
      if (item) {
        values.push(item.value);
        displayValues.push(item.displayValue);
      }
    }
    if (onChange$ && selectedIndexSetSig.value.size > 0) {
      await onChange$(context.multiple ? values : values[0]);
    }
    if (bindValueSig && bindValueSig.value) {
      const currUserSigValues = JSON.stringify(bindValueSig.value);
      const newUserSigValues = JSON.stringify(values);
      if (currUserSigValues !== newUserSigValues) {
        if (context.multiple) {
          bindValueSig.value = values;
        } else {
          bindValueSig.value = values[0];
        }
      }
    }
    context.currDisplayValueSig.value = displayValues;
    if (bindDisplayTextSig && context.currDisplayValueSig.value) {
      bindDisplayTextSig.value = context.multiple ? context.currDisplayValueSig.value : context.currDisplayValueSig.value[0];
    }
  });
  useTask$(() => {
    initialLoadSig.value = false;
  });
  useTask$(({ track }) => {
    isDisabledSig.value = track(() => disabled ?? false);
  });
  return /* @__PURE__ */ jsx("div", {
    role: "group",
    ref: rootRef,
    "data-open": context.isListboxOpenSig.value ? "" : void 0,
    "data-closed": !context.isListboxOpenSig.value ? "" : void 0,
    "data-disabled": isDisabledSig.value ? "" : void 0,
    "data-invalid": context.isInvalidSig?.value ? "" : void 0,
    "aria-invalid": context.isInvalidSig?.value,
    "data-qui-select-root": true,
    ...rest,
    children: /* @__PURE__ */ jsx(Slot, {})
  });
});
export {
  HSelectImpl
};
