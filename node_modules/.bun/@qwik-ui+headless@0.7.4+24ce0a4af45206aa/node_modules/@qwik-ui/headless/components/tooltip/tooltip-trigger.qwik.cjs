"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@builder.io/qwik/jsx-runtime");
const qwik = require("@builder.io/qwik");
const tooltipContext = require("./tooltip-context.qwik.cjs");
const build = require("@builder.io/qwik/build");
const usePopover = require("../popover/use-popover.qwik.cjs");
const HTooltipTrigger = qwik.component$((props) => {
  const context = qwik.useContext(tooltipContext.TooltipContextId);
  const openTimeout = qwik.useSignal();
  const closeTimeout = qwik.useSignal();
  const { showPopover, hidePopover } = usePopover.usePopover(context.localId);
  const clearTimeoutIfExists = qwik.$((timeoutRef) => {
    if (timeoutRef.value) {
      window.clearTimeout(timeoutRef.value);
      timeoutRef.value = void 0;
    }
  });
  const setTooltipState = qwik.$((open, state, timeoutRef) => {
    context.state.value = state;
    if (context.delayDuration > 0) {
      timeoutRef.value = window.setTimeout(() => {
        context.state.value = open ? "open" : "closed";
      }, context.delayDuration);
    } else {
      context.state.value = open ? "open" : "closed";
    }
  });
  const setTooltipOpen$ = qwik.$(() => {
    clearTimeoutIfExists(closeTimeout);
    showPopover();
    setTooltipState(true, "opening", openTimeout);
  });
  const setTooltipClosed$ = qwik.$(() => {
    clearTimeoutIfExists(openTimeout);
    hidePopover();
    setTooltipState(false, "closing", closeTimeout);
  });
  const preventDefaultSync$ = qwik.sync$((e) => {
    e.preventDefault();
  });
  const handleKeyDown$ = qwik.$(async (e) => {
    if (context.state.value === "open" && e.key === "Escape") {
      e.preventDefault();
      setTooltipClosed$();
    }
  });
  qwik.useTask$(({ track, cleanup }) => {
    track(() => context.state.value);
    if (build.isServer) return;
    if (context.state.value === "open") {
      document.addEventListener("keydown", handleKeyDown$);
      cleanup(() => {
        document.removeEventListener("keydown", handleKeyDown$);
      });
    } else if (context.state.value === "closed") {
      document.removeEventListener("keydown", handleKeyDown$);
    }
    cleanup(() => {
      document.removeEventListener("keydown", handleKeyDown$);
    });
  });
  return /* @__PURE__ */ jsxRuntime.jsx("button", {
    ref: context.triggerRef,
    onMouseOver$: [
      preventDefaultSync$,
      setTooltipOpen$
    ],
    onMouseLeave$: setTooltipClosed$,
    onFocus$: setTooltipOpen$,
    onBlur$: setTooltipClosed$,
    onKeyDown$: handleKeyDown$,
    "aria-describedby": context.localId,
    "data-state": context.state.value,
    ...props,
    children: /* @__PURE__ */ jsxRuntime.jsx(qwik.Slot, {})
  });
});
exports.HTooltipTrigger = HTooltipTrigger;
