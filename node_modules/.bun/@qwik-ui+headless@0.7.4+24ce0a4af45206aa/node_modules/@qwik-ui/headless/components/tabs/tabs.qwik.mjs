import { jsx, jsxs } from "@builder.io/qwik/jsx-runtime";
import { component$, useId, useSignal, useTask$, $, useContextProvider, Slot } from "@builder.io/qwik";
import { KeyCode } from "../../utils/key-code.type.qwik.mjs";
import { getEnabledTab, findNextEnabledTab, findPrevEnabledTab } from "./get-enabled-tab.qwik.mjs";
import { HTab } from "./tab.qwik.mjs";
import { HTabPanel } from "./tab-panel.qwik.mjs";
import { tabsContextId } from "./tabs-context-id.qwik.mjs";
import { HTabList } from "./tabs-list.qwik.mjs";
const HTabs = (props) => {
  const { children, tabListComponent: UserTabList, tabComponent: UserTab, tabPanelComponent: UserTabPanel, ...rest } = props;
  const TabList = UserTabList ? UserTabList : HTabList;
  const Tab = UserTab ? UserTab : HTab;
  const TabPanel = UserTabPanel ? UserTabPanel : HTabPanel;
  const childrenToProcess = Array.isArray(children) ? [
    ...children
  ] : [
    children
  ];
  let tabListComponent;
  const tabComponents = [];
  const panelComponents = [];
  const tabInfoList = [];
  let panelIndex = 0;
  let selectedIndex;
  while (childrenToProcess.length) {
    const child = childrenToProcess.shift();
    if (!child) {
      continue;
    }
    if (Array.isArray(child)) {
      childrenToProcess.unshift(...child);
      continue;
    }
    switch (child.type) {
      case TabList: {
        tabListComponent = child;
        const tabListChildren = Array.isArray(child.props.children) ? child.props.children : [
          child.props.children
        ];
        childrenToProcess.unshift(...tabListChildren);
        break;
      }
      case Tab: {
        if (child.props.selected) {
          const currentTabIndex = tabComponents.length;
          selectedIndex = currentTabIndex;
          child.props.selected = void 0;
        }
        tabComponents.push(child);
        break;
      }
      case TabPanel: {
        const { label, selected } = child.props;
        const matchedTabComponent = tabComponents[panelIndex];
        const tabIdFromTabMaybe = (matchedTabComponent?.props).tabId || matchedTabComponent?.key;
        const tabId = tabIdFromTabMaybe || child.key || `${panelIndex}`;
        if (label) {
          tabComponents.push(/* @__PURE__ */ jsx(Tab, {
            children: label
          }));
        }
        if (selected) {
          selectedIndex = panelIndex;
          child.props.selected = void 0;
        }
        child.key = tabId;
        child.props._tabId = tabId;
        panelComponents.push(child);
        tabInfoList.push({
          tabId,
          index: panelIndex,
          tabProps: {},
          panelProps: child.props
        });
        panelIndex++;
        break;
      }
      default: {
        console.error(`unhandled component ${child.type} given to Tabs`);
      }
    }
  }
  if (tabComponents.length !== panelIndex) {
    console.error(`mismatched number of tabs and panels: ${tabComponents.length} ${panelIndex}`);
  }
  tabComponents.forEach((tab, index) => {
    const tabId = tabInfoList[index]?.tabId;
    tab.key = tabId;
    tab.props.tabId = tabId;
    if (tabInfoList[index].panelProps.disabled !== void 0 && tab.props.disabled === void 0) {
      tab.props.disabled = tabInfoList[index].panelProps.disabled;
    }
    tabInfoList[index].tabProps = tab.props;
  });
  if (tabListComponent) {
    tabListComponent.children = tabComponents;
    tabListComponent.props.children = tabComponents;
  } else {
    tabListComponent = /* @__PURE__ */ jsx(TabList, {
      children: tabComponents
    });
  }
  if (typeof selectedIndex === "number") {
    rest.selectedIndex = selectedIndex;
  }
  return /* @__PURE__ */ jsxs(TabsImpl, {
    tabInfoList,
    ...rest,
    children: [
      tabListComponent,
      panelComponents
    ]
  });
};
const TabsImpl = component$((props) => {
  const {
    // We take these out of the props for the DOM element but we must refer
    // to them as e.g. props.tabs for reactivity
    tabInfoList: _0,
    behavior = "manual",
    selectedTabId: _1,
    selectedIndex: _2,
    vertical,
    selectedClassName,
    onSelectedIndexChange$,
    onSelectedTabIdChange$,
    "bind:selectedIndex": givenIndexSig,
    "bind:selectedTabId": givenTabIdSig,
    ...rest
  } = props;
  const tabsPrefix = useId();
  const ref = useSignal();
  const initialSelectedIndexSig = useSignal();
  const selectedIndexSig = givenIndexSig || initialSelectedIndexSig;
  const initialSelectedTabIdSig = useSignal();
  const selectedTabIdSig = givenTabIdSig || initialSelectedTabIdSig;
  useTask$(function syncTabsTask({ track }) {
    const tabInfoList = track(() => props.tabInfoList);
    const tabId = selectedTabIdSig.value;
    syncSelectedStateSignals(tabInfoList, selectedIndexSig, selectedTabIdSig, {
      tabIdToSelect: tabId
    }, true);
  });
  useTask$(function syncPropSelectedIndexTask({ track }) {
    const updatedIndexFromProps = track(() => props.selectedIndex);
    syncSelectedStateSignals(props.tabInfoList, selectedIndexSig, selectedTabIdSig, {
      indexToSelect: updatedIndexFromProps
    });
  });
  useTask$(function syncSelectedIndexSigTask({ track }) {
    const updatedIndexSignal = track(() => selectedIndexSig.value);
    syncSelectedStateSignals(props.tabInfoList, selectedIndexSig, selectedTabIdSig, {
      indexToSelect: updatedIndexSignal
    });
    if (typeof selectedIndexSig.value !== "undefined") {
      onSelectedIndexChange$?.(selectedIndexSig.value);
    }
  });
  useTask$(function syncPropSelectedTabIdTask({ track }) {
    const updatedTabIdFromProps = track(() => props.selectedTabId);
    syncSelectedStateSignals(props.tabInfoList, selectedIndexSig, selectedTabIdSig, {
      tabIdToSelect: updatedTabIdFromProps
    });
  });
  useTask$(function syncSelectedTabIdSigTask({ track }) {
    let updatedTabId = track(() => selectedTabIdSig.value);
    if (typeof updatedTabId !== "string") {
      const tab = getEnabledTab(props.tabInfoList, 0);
      if (tab) {
        updatedTabId = tab.tabId;
      }
    }
    syncSelectedStateSignals(props.tabInfoList, selectedIndexSig, selectedTabIdSig, {
      tabIdToSelect: updatedTabId
    });
    if (typeof selectedTabIdSig.value !== "undefined") {
      onSelectedTabIdChange$?.(selectedTabIdSig.value);
    }
  });
  useTask$(function callOnSelectedChangeTask({ track }) {
    if (!onSelectedIndexChange$) return;
    const idx = track(() => selectedIndexSig.value);
    if (typeof idx === "number" && idx >= 0) onSelectedIndexChange$(idx);
  });
  const selectTab$ = $((tabId) => {
    syncSelectedStateSignals(props.tabInfoList, selectedIndexSig, selectedTabIdSig, {
      tabIdToSelect: tabId
    });
  });
  const selectIfAutomatic$ = $((tabId) => {
    if (behavior === "automatic") {
      selectTab$(tabId);
    }
  });
  const onTabKeyDown$ = $((key, currentTabId) => {
    const tabsRootElement = ref.value;
    const currentFocusedTabIndex = props.tabInfoList.findIndex((tabData) => tabData.tabId === currentTabId);
    let tabInfo;
    if (!vertical && key === KeyCode.ArrowRight || vertical && key === KeyCode.ArrowDown) {
      tabInfo = findNextEnabledTab(props.tabInfoList, currentFocusedTabIndex + 1, {
        wrap: true
      });
    } else if (!vertical && key === KeyCode.ArrowLeft || vertical && key === KeyCode.ArrowUp) {
      tabInfo = findPrevEnabledTab(props.tabInfoList, currentFocusedTabIndex, {
        wrap: true
      });
    } else if (key === KeyCode.Home || key === KeyCode.PageUp) {
      tabInfo = findNextEnabledTab(props.tabInfoList, 0);
    } else if (key === KeyCode.End || key === KeyCode.PageDown) {
      tabInfo = findPrevEnabledTab(props.tabInfoList, props.tabInfoList.length);
    }
    if (tabInfo) {
      focusOnTab(tabInfo.index);
    }
    function focusOnTab(index) {
      const tabListElement = tabsRootElement?.children[0];
      const tabToFocusOn = tabListElement?.children[index];
      tabToFocusOn.focus();
    }
  });
  const contextService = {
    selectTab$,
    tabsPrefix,
    onTabKeyDown$,
    selectIfAutomatic$,
    selectedTabIdSig,
    selectedClassName
  };
  useContextProvider(tabsContextId, contextService);
  return /* @__PURE__ */ jsx("div", {
    "data-qui-tabs-root": true,
    ref,
    ...rest,
    children: /* @__PURE__ */ jsx(Slot, {})
  });
});
const syncSelectedStateSignals = (tabsInfoList, selectedIndexSig, selectedTabIdSig, { indexToSelect, tabIdToSelect }, ignoreIndexNotFound) => {
  if (tabIdToSelect) {
    indexToSelect = tabsInfoList.findIndex((tabInfo) => tabInfo.tabId === tabIdToSelect);
  }
  if (typeof indexToSelect !== "number") return;
  if (indexToSelect && indexToSelect < 0) {
    if (!ignoreIndexNotFound) {
      return;
    }
    indexToSelect = selectedIndexSig.value;
    if (typeof indexToSelect !== "number") return;
  }
  const tab = getEnabledTab(tabsInfoList, indexToSelect);
  if (tab && (tab.index !== selectedIndexSig.value || tab.tabId !== selectedTabIdSig.value)) {
    selectedIndexSig.value = tab.index;
    selectedTabIdSig.value = tab.tabId;
  }
};
export {
  HTabs,
  TabsImpl,
  syncSelectedStateSignals
};
