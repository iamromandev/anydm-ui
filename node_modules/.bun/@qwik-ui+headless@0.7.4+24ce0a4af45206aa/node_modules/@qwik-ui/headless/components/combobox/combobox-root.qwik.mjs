import { jsx } from "@builder.io/qwik/jsx-runtime";
import { component$, useStyles$, useComputed$, useSignal, useId, useTask$, useContextProvider, Slot } from "@builder.io/qwik";
import { comboboxContextId } from "./combobox-context.qwik.mjs";
import { useCombinedRef } from "../../hooks/combined-refs.qwik.mjs";
import { useBoundSignal } from "../../utils/bound-signal.qwik.mjs";
import styles from "./combobox.css.qwik.mjs";
const HComboboxRootImpl = component$((props) => {
  useStyles$(styles);
  const { onInput$, onChange$, onOpenChange$, initialIndex, initialValue, loop: givenLoop, scrollOptions: givenScrollOptions, multiple = false, placeholder, filter = true, _itemsMap, hasEmptyComp, removeOnBackspace = false, name, required, mode = "popover", "bind:value": givenValueSig, "bind:open": givenOpenSig, "bind:displayValue": givenDisplayValueSig, ...rest } = props;
  const isListboxOpenSig = useBoundSignal(givenOpenSig, false);
  const displayValuesSig = useBoundSignal(givenDisplayValueSig, []);
  const selectedValuesSig = useBoundSignal(givenValueSig, multiple ? initialValue ? [
    initialValue
  ] : [] : initialValue || "");
  const itemsMapSig = useComputed$(() => {
    return props._itemsMap ?? /* @__PURE__ */ new Map();
  });
  const rootRef = useCombinedRef(props.ref);
  const triggerRef = useSignal();
  const inputRef = useSignal();
  const panelRef = useSignal();
  const labelRef = useSignal();
  const groupRef = useSignal();
  const controlRef = useSignal();
  const loop = givenLoop ?? false;
  const localId = useId();
  const selectedValueSetSig = useSignal(new Set(initialValue ? [
    initialValue
  ] : []));
  const disabledIndexSetSig = useSignal(/* @__PURE__ */ new Set());
  const filteredIndexSetSig = useSignal(/* @__PURE__ */ new Set());
  const isMouseOverPopupSig = useSignal(false);
  const highlightedIndexSig = useSignal(initialIndex ?? null);
  const initialLoadSig = useSignal(true);
  const scrollOptions = givenScrollOptions ?? {
    behavior: "smooth",
    block: "center",
    inline: "nearest"
  };
  const inputValueSig = useSignal(inputRef.value?.value ?? "");
  const isDisabledSig = useComputed$(() => props.disabled ?? false);
  const isInvalidSig = useComputed$(() => props.hasErrorComp ?? false);
  const isKeyboardFocusSig = useSignal(false);
  useTask$(() => {
    const disabledIndices = /* @__PURE__ */ new Set();
    for (const [index, item] of itemsMapSig.value) {
      if (item.disabled) {
        disabledIndices.add(index);
      }
    }
    disabledIndexSetSig.value = disabledIndices;
  });
  const isNoItemsSig = useComputed$(() => {
    return itemsMapSig.value.size === filteredIndexSetSig.value.size || itemsMapSig.value.size === 0;
  });
  useTask$(function closeIfEmptyComp({ track }) {
    track(() => itemsMapSig.value);
    track(() => filteredIndexSetSig.value);
    if (!hasEmptyComp && isNoItemsSig.value) {
      isListboxOpenSig.value = false;
    }
  });
  const isExpandedSig = useComputed$(() => {
    if (mode === "inline") {
      return void 0;
    }
    if (isListboxOpenSig.value) {
      return "true";
    } else {
      return "false";
    }
  });
  const context = {
    isListboxOpenSig,
    inputValueSig,
    itemsMapSig,
    triggerRef,
    inputRef,
    panelRef,
    labelRef,
    groupRef,
    controlRef,
    localId,
    highlightedIndexSig,
    isExpandedSig,
    selectedValuesSig,
    selectedValueSetSig,
    disabledIndexSetSig,
    filteredIndexSetSig,
    displayValuesSig,
    isMouseOverPopupSig,
    isKeyboardFocusSig,
    initialLoadSig,
    removeOnBackspace,
    filter,
    loop,
    mode,
    multiple,
    initialValue,
    scrollOptions,
    placeholder,
    isNoItemsSig,
    name,
    required,
    isDisabledSig,
    isInvalidSig
  };
  useContextProvider(comboboxContextId, context);
  useTask$(async function handleOpenChange({ track }) {
    track(() => isListboxOpenSig.value);
    if (!initialLoadSig.value) {
      await onOpenChange$?.(isListboxOpenSig.value);
    }
  });
  useTask$(async function handleInput({ track }) {
    track(() => context.inputValueSig.value);
    if (!initialLoadSig.value) {
      await onInput$?.(context.inputValueSig.value);
    }
  });
  useTask$(async function handleChange({ track }) {
    track(() => selectedValuesSig.value);
    if (!initialLoadSig.value && selectedValuesSig.value.length > 0) {
      await onChange$?.(selectedValuesSig.value);
    }
    const selectedValues = Array.isArray(selectedValuesSig.value) ? selectedValuesSig.value : [
      selectedValuesSig.value
    ];
    const displayValues = [];
    for (const [index, item] of itemsMapSig.value.entries()) {
      if (selectedValues.includes(item.value)) {
        displayValues.push(item.displayValue);
        if (context.isListboxOpenSig.value === false) {
          context.highlightedIndexSig.value = index;
        }
      }
    }
    displayValuesSig.value = displayValues;
    if (mode === "inline") return;
    if (multiple || !context.inputRef.value || !displayValues[0]) return;
    context.inputRef.value.value = displayValues[0];
  });
  useTask$(() => {
    initialLoadSig.value = false;
  });
  return /* @__PURE__ */ jsx("div", {
    role: "group",
    ref: rootRef,
    "data-open": context.isListboxOpenSig.value ? "" : void 0,
    "data-closed": !context.isListboxOpenSig.value ? "" : void 0,
    "data-disabled": isDisabledSig.value,
    "data-invalid": context.isInvalidSig.value ? "" : void 0,
    "aria-invalid": context.isInvalidSig.value,
    "data-combobox-root": true,
    ...rest,
    children: /* @__PURE__ */ jsx(Slot, {})
  });
});
export {
  HComboboxRootImpl
};
