"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@builder.io/qwik/jsx-runtime");
const qwik = require("@builder.io/qwik");
const comboboxContext = require("./combobox-context.qwik.cjs");
const combinedRefs = require("../../hooks/combined-refs.qwik.cjs");
const boundSignal = require("../../utils/bound-signal.qwik.cjs");
const combobox = require("./combobox.css.qwik.cjs");
const HComboboxRootImpl = qwik.component$((props) => {
  qwik.useStyles$(combobox);
  const { onInput$, onChange$, onOpenChange$, initialIndex, initialValue, loop: givenLoop, scrollOptions: givenScrollOptions, multiple = false, placeholder, filter = true, _itemsMap, hasEmptyComp, removeOnBackspace = false, name, required, mode = "popover", "bind:value": givenValueSig, "bind:open": givenOpenSig, "bind:displayValue": givenDisplayValueSig, ...rest } = props;
  const isListboxOpenSig = boundSignal.useBoundSignal(givenOpenSig, false);
  const displayValuesSig = boundSignal.useBoundSignal(givenDisplayValueSig, []);
  const selectedValuesSig = boundSignal.useBoundSignal(givenValueSig, multiple ? initialValue ? [
    initialValue
  ] : [] : initialValue || "");
  const itemsMapSig = qwik.useComputed$(() => {
    return props._itemsMap ?? /* @__PURE__ */ new Map();
  });
  const rootRef = combinedRefs.useCombinedRef(props.ref);
  const triggerRef = qwik.useSignal();
  const inputRef = qwik.useSignal();
  const panelRef = qwik.useSignal();
  const labelRef = qwik.useSignal();
  const groupRef = qwik.useSignal();
  const controlRef = qwik.useSignal();
  const loop = givenLoop ?? false;
  const localId = qwik.useId();
  const selectedValueSetSig = qwik.useSignal(new Set(initialValue ? [
    initialValue
  ] : []));
  const disabledIndexSetSig = qwik.useSignal(/* @__PURE__ */ new Set());
  const filteredIndexSetSig = qwik.useSignal(/* @__PURE__ */ new Set());
  const isMouseOverPopupSig = qwik.useSignal(false);
  const highlightedIndexSig = qwik.useSignal(initialIndex ?? null);
  const initialLoadSig = qwik.useSignal(true);
  const scrollOptions = givenScrollOptions ?? {
    behavior: "smooth",
    block: "center",
    inline: "nearest"
  };
  const inputValueSig = qwik.useSignal(inputRef.value?.value ?? "");
  const isDisabledSig = qwik.useComputed$(() => props.disabled ?? false);
  const isInvalidSig = qwik.useComputed$(() => props.hasErrorComp ?? false);
  const isKeyboardFocusSig = qwik.useSignal(false);
  qwik.useTask$(() => {
    const disabledIndices = /* @__PURE__ */ new Set();
    for (const [index, item] of itemsMapSig.value) {
      if (item.disabled) {
        disabledIndices.add(index);
      }
    }
    disabledIndexSetSig.value = disabledIndices;
  });
  const isNoItemsSig = qwik.useComputed$(() => {
    return itemsMapSig.value.size === filteredIndexSetSig.value.size || itemsMapSig.value.size === 0;
  });
  qwik.useTask$(function closeIfEmptyComp({ track }) {
    track(() => itemsMapSig.value);
    track(() => filteredIndexSetSig.value);
    if (!hasEmptyComp && isNoItemsSig.value) {
      isListboxOpenSig.value = false;
    }
  });
  const isExpandedSig = qwik.useComputed$(() => {
    if (mode === "inline") {
      return void 0;
    }
    if (isListboxOpenSig.value) {
      return "true";
    } else {
      return "false";
    }
  });
  const context = {
    isListboxOpenSig,
    inputValueSig,
    itemsMapSig,
    triggerRef,
    inputRef,
    panelRef,
    labelRef,
    groupRef,
    controlRef,
    localId,
    highlightedIndexSig,
    isExpandedSig,
    selectedValuesSig,
    selectedValueSetSig,
    disabledIndexSetSig,
    filteredIndexSetSig,
    displayValuesSig,
    isMouseOverPopupSig,
    isKeyboardFocusSig,
    initialLoadSig,
    removeOnBackspace,
    filter,
    loop,
    mode,
    multiple,
    initialValue,
    scrollOptions,
    placeholder,
    isNoItemsSig,
    name,
    required,
    isDisabledSig,
    isInvalidSig
  };
  qwik.useContextProvider(comboboxContext.comboboxContextId, context);
  qwik.useTask$(async function handleOpenChange({ track }) {
    track(() => isListboxOpenSig.value);
    if (!initialLoadSig.value) {
      await onOpenChange$?.(isListboxOpenSig.value);
    }
  });
  qwik.useTask$(async function handleInput({ track }) {
    track(() => context.inputValueSig.value);
    if (!initialLoadSig.value) {
      await onInput$?.(context.inputValueSig.value);
    }
  });
  qwik.useTask$(async function handleChange({ track }) {
    track(() => selectedValuesSig.value);
    if (!initialLoadSig.value && selectedValuesSig.value.length > 0) {
      await onChange$?.(selectedValuesSig.value);
    }
    const selectedValues = Array.isArray(selectedValuesSig.value) ? selectedValuesSig.value : [
      selectedValuesSig.value
    ];
    const displayValues = [];
    for (const [index, item] of itemsMapSig.value.entries()) {
      if (selectedValues.includes(item.value)) {
        displayValues.push(item.displayValue);
        if (context.isListboxOpenSig.value === false) {
          context.highlightedIndexSig.value = index;
        }
      }
    }
    displayValuesSig.value = displayValues;
    if (mode === "inline") return;
    if (multiple || !context.inputRef.value || !displayValues[0]) return;
    context.inputRef.value.value = displayValues[0];
  });
  qwik.useTask$(() => {
    initialLoadSig.value = false;
  });
  return /* @__PURE__ */ jsxRuntime.jsx("div", {
    role: "group",
    ref: rootRef,
    "data-open": context.isListboxOpenSig.value ? "" : void 0,
    "data-closed": !context.isListboxOpenSig.value ? "" : void 0,
    "data-disabled": isDisabledSig.value,
    "data-invalid": context.isInvalidSig.value ? "" : void 0,
    "aria-invalid": context.isInvalidSig.value,
    "data-combobox-root": true,
    ...rest,
    children: /* @__PURE__ */ jsxRuntime.jsx(qwik.Slot, {})
  });
});
exports.HComboboxRootImpl = HComboboxRootImpl;
