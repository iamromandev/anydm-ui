import { useContext, $ } from "@builder.io/qwik";
import { comboboxContextId } from "./combobox-context.qwik.mjs";
class ValueManager {
  constructor(isMultiple, initialValue) {
    this.isMultiple = isMultiple;
    this.initialValue = initialValue;
  }
  add(value) {
    if (this.isMultiple) {
      const currentArray = Array.isArray(this.initialValue) ? [
        ...this.initialValue
      ] : [];
      return [
        ...currentArray,
        value
      ];
    }
    return value;
  }
  remove(value) {
    if (this.isMultiple && Array.isArray(this.initialValue)) {
      return this.initialValue.filter((v) => v !== value);
    }
    return "";
  }
  toggle(value) {
    if (this.isMultiple) {
      const currentArray = Array.isArray(this.initialValue) ? [
        ...this.initialValue
      ] : [];
      return currentArray.includes(value) ? currentArray.filter((v) => v !== value) : [
        ...currentArray,
        value
      ];
    }
    return this.initialValue === value ? "" : value;
  }
}
function useCombobox() {
  const context = useContext(comboboxContextId);
  const selectionManager$ = $(async (index, action) => {
    if (index === null) return;
    const selectedDisplayValue = context.itemsMapSig.value.get(index)?.displayValue;
    const value = context.itemsMapSig.value.get(index)?.value;
    if (!value) {
      throw new Error("Qwik UI: value not found when trying to select or unselect an item.");
    }
    const valueManager = new ValueManager(context.multiple ?? false, context.selectedValuesSig.value);
    switch (action) {
      case "add":
        context.selectedValuesSig.value = valueManager.add(value);
        break;
      case "remove":
        context.selectedValuesSig.value = valueManager.remove(value);
        return;
      // Early return for 'remove' action
      case "toggle":
        context.selectedValuesSig.value = valueManager.toggle(value);
        break;
    }
    const shouldUpdateInput = !context.multiple && context.mode !== "inline" && context.inputRef.value && selectedDisplayValue;
    if (shouldUpdateInput && context.inputRef.value) {
      context.inputRef.value.value = selectedDisplayValue;
    }
  });
  const filterManager$ = $(async (isVisible, itemRef, index) => {
    if (!itemRef.value) return;
    const isDisabled = context.itemsMapSig.value.get(index)?.disabled;
    itemRef.value.style.display = isVisible ? "" : "none";
    context.filteredIndexSetSig.value = new Set(isVisible ? [
      ...context.filteredIndexSetSig.value
    ].filter((filteredIndex) => filteredIndex !== index) : [
      ...context.filteredIndexSetSig.value,
      index
    ]);
    if (isDisabled) {
      context.disabledIndexSetSig.value = /* @__PURE__ */ new Set([
        ...context.disabledIndexSetSig.value,
        index
      ]);
    } else {
      context.disabledIndexSetSig.value = new Set([
        ...context.disabledIndexSetSig.value
      ].filter((disabledIndex) => disabledIndex !== index));
    }
    if (context.mode !== "inline") return;
    if (!isVisible) return;
    if (isDisabled) return;
    if (context.filter === false) {
      const firstVisibleIndex = await getNextEnabledItemIndex$(-1);
      if (firstVisibleIndex !== -1) {
        context.highlightedIndexSig.value = firstVisibleIndex;
      }
    } else {
      const firstVisibleIndex = [
        ...Array(context.itemsMapSig.value.size).keys()
      ].find((i) => !context.filteredIndexSetSig.value.has(i));
      if (firstVisibleIndex !== void 0) {
        context.highlightedIndexSig.value = firstVisibleIndex;
      }
    }
  });
  const getNextEnabledItemIndex$ = $((index) => {
    const len = context.itemsMapSig.value.size;
    if (len === 0) return -1;
    const findNextEnabled = (start) => {
      for (let i = 0; i < len; i++) {
        const nextIndex2 = (start + i) % len;
        if (!context.disabledIndexSetSig.value.has(nextIndex2) && !context.filteredIndexSetSig.value.has(nextIndex2)) {
          return nextIndex2;
        }
      }
      return -1;
    };
    if (index === -1 || len === 1) {
      return findNextEnabled(0);
    }
    const nextIndex = findNextEnabled(index + 1);
    return context.loop || nextIndex > index ? nextIndex : index;
  });
  const getPrevEnabledItemIndex$ = $((index) => {
    const len = context.itemsMapSig.value.size;
    if (len === 0) return -1;
    const findPrevEnabled = (start) => {
      for (let i = 0; i < len; i++) {
        const prevIndex2 = (start - i + len) % len;
        if (!context.disabledIndexSetSig.value.has(prevIndex2) && !context.filteredIndexSetSig.value.has(prevIndex2)) {
          return prevIndex2;
        }
      }
      return -1;
    };
    if (index === -1 || len === 1) {
      return findPrevEnabled(len - 1);
    }
    const prevIndex = findPrevEnabled(index - 1);
    return context.loop || prevIndex < index ? prevIndex : index;
  });
  return {
    getNextEnabledItemIndex$,
    getPrevEnabledItemIndex$,
    selectionManager$,
    filterManager$
  };
}
export {
  useCombobox
};
