import { jsx } from "@builder.io/qwik/jsx-runtime";
import { component$, useId, useSignal, useComputed$, useContextProvider, useTask$, Slot } from "@builder.io/qwik";
import { carouselContextId } from "./context.qwik.mjs";
import { useBoundSignal } from "../../utils/bound-signal.qwik.mjs";
import { useAutoplay } from "./use-carousel.qwik.mjs";
const CarouselBase = component$((props) => {
  const { align, "bind:currSlideIndex": givenOldSlideIndexSig, "bind:selectedIndex": givenSlideIndexSig, "bind:autoplay": givenAutoplaySig, "bind:progress": givenProgressSig, _isTitle: isTitle, startIndex, ...rest } = props;
  const localId = useId();
  const scrollerRef = useSignal();
  const nextButtonRef = useSignal();
  const prevButtonRef = useSignal();
  const scrollStartRef = useSignal();
  const isMouseDraggingSig = useSignal(false);
  const slideRefsArray = useSignal([]);
  const bulletRefsArray = useSignal([]);
  const startIndexSig = useComputed$(() => {
    return startIndex ?? givenSlideIndexSig?.value ?? 0;
  });
  const currentIndexSig = useBoundSignal(givenSlideIndexSig ?? givenOldSlideIndexSig, startIndexSig.value);
  const isScrollerSig = useSignal(false);
  const isAutoplaySig = useBoundSignal(givenAutoplaySig, false);
  const getInitialProgress = () => {
    return startIndexSig.value ? startIndexSig.value / ((props._numSlides ?? 1) - 1) : 0;
  };
  const numSlidesSig = useComputed$(() => props._numSlides ?? 0);
  const isDraggableSig = useComputed$(() => props.draggable ?? true);
  const slidesPerViewSig = useComputed$(() => props.slidesPerView ?? 1);
  const gapSig = useComputed$(() => props.gap ?? 0);
  const alignSig = useComputed$(() => props.align ?? "start");
  const isRewindSig = useComputed$(() => props.rewind ?? false);
  const autoPlayIntervalMsSig = useComputed$(() => props.autoPlayIntervalMs ?? 0);
  const progressSig = useBoundSignal(givenProgressSig, getInitialProgress());
  const sensitivitySig = useComputed$(() => {
    return {
      mouse: props.sensitivity?.mouse ?? 1.5,
      touch: props.sensitivity?.touch ?? 1.25
    };
  });
  const moveSig = useComputed$(() => props.move ?? 1);
  const maxSlideHeightSig = useComputed$(() => props.maxSlideHeight ?? void 0);
  const orientationSig = useComputed$(() => {
    if (props.maxSlideHeight === void 0) {
      return "horizontal";
    }
    return props.orientation ?? "horizontal";
  });
  const isMouseWheelSig = useComputed$(() => props.mousewheel ?? false);
  const titleId = `${localId}-title`;
  const context = {
    localId,
    scrollerRef,
    nextButtonRef,
    prevButtonRef,
    scrollStartRef,
    isMouseDraggingSig,
    isMouseWheelSig,
    slideRefsArray,
    bulletRefsArray,
    currentIndexSig,
    isScrollerSig,
    isAutoplaySig,
    numSlidesSig,
    isDraggableSig,
    slidesPerViewSig,
    gapSig,
    alignSig,
    isRewindSig,
    autoPlayIntervalMsSig,
    startIndexSig,
    sensitivitySig,
    moveSig,
    orientationSig,
    maxSlideHeightSig
  };
  useAutoplay(context);
  useContextProvider(carouselContextId, context);
  useTask$(({ track }) => {
    if (!givenProgressSig) return;
    track(() => currentIndexSig.value);
    track(() => numSlidesSig.value);
    if (numSlidesSig.value > 1) {
      progressSig.value = currentIndexSig.value / (numSlidesSig.value - 1) * 100;
    } else {
      progressSig.value = 0;
    }
  });
  return /* @__PURE__ */ jsx("div", {
    role: "group",
    "aria-labelledby": isTitle ? titleId : void 0,
    "aria-label": !isTitle ? `content slideshow` : void 0,
    "aria-roledescription": "carousel",
    "aria-live": isAutoplaySig.value ? "off" : "polite",
    "data-qui-carousel": true,
    ...rest,
    style: {
      "--slides-per-view": slidesPerViewSig.value,
      "--gap": `${gapSig.value}px`,
      "--scroll-snap-align": alignSig.value,
      "--orientation": orientationSig.value === "vertical" ? "column" : "row",
      "--max-slide-height": `${maxSlideHeightSig.value}px`
    },
    children: /* @__PURE__ */ jsx(Slot, {})
  });
});
export {
  CarouselBase
};
