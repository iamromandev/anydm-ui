"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@builder.io/qwik/jsx-runtime");
const qwik = require("@builder.io/qwik");
const context = require("./context.qwik.cjs");
const carousel = require("./carousel.css.qwik.cjs");
const build = require("@builder.io/qwik/build");
const useDebouncer = require("../../hooks/use-debouncer.qwik.cjs");
const useScroller = require("./use-scroller.qwik.cjs");
const useCarousel = require("./use-carousel.qwik.cjs");
const CarouselScroller = qwik.component$((props) => {
  qwik.useStyles$(carousel);
  const context$1 = qwik.useContext(context.carouselContextId);
  const { onMouseDown$, onTouchStart$, onTouchMove$, onTouchEnd$, ...rest } = props;
  const isMouseMovingSig = qwik.useSignal(false);
  const isTouchMovingSig = qwik.useSignal(true);
  const isTouchStartSig = qwik.useSignal(false);
  const initialLoadSig = qwik.useSignal(true);
  const isNewPosOnLoadSig = qwik.useSignal(false);
  const { validIndexesSig } = useCarousel.useCarousel(context$1);
  const { startPosSig, transformSig, boundariesSig, isMouseDownSig, isTouchDeviceSig, orientationProps, getSlidePosition, setBoundaries, setTransform, setTransition, setInitialSlidePos } = useScroller.useScroller(context$1);
  const { direction, pagePosition, clientPosition } = orientationProps[context$1.orientationSig.value];
  const handleMouseMove = qwik.$(async (e) => {
    if (!isMouseDownSig.value || startPosSig.value === void 0) return;
    if (!context$1.scrollerRef.value || !boundariesSig.value) return;
    const pos = e[pagePosition];
    const dragSpeed = context$1.sensitivitySig.value.mouse;
    const walk = (startPosSig.value - pos) * dragSpeed;
    const newTransform = transformSig.value[direction] - walk;
    if (newTransform >= boundariesSig.value.min && newTransform <= boundariesSig.value.max) {
      transformSig.value[direction] = newTransform;
      await setTransition(false);
      await setTransform();
    }
    startPosSig.value = pos;
    isMouseMovingSig.value = true;
  });
  const handleDragSnap = qwik.$(async () => {
    if (!context$1.scrollerRef.value) return;
    const slides = context$1.slideRefsArray.value;
    const currentPosition = -transformSig.value[direction];
    let closestIndex = 0;
    let minDistance = Infinity;
    for (let i = 0; i < slides.length; i++) {
      const slide = slides[i].value;
      if (!slide) continue;
      const slidePosition = await getSlidePosition(i);
      const distance = Math.abs(slidePosition - currentPosition);
      if (distance < minDistance) {
        closestIndex = i;
        minDistance = distance;
      }
    }
    const dragSnapPosition = await getSlidePosition(closestIndex);
    await setTransition(true);
    transformSig.value[direction] = -dragSnapPosition;
    await setTransform();
    context$1.currentIndexSig.value = closestIndex;
    isMouseDownSig.value = false;
    isMouseMovingSig.value = false;
    isTouchMovingSig.value = false;
    isTouchStartSig.value = false;
    window.removeEventListener("mousemove", handleMouseMove);
  });
  const handleMouseDown = qwik.$(async (e) => {
    if (!context$1.isDraggableSig.value) return;
    if (!context$1.scrollerRef.value) return;
    await setTransition(true);
    if (context$1.startIndexSig.value && context$1.scrollStartRef.value) {
      context$1.scrollStartRef.value.style.setProperty("--scroll-snap-align", "none");
    }
    await setBoundaries();
    isMouseDownSig.value = true;
    startPosSig.value = e.pageX;
    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("mouseup", handleDragSnap);
    isMouseMovingSig.value = false;
  });
  qwik.useTask$(async function nonDragSnap({ track }) {
    track(() => context$1.currentIndexSig.value);
    if (isMouseMovingSig.value) {
      isMouseMovingSig.value = false;
      return;
    }
    if (isTouchDeviceSig.value && isTouchMovingSig.value) return;
    if (!context$1.scrollerRef.value || build.isServer) return;
    context$1.scrollStartRef.value?.style.setProperty("--scroll-snap-align", "none");
    if (isMouseDownSig.value) return;
    const currentIndex = context$1.currentIndexSig.value;
    const snapPosition = await getSlidePosition(currentIndex);
    await setTransition(true);
    transformSig.value[direction] = -snapPosition;
    await setTransform();
    window.removeEventListener("mousemove", handleMouseMove);
  });
  const handleResize = qwik.$(async () => {
    const isCoarsePointer = window.matchMedia("(pointer: coarse)").matches;
    if (isCoarsePointer) return;
    await setTransition(true);
    if (!context$1.scrollerRef.value) return;
    const newPosition = await getSlidePosition(context$1.currentIndexSig.value);
    transformSig.value.x = -newPosition;
    await setTransform();
    context$1.scrollerRef.value.style.transition = "none";
  });
  const handleTouchStart = qwik.$(async (e) => {
    if (!context$1.isDraggableSig.value || !context$1.scrollerRef.value) return;
    if (context$1.startIndexSig.value && context$1.scrollStartRef.value) {
      context$1.scrollStartRef.value.style.setProperty("--scroll-snap-align", "none");
    }
    startPosSig.value = e.touches[0][clientPosition];
    isTouchStartSig.value = true;
    isTouchMovingSig.value = false;
    await setBoundaries();
    await setTransition(false);
  });
  const debouncedUpdate = useDebouncer.useDebouncer(setTransform, 1);
  const handleTouchMove = qwik.$(async (e) => {
    if (isMouseDownSig.value || startPosSig.value === void 0) return;
    if (!context$1.scrollerRef.value || !boundariesSig.value) return;
    const pos = e.touches[0][clientPosition];
    const dragSpeed = context$1.sensitivitySig.value.touch;
    const walk = (startPosSig.value - pos) * dragSpeed;
    const newTransform = transformSig.value[direction] - walk;
    if (newTransform >= boundariesSig.value.min && newTransform <= boundariesSig.value.max) {
      transformSig.value[direction] = newTransform;
      await debouncedUpdate();
    }
    startPosSig.value = pos;
    isTouchMovingSig.value = true;
  });
  qwik.useOnWindow("resize", handleResize);
  qwik.useTask$(() => {
    if (!initialLoadSig.value) return;
    isNewPosOnLoadSig.value = context$1.startIndexSig.value !== 0 && context$1.startIndexSig.value !== void 0 && context$1.currentIndexSig.value !== 0;
  });
  const handleWheel = qwik.$(async (e) => {
    if (!context$1.isDraggableSig.value || !context$1.scrollerRef.value) return;
    if (!context$1.isMouseWheelSig.value) return;
    const validIndexes = validIndexesSig.value;
    const currentIndex = context$1.currentIndexSig.value;
    const currentPosition = validIndexes.indexOf(currentIndex);
    const direction2 = e.deltaY > 0 ? 1 : -1;
    const newPosition = Math.max(0, Math.min(currentPosition + direction2, validIndexes.length - 1));
    context$1.currentIndexSig.value = validIndexes[newPosition];
  });
  qwik.useTask$(() => {
    initialLoadSig.value = false;
  });
  let touchStartX = 0;
  let touchStartY = 0;
  let activeCarousel = null;
  let carouselOrientation = null;
  const preventTouchStart = qwik.sync$((e) => {
    const touch = e.touches[0];
    if (!touch) return;
    const target = e.target;
    activeCarousel = target.closest("[data-qui-carousel-scroller]");
    if (!activeCarousel) return;
    carouselOrientation = activeCarousel.getAttribute("data-orientation");
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
  });
  const preventTouchMove = qwik.sync$((e) => {
    if (!activeCarousel || !carouselOrientation) return;
    const touch = e.touches[0];
    if (!touch) return;
    const deltaX = Math.abs(touch.clientX - touchStartX);
    const deltaY = Math.abs(touch.clientY - touchStartY);
    if (carouselOrientation === "horizontal" && deltaX > deltaY && deltaX > 5) {
      e.preventDefault();
    } else if (carouselOrientation === "vertical" && deltaY > deltaX && deltaY > 5) {
      e.preventDefault();
    }
  });
  return /* @__PURE__ */ jsxRuntime.jsx("div", {
    "data-qui-carousel-viewport": true,
    onMouseDown$: [
      handleMouseDown,
      onMouseDown$
    ],
    onTouchStart$: [
      preventTouchStart,
      handleTouchStart,
      onTouchStart$
    ],
    onTouchMove$: [
      preventTouchMove,
      handleTouchMove,
      onTouchMove$
    ],
    onTouchEnd$: [
      handleDragSnap,
      onTouchEnd$
    ],
    onQVisible$: isNewPosOnLoadSig.value ? setInitialSlidePos : void 0,
    onWheel$: handleWheel,
    "preventdefault:wheel": context$1.isMouseWheelSig.value,
    children: /* @__PURE__ */ jsxRuntime.jsx("div", {
      ref: context$1.scrollerRef,
      "data-qui-carousel-scroller": true,
      "data-draggable": context$1.isDraggableSig.value ? "" : void 0,
      "data-align": context$1.alignSig.value,
      "data-initial-touch": isTouchStartSig.value ? "" : void 0,
      "data-initial": isNewPosOnLoadSig.value ? "" : void 0,
      "data-orientation": context$1.orientationSig.value,
      ...rest,
      children: /* @__PURE__ */ jsxRuntime.jsx(qwik.Slot, {})
    })
  });
});
exports.CarouselScroller = CarouselScroller;
