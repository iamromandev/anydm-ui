"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@builder.io/qwik/jsx-runtime");
const qwik = require("@builder.io/qwik");
const context = require("./context.qwik.cjs");
const useCarousel = require("./use-carousel.qwik.cjs");
const CarouselNext = qwik.component$((props) => {
  const context$1 = qwik.useContext(context.carouselContextId);
  const isLastSlideInViewSig = qwik.useSignal(false);
  const initialLoadSig = qwik.useSignal(true);
  const isKeyboardFocusSig = qwik.useSignal(false);
  const { validIndexesSig } = useCarousel.useCarousel(context$1);
  const isLastScrollableIndexSig = qwik.useComputed$(() => {
    const validIndexes = validIndexesSig.value;
    return validIndexes[validIndexes.length - 1];
  });
  const handleFocusPrev$ = qwik.$(() => {
    if (context$1.isRewindSig.value) return;
    if (isKeyboardFocusSig.value && isLastSlideInViewSig.value) {
      const activeElAtBlur = document.activeElement;
      setTimeout(() => {
        if (document.activeElement !== activeElAtBlur) return;
        if (isLastScrollableIndexSig.value >= context$1.currentIndexSig.value) {
          context$1.prevButtonRef.value?.focus();
        }
      }, 2e3);
    }
    isKeyboardFocusSig.value = false;
  });
  const handleKeyDown$ = qwik.$(() => {
    if (!isLastScrollableIndexSig.value) return;
    isKeyboardFocusSig.value = true;
  });
  qwik.useTask$(function updateSlidesPerViewState({ track }) {
    track(() => context$1.currentIndexSig.value);
    if (initialLoadSig.value) return;
    const validIndexes = validIndexesSig.value;
    isLastSlideInViewSig.value = validIndexes.indexOf(context$1.currentIndexSig.value) === validIndexes.length - 1;
  });
  qwik.useTask$(() => {
    initialLoadSig.value = false;
  });
  const handleClick$ = qwik.$(() => {
    const validIndexes = validIndexesSig.value;
    const currentIndex = context$1.currentIndexSig.value;
    const currentPosition = validIndexes.indexOf(currentIndex);
    if (currentPosition === validIndexes.length - 1 && context$1.isRewindSig.value) {
      context$1.currentIndexSig.value = validIndexes[0];
    } else {
      const nextPosition = Math.min(currentPosition + 1, validIndexes.length - 1);
      context$1.currentIndexSig.value = validIndexes[nextPosition];
    }
  });
  return /* @__PURE__ */ jsxRuntime.jsx("button", {
    ...props,
    ref: context$1.nextButtonRef,
    "aria-disabled": isLastSlideInViewSig.value && !context$1.isRewindSig.value,
    disabled: isLastSlideInViewSig.value && !context$1.isRewindSig.value,
    onClick$: [
      handleClick$,
      props.onClick$
    ],
    onKeyDown$: [
      handleKeyDown$,
      props.onKeyDown$
    ],
    onBlur$: [
      handleFocusPrev$,
      props.onBlur$
    ],
    "data-qui-carousel-next": true,
    "aria-label": "next slide",
    children: /* @__PURE__ */ jsxRuntime.jsx(qwik.Slot, {})
  });
});
exports.CarouselNext = CarouselNext;
